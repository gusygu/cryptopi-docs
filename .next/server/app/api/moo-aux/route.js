/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/moo-aux/route";
exports.ids = ["app/api/moo-aux/route"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fmoo-aux%2Froute&page=%2Fapi%2Fmoo-aux%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fmoo-aux%2Froute.ts&appDir=H%3A%5CUsers%5CGus%5Csource%5Crepo%5Cdynamics%5Cdynamics-b%5Ccryptopi-dynamics%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=H%3A%5CUsers%5CGus%5Csource%5Crepo%5Cdynamics%5Cdynamics-b%5Ccryptopi-dynamics&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fmoo-aux%2Froute&page=%2Fapi%2Fmoo-aux%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fmoo-aux%2Froute.ts&appDir=H%3A%5CUsers%5CGus%5Csource%5Crepo%5Cdynamics%5Cdynamics-b%5Ccryptopi-dynamics%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=H%3A%5CUsers%5CGus%5Csource%5Crepo%5Cdynamics%5Cdynamics-b%5Ccryptopi-dynamics&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=! ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handler: () => (/* binding */ handler),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   workAsyncStorage: () => (/* binding */ workAsyncStorage),\n/* harmony export */   workUnitAsyncStorage: () => (/* binding */ workUnitAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/server/request-meta */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/request-meta.js\");\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/shared/lib/router/utils/app-paths */ \"next/dist/shared/lib/router/utils/app-paths\");\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/base-http/node */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/base-http/node.js\");\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! next/dist/server/web/spec-extension/adapters/next-request */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/web/spec-extension/adapters/next-request.js\");\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! next/dist/server/instrumentation/utils */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/instrumentation/utils.js\");\n/* harmony import */ var next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! next/dist/server/send-response */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/send-response.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! next/dist/server/web/utils */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/web/utils.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! next/dist/server/lib/cache-control */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/lib/cache-control.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! next/dist/lib/constants */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/lib/constants.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! next/dist/shared/lib/no-fallback-error.external */ \"next/dist/shared/lib/no-fallback-error.external\");\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! next/dist/server/response-cache */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/response-cache/index.js\");\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var H_Users_Gus_source_repo_dynamics_dynamics_b_cryptopi_dynamics_src_app_api_moo_aux_route_ts__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/app/api/moo-aux/route.ts */ \"(rsc)/./src/app/api/moo-aux/route.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([H_Users_Gus_source_repo_dynamics_dynamics_b_cryptopi_dynamics_src_app_api_moo_aux_route_ts__WEBPACK_IMPORTED_MODULE_16__]);\nH_Users_Gus_source_repo_dynamics_dynamics_b_cryptopi_dynamics_src_app_api_moo_aux_route_ts__WEBPACK_IMPORTED_MODULE_16__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/moo-aux/route\",\n        pathname: \"/api/moo-aux\",\n        filename: \"route\",\n        bundlePath: \"app/api/moo-aux/route\"\n    },\n    distDir: \".next\" || 0,\n    relativeProjectDir:  false || '',\n    resolvedPagePath: \"H:\\\\Users\\\\Gus\\\\source\\\\repo\\\\dynamics\\\\dynamics-b\\\\cryptopi-dynamics\\\\src\\\\app\\\\api\\\\moo-aux\\\\route.ts\",\n    nextConfigOutput,\n    userland: H_Users_Gus_source_repo_dynamics_dynamics_b_cryptopi_dynamics_src_app_api_moo_aux_route_ts__WEBPACK_IMPORTED_MODULE_16__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n\nasync function handler(req, res, ctx) {\n    var _nextConfig_experimental;\n    let srcPage = \"/api/moo-aux/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {} else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = false;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname } = prepareResult;\n    const normalizedSrcPage = (0,next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__.normalizeAppPath)(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                throw new next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isRevalidate = isIsr && !supportsDynamicResponse;\n    const method = req.method || 'GET';\n    const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.getTracer)();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            supportsDynamicResponse,\n            incrementalCache: (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'incrementalCache'),\n            cacheLifeProfiles: (_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.cacheLife,\n            isRevalidate,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextRequest(req);\n    const nodeNextRes = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextResponse(res);\n    const nextReq = next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.NextRequestAdapter.fromNodeNextRequest(nodeNextReq, (0,next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.signalFromNodeResponse)(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        };\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.toNodeOutgoingHttpHeaders)(response.headers);\n                        if (cacheTags) {\n                            headers[next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                                isRevalidate,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode')) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.fromNodeOutgoingHttpHeaders)(cacheEntry.value.headers);\n            if (!((0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isIsr)) {\n                headers.delete(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', (0,next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__.getCacheControlHeader)(cacheEntry.cacheControl));\n            }\n            await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        // if we aren't wrapped by base-server handle here\n        if (!activeSpan && !(err instanceof next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                    isRevalidate,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS41LjJfQHBsYXl3cmlnaHQrdGVzX2I3ZTZjMjgwZTlhMWI0MzA5MzQ3YzBiZjBhYjQ3NmQ1L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtYXBwLWxvYWRlci9pbmRleC5qcz9uYW1lPWFwcCUyRmFwaSUyRm1vby1hdXglMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRm1vby1hdXglMkZyb3V0ZSZhcHBQYXRocz0mcGFnZVBhdGg9cHJpdmF0ZS1uZXh0LWFwcC1kaXIlMkZhcGklMkZtb28tYXV4JTJGcm91dGUudHMmYXBwRGlyPUglM0ElNUNVc2VycyU1Q0d1cyU1Q3NvdXJjZSU1Q3JlcG8lNUNkeW5hbWljcyU1Q2R5bmFtaWNzLWIlNUNjcnlwdG9waS1keW5hbWljcyU1Q3NyYyU1Q2FwcCZwYWdlRXh0ZW5zaW9ucz10c3gmcGFnZUV4dGVuc2lvbnM9dHMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPWpzJnJvb3REaXI9SCUzQSU1Q1VzZXJzJTVDR3VzJTVDc291cmNlJTVDcmVwbyU1Q2R5bmFtaWNzJTVDZHluYW1pY3MtYiU1Q2NyeXB0b3BpLWR5bmFtaWNzJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEJmlzR2xvYmFsTm90Rm91bmRFbmFibGVkPSEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0Y7QUFDdkM7QUFDcUI7QUFDZDtBQUNTO0FBQ087QUFDSztBQUNtQztBQUNqRDtBQUNPO0FBQ2Y7QUFDc0M7QUFDekI7QUFDTTtBQUNDO0FBQ2hCO0FBQ2tFO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5R0FBbUI7QUFD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O0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3RkFBMkI7QUFDdkQsa0JBQWtCLDZFQUFjO0FBQ2hDLCtCQUErQiw0RUFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMEZBQXFCO0FBQ2xFO0FBQ0Esa0JBQWtCLDZFQUFZO0FBQzlCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZFQUE2RSxnRkFBYztBQUMzRixpQ0FBaUMsUUFBUSxFQUFFLFFBQVE7QUFDbkQsMEJBQTBCLHVFQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNENBQTRDLDZGQUFlO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJGQUFtQjtBQUNyRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2RUFBWTtBQUMxQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgeyBnZXRSZXF1ZXN0TWV0YSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3QtbWV0YVwiO1xuaW1wb3J0IHsgZ2V0VHJhY2VyLCBTcGFuS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi90cmFjZS90cmFjZXJcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZUFwcFBhdGggfSBmcm9tIFwibmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FwcC1wYXRoc1wiO1xuaW1wb3J0IHsgTm9kZU5leHRSZXF1ZXN0LCBOb2RlTmV4dFJlc3BvbnNlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvYmFzZS1odHRwL25vZGVcIjtcbmltcG9ydCB7IE5leHRSZXF1ZXN0QWRhcHRlciwgc2lnbmFsRnJvbU5vZGVSZXNwb25zZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9uZXh0LXJlcXVlc3RcIjtcbmltcG9ydCB7IEJhc2VTZXJ2ZXJTcGFuIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3RyYWNlL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZ2V0UmV2YWxpZGF0ZVJlYXNvbiB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2luc3RydW1lbnRhdGlvbi91dGlsc1wiO1xuaW1wb3J0IHsgc2VuZFJlc3BvbnNlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvc2VuZC1yZXNwb25zZVwiO1xuaW1wb3J0IHsgZnJvbU5vZGVPdXRnb2luZ0h0dHBIZWFkZXJzLCB0b05vZGVPdXRnb2luZ0h0dHBIZWFkZXJzIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvd2ViL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXRDYWNoZUNvbnRyb2xIZWFkZXIgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvY2FjaGUtY29udHJvbFwiO1xuaW1wb3J0IHsgSU5GSU5JVEVfQ0FDSEUsIE5FWFRfQ0FDSEVfVEFHU19IRUFERVIgfSBmcm9tIFwibmV4dC9kaXN0L2xpYi9jb25zdGFudHNcIjtcbmltcG9ydCB7IE5vRmFsbGJhY2tFcnJvciB9IGZyb20gXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9uby1mYWxsYmFjay1lcnJvci5leHRlcm5hbFwiO1xuaW1wb3J0IHsgQ2FjaGVkUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcmVzcG9uc2UtY2FjaGVcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCJIOlxcXFxVc2Vyc1xcXFxHdXNcXFxcc291cmNlXFxcXHJlcG9cXFxcZHluYW1pY3NcXFxcZHluYW1pY3MtYlxcXFxjcnlwdG9waS1keW5hbWljc1xcXFxzcmNcXFxcYXBwXFxcXGFwaVxcXFxtb28tYXV4XFxcXHJvdXRlLnRzXCI7XG4vLyBXZSBpbmplY3QgdGhlIG5leHRDb25maWdPdXRwdXQgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IG5leHRDb25maWdPdXRwdXQgPSBcIlwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9tb28tYXV4L3JvdXRlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvbW9vLWF1eFwiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvbW9vLWF1eC9yb3V0ZVwiXG4gICAgfSxcbiAgICBkaXN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfRElTVF9ESVIgfHwgJycsXG4gICAgcmVsYXRpdmVQcm9qZWN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfUFJPSkVDVF9ESVIgfHwgJycsXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCJIOlxcXFxVc2Vyc1xcXFxHdXNcXFxcc291cmNlXFxcXHJlcG9cXFxcZHluYW1pY3NcXFxcZHluYW1pY3MtYlxcXFxjcnlwdG9waS1keW5hbWljc1xcXFxzcmNcXFxcYXBwXFxcXGFwaVxcXFxtb28tYXV4XFxcXHJvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgd29ya0FzeW5jU3RvcmFnZSwgd29ya1VuaXRBc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgd29ya0FzeW5jU3RvcmFnZSxcbiAgICAgICAgd29ya1VuaXRBc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCB3b3JrQXN5bmNTdG9yYWdlLCB3b3JrVW5pdEFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIHBhdGNoRmV0Y2gsICB9O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxLCByZXMsIGN0eCkge1xuICAgIHZhciBfbmV4dENvbmZpZ19leHBlcmltZW50YWw7XG4gICAgbGV0IHNyY1BhZ2UgPSBcIi9hcGkvbW9vLWF1eC9yb3V0ZVwiO1xuICAgIC8vIHR1cmJvcGFjayBkb2Vzbid0IG5vcm1hbGl6ZSBgL2luZGV4YCBpbiB0aGUgcGFnZSBuYW1lXG4gICAgLy8gc28gd2UgbmVlZCB0byB0byBwcm9jZXNzIGR5bmFtaWMgcm91dGVzIHByb3Blcmx5XG4gICAgLy8gVE9ETzogZml4IHR1cmJvcGFjayBwcm92aWRpbmcgZGlmZmVyaW5nIHZhbHVlIGZyb20gd2VicGFja1xuICAgIGlmIChwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICAgICAgc3JjUGFnZSA9IHNyY1BhZ2UucmVwbGFjZSgvXFwvaW5kZXgkLywgJycpIHx8ICcvJztcbiAgICB9IGVsc2UgaWYgKHNyY1BhZ2UgPT09ICcvaW5kZXgnKSB7XG4gICAgICAgIC8vIHdlIGFsd2F5cyBub3JtYWxpemUgL2luZGV4IHNwZWNpZmljYWxseVxuICAgICAgICBzcmNQYWdlID0gJy8nO1xuICAgIH1cbiAgICBjb25zdCBtdWx0aVpvbmVEcmFmdE1vZGUgPSBwcm9jZXNzLmVudi5fX05FWFRfTVVMVElfWk9ORV9EUkFGVF9NT0RFO1xuICAgIGNvbnN0IHByZXBhcmVSZXN1bHQgPSBhd2FpdCByb3V0ZU1vZHVsZS5wcmVwYXJlKHJlcSwgcmVzLCB7XG4gICAgICAgIHNyY1BhZ2UsXG4gICAgICAgIG11bHRpWm9uZURyYWZ0TW9kZVxuICAgIH0pO1xuICAgIGlmICghcHJlcGFyZVJlc3VsdCkge1xuICAgICAgICByZXMuc3RhdHVzQ29kZSA9IDQwMDtcbiAgICAgICAgcmVzLmVuZCgnQmFkIFJlcXVlc3QnKTtcbiAgICAgICAgY3R4LndhaXRVbnRpbCA9PSBudWxsID8gdm9pZCAwIDogY3R4LndhaXRVbnRpbC5jYWxsKGN0eCwgUHJvbWlzZS5yZXNvbHZlKCkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeyBidWlsZElkLCBwYXJhbXMsIG5leHRDb25maWcsIGlzRHJhZnRNb2RlLCBwcmVyZW5kZXJNYW5pZmVzdCwgcm91dGVyU2VydmVyQ29udGV4dCwgaXNPbkRlbWFuZFJldmFsaWRhdGUsIHJldmFsaWRhdGVPbmx5R2VuZXJhdGVkLCByZXNvbHZlZFBhdGhuYW1lIH0gPSBwcmVwYXJlUmVzdWx0O1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRTcmNQYWdlID0gbm9ybWFsaXplQXBwUGF0aChzcmNQYWdlKTtcbiAgICBsZXQgaXNJc3IgPSBCb29sZWFuKHByZXJlbmRlck1hbmlmZXN0LmR5bmFtaWNSb3V0ZXNbbm9ybWFsaXplZFNyY1BhZ2VdIHx8IHByZXJlbmRlck1hbmlmZXN0LnJvdXRlc1tyZXNvbHZlZFBhdGhuYW1lXSk7XG4gICAgaWYgKGlzSXNyICYmICFpc0RyYWZ0TW9kZSkge1xuICAgICAgICBjb25zdCBpc1ByZXJlbmRlcmVkID0gQm9vbGVhbihwcmVyZW5kZXJNYW5pZmVzdC5yb3V0ZXNbcmVzb2x2ZWRQYXRobmFtZV0pO1xuICAgICAgICBjb25zdCBwcmVyZW5kZXJJbmZvID0gcHJlcmVuZGVyTWFuaWZlc3QuZHluYW1pY1JvdXRlc1tub3JtYWxpemVkU3JjUGFnZV07XG4gICAgICAgIGlmIChwcmVyZW5kZXJJbmZvKSB7XG4gICAgICAgICAgICBpZiAocHJlcmVuZGVySW5mby5mYWxsYmFjayA9PT0gZmFsc2UgJiYgIWlzUHJlcmVuZGVyZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9GYWxsYmFja0Vycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNhY2hlS2V5ID0gbnVsbDtcbiAgICBpZiAoaXNJc3IgJiYgIXJvdXRlTW9kdWxlLmlzRGV2ICYmICFpc0RyYWZ0TW9kZSkge1xuICAgICAgICBjYWNoZUtleSA9IHJlc29sdmVkUGF0aG5hbWU7XG4gICAgICAgIC8vIGVuc3VyZSAvaW5kZXggYW5kIC8gaXMgbm9ybWFsaXplZCB0byBvbmUga2V5XG4gICAgICAgIGNhY2hlS2V5ID0gY2FjaGVLZXkgPT09ICcvaW5kZXgnID8gJy8nIDogY2FjaGVLZXk7XG4gICAgfVxuICAgIGNvbnN0IHN1cHBvcnRzRHluYW1pY1Jlc3BvbnNlID0gLy8gSWYgd2UncmUgaW4gZGV2ZWxvcG1lbnQsIHdlIGFsd2F5cyBzdXBwb3J0IGR5bmFtaWMgSFRNTFxuICAgIHJvdXRlTW9kdWxlLmlzRGV2ID09PSB0cnVlIHx8IC8vIElmIHRoaXMgaXMgbm90IFNTRyBvciBkb2VzIG5vdCBoYXZlIHN0YXRpYyBwYXRocywgdGhlbiBpdCBzdXBwb3J0c1xuICAgIC8vIGR5bmFtaWMgSFRNTC5cbiAgICAhaXNJc3I7XG4gICAgLy8gVGhpcyBpcyBhIHJldmFsaWRhdGlvbiByZXF1ZXN0IGlmIHRoZSByZXF1ZXN0IGlzIGZvciBhIHN0YXRpY1xuICAgIC8vIHBhZ2UgYW5kIGl0IGlzIG5vdCBiZWluZyByZXN1bWVkIGZyb20gYSBwb3N0cG9uZWQgcmVuZGVyIGFuZFxuICAgIC8vIGl0IGlzIG5vdCBhIGR5bmFtaWMgUlNDIHJlcXVlc3QgdGhlbiBpdCBpcyBhIHJldmFsaWRhdGlvblxuICAgIC8vIHJlcXVlc3QuXG4gICAgY29uc3QgaXNSZXZhbGlkYXRlID0gaXNJc3IgJiYgIXN1cHBvcnRzRHluYW1pY1Jlc3BvbnNlO1xuICAgIGNvbnN0IG1ldGhvZCA9IHJlcS5tZXRob2QgfHwgJ0dFVCc7XG4gICAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKCk7XG4gICAgY29uc3QgYWN0aXZlU3BhbiA9IHRyYWNlci5nZXRBY3RpdmVTY29wZVNwYW4oKTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHByZXJlbmRlck1hbmlmZXN0LFxuICAgICAgICByZW5kZXJPcHRzOiB7XG4gICAgICAgICAgICBleHBlcmltZW50YWw6IHtcbiAgICAgICAgICAgICAgICBjYWNoZUNvbXBvbmVudHM6IEJvb2xlYW4obmV4dENvbmZpZy5leHBlcmltZW50YWwuY2FjaGVDb21wb25lbnRzKSxcbiAgICAgICAgICAgICAgICBhdXRoSW50ZXJydXB0czogQm9vbGVhbihuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5hdXRoSW50ZXJydXB0cylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdXBwb3J0c0R5bmFtaWNSZXNwb25zZSxcbiAgICAgICAgICAgIGluY3JlbWVudGFsQ2FjaGU6IGdldFJlcXVlc3RNZXRhKHJlcSwgJ2luY3JlbWVudGFsQ2FjaGUnKSxcbiAgICAgICAgICAgIGNhY2hlTGlmZVByb2ZpbGVzOiAoX25leHRDb25maWdfZXhwZXJpbWVudGFsID0gbmV4dENvbmZpZy5leHBlcmltZW50YWwpID09IG51bGwgPyB2b2lkIDAgOiBfbmV4dENvbmZpZ19leHBlcmltZW50YWwuY2FjaGVMaWZlLFxuICAgICAgICAgICAgaXNSZXZhbGlkYXRlLFxuICAgICAgICAgICAgd2FpdFVudGlsOiBjdHgud2FpdFVudGlsLFxuICAgICAgICAgICAgb25DbG9zZTogKGNiKT0+e1xuICAgICAgICAgICAgICAgIHJlcy5vbignY2xvc2UnLCBjYik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25BZnRlclRhc2tFcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb25JbnN0cnVtZW50YXRpb25SZXF1ZXN0RXJyb3I6IChlcnJvciwgX3JlcXVlc3QsIGVycm9yQ29udGV4dCk9PnJvdXRlTW9kdWxlLm9uUmVxdWVzdEVycm9yKHJlcSwgZXJyb3IsIGVycm9yQ29udGV4dCwgcm91dGVyU2VydmVyQ29udGV4dClcbiAgICAgICAgfSxcbiAgICAgICAgc2hhcmVkQ29udGV4dDoge1xuICAgICAgICAgICAgYnVpbGRJZFxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBub2RlTmV4dFJlcSA9IG5ldyBOb2RlTmV4dFJlcXVlc3QocmVxKTtcbiAgICBjb25zdCBub2RlTmV4dFJlcyA9IG5ldyBOb2RlTmV4dFJlc3BvbnNlKHJlcyk7XG4gICAgY29uc3QgbmV4dFJlcSA9IE5leHRSZXF1ZXN0QWRhcHRlci5mcm9tTm9kZU5leHRSZXF1ZXN0KG5vZGVOZXh0UmVxLCBzaWduYWxGcm9tTm9kZVJlc3BvbnNlKHJlcykpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGludm9rZVJvdXRlTW9kdWxlID0gYXN5bmMgKHNwYW4pPT57XG4gICAgICAgICAgICByZXR1cm4gcm91dGVNb2R1bGUuaGFuZGxlKG5leHRSZXEsIGNvbnRleHQpLmZpbmFsbHkoKCk9PntcbiAgICAgICAgICAgICAgICBpZiAoIXNwYW4pIHJldHVybjtcbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAnaHR0cC5zdGF0dXNfY29kZSc6IHJlcy5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgICAnbmV4dC5yc2MnOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvb3RTcGFuQXR0cmlidXRlcyA9IHRyYWNlci5nZXRSb290U3BhbkF0dHJpYnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAvLyBXZSB3ZXJlIHVuYWJsZSB0byBnZXQgYXR0cmlidXRlcywgcHJvYmFibHkgT1RFTCBpcyBub3QgZW5hYmxlZFxuICAgICAgICAgICAgICAgIGlmICghcm9vdFNwYW5BdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RTcGFuQXR0cmlidXRlcy5nZXQoJ25leHQuc3Bhbl90eXBlJykgIT09IEJhc2VTZXJ2ZXJTcGFuLmhhbmRsZVJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmV4cGVjdGVkIHJvb3Qgc3BhbiB0eXBlICcke3Jvb3RTcGFuQXR0cmlidXRlcy5nZXQoJ25leHQuc3Bhbl90eXBlJyl9Jy4gUGxlYXNlIHJlcG9ydCB0aGlzIE5leHQuanMgaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGUgPSByb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnJvdXRlJyk7XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBgJHttZXRob2R9ICR7cm91dGV9YDtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXh0LnJvdXRlJzogcm91dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC5yb3V0ZSc6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ25leHQuc3Bhbl9uYW1lJzogbmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi51cGRhdGVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4udXBkYXRlTmFtZShgJHttZXRob2R9ICR7cmVxLnVybH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFuZGxlUmVzcG9uc2UgPSBhc3luYyAoY3VycmVudFNwYW4pPT57XG4gICAgICAgICAgICB2YXIgX2NhY2hlRW50cnlfdmFsdWU7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUdlbmVyYXRvciA9IGFzeW5jICh7IHByZXZpb3VzQ2FjaGVFbnRyeSB9KT0+e1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2V0UmVxdWVzdE1ldGEocmVxLCAnbWluaW1hbE1vZGUnKSAmJiBpc09uRGVtYW5kUmV2YWxpZGF0ZSAmJiByZXZhbGlkYXRlT25seUdlbmVyYXRlZCAmJiAhcHJldmlvdXNDYWNoZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuc3RhdHVzQ29kZSA9IDQwNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uLWRlbWFuZCByZXZhbGlkYXRlIGFsd2F5cyBzZXRzIHRoaXMgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuc2V0SGVhZGVyKCd4LW5leHRqcy1jYWNoZScsICdSRVZBTElEQVRFRCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmVuZCgnVGhpcyBwYWdlIGNvdWxkIG5vdCBiZSBmb3VuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBpbnZva2VSb3V0ZU1vZHVsZShjdXJyZW50U3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5mZXRjaE1ldHJpY3MgPSBjb250ZXh0LnJlbmRlck9wdHMuZmV0Y2hNZXRyaWNzO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGVuZGluZ1dhaXRVbnRpbCA9IGNvbnRleHQucmVuZGVyT3B0cy5wZW5kaW5nV2FpdFVudGlsO1xuICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHVzaW5nIHByb3ZpZGVkIHdhaXRVbnRpbCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQncyBub3Qgd2UgZmFsbGJhY2sgdG8gc2VuZFJlc3BvbnNlJ3MgaGFuZGxpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdXYWl0VW50aWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHgud2FpdFVudGlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LndhaXRVbnRpbChwZW5kaW5nV2FpdFVudGlsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nV2FpdFVudGlsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlVGFncyA9IGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRUYWdzO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdCBpcyBmb3IgYSBzdGF0aWMgcmVzcG9uc2UsIHdlIGNhbiBjYWNoZSBpdCBzbyBsb25nXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIGl0J3Mgbm90IGVkZ2UuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0lzcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcHkgdGhlIGhlYWRlcnMgZnJvbSB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gdG9Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyhyZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZVRhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW05FWFRfQ0FDSEVfVEFHU19IRUFERVJdID0gY2FjaGVUYWdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoZWFkZXJzWydjb250ZW50LXR5cGUnXSAmJiBibG9iLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IGJsb2IudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldmFsaWRhdGUgPSB0eXBlb2YgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZFJldmFsaWRhdGUgPT09ICd1bmRlZmluZWQnIHx8IGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRSZXZhbGlkYXRlID49IElORklOSVRFX0NBQ0hFID8gZmFsc2UgOiBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkUmV2YWxpZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cGlyZSA9IHR5cGVvZiBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkRXhwaXJlID09PSAndW5kZWZpbmVkJyB8fCBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkRXhwaXJlID49IElORklOSVRFX0NBQ0hFID8gdW5kZWZpbmVkIDogY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgY2FjaGUgZW50cnkgZm9yIHRoZSByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlRW50cnkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogQ2FjaGVkUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IEJ1ZmZlci5mcm9tKGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlQ29udHJvbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZhbGlkYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBpcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlRW50cnk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZW5kIHJlc3BvbnNlIHdpdGhvdXQgY2FjaGluZyBpZiBub3QgSVNSXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCByZXNwb25zZSwgY29udGV4dC5yZW5kZXJPcHRzLnBlbmRpbmdXYWl0VW50aWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGJhY2tncm91bmQgcmV2YWxpZGF0ZSB3ZSBuZWVkIHRvIHJlcG9ydFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCBlcnJvciBoZXJlIGFzIGl0IHdvbid0IGJlIGJ1YmJsZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzQ2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogcHJldmlvdXNDYWNoZUVudHJ5LmlzU3RhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJvdXRlTW9kdWxlLm9uUmVxdWVzdEVycm9yKHJlcSwgZXJyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyS2luZDogJ0FwcCBSb3V0ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlUGF0aDogc3JjUGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVR5cGU6ICdyb3V0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZVJlYXNvbjogZ2V0UmV2YWxpZGF0ZVJlYXNvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNPbkRlbWFuZFJldmFsaWRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcm91dGVyU2VydmVyQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjYWNoZUVudHJ5ID0gYXdhaXQgcm91dGVNb2R1bGUuaGFuZGxlUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgIGNhY2hlS2V5LFxuICAgICAgICAgICAgICAgIHJvdXRlS2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgICAgICAgICBpc0ZhbGxiYWNrOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcmVyZW5kZXJNYW5pZmVzdCxcbiAgICAgICAgICAgICAgICBpc1JvdXRlUFBSRW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNPbkRlbWFuZFJldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0ZU9ubHlHZW5lcmF0ZWQsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VHZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgd2FpdFVudGlsOiBjdHgud2FpdFVudGlsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNyZWF0ZSBhIGNhY2hlRW50cnkgZm9yIElTUlxuICAgICAgICAgICAgaWYgKCFpc0lzcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChjYWNoZUVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiAoX2NhY2hlRW50cnlfdmFsdWUgPSBjYWNoZUVudHJ5LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2NhY2hlRW50cnlfdmFsdWUua2luZCkgIT09IENhY2hlZFJvdXRlS2luZC5BUFBfUk9VVEUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2NhY2hlRW50cnlfdmFsdWUxO1xuICAgICAgICAgICAgICAgIHRocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgRXJyb3IoYEludmFyaWFudDogYXBwLXJvdXRlIHJlY2VpdmVkIGludmFsaWQgY2FjaGUgZW50cnkgJHtjYWNoZUVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiAoX2NhY2hlRW50cnlfdmFsdWUxID0gY2FjaGVFbnRyeS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jYWNoZUVudHJ5X3ZhbHVlMS5raW5kfWApLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiRTcwMVwiLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWdldFJlcXVlc3RNZXRhKHJlcSwgJ21pbmltYWxNb2RlJykpIHtcbiAgICAgICAgICAgICAgICByZXMuc2V0SGVhZGVyKCd4LW5leHRqcy1jYWNoZScsIGlzT25EZW1hbmRSZXZhbGlkYXRlID8gJ1JFVkFMSURBVEVEJyA6IGNhY2hlRW50cnkuaXNNaXNzID8gJ01JU1MnIDogY2FjaGVFbnRyeS5pc1N0YWxlID8gJ1NUQUxFJyA6ICdISVQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERyYWZ0IG1vZGUgc2hvdWxkIG5ldmVyIGJlIGNhY2hlZFxuICAgICAgICAgICAgaWYgKGlzRHJhZnRNb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcignQ2FjaGUtQ29udHJvbCcsICdwcml2YXRlLCBuby1jYWNoZSwgbm8tc3RvcmUsIG1heC1hZ2U9MCwgbXVzdC1yZXZhbGlkYXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gZnJvbU5vZGVPdXRnb2luZ0h0dHBIZWFkZXJzKGNhY2hlRW50cnkudmFsdWUuaGVhZGVycyk7XG4gICAgICAgICAgICBpZiAoIShnZXRSZXF1ZXN0TWV0YShyZXEsICdtaW5pbWFsTW9kZScpICYmIGlzSXNyKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuZGVsZXRlKE5FWFRfQ0FDSEVfVEFHU19IRUFERVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgY2FjaGUgY29udHJvbCBpcyBhbHJlYWR5IHNldCBvbiB0aGUgcmVzcG9uc2Ugd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlIGl0IHRvIGFsbG93IHVzZXJzIHRvIGN1c3RvbWl6ZSBpdCB2aWEgbmV4dC5jb25maWdcbiAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5LmNhY2hlQ29udHJvbCAmJiAhcmVzLmdldEhlYWRlcignQ2FjaGUtQ29udHJvbCcpICYmICFoZWFkZXJzLmdldCgnQ2FjaGUtQ29udHJvbCcpKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5zZXQoJ0NhY2hlLUNvbnRyb2wnLCBnZXRDYWNoZUNvbnRyb2xIZWFkZXIoY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHNlbmRSZXNwb25zZShub2RlTmV4dFJlcSwgbm9kZU5leHRSZXMsIG5ldyBSZXNwb25zZShjYWNoZUVudHJ5LnZhbHVlLmJvZHksIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIHN0YXR1czogY2FjaGVFbnRyeS52YWx1ZS5zdGF0dXMgfHwgMjAwXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETzogYWN0aXZlU3BhbiBjb2RlIHBhdGggaXMgZm9yIHdoZW4gd3JhcHBlZCBieVxuICAgICAgICAvLyBuZXh0LXNlcnZlciBjYW4gYmUgcmVtb3ZlZCB3aGVuIHRoaXMgaXMgbm8gbG9uZ2VyIHVzZWRcbiAgICAgICAgaWYgKGFjdGl2ZVNwYW4pIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZVJlc3BvbnNlKGFjdGl2ZVNwYW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdHJhY2VyLndpdGhQcm9wYWdhdGVkQ29udGV4dChyZXEuaGVhZGVycywgKCk9PnRyYWNlci50cmFjZShCYXNlU2VydmVyU3Bhbi5oYW5kbGVSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW5OYW1lOiBgJHttZXRob2R9ICR7cmVxLnVybH1gLFxuICAgICAgICAgICAgICAgICAgICBraW5kOiBTcGFuS2luZC5TRVJWRVIsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdodHRwLm1ldGhvZCc6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdodHRwLnRhcmdldCc6IHJlcS51cmxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGhhbmRsZVJlc3BvbnNlKSk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gaWYgd2UgYXJlbid0IHdyYXBwZWQgYnkgYmFzZS1zZXJ2ZXIgaGFuZGxlIGhlcmVcbiAgICAgICAgaWYgKCFhY3RpdmVTcGFuICYmICEoZXJyIGluc3RhbmNlb2YgTm9GYWxsYmFja0Vycm9yKSkge1xuICAgICAgICAgICAgYXdhaXQgcm91dGVNb2R1bGUub25SZXF1ZXN0RXJyb3IocmVxLCBlcnIsIHtcbiAgICAgICAgICAgICAgICByb3V0ZXJLaW5kOiAnQXBwIFJvdXRlcicsXG4gICAgICAgICAgICAgICAgcm91dGVQYXRoOiBub3JtYWxpemVkU3JjUGFnZSxcbiAgICAgICAgICAgICAgICByb3V0ZVR5cGU6ICdyb3V0ZScsXG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0ZVJlYXNvbjogZ2V0UmV2YWxpZGF0ZVJlYXNvbih7XG4gICAgICAgICAgICAgICAgICAgIGlzUmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNPbkRlbWFuZFJldmFsaWRhdGVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0aHJvdyBzbyB0aGF0IHdlIGNhbiBoYW5kbGUgc2VydmluZyBlcnJvciBwYWdlXG4gICAgICAgIC8vIElmIHRoaXMgaXMgZHVyaW5nIHN0YXRpYyBnZW5lcmF0aW9uLCB0aHJvdyB0aGUgZXJyb3IgYWdhaW4uXG4gICAgICAgIGlmIChpc0lzcikgdGhyb3cgZXJyO1xuICAgICAgICAvLyBPdGhlcndpc2UsIHNlbmQgYSA1MDAgcmVzcG9uc2UuXG4gICAgICAgIGF3YWl0IHNlbmRSZXNwb25zZShub2RlTmV4dFJlcSwgbm9kZU5leHRSZXMsIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgICAgICBzdGF0dXM6IDUwMFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fmoo-aux%2Froute&page=%2Fapi%2Fmoo-aux%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fmoo-aux%2Froute.ts&appDir=H%3A%5CUsers%5CGus%5Csource%5Crepo%5Cdynamics%5Cdynamics-b%5Ccryptopi-dynamics%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=H%3A%5CUsers%5CGus%5Csource%5Crepo%5Cdynamics%5Cdynamics-b%5Ccryptopi-dynamics&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-flight-action-entry-loader.js?actions=%5B%5B%22H%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%2C%5B%7B%22id%22%3A%2200532f31c65bd9d7119874b7c000efa42c3a9e2e3a%22%2C%22exportedName%22%3A%22getAll%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%2C%7B%22id%22%3A%2200696b0d07c16ebe05246c326940d3b9133dac036c%22%2C%22exportedName%22%3A%22resolveCoinsFromSettings%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%2C%7B%22id%22%3A%22402b519d81502a95cf319ddb5b60bce32907aa6f08%22%2C%22exportedName%22%3A%22setAll%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%2C%7B%22id%22%3A%2240f9a1c8f3a3ab5d85ba51065396bf00a061db869e%22%2C%22exportedName%22%3A%22serializeSettingsCookie%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%5D%5D%5D&__client_imported__=!":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-flight-action-entry-loader.js?actions=%5B%5B%22H%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%2C%5B%7B%22id%22%3A%2200532f31c65bd9d7119874b7c000efa42c3a9e2e3a%22%2C%22exportedName%22%3A%22getAll%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%2C%7B%22id%22%3A%2200696b0d07c16ebe05246c326940d3b9133dac036c%22%2C%22exportedName%22%3A%22resolveCoinsFromSettings%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%2C%7B%22id%22%3A%22402b519d81502a95cf319ddb5b60bce32907aa6f08%22%2C%22exportedName%22%3A%22setAll%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%2C%7B%22id%22%3A%2240f9a1c8f3a3ab5d85ba51065396bf00a061db869e%22%2C%22exportedName%22%3A%22serializeSettingsCookie%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%5D%5D%5D&__client_imported__=! ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"00532f31c65bd9d7119874b7c000efa42c3a9e2e3a\": () => (/* reexport safe */ H_Users_Gus_source_repo_dynamics_dynamics_b_cryptopi_dynamics_src_lib_settings_server_ts__WEBPACK_IMPORTED_MODULE_0__.getAll),\n/* harmony export */   \"00696b0d07c16ebe05246c326940d3b9133dac036c\": () => (/* reexport safe */ H_Users_Gus_source_repo_dynamics_dynamics_b_cryptopi_dynamics_src_lib_settings_server_ts__WEBPACK_IMPORTED_MODULE_0__.resolveCoinsFromSettings),\n/* harmony export */   \"402b519d81502a95cf319ddb5b60bce32907aa6f08\": () => (/* reexport safe */ H_Users_Gus_source_repo_dynamics_dynamics_b_cryptopi_dynamics_src_lib_settings_server_ts__WEBPACK_IMPORTED_MODULE_0__.setAll),\n/* harmony export */   \"40f9a1c8f3a3ab5d85ba51065396bf00a061db869e\": () => (/* reexport safe */ H_Users_Gus_source_repo_dynamics_dynamics_b_cryptopi_dynamics_src_lib_settings_server_ts__WEBPACK_IMPORTED_MODULE_0__.serializeSettingsCookie)\n/* harmony export */ });\n/* harmony import */ var H_Users_Gus_source_repo_dynamics_dynamics_b_cryptopi_dynamics_src_lib_settings_server_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/lib/settings/server.ts */ \"(rsc)/./src/lib/settings/server.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([H_Users_Gus_source_repo_dynamics_dynamics_b_cryptopi_dynamics_src_lib_settings_server_ts__WEBPACK_IMPORTED_MODULE_0__]);\nH_Users_Gus_source_repo_dynamics_dynamics_b_cryptopi_dynamics_src_lib_settings_server_ts__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS41LjJfQHBsYXl3cmlnaHQrdGVzX2I3ZTZjMjgwZTlhMWI0MzA5MzQ3YzBiZjBhYjQ3NmQ1L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWFjdGlvbi1lbnRyeS1sb2FkZXIuanM/YWN0aW9ucz0lNUIlNUIlMjJIJTNBJTVDJTVDVXNlcnMlNUMlNUNHdXMlNUMlNUNzb3VyY2UlNUMlNUNyZXBvJTVDJTVDZHluYW1pY3MlNUMlNUNkeW5hbWljcy1iJTVDJTVDY3J5cHRvcGktZHluYW1pY3MlNUMlNUNzcmMlNUMlNUNsaWIlNUMlNUNzZXR0aW5ncyU1QyU1Q3NlcnZlci50cyUyMiUyQyU1QiU3QiUyMmlkJTIyJTNBJTIyMDA1MzJmMzFjNjViZDlkNzExOTg3NGI3YzAwMGVmYTQyYzNhOWUyZTNhJTIyJTJDJTIyZXhwb3J0ZWROYW1lJTIyJTNBJTIyZ2V0QWxsJTIyJTJDJTIyZmlsZW5hbWUlMjIlM0ElMjIuLiUyRkglM0ElNUMlNUNVc2VycyU1QyU1Q0d1cyU1QyU1Q3NvdXJjZSU1QyU1Q3JlcG8lNUMlNUNkeW5hbWljcyU1QyU1Q2R5bmFtaWNzLWIlNUMlNUNjcnlwdG9waS1keW5hbWljcyU1QyU1Q3NyYyU1QyU1Q2xpYiU1QyU1Q3NldHRpbmdzJTVDJTVDc2VydmVyLnRzJTIyJTdEJTJDJTdCJTIyaWQlMjIlM0ElMjIwMDY5NmIwZDA3YzE2ZWJlMDUyNDZjMzI2OTQwZDNiOTEzM2RhYzAzNmMlMjIlMkMlMjJleHBvcnRlZE5hbWUlMjIlM0ElMjJyZXNvbHZlQ29pbnNGcm9tU2V0dGluZ3MlMjIlMkMlMjJmaWxlbmFtZSUyMiUzQSUyMi4uJTJGSCUzQSU1QyU1Q1VzZXJzJTVDJTVDR3VzJTVDJTVDc291cmNlJTVDJTVDcmVwbyU1QyU1Q2R5bmFtaWNzJTVDJTVDZHluYW1pY3MtYiU1QyU1Q2NyeXB0b3BpLWR5bmFtaWNzJTVDJTVDc3JjJTVDJTVDbGliJTVDJTVDc2V0dGluZ3MlNUMlNUNzZXJ2ZXIudHMlMjIlN0QlMkMlN0IlMjJpZCUyMiUzQSUyMjQwMmI1MTlkODE1MDJhOTVjZjMxOWRkYjViNjBiY2UzMjkwN2FhNmYwOCUyMiUyQyUyMmV4cG9ydGVkTmFtZSUyMiUzQSUyMnNldEFsbCUyMiUyQyUyMmZpbGVuYW1lJTIyJTNBJTIyLi4lMkZIJTNBJTVDJTVDVXNlcnMlNUMlNUNHdXMlNUMlNUNzb3VyY2UlNUMlNUNyZXBvJTVDJTVDZHluYW1pY3MlNUMlNUNkeW5hbWljcy1iJTVDJTVDY3J5cHRvcGktZHluYW1pY3MlNUMlNUNzcmMlNUMlNUNsaWIlNUMlNUNzZXR0aW5ncyU1QyU1Q3NlcnZlci50cyUyMiU3RCUyQyU3QiUyMmlkJTIyJTNBJTIyNDBmOWExYzhmM2EzYWI1ZDg1YmE1MTA2NTM5NmJmMDBhMDYxZGI4NjllJTIyJTJDJTIyZXhwb3J0ZWROYW1lJTIyJTNBJTIyc2VyaWFsaXplU2V0dGluZ3NDb29raWUlMjIlMkMlMjJmaWxlbmFtZSUyMiUzQSUyMi4uJTJGSCUzQSU1QyU1Q1VzZXJzJTVDJTVDR3VzJTVDJTVDc291cmNlJTVDJTVDcmVwbyU1QyU1Q2R5bmFtaWNzJTVDJTVDZHluYW1pY3MtYiU1QyU1Q2NyeXB0b3BpLWR5bmFtaWNzJTVDJTVDc3JjJTVDJTVDbGliJTVDJTVDc2V0dGluZ3MlNUMlNUNzZXJ2ZXIudHMlMjIlN0QlNUQlNUQlNUQmX19jbGllbnRfaW1wb3J0ZWRfXz0hIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUM2SztBQUNrQjtBQUNsQjtBQUNpQiIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuZXhwb3J0IHsgZ2V0QWxsIGFzIFwiMDA1MzJmMzFjNjViZDlkNzExOTg3NGI3YzAwMGVmYTQyYzNhOWUyZTNhXCIgfSBmcm9tIFwiSDpcXFxcVXNlcnNcXFxcR3VzXFxcXHNvdXJjZVxcXFxyZXBvXFxcXGR5bmFtaWNzXFxcXGR5bmFtaWNzLWJcXFxcY3J5cHRvcGktZHluYW1pY3NcXFxcc3JjXFxcXGxpYlxcXFxzZXR0aW5nc1xcXFxzZXJ2ZXIudHNcIlxuZXhwb3J0IHsgcmVzb2x2ZUNvaW5zRnJvbVNldHRpbmdzIGFzIFwiMDA2OTZiMGQwN2MxNmViZTA1MjQ2YzMyNjk0MGQzYjkxMzNkYWMwMzZjXCIgfSBmcm9tIFwiSDpcXFxcVXNlcnNcXFxcR3VzXFxcXHNvdXJjZVxcXFxyZXBvXFxcXGR5bmFtaWNzXFxcXGR5bmFtaWNzLWJcXFxcY3J5cHRvcGktZHluYW1pY3NcXFxcc3JjXFxcXGxpYlxcXFxzZXR0aW5nc1xcXFxzZXJ2ZXIudHNcIlxuZXhwb3J0IHsgc2V0QWxsIGFzIFwiNDAyYjUxOWQ4MTUwMmE5NWNmMzE5ZGRiNWI2MGJjZTMyOTA3YWE2ZjA4XCIgfSBmcm9tIFwiSDpcXFxcVXNlcnNcXFxcR3VzXFxcXHNvdXJjZVxcXFxyZXBvXFxcXGR5bmFtaWNzXFxcXGR5bmFtaWNzLWJcXFxcY3J5cHRvcGktZHluYW1pY3NcXFxcc3JjXFxcXGxpYlxcXFxzZXR0aW5nc1xcXFxzZXJ2ZXIudHNcIlxuZXhwb3J0IHsgc2VyaWFsaXplU2V0dGluZ3NDb29raWUgYXMgXCI0MGY5YTFjOGYzYTNhYjVkODViYTUxMDY1Mzk2YmYwMGEwNjFkYjg2OWVcIiB9IGZyb20gXCJIOlxcXFxVc2Vyc1xcXFxHdXNcXFxcc291cmNlXFxcXHJlcG9cXFxcZHluYW1pY3NcXFxcZHluYW1pY3MtYlxcXFxjcnlwdG9waS1keW5hbWljc1xcXFxzcmNcXFxcbGliXFxcXHNldHRpbmdzXFxcXHNlcnZlci50c1wiXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-flight-action-entry-loader.js?actions=%5B%5B%22H%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%2C%5B%7B%22id%22%3A%2200532f31c65bd9d7119874b7c000efa42c3a9e2e3a%22%2C%22exportedName%22%3A%22getAll%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%2C%7B%22id%22%3A%2200696b0d07c16ebe05246c326940d3b9133dac036c%22%2C%22exportedName%22%3A%22resolveCoinsFromSettings%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%2C%7B%22id%22%3A%22402b519d81502a95cf319ddb5b60bce32907aa6f08%22%2C%22exportedName%22%3A%22setAll%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%2C%7B%22id%22%3A%2240f9a1c8f3a3ab5d85ba51065396bf00a061db869e%22%2C%22exportedName%22%3A%22serializeSettingsCookie%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%5D%5D%5D&__client_imported__=!\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!**************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \**************************************************************************************************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(rsc)/./src/app/api/matrices/latest/route.ts":
/*!**********************************************!*\
  !*** ./src/app/api/matrices/latest/route.ts ***!
  \**********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   buildMatricesLatestPayload: () => (/* binding */ buildMatricesLatestPayload),\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/api/server.js\");\n/* harmony import */ var next_headers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/headers */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/api/headers.js\");\n/* harmony import */ var _core_db_db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/core/db/db */ \"(rsc)/./src/core/db/db.ts\");\n/* harmony import */ var _core_features_matrices_liveFromSources__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/core/features/matrices/liveFromSources */ \"(rsc)/./src/core/features/matrices/liveFromSources.ts\");\n/* harmony import */ var _core_maths_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/core/maths/math */ \"(rsc)/./src/core/maths/math.ts\");\n/* harmony import */ var _core_features_matrices_opening__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/core/features/matrices/opening */ \"(rsc)/./src/core/features/matrices/opening.ts\");\n/* harmony import */ var _lib_settings_server__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/settings/server */ \"(rsc)/./src/lib/settings/server.ts\");\n/* harmony import */ var _lib_settings_coin_universe__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/lib/settings/coin-universe */ \"(rsc)/./src/lib/settings/coin-universe.ts\");\n/* harmony import */ var _core_db_pool_server__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/core/db/pool_server */ \"(rsc)/./src/core/db/pool_server.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_db_db__WEBPACK_IMPORTED_MODULE_2__, _core_features_matrices_liveFromSources__WEBPACK_IMPORTED_MODULE_3__, _core_features_matrices_opening__WEBPACK_IMPORTED_MODULE_5__, _lib_settings_server__WEBPACK_IMPORTED_MODULE_6__, _lib_settings_coin_universe__WEBPACK_IMPORTED_MODULE_7__, _core_db_pool_server__WEBPACK_IMPORTED_MODULE_8__]);\n([_core_db_db__WEBPACK_IMPORTED_MODULE_2__, _core_features_matrices_liveFromSources__WEBPACK_IMPORTED_MODULE_3__, _core_features_matrices_opening__WEBPACK_IMPORTED_MODULE_5__, _lib_settings_server__WEBPACK_IMPORTED_MODULE_6__, _lib_settings_coin_universe__WEBPACK_IMPORTED_MODULE_7__, _core_db_pool_server__WEBPACK_IMPORTED_MODULE_8__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n// app/api/matrices/latest/route.ts\n\n\n\n\n\n\n\n\n\nconst ALLOWED_WINDOWS = new Set([\n    \"15m\",\n    \"30m\",\n    \"1h\"\n]);\nconst normalizeCoins = (xs)=>Array.from(new Set(xs.map((s)=>s.trim().toUpperCase()).filter(Boolean)));\nfunction parseCoinsCSV(csv) {\n    if (!csv) return null;\n    return normalizeCoins(csv.split(\",\"));\n}\nfunction parseCoinsJSON(jsonStr) {\n    if (!jsonStr) return null;\n    try {\n        const xs = JSON.parse(jsonStr);\n        if (!Array.isArray(xs)) return null;\n        return normalizeCoins(xs);\n    } catch  {\n        return null;\n    }\n}\nfunction coinsAddUSDTFirst(userCoins) {\n    const xs = normalizeCoins(userCoins);\n    const withoutUSDT = xs.filter((c)=>c !== \"USDT\");\n    return [\n        \"USDT\",\n        ...withoutUSDT\n    ];\n}\nasync function coinsFromCookiesOrHeaders() {\n    const bagCookies = (0,next_headers__WEBPACK_IMPORTED_MODULE_1__.cookies)();\n    const bagHeaders = (0,next_headers__WEBPACK_IMPORTED_MODULE_1__.headers)();\n    const ckJson = (await bagCookies).get(\"cp_coins\")?.value; // JSON array\n    const ckCsv = (await bagCookies).get(\"cp.coins\")?.value; // CSV\n    const fromCkJson = parseCoinsJSON(ckJson);\n    const fromCkCsv = parseCoinsCSV(ckCsv);\n    if (fromCkJson?.length) return fromCkJson;\n    if (fromCkCsv?.length) return fromCkCsv;\n    const hxCsv = (await bagHeaders).get(\"x-cp-coins\");\n    const hxJson = (await bagHeaders).get(\"x-cp-coins-json\");\n    const fromHxCsv = parseCoinsCSV(hxCsv ?? undefined);\n    const fromHxJson = parseCoinsJSON(hxJson ?? undefined);\n    if (fromHxJson?.length) return fromHxJson;\n    if (fromHxCsv?.length) return fromHxCsv;\n    return null;\n}\nasync function resolveCoinsUniverse(preferred) {\n    if (preferred && preferred.length) return coinsAddUSDTFirst(preferred);\n    const fromSettings = await (0,_lib_settings_server__WEBPACK_IMPORTED_MODULE_6__.resolveCoinsFromSettings)();\n    if (fromSettings.length) return coinsAddUSDTFirst(fromSettings);\n    const legacy = await coinsFromCookiesOrHeaders();\n    if (legacy?.length) return coinsAddUSDTFirst(legacy);\n    return [\n        \"USDT\"\n    ];\n}\nfunction ensureWindow(win) {\n    if (!win) return \"30m\";\n    const lc = win.toLowerCase();\n    return ALLOWED_WINDOWS.has(lc) ? lc : \"30m\";\n}\nfunction toGrid(coins, values) {\n    const n = coins.length;\n    const grid = Array.from({\n        length: n\n    }, ()=>Array.from({\n            length: n\n        }, ()=>null));\n    for(let i = 0; i < n; i++){\n        const bi = coins[i];\n        const row = values[bi] || {};\n        for(let j = 0; j < n; j++){\n            if (i === j) continue;\n            const qj = coins[j];\n            const v = row[qj];\n            grid[i][j] = v == null ? null : Number(v);\n        }\n    }\n    return grid;\n}\nfunction toValues(coins, grid) {\n    const out = {};\n    for(let i = 0; i < coins.length; i++){\n        const bi = coins[i];\n        out[bi] = {};\n        for(let j = 0; j < coins.length; j++){\n            if (i === j) continue;\n            const qj = coins[j];\n            out[bi][qj] = grid[i][j] ?? null;\n        }\n    }\n    return out;\n}\nfunction parseQuery(req) {\n    const url = new URL(req.url);\n    const qCoins = parseCoinsCSV(url.searchParams.get(\"coins\"));\n    const quote = (url.searchParams.get(\"quote\") || \"USDT\").toUpperCase();\n    const window = ensureWindow(url.searchParams.get(\"window\"));\n    const appSessionId = url.searchParams.get(\"appSessionId\") || null;\n    return {\n        coins: qCoins,\n        quote,\n        window,\n        appSessionId\n    };\n}\nconst pickValues = (coins, vals)=>{\n    const toKeep = coins;\n    const out = {};\n    for (const b of toKeep){\n        const row = vals[b] || {};\n        const dst = {};\n        for (const q of toKeep){\n            if (b === q) continue;\n            if (Object.prototype.hasOwnProperty.call(row, q)) {\n                dst[q] = row[q];\n            }\n        }\n        out[b] = dst;\n    }\n    return out;\n};\nasync function buildMatricesLatestPayload(params = {}) {\n    const quote = (params.quote ?? \"USDT\").toUpperCase();\n    const window = ensureWindow(params.window ?? null);\n    const appSessionId = params.appSessionId ?? null;\n    try {\n        const queryCoinsNormalized = Array.isArray(params.coins) ? normalizeCoins(params.coins) : null;\n        const preferCoins = queryCoinsNormalized && queryCoinsNormalized.length ? queryCoinsNormalized : null;\n        const resolvedCoins = await resolveCoinsUniverse(preferCoins);\n        const viewCoins = preferCoins == null ? await (0,_lib_settings_coin_universe__WEBPACK_IMPORTED_MODULE_7__.fetchPairUniverseCoins)() : [];\n        const coins = normalizeCoins([\n            ...resolvedCoins,\n            ...viewCoins\n        ]);\n        if (!coins.length) {\n            throw new Error(\"No coins resolved for matrices universe\");\n        }\n        const live = await (0,_core_features_matrices_liveFromSources__WEBPACK_IMPORTED_MODULE_3__.liveFromSources)(coins);\n        const bmGrid = toGrid(coins, live.matrices.benchmark.values);\n        const nowTs = live.matrices.benchmark.ts;\n        const [prevBenchmarkRows, prevIdPctRows] = await Promise.all([\n            (0,_core_db_db__WEBPACK_IMPORTED_MODULE_2__.getPrevSnapshotByType)(\"benchmark\", nowTs, coins),\n            (0,_core_db_db__WEBPACK_IMPORTED_MODULE_2__.getPrevSnapshotByType)(\"id_pct\", nowTs, coins)\n        ]);\n        const prevBenchmarkMap = new Map();\n        for (const row of prevBenchmarkRows){\n            const key = `${row.base.toUpperCase()}/${row.quote.toUpperCase()}`;\n            const value = Number(row.value);\n            if (Number.isFinite(value)) prevBenchmarkMap.set(key, value);\n        }\n        const prevIdPctMap = new Map();\n        for (const row of prevIdPctRows){\n            const key = `${row.base.toUpperCase()}/${row.quote.toUpperCase()}`;\n            const value = Number(row.value);\n            if (Number.isFinite(value)) prevIdPctMap.set(key, value);\n        }\n        let lastOpeningTs = null;\n        (0,_core_maths_math__WEBPACK_IMPORTED_MODULE_4__.configureBenchmarkProviders)({\n            getPrev: async (matrix_type, base, quoteSym, beforeTs)=>{\n                const key = `${base.toUpperCase()}/${quoteSym.toUpperCase()}`;\n                const fromPrefetch = matrix_type === \"benchmark\" ? prevBenchmarkMap.get(key) : matrix_type === \"id_pct\" ? prevIdPctMap.get(key) : undefined;\n                if (fromPrefetch != null) return fromPrefetch;\n                return (0,_core_db_db__WEBPACK_IMPORTED_MODULE_2__.getPrevValue)(matrix_type, base.toUpperCase(), quoteSym.toUpperCase(), beforeTs);\n            },\n            fetchOpeningGrid: async (coinsUniverse, nowTsParam)=>{\n                const ref = await (0,_core_features_matrices_opening__WEBPACK_IMPORTED_MODULE_5__.fetchOpeningGridFromView)({\n                    coins: coinsUniverse,\n                    window,\n                    appSessionId,\n                    openingTs: undefined\n                });\n                lastOpeningTs = ref.ts ?? nowTsParam;\n                return {\n                    ts: ref.ts ?? nowTsParam,\n                    grid: ref.grid\n                };\n            }\n        });\n        const derived = await (0,_core_maths_math__WEBPACK_IMPORTED_MODULE_4__.computeFromDbAndLive)({\n            coins: coins.slice(),\n            nowTs,\n            liveBenchmark: bmGrid\n        });\n        const bmValues = pickValues(coins, live.matrices.benchmark.values);\n        const pct24Values = pickValues(coins, live.matrices.pct24h.values);\n        const idPctValues = toValues(coins, derived.id_pct);\n        const drvValues = toValues(coins, derived.pct_drv);\n        const pctRefValues = toValues(coins, derived.pct_ref);\n        const refValues = toValues(coins, derived.ref);\n        const deltaValues = toValues(coins, derived.delta);\n        const symbols = [];\n        for(let i = 0; i < coins.length; i++){\n            for(let j = 0; j < coins.length; j++){\n                if (i === j) continue;\n                symbols.push(`${coins[i]}${coins[j]}`);\n            }\n        }\n        const coinsDisplay = coins.filter((c)=>c !== quote);\n        return {\n            ok: true,\n            coins: coinsDisplay,\n            symbols,\n            quote,\n            window,\n            ts: nowTs,\n            matrices: {\n                benchmark: {\n                    ts: nowTs,\n                    values: bmValues,\n                    flags: live.matrices.benchmark.flags\n                },\n                pct24h: {\n                    ts: nowTs,\n                    values: pct24Values,\n                    flags: live.matrices.pct24h.flags\n                },\n                id_pct: {\n                    ts: nowTs,\n                    values: idPctValues\n                },\n                pct_drv: {\n                    ts: nowTs,\n                    values: drvValues\n                },\n                pct_ref: {\n                    ts: nowTs,\n                    values: pctRefValues\n                },\n                ref: {\n                    ts: nowTs,\n                    values: refValues\n                },\n                delta: {\n                    ts: nowTs,\n                    values: deltaValues\n                }\n            },\n            meta: {\n                openingTs: lastOpeningTs,\n                universe: coins\n            }\n        };\n    } catch (err) {\n        console.error(\"[matrices/latest] error:\", err);\n        return {\n            ok: false,\n            error: String(err?.message ?? err)\n        };\n    }\n}\nasync function GET(req) {\n    const q = parseQuery(req);\n    const payload = await buildMatricesLatestPayload(q);\n    const status = payload.ok ? 200 : 500;\n    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(payload, {\n        status\n    });\n}\nasync function handler(_req, res) {\n    try {\n        const sql = `\n      SELECT dv.*\n      FROM matrices.dyn_values dv\n      JOIN settings.coin_universe cu\n        ON cu.base_asset = dv.base\n       AND cu.quote_asset = dv.quote\n       AND cu.enabled = true\n      WHERE dv.matrix_type = 'benchmark'\n        AND dv.ts_ms = (\n          SELECT MAX(ts_ms)\n          FROM matrices.dyn_values d2\n          WHERE d2.matrix_type = dv.matrix_type\n            AND d2.base = dv.base\n            AND d2.quote = dv.quote\n        )\n      ORDER BY COALESCE(cu.sort_order, 999), dv.base\n    `;\n        const { rows } = await (0,_core_db_pool_server__WEBPACK_IMPORTED_MODULE_8__.query)(sql);\n        res.status(200).json(rows);\n    } catch (e) {\n        res.status(500).json({\n            error: e?.message ?? \"unknown error\"\n        });\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvYXBwL2FwaS9tYXRyaWNlcy9sYXRlc3Qvcm91dGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsbUNBQW1DO0FBRVE7QUFDSztBQUsxQjtBQUNxRDtBQUloRDtBQUNpRDtBQUNYO0FBQ0s7QUFTeEI7QUFTOUMsTUFBTVksa0JBQWtCLElBQUlDLElBQUk7SUFBQztJQUFPO0lBQU87Q0FBSztBQUdwRCxNQUFNQyxpQkFBaUIsQ0FBQ0MsS0FDdEJDLE1BQU1DLElBQUksQ0FBQyxJQUFJSixJQUFJRSxHQUFHRyxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRUMsSUFBSSxHQUFHQyxXQUFXLElBQUlDLE1BQU0sQ0FBQ0M7QUFFbEUsU0FBU0MsY0FBY0MsR0FBOEI7SUFDbkQsSUFBSSxDQUFDQSxLQUFLLE9BQU87SUFDakIsT0FBT1gsZUFBZVcsSUFBSUMsS0FBSyxDQUFDO0FBQ2xDO0FBRUEsU0FBU0MsZUFBZUMsT0FBa0M7SUFDeEQsSUFBSSxDQUFDQSxTQUFTLE9BQU87SUFDckIsSUFBSTtRQUNGLE1BQU1iLEtBQUtjLEtBQUtDLEtBQUssQ0FBQ0Y7UUFDdEIsSUFBSSxDQUFDWixNQUFNZSxPQUFPLENBQUNoQixLQUFLLE9BQU87UUFDL0IsT0FBT0QsZUFBZUM7SUFDeEIsRUFBRSxPQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0Y7QUFFQSxTQUFTaUIsa0JBQWtCQyxTQUE0QjtJQUNyRCxNQUFNbEIsS0FBS0QsZUFBZW1CO0lBQzFCLE1BQU1DLGNBQWNuQixHQUFHTyxNQUFNLENBQUMsQ0FBQ2EsSUFBTUEsTUFBTTtJQUMzQyxPQUFPO1FBQUM7V0FBV0Q7S0FBWTtBQUNqQztBQUVBLGVBQWVFO0lBQ2IsTUFBTUMsYUFBYXBDLHFEQUFPQTtJQUMxQixNQUFNcUMsYUFBYXBDLHFEQUFPQTtJQUUxQixNQUFNcUMsU0FBUyxDQUFDLE1BQU1GLFVBQVMsRUFBR0csR0FBRyxDQUFDLGFBQWFDLE9BQU8sYUFBYTtJQUN2RSxNQUFNQyxR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ZHluYW1pY3MtYlxcY3J5cHRvcGktZHluYW1pY3NcXHNyY1xcYXBwXFxhcGlcXG1hdHJpY2VzXFxsYXRlc3RcXHJvdXRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGFwcC9hcGkvbWF0cmljZXMvbGF0ZXN0L3JvdXRlLnRzXG5cbmltcG9ydCB7IE5leHRSZXNwb25zZSB9IGZyb20gXCJuZXh0L3NlcnZlclwiO1xuaW1wb3J0IHsgY29va2llcywgaGVhZGVycyB9IGZyb20gXCJuZXh0L2hlYWRlcnNcIjtcbmltcG9ydCB0eXBlIHsgTmV4dEFwaVJlcXVlc3QsIE5leHRBcGlSZXNwb25zZSB9IGZyb20gXCJuZXh0XCI7XG5pbXBvcnQge1xuICBnZXRQcmV2U25hcHNob3RCeVR5cGUsXG4gIGdldFByZXZWYWx1ZSxcbn0gZnJvbSBcIkAvY29yZS9kYi9kYlwiO1xuaW1wb3J0IHsgbGl2ZUZyb21Tb3VyY2VzIH0gZnJvbSBcIkAvY29yZS9mZWF0dXJlcy9tYXRyaWNlcy9saXZlRnJvbVNvdXJjZXNcIjtcbmltcG9ydCB7XG4gIGNvbmZpZ3VyZUJlbmNobWFya1Byb3ZpZGVycyxcbiAgY29tcHV0ZUZyb21EYkFuZExpdmUsXG59IGZyb20gXCJAL2NvcmUvbWF0aHMvbWF0aFwiO1xuaW1wb3J0IHsgZmV0Y2hPcGVuaW5nR3JpZEZyb21WaWV3IH0gZnJvbSBcIkAvY29yZS9mZWF0dXJlcy9tYXRyaWNlcy9vcGVuaW5nXCI7XG5pbXBvcnQgeyByZXNvbHZlQ29pbnNGcm9tU2V0dGluZ3MgfSBmcm9tIFwiQC9saWIvc2V0dGluZ3Mvc2VydmVyXCI7XG5pbXBvcnQgeyBmZXRjaFBhaXJVbml2ZXJzZUNvaW5zIH0gZnJvbSBcIkAvbGliL3NldHRpbmdzL2NvaW4tdW5pdmVyc2VcIjtcbi8vIHR5cGVkIGRvd25zdHJlYW0gaW1wb3J0IGZyb20gbWF0cmljZXMgZnJvemVuIGhlbHBlcnMgKG5vIHJ1bnRpbWUgaW1wYWN0KVxuaW1wb3J0IHR5cGUge1xuICBGcm96ZW5QYWlyS2V5LFxuICBidWlsZEZyb3plblNldEZyb21GbGFncyxcbiAgbWF0ZXJpYWxpemVGcm96ZW5HcmlkRnJvbVNldCxcbiAgaXNQYWlyRnJvemVuRnJvbVNldCxcbiAgZ2V0RnJvemVuU2V0RnJvbU1hdHJpY2VzTGF0ZXN0LFxufSBmcm9tIFwiQC9jb3JlL2ZlYXR1cmVzL21hdHJpY2VzL21hdHJpY2VzXCI7XG5pbXBvcnQgeyBxdWVyeSB9IGZyb20gXCJAL2NvcmUvZGIvcG9vbF9zZXJ2ZXJcIjtcblxuLy8ga2VlcCB0aGVzZSBhbGlhc2VzIHNvIFRTIHRyZWF0cyB0aGUgaW1wb3J0cyBhcyDigJx1c2Vk4oCdIChzdGlsbCB0eXBlLW9ubHkpXG50eXBlIF9Gcm96ZW5QYWlyS2V5ID0gRnJvemVuUGFpcktleTtcbnR5cGUgX0Zyb3plblNldEJ1aWxkZXIgPSB0eXBlb2YgYnVpbGRGcm96ZW5TZXRGcm9tRmxhZ3M7XG50eXBlIF9Gcm96ZW5HcmlkTWF0ZXJpYWxpemVyID0gdHlwZW9mIG1hdGVyaWFsaXplRnJvemVuR3JpZEZyb21TZXQ7XG50eXBlIF9Jc1BhaXJGcm96ZW4gPSB0eXBlb2YgaXNQYWlyRnJvemVuRnJvbVNldDtcbnR5cGUgX0dldEZyb3plblNldExhdGVzdCA9IHR5cGVvZiBnZXRGcm96ZW5TZXRGcm9tTWF0cmljZXNMYXRlc3Q7XG5cbmNvbnN0IEFMTE9XRURfV0lORE9XUyA9IG5ldyBTZXQoW1wiMTVtXCIsIFwiMzBtXCIsIFwiMWhcIl0gYXMgY29uc3QpO1xudHlwZSBNYXRyaXhXaW5kb3cgPSBcIjE1bVwiIHwgXCIzMG1cIiB8IFwiMWhcIjtcblxuY29uc3Qgbm9ybWFsaXplQ29pbnMgPSAoeHM6IHJlYWRvbmx5IHN0cmluZ1tdKSA9PlxuICBBcnJheS5mcm9tKG5ldyBTZXQoeHMubWFwKChzKSA9PiBzLnRyaW0oKS50b1VwcGVyQ2FzZSgpKS5maWx0ZXIoQm9vbGVhbikpKTtcblxuZnVuY3Rpb24gcGFyc2VDb2luc0NTVihjc3Y6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpOiBzdHJpbmdbXSB8IG51bGwge1xuICBpZiAoIWNzdikgcmV0dXJuIG51bGw7XG4gIHJldHVybiBub3JtYWxpemVDb2lucyhjc3Yuc3BsaXQoXCIsXCIpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDb2luc0pTT04oanNvblN0cjogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCk6IHN0cmluZ1tdIHwgbnVsbCB7XG4gIGlmICghanNvblN0cikgcmV0dXJuIG51bGw7XG4gIHRyeSB7XG4gICAgY29uc3QgeHMgPSBKU09OLnBhcnNlKGpzb25TdHIpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh4cykpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBub3JtYWxpemVDb2lucyh4cyk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvaW5zQWRkVVNEVEZpcnN0KHVzZXJDb2luczogcmVhZG9ubHkgc3RyaW5nW10pIHtcbiAgY29uc3QgeHMgPSBub3JtYWxpemVDb2lucyh1c2VyQ29pbnMpO1xuICBjb25zdCB3aXRob3V0VVNEVCA9IHhzLmZpbHRlcigoYykgPT4gYyAhPT0gXCJVU0RUXCIpO1xuICByZXR1cm4gW1wiVVNEVFwiLCAuLi53aXRob3V0VVNEVF07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvaW5zRnJvbUNvb2tpZXNPckhlYWRlcnMoKTogUHJvbWlzZTxzdHJpbmdbXSB8IG51bGw+IHtcbiAgY29uc3QgYmFnQ29va2llcyA9IGNvb2tpZXMoKTtcbiAgY29uc3QgYmFnSGVhZGVycyA9IGhlYWRlcnMoKTtcblxuICBjb25zdCBja0pzb24gPSAoYXdhaXQgYmFnQ29va2llcykuZ2V0KFwiY3BfY29pbnNcIik/LnZhbHVlOyAvLyBKU09OIGFycmF5XG4gIGNvbnN0IGNrQ3N2ID0gKGF3YWl0IGJhZ0Nvb2tpZXMpLmdldChcImNwLmNvaW5zXCIpPy52YWx1ZTsgLy8gQ1NWXG4gIGNvbnN0IGZyb21Da0pzb24gPSBwYXJzZUNvaW5zSlNPTihja0pzb24pO1xuICBjb25zdCBmcm9tQ2tDc3YgPSBwYXJzZUNvaW5zQ1NWKGNrQ3N2KTtcbiAgaWYgKGZyb21Da0pzb24/Lmxlbmd0aCkgcmV0dXJuIGZyb21Da0pzb247XG4gIGlmIChmcm9tQ2tDc3Y/Lmxlbmd0aCkgcmV0dXJuIGZyb21Da0NzdjtcblxuICBjb25zdCBoeENzdiA9IChhd2FpdCBiYWdIZWFkZXJzKS5nZXQoXCJ4LWNwLWNvaW5zXCIpO1xuICBjb25zdCBoeEpzb24gPSAoYXdhaXQgYmFnSGVhZGVycykuZ2V0KFwieC1jcC1jb2lucy1qc29uXCIpO1xuICBjb25zdCBmcm9tSHhDc3YgPSBwYXJzZUNvaW5zQ1NWKGh4Q3N2ID8/IHVuZGVmaW5lZCk7XG4gIGNvbnN0IGZyb21IeEpzb24gPSBwYXJzZUNvaW5zSlNPTihoeEpzb24gPz8gdW5kZWZpbmVkKTtcbiAgaWYgKGZyb21IeEpzb24/Lmxlbmd0aCkgcmV0dXJuIGZyb21IeEpzb247XG4gIGlmIChmcm9tSHhDc3Y/Lmxlbmd0aCkgcmV0dXJuIGZyb21IeENzdjtcblxuICByZXR1cm4gbnVsbDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUNvaW5zVW5pdmVyc2UocHJlZmVycmVkOiBzdHJpbmdbXSB8IG51bGwpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIGlmIChwcmVmZXJyZWQgJiYgcHJlZmVycmVkLmxlbmd0aCkgcmV0dXJuIGNvaW5zQWRkVVNEVEZpcnN0KHByZWZlcnJlZCk7XG5cbiAgY29uc3QgZnJvbVNldHRpbmdzID0gYXdhaXQgcmVzb2x2ZUNvaW5zRnJvbVNldHRpbmdzKCk7XG4gIGlmIChmcm9tU2V0dGluZ3MubGVuZ3RoKSByZXR1cm4gY29pbnNBZGRVU0RURmlyc3QoZnJvbVNldHRpbmdzKTtcblxuICBjb25zdCBsZWdhY3kgPSBhd2FpdCBjb2luc0Zyb21Db29raWVzT3JIZWFkZXJzKCk7XG4gIGlmIChsZWdhY3k/Lmxlbmd0aCkgcmV0dXJuIGNvaW5zQWRkVVNEVEZpcnN0KGxlZ2FjeSk7XG5cbiAgcmV0dXJuIFtcIlVTRFRcIl07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVdpbmRvdyh3aW46IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpOiBNYXRyaXhXaW5kb3cge1xuICBpZiAoIXdpbikgcmV0dXJuIFwiMzBtXCI7XG4gIGNvbnN0IGxjID0gd2luLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBBTExPV0VEX1dJTkRPV1MuaGFzKGxjIGFzIE1hdHJpeFdpbmRvdylcbiAgICA/IChsYyBhcyBNYXRyaXhXaW5kb3cpXG4gICAgOiBcIjMwbVwiO1xufVxuXG50eXBlIE1hdFZhbHVlcyA9IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIG51bWJlciB8IG51bGw+PjtcblxudHlwZSBNYXRyaWNlc0xhdGVzdFN1Y2Nlc3NQYXlsb2FkID0ge1xuICBvazogdHJ1ZTtcbiAgY29pbnM6IHN0cmluZ1tdO1xuICBzeW1ib2xzOiBzdHJpbmdbXTtcbiAgcXVvdGU6IHN0cmluZztcbiAgd2luZG93OiBNYXRyaXhXaW5kb3c7XG4gIHRzOiBudW1iZXI7XG4gIG1hdHJpY2VzOiB7XG4gICAgYmVuY2htYXJrOiB7IHRzOiBudW1iZXI7IHZhbHVlczogTWF0VmFsdWVzOyBmbGFncz86IGFueSB9O1xuICAgIHBjdDI0aDogeyB0czogbnVtYmVyOyB2YWx1ZXM6IE1hdFZhbHVlczsgZmxhZ3M/OiBhbnkgfTtcbiAgICBpZF9wY3Q6IHsgdHM6IG51bWJlcjsgdmFsdWVzOiBNYXRWYWx1ZXMgfTtcbiAgICBwY3RfZHJ2OiB7IHRzOiBudW1iZXI7IHZhbHVlczogTWF0VmFsdWVzIH07XG4gICAgcGN0X3JlZjogeyB0czogbnVtYmVyOyB2YWx1ZXM6IE1hdFZhbHVlcyB9O1xuICAgIHJlZjogeyB0czogbnVtYmVyOyB2YWx1ZXM6IE1hdFZhbHVlcyB9O1xuICAgIGRlbHRhOiB7IHRzOiBudW1iZXI7IHZhbHVlczogTWF0VmFsdWVzIH07XG4gIH07XG4gIG1ldGE6IHtcbiAgICBvcGVuaW5nVHM6IG51bWJlciB8IG51bGw7XG4gICAgdW5pdmVyc2U6IHN0cmluZ1tdO1xuICB9O1xufTtcblxudHlwZSBNYXRyaWNlc0xhdGVzdEVycm9yUGF5bG9hZCA9IHtcbiAgb2s6IGZhbHNlO1xuICBlcnJvcjogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgTWF0cmljZXNMYXRlc3RQYXlsb2FkID1cbiAgfCBNYXRyaWNlc0xhdGVzdFN1Y2Nlc3NQYXlsb2FkXG4gIHwgTWF0cmljZXNMYXRlc3RFcnJvclBheWxvYWQ7XG5cbmZ1bmN0aW9uIHRvR3JpZChcbiAgY29pbnM6IHJlYWRvbmx5IHN0cmluZ1tdLFxuICB2YWx1ZXM6IE1hdFZhbHVlc1xuKTogKG51bWJlciB8IG51bGwpW11bXSB7XG4gIGNvbnN0IG4gPSBjb2lucy5sZW5ndGg7XG4gIGNvbnN0IGdyaWQ6IChudW1iZXIgfCBudWxsKVtdW10gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBuIH0sICgpID0+XG4gICAgQXJyYXkuZnJvbSh7IGxlbmd0aDogbiB9LCAoKSA9PiBudWxsKVxuICApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGNvbnN0IGJpID0gY29pbnNbaV0hO1xuICAgIGNvbnN0IHJvdyA9IHZhbHVlc1tiaV0gfHwge307XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgIGlmIChpID09PSBqKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHFqID0gY29pbnNbal0hO1xuICAgICAgY29uc3QgdiA9IHJvd1txal07XG4gICAgICBncmlkW2ldW2pdID0gdiA9PSBudWxsID8gbnVsbCA6IE51bWJlcih2KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdyaWQ7XG59XG5cbmZ1bmN0aW9uIHRvVmFsdWVzKFxuICBjb2luczogcmVhZG9ubHkgc3RyaW5nW10sXG4gIGdyaWQ6IChudW1iZXIgfCBudWxsKVtdW11cbik6IE1hdFZhbHVlcyB7XG4gIGNvbnN0IG91dDogTWF0VmFsdWVzID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29pbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBiaSA9IGNvaW5zW2ldITtcbiAgICBvdXRbYmldID0ge30gYXMgYW55O1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29pbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChpID09PSBqKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHFqID0gY29pbnNbal0hO1xuICAgICAgb3V0W2JpXVtxal0gPSBncmlkW2ldW2pdID8/IG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUXVlcnkocmVxOiBSZXF1ZXN0KToge1xuICBjb2luczogc3RyaW5nW10gfCBudWxsO1xuICBxdW90ZTogc3RyaW5nO1xuICB3aW5kb3c6IE1hdHJpeFdpbmRvdztcbiAgYXBwU2Vzc2lvbklkOiBzdHJpbmcgfCBudWxsO1xufSB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxLnVybCk7XG4gIGNvbnN0IHFDb2lucyA9IHBhcnNlQ29pbnNDU1YodXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJjb2luc1wiKSk7XG4gIGNvbnN0IHF1b3RlID0gKHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwicXVvdGVcIikgfHwgXCJVU0RUXCIpLnRvVXBwZXJDYXNlKCk7XG4gIGNvbnN0IHdpbmRvdyA9IGVuc3VyZVdpbmRvdyh1cmwuc2VhcmNoUGFyYW1zLmdldChcIndpbmRvd1wiKSk7XG4gIGNvbnN0IGFwcFNlc3Npb25JZCA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwiYXBwU2Vzc2lvbklkXCIpIHx8IG51bGw7XG4gIHJldHVybiB7IGNvaW5zOiBxQ29pbnMsIHF1b3RlLCB3aW5kb3csIGFwcFNlc3Npb25JZCB9O1xufVxuXG50eXBlIEJ1aWxkTWF0cmljZXNMYXRlc3RBcmdzID0ge1xuICBjb2lucz86IHN0cmluZ1tdIHwgbnVsbDtcbiAgcXVvdGU/OiBzdHJpbmc7XG4gIHdpbmRvdz86IHN0cmluZyB8IG51bGw7XG4gIGFwcFNlc3Npb25JZD86IHN0cmluZyB8IG51bGw7XG59O1xuXG5jb25zdCBwaWNrVmFsdWVzID0gKGNvaW5zOiByZWFkb25seSBzdHJpbmdbXSwgdmFsczogTWF0VmFsdWVzKTogTWF0VmFsdWVzID0+IHtcbiAgY29uc3QgdG9LZWVwID0gY29pbnM7XG4gIGNvbnN0IG91dDogTWF0VmFsdWVzID0ge307XG4gIGZvciAoY29uc3QgYiBvZiB0b0tlZXApIHtcbiAgICBjb25zdCByb3cgPSB2YWxzW2JdIHx8IHt9O1xuICAgIGNvbnN0IGRzdDogUmVjb3JkPHN0cmluZywgbnVtYmVyIHwgbnVsbD4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IHEgb2YgdG9LZWVwKSB7XG4gICAgICBpZiAoYiA9PT0gcSkgY29udGludWU7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJvdywgcSkpIHtcbiAgICAgICAgZHN0W3FdID0gcm93W3FdITtcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0W2JdID0gZHN0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYnVpbGRNYXRyaWNlc0xhdGVzdFBheWxvYWQoXG4gIHBhcmFtczogQnVpbGRNYXRyaWNlc0xhdGVzdEFyZ3MgPSB7fVxuKTogUHJvbWlzZTxNYXRyaWNlc0xhdGVzdFBheWxvYWQ+IHtcbiAgY29uc3QgcXVvdGUgPSAocGFyYW1zLnF1b3RlID8/IFwiVVNEVFwiKS50b1VwcGVyQ2FzZSgpO1xuICBjb25zdCB3aW5kb3cgPSBlbnN1cmVXaW5kb3cocGFyYW1zLndpbmRvdyA/PyBudWxsKTtcbiAgY29uc3QgYXBwU2Vzc2lvbklkID0gcGFyYW1zLmFwcFNlc3Npb25JZCA/PyBudWxsO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnlDb2luc05vcm1hbGl6ZWQgPSBBcnJheS5pc0FycmF5KHBhcmFtcy5jb2lucylcbiAgICAgID8gbm9ybWFsaXplQ29pbnMocGFyYW1zLmNvaW5zKVxuICAgICAgOiBudWxsO1xuXG4gICAgY29uc3QgcHJlZmVyQ29pbnMgPVxuICAgICAgcXVlcnlDb2luc05vcm1hbGl6ZWQgJiYgcXVlcnlDb2luc05vcm1hbGl6ZWQubGVuZ3RoXG4gICAgICAgID8gcXVlcnlDb2luc05vcm1hbGl6ZWRcbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IHJlc29sdmVkQ29pbnMgPSBhd2FpdCByZXNvbHZlQ29pbnNVbml2ZXJzZShwcmVmZXJDb2lucyk7XG4gICAgY29uc3Qgdmlld0NvaW5zID1cbiAgICAgIHByZWZlckNvaW5zID09IG51bGwgPyBhd2FpdCBmZXRjaFBhaXJVbml2ZXJzZUNvaW5zKCkgOiBbXTtcbiAgICBjb25zdCBjb2lucyA9IG5vcm1hbGl6ZUNvaW5zKFsuLi5yZXNvbHZlZENvaW5zLCAuLi52aWV3Q29pbnNdKTtcblxuICAgIGlmICghY29pbnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjb2lucyByZXNvbHZlZCBmb3IgbWF0cmljZXMgdW5pdmVyc2VcIik7XG4gICAgfVxuXG4gICAgY29uc3QgbGl2ZSA9IGF3YWl0IGxpdmVGcm9tU291cmNlcyhjb2lucyk7XG5cbiAgICBjb25zdCBibUdyaWQgPSB0b0dyaWQoY29pbnMsIGxpdmUubWF0cmljZXMuYmVuY2htYXJrLnZhbHVlcyk7XG4gICAgY29uc3Qgbm93VHMgPSBsaXZlLm1hdHJpY2VzLmJlbmNobWFyay50cztcblxuICAgIGNvbnN0IFtwcmV2QmVuY2htYXJrUm93cywgcHJldklkUGN0Um93c10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBnZXRQcmV2U25hcHNob3RCeVR5cGUoXCJiZW5jaG1hcmtcIiwgbm93VHMsIGNvaW5zKSxcbiAgICAgIGdldFByZXZTbmFwc2hvdEJ5VHlwZShcImlkX3BjdFwiLCBub3dUcywgY29pbnMpLFxuICAgIF0pO1xuXG4gICAgY29uc3QgcHJldkJlbmNobWFya01hcCA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG4gICAgZm9yIChjb25zdCByb3cgb2YgcHJldkJlbmNobWFya1Jvd3MpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke3Jvdy5iYXNlLnRvVXBwZXJDYXNlKCl9LyR7cm93LnF1b3RlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgIGNvbnN0IHZhbHVlID0gTnVtYmVyKHJvdy52YWx1ZSk7XG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHZhbHVlKSkgcHJldkJlbmNobWFya01hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJldklkUGN0TWFwID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcbiAgICBmb3IgKGNvbnN0IHJvdyBvZiBwcmV2SWRQY3RSb3dzKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtyb3cuYmFzZS50b1VwcGVyQ2FzZSgpfS8ke3Jvdy5xdW90ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICBjb25zdCB2YWx1ZSA9IE51bWJlcihyb3cudmFsdWUpO1xuICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHByZXZJZFBjdE1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgbGV0IGxhc3RPcGVuaW5nVHM6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gICAgY29uZmlndXJlQmVuY2htYXJrUHJvdmlkZXJzKHtcbiAgICAgIGdldFByZXY6IGFzeW5jIChtYXRyaXhfdHlwZSwgYmFzZSwgcXVvdGVTeW0sIGJlZm9yZVRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGtleSA9IGAke2Jhc2UudG9VcHBlckNhc2UoKX0vJHtxdW90ZVN5bS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICAgIGNvbnN0IGZyb21QcmVmZXRjaCA9XG4gICAgICAgICAgbWF0cml4X3R5cGUgPT09IFwiYmVuY2htYXJrXCJcbiAgICAgICAgICAgID8gcHJldkJlbmNobWFya01hcC5nZXQoa2V5KVxuICAgICAgICAgICAgOiBtYXRyaXhfdHlwZSA9PT0gXCJpZF9wY3RcIlxuICAgICAgICAgICAgPyBwcmV2SWRQY3RNYXAuZ2V0KGtleSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZnJvbVByZWZldGNoICE9IG51bGwpIHJldHVybiBmcm9tUHJlZmV0Y2g7XG4gICAgICAgIHJldHVybiBnZXRQcmV2VmFsdWUoXG4gICAgICAgICAgbWF0cml4X3R5cGUsXG4gICAgICAgICAgYmFzZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgIHF1b3RlU3ltLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgYmVmb3JlVHNcbiAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIGZldGNoT3BlbmluZ0dyaWQ6IGFzeW5jIChjb2luc1VuaXZlcnNlLCBub3dUc1BhcmFtKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZiA9IGF3YWl0IGZldGNoT3BlbmluZ0dyaWRGcm9tVmlldyh7XG4gICAgICAgICAgY29pbnM6IGNvaW5zVW5pdmVyc2UsXG4gICAgICAgICAgd2luZG93LFxuICAgICAgICAgIGFwcFNlc3Npb25JZCxcbiAgICAgICAgICBvcGVuaW5nVHM6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGxhc3RPcGVuaW5nVHMgPSByZWYudHMgPz8gbm93VHNQYXJhbTtcbiAgICAgICAgcmV0dXJuIHsgdHM6IHJlZi50cyA/PyBub3dUc1BhcmFtLCBncmlkOiByZWYuZ3JpZCB9O1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGRlcml2ZWQgPSBhd2FpdCBjb21wdXRlRnJvbURiQW5kTGl2ZSh7XG4gICAgICBjb2luczogY29pbnMuc2xpY2UoKSxcbiAgICAgIG5vd1RzLFxuICAgICAgbGl2ZUJlbmNobWFyazogYm1HcmlkLFxuICAgIH0pO1xuXG4gICAgY29uc3QgYm1WYWx1ZXMgPSBwaWNrVmFsdWVzKGNvaW5zLCBsaXZlLm1hdHJpY2VzLmJlbmNobWFyay52YWx1ZXMpO1xuICAgIGNvbnN0IHBjdDI0VmFsdWVzID0gcGlja1ZhbHVlcyhjb2lucywgbGl2ZS5tYXRyaWNlcy5wY3QyNGgudmFsdWVzKTtcbiAgICBjb25zdCBpZFBjdFZhbHVlcyA9IHRvVmFsdWVzKGNvaW5zLCBkZXJpdmVkLmlkX3BjdCk7XG4gICAgY29uc3QgZHJ2VmFsdWVzID0gdG9WYWx1ZXMoY29pbnMsIGRlcml2ZWQucGN0X2Rydik7XG4gICAgY29uc3QgcGN0UmVmVmFsdWVzID0gdG9WYWx1ZXMoY29pbnMsIGRlcml2ZWQucGN0X3JlZik7XG4gICAgY29uc3QgcmVmVmFsdWVzID0gdG9WYWx1ZXMoY29pbnMsIGRlcml2ZWQucmVmKTtcbiAgICBjb25zdCBkZWx0YVZhbHVlcyA9IHRvVmFsdWVzKGNvaW5zLCBkZXJpdmVkLmRlbHRhKTtcblxuICAgIGNvbnN0IHN5bWJvbHM6IHN0cmluZ1tdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2lucy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoaSA9PT0gaikgY29udGludWU7XG4gICAgICAgIHN5bWJvbHMucHVzaChgJHtjb2luc1tpXX0ke2NvaW5zW2pdfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNvaW5zRGlzcGxheSA9IGNvaW5zLmZpbHRlcigoYykgPT4gYyAhPT0gcXVvdGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAgY29pbnM6IGNvaW5zRGlzcGxheSxcbiAgICAgIHN5bWJvbHMsXG4gICAgICBxdW90ZSxcbiAgICAgIHdpbmRvdyxcbiAgICAgIHRzOiBub3dUcyxcbiAgICAgIG1hdHJpY2VzOiB7XG4gICAgICAgIGJlbmNobWFyazoge1xuICAgICAgICAgIHRzOiBub3dUcyxcbiAgICAgICAgICB2YWx1ZXM6IGJtVmFsdWVzLFxuICAgICAgICAgIGZsYWdzOiBsaXZlLm1hdHJpY2VzLmJlbmNobWFyay5mbGFncyxcbiAgICAgICAgfSxcbiAgICAgICAgcGN0MjRoOiB7XG4gICAgICAgICAgdHM6IG5vd1RzLFxuICAgICAgICAgIHZhbHVlczogcGN0MjRWYWx1ZXMsXG4gICAgICAgICAgZmxhZ3M6IGxpdmUubWF0cmljZXMucGN0MjRoLmZsYWdzLFxuICAgICAgICB9LFxuICAgICAgICBpZF9wY3Q6IHsgdHM6IG5vd1RzLCB2YWx1ZXM6IGlkUGN0VmFsdWVzIH0sXG4gICAgICAgIHBjdF9kcnY6IHsgdHM6IG5vd1RzLCB2YWx1ZXM6IGRydlZhbHVlcyB9LFxuICAgICAgICBwY3RfcmVmOiB7IHRzOiBub3dUcywgdmFsdWVzOiBwY3RSZWZWYWx1ZXMgfSxcbiAgICAgICAgcmVmOiB7IHRzOiBub3dUcywgdmFsdWVzOiByZWZWYWx1ZXMgfSxcbiAgICAgICAgZGVsdGE6IHsgdHM6IG5vd1RzLCB2YWx1ZXM6IGRlbHRhVmFsdWVzIH0sXG4gICAgICB9LFxuICAgICAgbWV0YToge1xuICAgICAgICBvcGVuaW5nVHM6IGxhc3RPcGVuaW5nVHMsXG4gICAgICAgIHVuaXZlcnNlOiBjb2lucyxcbiAgICAgIH0sXG4gICAgfSBzYXRpc2ZpZXMgTWF0cmljZXNMYXRlc3RTdWNjZXNzUGF5bG9hZDtcbiAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW21hdHJpY2VzL2xhdGVzdF0gZXJyb3I6XCIsIGVycik7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9rOiBmYWxzZSxcbiAgICAgIGVycm9yOiBTdHJpbmcoZXJyPy5tZXNzYWdlID8/IGVyciksXG4gICAgfSBzYXRpc2ZpZXMgTWF0cmljZXNMYXRlc3RFcnJvclBheWxvYWQ7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIEdFVChyZXE6IFJlcXVlc3QpIHtcbiAgY29uc3QgcSA9IHBhcnNlUXVlcnkocmVxKTtcbiAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IGJ1aWxkTWF0cmljZXNMYXRlc3RQYXlsb2FkKHEpO1xuICBjb25zdCBzdGF0dXMgPSBwYXlsb2FkLm9rID8gMjAwIDogNTAwO1xuICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24ocGF5bG9hZCwgeyBzdGF0dXMgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIoX3JlcTogTmV4dEFwaVJlcXVlc3QsIHJlczogTmV4dEFwaVJlc3BvbnNlKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3FsID0gYFxuICAgICAgU0VMRUNUIGR2LipcbiAgICAgIEZST00gbWF0cmljZXMuZHluX3ZhbHVlcyBkdlxuICAgICAgSk9JTiBzZXR0aW5ncy5jb2luX3VuaXZlcnNlIGN1XG4gICAgICAgIE9OIGN1LmJhc2VfYXNzZXQgPSBkdi5iYXNlXG4gICAgICAgQU5EIGN1LnF1b3RlX2Fzc2V0ID0gZHYucXVvdGVcbiAgICAgICBBTkQgY3UuZW5hYmxlZCA9IHRydWVcbiAgICAgIFdIRVJFIGR2Lm1hdHJpeF90eXBlID0gJ2JlbmNobWFyaydcbiAgICAgICAgQU5EIGR2LnRzX21zID0gKFxuICAgICAgICAgIFNFTEVDVCBNQVgodHNfbXMpXG4gICAgICAgICAgRlJPTSBtYXRyaWNlcy5keW5fdmFsdWVzIGQyXG4gICAgICAgICAgV0hFUkUgZDIubWF0cml4X3R5cGUgPSBkdi5tYXRyaXhfdHlwZVxuICAgICAgICAgICAgQU5EIGQyLmJhc2UgPSBkdi5iYXNlXG4gICAgICAgICAgICBBTkQgZDIucXVvdGUgPSBkdi5xdW90ZVxuICAgICAgICApXG4gICAgICBPUkRFUiBCWSBDT0FMRVNDRShjdS5zb3J0X29yZGVyLCA5OTkpLCBkdi5iYXNlXG4gICAgYDtcbiAgICBjb25zdCB7IHJvd3MgfSA9IGF3YWl0IHF1ZXJ5KHNxbCk7XG4gICAgcmVzLnN0YXR1cygyMDApLmpzb24ocm93cyk7XG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6IGU/Lm1lc3NhZ2UgPz8gXCJ1bmtub3duIGVycm9yXCIgfSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJjb29raWVzIiwiaGVhZGVycyIsImdldFByZXZTbmFwc2hvdEJ5VHlwZSIsImdldFByZXZWYWx1ZSIsImxpdmVGcm9tU291cmNlcyIsImNvbmZpZ3VyZUJlbmNobWFya1Byb3ZpZGVycyIsImNvbXB1dGVGcm9tRGJBbmRMaXZlIiwiZmV0Y2hPcGVuaW5nR3JpZEZyb21WaWV3IiwicmVzb2x2ZUNvaW5zRnJvbVNldHRpbmdzIiwiZmV0Y2hQYWlyVW5pdmVyc2VDb2lucyIsInF1ZXJ5IiwiQUxMT1dFRF9XSU5ET1dTIiwiU2V0Iiwibm9ybWFsaXplQ29pbnMiLCJ4cyIsIkFycmF5IiwiZnJvbSIsIm1hcCIsInMiLCJ0cmltIiwidG9VcHBlckNhc2UiLCJmaWx0ZXIiLCJCb29sZWFuIiwicGFyc2VDb2luc0NTViIsImNzdiIsInNwbGl0IiwicGFyc2VDb2luc0pTT04iLCJqc29uU3RyIiwiSlNPTiIsInBhcnNlIiwiaXNBcnJheSIsImNvaW5zQWRkVVNEVEZpcnN0IiwidXNlckNvaW5zIiwid2l0aG91dFVTRFQiLCJjIiwiY29pbnNGcm9tQ29va2llc09ySGVhZGVycyIsImJhZ0Nvb2tpZXMiLCJiYWdIZWFkZXJzIiwiY2tKc29uIiwiZ2V0IiwidmFsdWUiLCJja0NzdiIsImZyb21Da0pzb24iLCJmcm9tQ2tDc3YiLCJsZW5ndGgiLCJoeENzdiIsImh4SnNvbiIsImZyb21IeENzdiIsInVuZGVmaW5lZCIsImZyb21IeEpzb24iLCJyZXNvbHZlQ29pbnNVbml2ZXJzZSIsInByZWZlcnJlZCIsImZyb21TZXR0aW5ncyIsImxlZ2FjeSIsImVuc3VyZVdpbmRvdyIsIndpbiIsImxjIiwidG9Mb3dlckNhc2UiLCJoYXMiLCJ0b0dyaWQiLCJjb2lucyIsInZhbHVlcyIsIm4iLCJncmlkIiwiaSIsImJpIiwicm93IiwiaiIsInFqIiwidiIsIk51bWJlciIsInRvVmFsdWVzIiwib3V0IiwicGFyc2VRdWVyeSIsInJlcSIsInVybCIsIlVSTCIsInFDb2lucyIsInNlYXJjaFBhcmFtcyIsInF1b3RlIiwid2luZG93IiwiYXBwU2Vzc2lvbklkIiwicGlja1ZhbHVlcyIsInZhbHMiLCJ0b0tlZXAiLCJiIiwiZHN0IiwicSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImJ1aWxkTWF0cmljZXNMYXRlc3RQYXlsb2FkIiwicGFyYW1zIiwicXVlcnlDb2luc05vcm1hbGl6ZWQiLCJwcmVmZXJDb2lucyIsInJlc29sdmVkQ29pbnMiLCJ2aWV3Q29pbnMiLCJFcnJvciIsImxpdmUiLCJibUdyaWQiLCJtYXRyaWNlcyIsImJlbmNobWFyayIsIm5vd1RzIiwidHMiLCJwcmV2QmVuY2htYXJrUm93cyIsInByZXZJZFBjdFJvd3MiLCJQcm9taXNlIiwiYWxsIiwicHJldkJlbmNobWFya01hcCIsIk1hcCIsImtleSIsImJhc2UiLCJpc0Zpbml0ZSIsInNldCIsInByZXZJZFBjdE1hcCIsImxhc3RPcGVuaW5nVHMiLCJnZXRQcmV2IiwibWF0cml4X3R5cGUiLCJxdW90ZVN5bSIsImJlZm9yZVRzIiwiZnJvbVByZWZldGNoIiwiZmV0Y2hPcGVuaW5nR3JpZCIsImNvaW5zVW5pdmVyc2UiLCJub3dUc1BhcmFtIiwicmVmIiwib3BlbmluZ1RzIiwiZGVyaXZlZCIsInNsaWNlIiwibGl2ZUJlbmNobWFyayIsImJtVmFsdWVzIiwicGN0MjRWYWx1ZXMiLCJwY3QyNGgiLCJpZFBjdFZhbHVlcyIsImlkX3BjdCIsImRydlZhbHVlcyIsInBjdF9kcnYiLCJwY3RSZWZWYWx1ZXMiLCJwY3RfcmVmIiwicmVmVmFsdWVzIiwiZGVsdGFWYWx1ZXMiLCJkZWx0YSIsInN5bWJvbHMiLCJwdXNoIiwiY29pbnNEaXNwbGF5Iiwib2siLCJmbGFncyIsIm1ldGEiLCJ1bml2ZXJzZSIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsIlN0cmluZyIsIm1lc3NhZ2UiLCJHRVQiLCJwYXlsb2FkIiwic3RhdHVzIiwianNvbiIsImhhbmRsZXIiLCJfcmVxIiwicmVzIiwic3FsIiwicm93cyIsImUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/matrices/latest/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/app/api/moo-aux/route.ts":
/*!**************************************!*\
  !*** ./src/app/api/moo-aux/route.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   revalidate: () => (/* binding */ revalidate)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/api/server.js\");\n/* harmony import */ var _core_db_db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/core/db/db */ \"(rsc)/./src/core/db/db.ts\");\n/* harmony import */ var _core_features_moo_aux_measures__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/core/features/moo-aux/measures */ \"(rsc)/./src/core/features/moo-aux/measures.ts\");\n/* harmony import */ var _core_features_moo_aux_tiers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/core/features/moo-aux/tiers */ \"(rsc)/./src/core/features/moo-aux/tiers.ts\");\n/* harmony import */ var _lib_markets_availability__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/markets/availability */ \"(rsc)/./src/lib/markets/availability.ts\");\n/* harmony import */ var _lib_settings_server__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/lib/settings/server */ \"(rsc)/./src/lib/settings/server.ts\");\n/* harmony import */ var _core_features_str_aux_calc_panel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/core/features/str-aux/calc/panel */ \"(rsc)/./src/core/features/str-aux/calc/panel.ts\");\n/* harmony import */ var _app_api_matrices_latest_route__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/app/api/matrices/latest/route */ \"(rsc)/./src/app/api/matrices/latest/route.ts\");\n/* harmony import */ var _lib_mea_mood__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/lib/mea/mood */ \"(rsc)/./src/lib/mea/mood.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_db_db__WEBPACK_IMPORTED_MODULE_1__, _core_features_moo_aux_measures__WEBPACK_IMPORTED_MODULE_2__, _lib_settings_server__WEBPACK_IMPORTED_MODULE_5__, _core_features_str_aux_calc_panel__WEBPACK_IMPORTED_MODULE_6__, _app_api_matrices_latest_route__WEBPACK_IMPORTED_MODULE_7__]);\n([_core_db_db__WEBPACK_IMPORTED_MODULE_1__, _core_features_moo_aux_measures__WEBPACK_IMPORTED_MODULE_2__, _lib_settings_server__WEBPACK_IMPORTED_MODULE_5__, _core_features_str_aux_calc_panel__WEBPACK_IMPORTED_MODULE_6__, _app_api_matrices_latest_route__WEBPACK_IMPORTED_MODULE_7__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n// NEW: mood imports (added in lib/mood.ts per our plan)\n\nconst dynamic = \"force-dynamic\";\nconst revalidate = 0;\nconst CACHE_HEADERS = {\n    \"Cache-Control\": \"no-store\"\n};\nconst DEFAULT_COINS = [\n    \"USDT\",\n    \"BTC\",\n    \"ETH\",\n    \"BNB\",\n    \"SOL\"\n];\nconst DEFAULT_APP_SESSION = process.env.NEXT_PUBLIC_APP_SESSION_ID ?? \"moo-aux\";\nconst STR_MOOD_WINDOW = process.env.MOO_AUX_STR_WINDOW ?? \"30m\";\nconst STR_MOOD_BINS = Number.isFinite(Number(process.env.MOO_AUX_STR_BINS)) ? Math.max(16, Math.floor(Number(process.env.MOO_AUX_STR_BINS))) : 128;\nconst MAX_MOOD_SYMBOLS = Number.isFinite(Number(process.env.MOO_AUX_SYMBOL_LIMIT)) ? Math.max(1, Math.floor(Number(process.env.MOO_AUX_SYMBOL_LIMIT))) : 12;\nconst DEFAULT_MOOD_STATS = {\n    idhr: {\n        alpha: 2.5,\n        sMin: 1e-6,\n        smooth: 3,\n        topK: 8\n    },\n    epsGfmPct: 0.35,\n    epsBfmPct: 0.35,\n    vScale: 100,\n    tendencyWin: 30,\n    tendencyNorm: \"mad\",\n    swapAlpha: 1.2\n};\nasync function GET(req) {\n    try {\n        const url = new URL(req.url);\n        const appSessionId = (url.searchParams.get(\"sessionId\") ?? DEFAULT_APP_SESSION).slice(0, 64);\n        // -------- timing\n        const tsParam = Number(url.searchParams.get(\"ts\") ?? url.searchParams.get(\"timestamp\"));\n        const tsMs = Number.isFinite(tsParam) && tsParam > 0 ? tsParam : Date.now();\n        // -------- coins universe\n        const { coins: initialCoins, source: coinsSource } = await resolveCoins(url);\n        // -------- id_pct grid (DB-backed)\n        const { grid: idPctGridRaw, source: idPctSource } = await readIdPctGrid(initialCoins, tsMs);\n        const dedupedCoins = dedupeCoins([\n            ...initialCoins,\n            ...coinsFromGrid(idPctGridRaw)\n        ]);\n        if (!dedupedCoins.length) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                ok: true,\n                coins: [],\n                k: 0,\n                grid: {}\n            }, {\n                headers: CACHE_HEADERS\n            });\n        }\n        let coins = dedupedCoins;\n        if (!coins.includes(\"USDT\")) coins = [\n            \"USDT\",\n            ...coins\n        ];\n        // -------- availability filter\n        const availability = await (0,_lib_markets_availability__WEBPACK_IMPORTED_MODULE_4__.resolvePairAvailability)(coins);\n        const allowedSymbols = availability.set;\n        const moodSymbols = deriveMoodSymbols(coins, allowedSymbols);\n        // -------- normalize id_pct grid + balances\n        const idPctGrid = ensureIdPctGrid(idPctGridRaw, coins);\n        const { balances, source: balanceSource } = await readBalancesFromLedger(coins);\n        // -------- divisor (k)\n        const kParam = Number(url.searchParams.get(\"k\"));\n        const divisor = Number.isFinite(kParam) && kParam > 0 ? Math.floor(kParam) : Math.max(1, coins.length - 1);\n        // ======== NEW: mood normalization & coefficient (anchored) ========\n        // Query overrides (optional) for testing:\n        const q_gfmDeltaPct = toNum(url.searchParams.get(\"gfmDeltaPct\")); // e.g. 0.01 for +1%\n        const q_tendencyRaw = toNum(url.searchParams.get(\"tendencyRaw\"));\n        const q_swapRaw = toNum(url.searchParams.get(\"swapRaw\"));\n        const refs = {\n            gfmScale: toNum(url.searchParams.get(\"gfmScale\")) ?? 20,\n            vtMu: toNum(url.searchParams.get(\"vtMu\")) ?? 0,\n            vtSigma: toNum(url.searchParams.get(\"vtSigma\")) ?? 0.02,\n            vsMu: toNum(url.searchParams.get(\"vsMu\")) ?? 0,\n            vsSigma: toNum(url.searchParams.get(\"vsSigma\")) ?? 0.05,\n            vsAlpha: toNum(url.searchParams.get(\"vsAlpha\")) ?? 0.75\n        };\n        const haveRaw = q_gfmDeltaPct != null || q_tendencyRaw != null || q_swapRaw != null;\n        const manualSignals = {\n            gfmDeltaPct: q_gfmDeltaPct ?? 0,\n            tendencyRaw: q_tendencyRaw ?? 0,\n            swapRaw: q_swapRaw ?? 0\n        };\n        let derivedSignals = haveRaw ? null : await computeMoodSignalsFromStrAux(moodSymbols, STR_MOOD_WINDOW).catch(()=>null);\n        if (!derivedSignals) {\n            derivedSignals = {\n                gfmDeltaPct: 0,\n                tendencyRaw: 0,\n                swapRaw: 0,\n                symbols: []\n            };\n        }\n        const moodRawDescriptor = haveRaw ? {\n            source: \"query\",\n            signals: manualSignals,\n            symbols: [],\n            perSymbol: []\n        } : {\n            source: derivedSignals.symbols.length ? \"str-aux\" : \"str-aux:fallback\",\n            signals: {\n                gfmDeltaPct: derivedSignals.gfmDeltaPct,\n                tendencyRaw: derivedSignals.tendencyRaw,\n                swapRaw: derivedSignals.swapRaw\n            },\n            symbols: derivedSignals.symbols,\n            perSymbol: derivedSignals.perSymbol\n        };\n        const moodInputs = (0,_lib_mea_mood__WEBPACK_IMPORTED_MODULE_8__.normalizeMoodInputs)({\n            gfmDeltaPct: moodRawDescriptor.signals.gfmDeltaPct,\n            tendencyRaw: moodRawDescriptor.signals.tendencyRaw,\n            swapRaw: moodRawDescriptor.signals.swapRaw\n        }, refs);\n        const { coeff: moodCoeff, buckets } = (0,_lib_mea_mood__WEBPACK_IMPORTED_MODULE_8__.computeMoodCoeffV1)(moodInputs);\n        const moodUUID = (0,_lib_mea_mood__WEBPACK_IMPORTED_MODULE_8__.moodUUIDFromBuckets)(buckets);\n        const perSymbolMood = buildPerSymbolMood(moodRawDescriptor.perSymbol, refs);\n        // ================================================================\n        // -------- build MEA weights (legacy function untouched)\n        const grid = (0,_core_features_moo_aux_measures__WEBPACK_IMPORTED_MODULE_2__.buildMeaAux)({\n            coins,\n            idPct: idPctGrid,\n            balances,\n            k: divisor,\n            rules: _core_features_moo_aux_tiers__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_TIER_RULES,\n            moodCoeff\n        });\n        // Persist observation (best-effort)\n        const observationPayload = {\n            source: moodRawDescriptor.source,\n            symbols: moodRawDescriptor.symbols,\n            signals: moodRawDescriptor.signals,\n            inputs: moodInputs,\n            refs,\n            perSymbol: perSymbolMood\n        };\n        (0,_core_features_moo_aux_measures__WEBPACK_IMPORTED_MODULE_2__.saveMoodObservation)(appSessionId, tsMs, moodUUID, moodCoeff, observationPayload).catch((err)=>{\n            console.warn(\"[moo-aux] mood observation skipped:\", err);\n        });\n        // -------- mask unavailable symbols/pairs\n        if (allowedSymbols.size) {\n            (0,_lib_markets_availability__WEBPACK_IMPORTED_MODULE_4__.maskUnavailableMatrix)(grid, allowedSymbols);\n            (0,_lib_markets_availability__WEBPACK_IMPORTED_MODULE_4__.maskUnavailableMatrix)(idPctGrid, allowedSymbols);\n        }\n        // -------- response\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            ok: true,\n            ts_ms: tsMs,\n            coins,\n            k: divisor,\n            grid,\n            id_pct: idPctGrid,\n            balances,\n            mood: {\n                coeff: moodCoeff,\n                uuid: moodUUID,\n                inputs: moodInputs,\n                refs,\n                raw: moodRawDescriptor,\n                perSymbol: perSymbolMood\n            },\n            sources: {\n                coins: coinsSource,\n                id_pct: idPctSource,\n                balances: balanceSource,\n                mood: moodRawDescriptor.source\n            },\n            availability: {\n                symbols: availability.symbols,\n                pairs: availability.pairs\n            }\n        }, {\n            headers: CACHE_HEADERS\n        });\n    } catch (err) {\n        const message = err instanceof Error ? err.message : String(err);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            ok: false,\n            error: message\n        }, {\n            status: 500,\n            headers: CACHE_HEADERS\n        });\n    }\n}\n//  helpers (unchanged + small additions)\nfunction toNum(x) {\n    if (x == null) return null;\n    const n = Number(x);\n    return Number.isFinite(n) ? n : null;\n}\nfunction normalizeCoinSymbol(raw) {\n    if (raw == null) return null;\n    const trimmed = String(raw).trim().toUpperCase();\n    return trimmed ? trimmed : null;\n}\nfunction splitSymbolPair(symbol) {\n    const upper = String(symbol ?? \"\").trim().toUpperCase();\n    if (!upper) return null;\n    const commons = [\n        \"USDT\",\n        \"USD\",\n        \"USDC\",\n        \"BUSD\",\n        \"EUR\",\n        \"BTC\",\n        \"ETH\",\n        \"BNB\",\n        \"BRL\"\n    ];\n    for (const quote of commons){\n        if (upper.endsWith(quote) && upper.length > quote.length) {\n            return {\n                base: upper.slice(0, -quote.length),\n                quote\n            };\n        }\n    }\n    if (upper.length >= 6) {\n        return {\n            base: upper.slice(0, upper.length - 4),\n            quote: upper.slice(-4)\n        };\n    }\n    return null;\n}\nfunction deriveMoodSymbols(coins, allowed) {\n    const normalized = Array.from(new Set(coins.map((coin)=>normalizeCoinSymbol(coin)).filter((c)=>Boolean(c))));\n    const desired = [];\n    for (const base of normalized){\n        const preferred = `${base}USDT`;\n        if (base !== \"USDT\" && allowed.has(preferred)) desired.push(preferred);\n    }\n    for (const base of normalized){\n        for (const quote of normalized){\n            if (base === quote) continue;\n            const symbol = `${base}${quote}`;\n            if (allowed.has(symbol)) desired.push(symbol);\n        }\n    }\n    if (!desired.length && allowed.size) {\n        for (const symbol of allowed)desired.push(String(symbol ?? \"\").toUpperCase());\n    }\n    const unique = Array.from(new Set(desired.map((s)=>String(s ?? \"\").toUpperCase()).filter(Boolean)));\n    return unique.slice(0, MAX_MOOD_SYMBOLS);\n}\nfunction buildPerSymbolMood(details, refs) {\n    const out = {};\n    for (const detail of details ?? []){\n        const normalized = (0,_lib_mea_mood__WEBPACK_IMPORTED_MODULE_8__.normalizeMoodInputs)({\n            gfmDeltaPct: detail.gfmDeltaPct,\n            tendencyRaw: detail.tendencyRaw,\n            swapRaw: detail.swapRaw\n        }, refs);\n        const { coeff, buckets } = (0,_lib_mea_mood__WEBPACK_IMPORTED_MODULE_8__.computeMoodCoeffV1)(normalized);\n        const uuid = (0,_lib_mea_mood__WEBPACK_IMPORTED_MODULE_8__.moodUUIDFromBuckets)(buckets);\n        const quote = detail.quote;\n        const base = detail.base;\n        if (!quote || !base) continue;\n        (out[quote] ??= {})[base] = {\n            coeff,\n            uuid,\n            inputs: normalized,\n            raw: detail\n        };\n    }\n    return out;\n}\nasync function computeMoodSignalsFromStrAux(symbols, window) {\n    const unique = Array.from(new Set(symbols.map((s)=>String(s ?? \"\").toUpperCase()).filter(Boolean)));\n    if (!unique.length) {\n        return {\n            gfmDeltaPct: 0,\n            tendencyRaw: 0,\n            swapRaw: 0,\n            symbols: [],\n            perSymbol: []\n        };\n    }\n    const limited = unique.slice(0, MAX_MOOD_SYMBOLS);\n    const results = await (0,_core_features_str_aux_calc_panel__WEBPACK_IMPORTED_MODULE_6__.computeSampledMetrics)(limited, {\n        window,\n        bins: STR_MOOD_BINS,\n        stats: DEFAULT_MOOD_STATS\n    });\n    const fallbackTargets = [];\n    for (const symbol of limited){\n        const entry = results[symbol];\n        if (!entry || !entry.ok) {\n            fallbackTargets.push(symbol);\n            continue;\n        }\n        const tendencyScore = Number(entry.stats.vectors?.tendency?.metrics?.score);\n        const swapScore = Number(entry.stats.vectors?.swap?.score);\n        if (!Number.isFinite(tendencyScore) || !Number.isFinite(swapScore)) {\n            fallbackTargets.push(symbol);\n        }\n    }\n    const fallbackMap = fallbackTargets.length ? await fetchWindowVectorFallbacks(fallbackTargets, window) : {};\n    let gfmNum = 0;\n    let gfmDen = 0;\n    let tendNum = 0;\n    let tendDen = 0;\n    let swapNum = 0;\n    let swapDen = 0;\n    const used = [];\n    const perSymbol = [];\n    for (const symbol of limited){\n        const entry = results[symbol];\n        const fallback = fallbackMap[symbol];\n        if ((!entry || !entry.ok) && !fallback) continue;\n        const weight = entry && entry.ok ? Math.max(1, Number(entry.meta?.n ?? 0) || 1) : Math.max(1, Number(fallback?.weight ?? 1));\n        let usedSymbol = false;\n        const gfmPct = entry && entry.ok ? Number(entry.stats.deltaGfmPct) : NaN;\n        if (Number.isFinite(gfmPct)) {\n            gfmNum += gfmPct / 100 * weight;\n            gfmDen += weight;\n            usedSymbol = true;\n        }\n        let tendencyScore = entry && entry.ok ? Number(entry.stats.vectors?.tendency?.metrics?.score) : NaN;\n        if (!Number.isFinite(tendencyScore) && fallback) {\n            const fbTendency = Number(fallback.tendency);\n            if (Number.isFinite(fbTendency)) tendencyScore = fbTendency;\n        }\n        if (Number.isFinite(tendencyScore)) {\n            tendNum += tendencyScore / 100 * weight;\n            tendDen += weight;\n            usedSymbol = true;\n        }\n        let swapScore = entry && entry.ok ? Number(entry.stats.vectors?.swap?.score) : NaN;\n        if (!Number.isFinite(swapScore) && fallback) {\n            const fbSwap = Number(fallback.swap);\n            if (Number.isFinite(fbSwap)) swapScore = fbSwap;\n        }\n        if (Number.isFinite(swapScore)) {\n            swapNum += swapScore / 100 * weight;\n            swapDen += weight;\n            usedSymbol = true;\n        }\n        const pair = splitSymbolPair(symbol);\n        if (pair && (Number.isFinite(gfmPct) || Number.isFinite(tendencyScore) || Number.isFinite(swapScore))) {\n            perSymbol.push({\n                symbol,\n                base: pair.base,\n                quote: pair.quote,\n                weight,\n                gfmDeltaPct: Number.isFinite(gfmPct) ? gfmPct / 100 : 0,\n                tendencyRaw: Number.isFinite(tendencyScore) ? tendencyScore / 100 : 0,\n                swapRaw: Number.isFinite(swapScore) ? swapScore / 100 : 0\n            });\n        }\n        if (usedSymbol) used.push(symbol);\n    }\n    return {\n        gfmDeltaPct: gfmDen ? gfmNum / gfmDen : 0,\n        tendencyRaw: tendDen ? tendNum / tendDen : 0,\n        swapRaw: swapDen ? swapNum / swapDen : 0,\n        symbols: used,\n        perSymbol\n    };\n}\nfunction dedupeCoins(list) {\n    const seen = new Set();\n    const out = [];\n    for (const item of list){\n        const norm = normalizeCoinSymbol(item);\n        if (!norm || seen.has(norm)) continue;\n        seen.add(norm);\n        out.push(norm);\n    }\n    return out;\n}\nfunction emptyBalances(coins) {\n    const out = {};\n    for (const coin of coins)out[coin] = 0;\n    return out;\n}\nfunction coinsFromGrid(grid) {\n    const set = new Set();\n    for (const base of Object.keys(grid ?? {})){\n        if (base) set.add(base);\n        const row = grid?.[base] ?? {};\n        for (const quote of Object.keys(row)){\n            if (quote) set.add(quote);\n        }\n    }\n    return Array.from(set);\n}\nfunction ensureIdPctGrid(grid, coins) {\n    for (const base of coins){\n        if (!grid[base]) grid[base] = {};\n        for (const quote of coins){\n            if (base === quote) {\n                grid[base][quote] = null;\n                continue;\n            }\n            const raw = Number(grid[base][quote]);\n            grid[base][quote] = Number.isFinite(raw) ? raw : 0;\n        }\n    }\n    return grid;\n}\nasync function resolveCoins(url) {\n    const coinsParam = url.searchParams.get(\"coins\");\n    if (coinsParam) {\n        const tokens = coinsParam.split(/[,\\s]+/).map((token)=>token.trim().toUpperCase()).filter(Boolean);\n        const coins = dedupeCoins(tokens);\n        if (coins.length) return {\n            coins,\n            source: \"query\"\n        };\n    }\n    try {\n        const settingsCoins = await (0,_lib_settings_server__WEBPACK_IMPORTED_MODULE_5__.resolveCoinsFromSettings)();\n        const coins = dedupeCoins(settingsCoins);\n        if (coins.length) return {\n            coins,\n            source: \"settings\"\n        };\n    } catch  {\n    // ignore parse errors from cookies/session\n    }\n    return {\n        coins: [\n            ...DEFAULT_COINS\n        ],\n        source: \"fallback\"\n    };\n}\nasync function readBalancesFromLedger(coins) {\n    if (!coins.length) return {\n        balances: {},\n        source: \"empty\"\n    };\n    const targets = coins.map((coin)=>coin.toUpperCase());\n    const zeros = emptyBalances(targets);\n    try {\n        const { rows } = await _core_db_db__WEBPACK_IMPORTED_MODULE_1__.db.query(`SELECT asset, amount\n         FROM wallet_balances_latest\n        WHERE asset = ANY($1::text[])`, [\n            targets\n        ]);\n        if (rows?.length) {\n            const balances = {\n                ...zeros\n            };\n            for (const row of rows){\n                const asset = normalizeCoinSymbol(row.asset);\n                if (!asset) continue;\n                const amount = Number(row.amount);\n                balances[asset] = Number.isFinite(amount) ? amount : 0;\n            }\n            return {\n                balances,\n                source: \"wallet_balances_latest\"\n            };\n        }\n    } catch  {\n    // preferred view may not exist; fall through\n    }\n    try {\n        const { rows } = await _core_db_db__WEBPACK_IMPORTED_MODULE_1__.db.query(`SELECT DISTINCT ON (asset) asset, amount\n         FROM balances\n        WHERE asset = ANY($1::text[])\n        ORDER BY asset, ts_epoch_ms DESC`, [\n            targets\n        ]);\n        if (rows?.length) {\n            const balances = {\n                ...zeros\n            };\n            for (const row of rows){\n                const asset = normalizeCoinSymbol(row.asset);\n                if (!asset) continue;\n                const amount = Number(row.amount);\n                balances[asset] = Number.isFinite(amount) ? amount : 0;\n            }\n            return {\n                balances,\n                source: \"balances\"\n            };\n        }\n    } catch  {\n    // optional historical table; fall through\n    }\n    return {\n        balances: zeros,\n        source: \"fallback:zero\"\n    };\n}\nasync function readIdPctGrid(coins, tsMs) {\n    const targets = coins.map((coin)=>coin.toUpperCase());\n    const baseGrid = {};\n    for (const base of targets){\n        baseGrid[base] = {};\n        for (const quote of targets)baseGrid[base][quote] = base === quote ? null : 0;\n    }\n    if (!targets.length) return {\n        grid: baseGrid,\n        source: \"empty\"\n    };\n    const applyIdPctRows = (rows, source)=>{\n        if (!rows?.length) return null;\n        for (const row of rows){\n            const base = normalizeCoinSymbol(row.base);\n            const quote = normalizeCoinSymbol(row.quote);\n            if (!base || !quote || base === quote) continue;\n            if (!baseGrid[base]) baseGrid[base] = {};\n            const idp = Number(row.value);\n            baseGrid[base][quote] = Number.isFinite(idp) ? idp : 0;\n        }\n        return {\n            grid: ensureIdPctGrid(baseGrid, targets),\n            source\n        };\n    };\n    try {\n        const matricesPayload = await (0,_app_api_matrices_latest_route__WEBPACK_IMPORTED_MODULE_7__.buildMatricesLatestPayload)({\n            coins: targets\n        });\n        if (matricesPayload.ok) {\n            const values = matricesPayload.matrices.id_pct?.values ?? {};\n            let populated = false;\n            for (const base of targets){\n                const row = values[base] ?? {};\n                for (const quote of targets){\n                    if (base === quote) continue;\n                    const num = Number(row?.[quote]);\n                    if (!Number.isFinite(num)) continue;\n                    if (!baseGrid[base]) baseGrid[base] = {};\n                    baseGrid[base][quote] = num;\n                    populated = true;\n                }\n            }\n            if (populated) {\n                return {\n                    grid: ensureIdPctGrid(baseGrid, targets),\n                    source: \"matrices.latest\"\n                };\n            }\n        }\n    } catch  {\n    // fall back to DB sources\n    }\n    if (Number.isFinite(tsMs)) {\n        try {\n            const { rows } = await _core_db_db__WEBPACK_IMPORTED_MODULE_1__.db.query(`SELECT DISTINCT ON (base, quote) base, quote, value\n           FROM matrices.dyn_values\n          WHERE matrix_type = 'id_pct'\n            AND ts_ms <= $1\n            AND base = ANY($2::text[])\n            AND quote = ANY($2::text[])\n          ORDER BY base, quote, ts_ms DESC`, [\n                tsMs,\n                targets\n            ]);\n            const applied = applyIdPctRows(rows, \"matrices.dyn_values\");\n            if (applied) return applied;\n        } catch  {\n        // fall back to other sources\n        }\n    }\n    try {\n        const { rows } = await _core_db_db__WEBPACK_IMPORTED_MODULE_1__.db.query(`SELECT DISTINCT ON (base, quote) base, quote, value\n         FROM matrices.dyn_values\n        WHERE matrix_type = 'id_pct'\n          AND base = ANY($1::text[])\n          AND quote = ANY($1::text[])\n        ORDER BY base, quote, ts_ms DESC`, [\n            targets\n        ]);\n        const applied = applyIdPctRows(rows, \"matrices.dyn_values\");\n        if (applied) return applied;\n    } catch  {\n    // continue with legacy fallbacks\n    }\n    if (Number.isFinite(tsMs)) {\n        try {\n            const { rows } = await _core_db_db__WEBPACK_IMPORTED_MODULE_1__.db.query(`SELECT DISTINCT ON (base, quote) base, quote, id_pct\n           FROM id_pct_pairs\n          WHERE ts_epoch_ms <= $1\n            AND base = ANY($2::text[])\n            AND quote = ANY($2::text[])\n          ORDER BY base, quote, ts_epoch_ms DESC`, [\n                tsMs,\n                targets\n            ]);\n            if (rows?.length) {\n                for (const row of rows){\n                    const base = normalizeCoinSymbol(row.base);\n                    const quote = normalizeCoinSymbol(row.quote);\n                    if (!base || !quote || base === quote) continue;\n                    const idp = Number(row.id_pct);\n                    if (!baseGrid[base]) baseGrid[base] = {};\n                    baseGrid[base][quote] = Number.isFinite(idp) ? idp : 0;\n                }\n                return {\n                    grid: ensureIdPctGrid(baseGrid, targets),\n                    source: \"id_pct_pairs\"\n                };\n            }\n        } catch  {\n        // fall back to latest view\n        }\n    }\n    try {\n        const { rows } = await _core_db_db__WEBPACK_IMPORTED_MODULE_1__.db.query(`SELECT base, quote, id_pct\n         FROM id_pct_latest\n        WHERE base = ANY($1::text[])\n          AND quote = ANY($1::text[])`, [\n            targets\n        ]);\n        if (rows?.length) {\n            for (const row of rows){\n                const base = normalizeCoinSymbol(row.base);\n                const quote = normalizeCoinSymbol(row.quote);\n                if (!base || !quote || base === quote) continue;\n                const idp = Number(row.id_pct);\n                if (!baseGrid[base]) baseGrid[base] = {};\n                baseGrid[base][quote] = Number.isFinite(idp) ? idp : 0;\n            }\n            return {\n                grid: ensureIdPctGrid(baseGrid, targets),\n                source: \"id_pct_latest\"\n            };\n        }\n    } catch  {\n    // fall through to metrics table\n    }\n    const metricKeys = [];\n    for (const base of targets){\n        for (const quote of targets){\n            if (base === quote) continue;\n            metricKeys.push(`id_pct:${base}|${quote}`);\n        }\n    }\n    if (metricKeys.length) {\n        try {\n            const { rows } = await _core_db_db__WEBPACK_IMPORTED_MODULE_1__.db.query(`SELECT DISTINCT ON (metric_key) metric_key, value\n           FROM metrics\n          WHERE metric_key = ANY($1::text[])\n          ORDER BY metric_key, ts_epoch_ms DESC`, [\n                metricKeys\n            ]);\n            if (rows?.length) {\n                for (const row of rows){\n                    const key = String(row.metric_key ?? \"\");\n                    const [, payload] = key.split(\"id_pct:\");\n                    if (!payload) continue;\n                    const [baseRaw, quoteRaw] = payload.split(\"|\");\n                    const base = normalizeCoinSymbol(baseRaw);\n                    const quote = normalizeCoinSymbol(quoteRaw);\n                    if (!base || !quote || base === quote) continue;\n                    if (!baseGrid[base]) baseGrid[base] = {};\n                    const idp = Number(row.value);\n                    baseGrid[base][quote] = Number.isFinite(idp) ? idp : 0;\n                }\n                return {\n                    grid: ensureIdPctGrid(baseGrid, targets),\n                    source: \"metrics\"\n                };\n            }\n        } catch  {\n        // ignore and fall back to zeros\n        }\n    }\n    return {\n        grid: ensureIdPctGrid(baseGrid, targets),\n        source: \"fallback:zero\"\n    };\n}\nasync function fetchWindowVectorFallbacks(symbols, window) {\n    const targets = Array.from(new Set(symbols.map((sym)=>normalizeCoinSymbol(sym)).filter((sym)=>Boolean(sym))));\n    if (!targets.length) return {};\n    try {\n        const { rows } = await _core_db_db__WEBPACK_IMPORTED_MODULE_1__.db.query(`select symbol, v_tend_close, v_swap_close, cycles_count\n         from str_aux.v_latest_windows\n        where window_label = $1\n          and symbol = any($2::text[])`, [\n            window,\n            targets\n        ]);\n        const out = {};\n        for (const row of rows ?? []){\n            const symbol = normalizeCoinSymbol(row.symbol);\n            if (!symbol) continue;\n            out[symbol] = {\n                symbol,\n                tendency: toNum(row.v_tend_close),\n                swap: toNum(row.v_swap_close),\n                weight: Math.max(1, Number(row.cycles_count) || 1)\n            };\n        }\n        return out;\n    } catch  {\n        return {};\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0I2SSxVQUFVTjtRQUFVN0osUUFBUTtJQUFnQjtBQUM3RTtBQVNBLGVBQWU2SCwyQkFDYjlFLE9BQWlCLEVBQ2pCK0QsTUFBeUI7SUFFekIsTUFBTStDLFVBQVVoRSxNQUFNQyxJQUFJLENBQ3hCLElBQUlDLElBQ0ZoRCxRQUNHaUQsR0FBRyxDQUFDLENBQUNtRixNQUFRbkcsb0JBQW9CbUcsTUFDakNqRixNQUFNLENBQUMsQ0FBQ2lGLE1BQXVCL0UsUUFBUStFO0lBRzlDLElBQUksQ0FBQ3RCLFFBQVFuSixNQUFNLEVBQUUsT0FBTyxDQUFDO0lBUzdCLElBQUk7UUFDRixNQUFNLEVBQUVxSixJQUFJLEVBQUUsR0FBRyxNQUFNeE4sMkNBQUVBLENBQUN5TixLQUFLLENBQzdCLENBQUM7OztzQ0FHK0IsQ0FBQyxFQUNqQztZQUFDbEQ7WUFBUStDO1NBQVE7UUFFbkIsTUFBTWpELE1BQTJDLENBQUM7UUFDbEQsS0FBSyxNQUFNMkMsT0FBT1EsUUFBUSxFQUFFLENBQUU7WUFDNUIsTUFBTTFFLFNBQVNMLG9CQUFvQnVFLElBQUlsRSxNQUFNO1lBQzdDLElBQUksQ0FBQ0EsUUFBUTtZQUNidUIsR0FBRyxDQUFDdkIsT0FBTyxHQUFHO2dCQUNaQTtnQkFDQWtDLFVBQVUxRixNQUFNMEgsSUFBSTZCLFlBQVk7Z0JBQ2hDekQsTUFBTTlGLE1BQU0wSCxJQUFJOEIsWUFBWTtnQkFDNUIvQyxRQUFRckssS0FBS0MsR0FBRyxDQUFDLEdBQUdKLE9BQU95TCxJQUFJK0IsWUFBWSxLQUFLO1lBQ2xEO1FBQ0Y7UUFDQSxPQUFPMUU7SUFDVCxFQUFFLE9BQU07UUFDTixPQUFPLENBQUM7SUFDVjtBQUNGIiwic291cmNlcyI6WyJIOlxcVXNlcnNcXEd1c1xcc291cmNlXFxyZXBvXFxkeW5hbWljc1xcZHluYW1pY3MtYlxcY3J5cHRvcGktZHluYW1pY3NcXHNyY1xcYXBwXFxhcGlcXG1vby1hdXhcXHJvdXRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXF1ZXN0LCBOZXh0UmVzcG9uc2UgfSBmcm9tIFwibmV4dC9zZXJ2ZXJcIjtcblxuaW1wb3J0IHsgZGIgfSBmcm9tIFwiQC9jb3JlL2RiL2RiXCI7XG5pbXBvcnQge1xuICBidWlsZE1lYUF1eCxcbiAgdHlwZSBCYWxhbmNlc01hcCxcbiAgdHlwZSBJZFBjdEdyaWQsXG4gIHNhdmVNb29kT2JzZXJ2YXRpb24sXG59IGZyb20gXCJAL2NvcmUvZmVhdHVyZXMvbW9vLWF1eC9tZWFzdXJlc1wiO1xuaW1wb3J0IHsgREVGQVVMVF9USUVSX1JVTEVTIH0gZnJvbSBcIkAvY29yZS9mZWF0dXJlcy9tb28tYXV4L3RpZXJzXCI7XG5pbXBvcnQgeyByZXNvbHZlUGFpckF2YWlsYWJpbGl0eSwgbWFza1VuYXZhaWxhYmxlTWF0cml4IH0gZnJvbSBcIkAvbGliL21hcmtldHMvYXZhaWxhYmlsaXR5XCI7XG5pbXBvcnQgdHlwZSB7IFBhaXJBdmFpbGFiaWxpdHlTbmFwc2hvdCB9IGZyb20gXCJAL2xpYi9tYXJrZXRzL2F2YWlsYWJpbGl0eVwiO1xuaW1wb3J0IHsgcmVzb2x2ZUNvaW5zRnJvbVNldHRpbmdzIH0gZnJvbSBcIkAvbGliL3NldHRpbmdzL3NlcnZlclwiO1xuaW1wb3J0IHsgY29tcHV0ZVNhbXBsZWRNZXRyaWNzIH0gZnJvbSBcIkAvY29yZS9mZWF0dXJlcy9zdHItYXV4L2NhbGMvcGFuZWxcIjtcbmltcG9ydCB0eXBlIHsgU3RhdHNPcHRpb25zIH0gZnJvbSBcIkAvY29yZS9mZWF0dXJlcy9zdHItYXV4L2NhbGMvc3RhdHNcIjtcbmltcG9ydCB0eXBlIHsgU2FtcGxpbmdXaW5kb3dLZXkgfSBmcm9tIFwiQC9jb3JlL2ZlYXR1cmVzL3N0ci1hdXgvc2FtcGxpbmdcIjtcbmltcG9ydCB7IGJ1aWxkTWF0cmljZXNMYXRlc3RQYXlsb2FkIH0gZnJvbSBcIkAvYXBwL2FwaS9tYXRyaWNlcy9sYXRlc3Qvcm91dGVcIjtcblxuLy8gTkVXOiBtb29kIGltcG9ydHMgKGFkZGVkIGluIGxpYi9tb29kLnRzIHBlciBvdXIgcGxhbilcbmltcG9ydCB7XG4gIG5vcm1hbGl6ZU1vb2RJbnB1dHMsXG4gIGNvbXB1dGVNb29kQ29lZmZWMSxcbiAgbW9vZFVVSURGcm9tQnVja2V0cyxcbiAgdHlwZSBNb29kSW5wdXRzLFxuICB0eXBlIE1vb2RSZWZlcmVudGlhbHMsXG59IGZyb20gXCJAL2xpYi9tZWEvbW9vZFwiO1xuXG5leHBvcnQgY29uc3QgZHluYW1pYyA9IFwiZm9yY2UtZHluYW1pY1wiO1xuZXhwb3J0IGNvbnN0IHJldmFsaWRhdGUgPSAwO1xuXG5jb25zdCBDQUNIRV9IRUFERVJTID0geyBcIkNhY2hlLUNvbnRyb2xcIjogXCJuby1zdG9yZVwiIH07XG5jb25zdCBERUZBVUxUX0NPSU5TID0gW1wiVVNEVFwiLCBcIkJUQ1wiLCBcIkVUSFwiLCBcIkJOQlwiLCBcIlNPTFwiXTtcbmNvbnN0IERFRkFVTFRfQVBQX1NFU1NJT04gPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUFBfU0VTU0lPTl9JRCA/PyBcIm1vby1hdXhcIjtcbmNvbnN0IFNUUl9NT09EX1dJTkRPVzogU2FtcGxpbmdXaW5kb3dLZXkgPVxuICAocHJvY2Vzcy5lbnYuTU9PX0FVWF9TVFJfV0lORE9XIGFzIFNhbXBsaW5nV2luZG93S2V5KSA/PyBcIjMwbVwiO1xuY29uc3QgU1RSX01PT0RfQklOUyA9IE51bWJlci5pc0Zpbml0ZShOdW1iZXIocHJvY2Vzcy5lbnYuTU9PX0FVWF9TVFJfQklOUykpXG4gID8gTWF0aC5tYXgoMTYsIE1hdGguZmxvb3IoTnVtYmVyKHByb2Nlc3MuZW52Lk1PT19BVVhfU1RSX0JJTlMpKSlcbiAgOiAxMjg7XG5jb25zdCBNQVhfTU9PRF9TWU1CT0xTID0gTnVtYmVyLmlzRmluaXRlKE51bWJlcihwcm9jZXNzLmVudi5NT09fQVVYX1NZTUJPTF9MSU1JVCkpXG4gID8gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihOdW1iZXIocHJvY2Vzcy5lbnYuTU9PX0FVWF9TWU1CT0xfTElNSVQpKSlcbiAgOiAxMjtcbmNvbnN0IERFRkFVTFRfTU9PRF9TVEFUUzogU3RhdHNPcHRpb25zID0ge1xuICBpZGhyOiB7IGFscGhhOiAyLjUsIHNNaW46IDFlLTYsIHNtb290aDogMywgdG9wSzogOCB9LFxuICBlcHNHZm1QY3Q6IDAuMzUsXG4gIGVwc0JmbVBjdDogMC4zNSxcbiAgdlNjYWxlOiAxMDAsXG4gIHRlbmRlbmN5V2luOiAzMCxcbiAgdGVuZGVuY3lOb3JtOiBcIm1hZFwiLFxuICBzd2FwQWxwaGE6IDEuMixcbn07XG5cbnR5cGUgQmFsYW5jZVJlYWRSZXN1bHQgPSB7IGJhbGFuY2VzOiBCYWxhbmNlc01hcDsgc291cmNlOiBzdHJpbmcgfTtcbnR5cGUgSWRQY3RSZWFkUmVzdWx0ID0geyBncmlkOiBJZFBjdEdyaWQ7IHNvdXJjZTogc3RyaW5nIH07XG50eXBlIE1vb2RTaWduYWxWYWx1ZXMgPSB7IGdmbURlbHRhUGN0OiBudW1iZXI7IHRlbmRlbmN5UmF3OiBudW1iZXI7IHN3YXBSYXc6IG51bWJlciB9O1xudHlwZSBTeW1ib2xNb29kU2lnbmFscyA9IE1vb2RTaWduYWxWYWx1ZXMgJiB7XG4gIHN5bWJvbDogc3RyaW5nO1xuICBiYXNlOiBzdHJpbmc7XG4gIHF1b3RlOiBzdHJpbmc7XG4gIHdlaWdodDogbnVtYmVyO1xufTtcbnR5cGUgTW9vZFJhd0Rlc2NyaXB0b3IgPSB7XG4gIHNvdXJjZTogc3RyaW5nO1xuICBzaWduYWxzOiBNb29kU2lnbmFsVmFsdWVzO1xuICBzeW1ib2xzOiBzdHJpbmdbXTtcbiAgcGVyU3ltYm9sOiBTeW1ib2xNb29kU2lnbmFsc1tdO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIEdFVChyZXE6IE5leHRSZXF1ZXN0KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXEudXJsKTtcbiAgICBjb25zdCBhcHBTZXNzaW9uSWQgPSAodXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJzZXNzaW9uSWRcIikgPz8gREVGQVVMVF9BUFBfU0VTU0lPTikuc2xpY2UoMCwgNjQpO1xuXG4gICAgLy8gLS0tLS0tLS0gdGltaW5nXG4gICAgY29uc3QgdHNQYXJhbSA9IE51bWJlcih1cmwuc2VhcmNoUGFyYW1zLmdldChcInRzXCIpID8/IHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwidGltZXN0YW1wXCIpKTtcbiAgICBjb25zdCB0c01zID0gTnVtYmVyLmlzRmluaXRlKHRzUGFyYW0pICYmIHRzUGFyYW0gPiAwID8gdHNQYXJhbSA6IERhdGUubm93KCk7XG5cbiAgICAvLyAtLS0tLS0tLSBjb2lucyB1bml2ZXJzZVxuICAgIGNvbnN0IHsgY29pbnM6IGluaXRpYWxDb2lucywgc291cmNlOiBjb2luc1NvdXJjZSB9ID0gYXdhaXQgcmVzb2x2ZUNvaW5zKHVybCk7XG5cbiAgICAvLyAtLS0tLS0tLSBpZF9wY3QgZ3JpZCAoREItYmFja2VkKVxuICAgIGNvbnN0IHsgZ3JpZDogaWRQY3RHcmlkUmF3LCBzb3VyY2U6IGlkUGN0U291cmNlIH0gPSBhd2FpdCByZWFkSWRQY3RHcmlkKGluaXRpYWxDb2lucywgdHNNcyk7XG4gICAgY29uc3QgZGVkdXBlZENvaW5zID0gZGVkdXBlQ29pbnMoWy4uLmluaXRpYWxDb2lucywgLi4uY29pbnNGcm9tR3JpZChpZFBjdEdyaWRSYXcpXSk7XG4gICAgaWYgKCFkZWR1cGVkQ29pbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgb2s6IHRydWUsIGNvaW5zOiBbXSwgazogMCwgZ3JpZDoge30gfSxcbiAgICAgICAgeyBoZWFkZXJzOiBDQUNIRV9IRUFERVJTIH0sXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQgY29pbnMgPSBkZWR1cGVkQ29pbnM7XG4gICAgaWYgKCFjb2lucy5pbmNsdWRlcyhcIlVTRFRcIikpIGNvaW5zID0gW1wiVVNEVFwiLCAuLi5jb2luc107XG5cbiAgICAvLyAtLS0tLS0tLSBhdmFpbGFiaWxpdHkgZmlsdGVyXG4gICAgY29uc3QgYXZhaWxhYmlsaXR5OiBQYWlyQXZhaWxhYmlsaXR5U25hcHNob3QgPSBhd2FpdCByZXNvbHZlUGFpckF2YWlsYWJpbGl0eShjb2lucyk7XG4gICAgY29uc3QgYWxsb3dlZFN5bWJvbHMgPSBhdmFpbGFiaWxpdHkuc2V0O1xuICAgIGNvbnN0IG1vb2RTeW1ib2xzID0gZGVyaXZlTW9vZFN5bWJvbHMoY29pbnMsIGFsbG93ZWRTeW1ib2xzKTtcblxuICAgIC8vIC0tLS0tLS0tIG5vcm1hbGl6ZSBpZF9wY3QgZ3JpZCArIGJhbGFuY2VzXG4gICAgY29uc3QgaWRQY3RHcmlkID0gZW5zdXJlSWRQY3RHcmlkKGlkUGN0R3JpZFJhdywgY29pbnMpO1xuICAgIGNvbnN0IHsgYmFsYW5jZXMsIHNvdXJjZTogYmFsYW5jZVNvdXJjZSB9ID0gYXdhaXQgcmVhZEJhbGFuY2VzRnJvbUxlZGdlcihjb2lucyk7XG5cbiAgICAvLyAtLS0tLS0tLSBkaXZpc29yIChrKVxuICAgIGNvbnN0IGtQYXJhbSA9IE51bWJlcih1cmwuc2VhcmNoUGFyYW1zLmdldChcImtcIikpO1xuICAgIGNvbnN0IGRpdmlzb3IgPSBOdW1iZXIuaXNGaW5pdGUoa1BhcmFtKSAmJiBrUGFyYW0gPiAwXG4gICAgICA/IE1hdGguZmxvb3Ioa1BhcmFtKVxuICAgICAgOiBNYXRoLm1heCgxLCBjb2lucy5sZW5ndGggLSAxKTtcblxuICAgIC8vID09PT09PT09IE5FVzogbW9vZCBub3JtYWxpemF0aW9uICYgY29lZmZpY2llbnQgKGFuY2hvcmVkKSA9PT09PT09PVxuICAgIC8vIFF1ZXJ5IG92ZXJyaWRlcyAob3B0aW9uYWwpIGZvciB0ZXN0aW5nOlxuICAgIGNvbnN0IHFfZ2ZtRGVsdGFQY3QgPSB0b051bSh1cmwuc2VhcmNoUGFyYW1zLmdldChcImdmbURlbHRhUGN0XCIpKTsgLy8gZS5nLiAwLjAxIGZvciArMSVcbiAgICBjb25zdCBxX3RlbmRlbmN5UmF3ID0gdG9OdW0odXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ0ZW5kZW5jeVJhd1wiKSk7XG4gICAgY29uc3QgcV9zd2FwUmF3ICAgICA9IHRvTnVtKHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwic3dhcFJhd1wiKSk7XG5cbiAgICBjb25zdCByZWZzOiBNb29kUmVmZXJlbnRpYWxzID0ge1xuICAgICAgZ2ZtU2NhbGU6IHRvTnVtKHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwiZ2ZtU2NhbGVcIikpID8/IDIwLFxuICAgICAgdnRNdTogdG9OdW0odXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ2dE11XCIpKSA/PyAwLFxuICAgICAgdnRTaWdtYTogdG9OdW0odXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ2dFNpZ21hXCIpKSA/PyAwLjAyLFxuICAgICAgdnNNdTogdG9OdW0odXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ2c011XCIpKSA/PyAwLFxuICAgICAgdnNTaWdtYTogdG9OdW0odXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ2c1NpZ21hXCIpKSA/PyAwLjA1LFxuICAgICAgdnNBbHBoYTogdG9OdW0odXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ2c0FscGhhXCIpKSA/PyAwLjc1LFxuICAgIH07XG5cbiAgICBjb25zdCBoYXZlUmF3ID1cbiAgICAgIHFfZ2ZtRGVsdGFQY3QgIT0gbnVsbCB8fCBxX3RlbmRlbmN5UmF3ICE9IG51bGwgfHwgcV9zd2FwUmF3ICE9IG51bGw7XG5cbiAgICBjb25zdCBtYW51YWxTaWduYWxzOiBNb29kU2lnbmFsVmFsdWVzID0ge1xuICAgICAgZ2ZtRGVsdGFQY3Q6IHFfZ2ZtRGVsdGFQY3QgPz8gMCxcbiAgICAgIHRlbmRlbmN5UmF3OiBxX3RlbmRlbmN5UmF3ID8/IDAsXG4gICAgICBzd2FwUmF3OiBxX3N3YXBSYXcgPz8gMCxcbiAgICB9O1xuXG4gICAgbGV0IGRlcml2ZWRTaWduYWxzID0gaGF2ZVJhd1xuICAgICAgPyBudWxsXG4gICAgICA6IGF3YWl0IGNvbXB1dGVNb29kU2lnbmFsc0Zyb21TdHJBdXgobW9vZFN5bWJvbHMsIFNUUl9NT09EX1dJTkRPVykuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgaWYgKCFkZXJpdmVkU2lnbmFscykge1xuICAgICAgZGVyaXZlZFNpZ25hbHMgPSB7IGdmbURlbHRhUGN0OiAwLCB0ZW5kZW5jeVJhdzogMCwgc3dhcFJhdzogMCwgc3ltYm9sczogW10gfTtcbiAgICB9XG5cbiAgICBjb25zdCBtb29kUmF3RGVzY3JpcHRvcjogTW9vZFJhd0Rlc2NyaXB0b3IgPSBoYXZlUmF3XG4gICAgICA/IHsgc291cmNlOiBcInF1ZXJ5XCIsIHNpZ25hbHM6IG1hbnVhbFNpZ25hbHMsIHN5bWJvbHM6IFtdLCBwZXJTeW1ib2w6IFtdIH1cbiAgICAgIDoge1xuICAgICAgICAgIHNvdXJjZTogZGVyaXZlZFNpZ25hbHMuc3ltYm9scy5sZW5ndGggPyBcInN0ci1hdXhcIiA6IFwic3RyLWF1eDpmYWxsYmFja1wiLFxuICAgICAgICAgIHNpZ25hbHM6IHtcbiAgICAgICAgICAgIGdmbURlbHRhUGN0OiBkZXJpdmVkU2lnbmFscy5nZm1EZWx0YVBjdCxcbiAgICAgICAgICAgIHRlbmRlbmN5UmF3OiBkZXJpdmVkU2lnbmFscy50ZW5kZW5jeVJhdyxcbiAgICAgICAgICAgIHN3YXBSYXc6IGRlcml2ZWRTaWduYWxzLnN3YXBSYXcsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzeW1ib2xzOiBkZXJpdmVkU2lnbmFscy5zeW1ib2xzLFxuICAgICAgICAgIHBlclN5bWJvbDogZGVyaXZlZFNpZ25hbHMucGVyU3ltYm9sLFxuICAgICAgICB9O1xuXG4gICAgY29uc3QgbW9vZElucHV0cyA9IG5vcm1hbGl6ZU1vb2RJbnB1dHMoXG4gICAgICB7XG4gICAgICAgIGdmbURlbHRhUGN0OiBtb29kUmF3RGVzY3JpcHRvci5zaWduYWxzLmdmbURlbHRhUGN0LFxuICAgICAgICB0ZW5kZW5jeVJhdzogbW9vZFJhd0Rlc2NyaXB0b3Iuc2lnbmFscy50ZW5kZW5jeVJhdyxcbiAgICAgICAgc3dhcFJhdzogbW9vZFJhd0Rlc2NyaXB0b3Iuc2lnbmFscy5zd2FwUmF3LFxuICAgICAgfSxcbiAgICAgIHJlZnNcbiAgICApO1xuXG4gICAgY29uc3QgeyBjb2VmZjogbW9vZENvZWZmLCBidWNrZXRzIH0gPSBjb21wdXRlTW9vZENvZWZmVjEobW9vZElucHV0cyk7XG4gICAgY29uc3QgbW9vZFVVSUQgPSBtb29kVVVJREZyb21CdWNrZXRzKGJ1Y2tldHMpO1xuICAgIGNvbnN0IHBlclN5bWJvbE1vb2QgPSBidWlsZFBlclN5bWJvbE1vb2QobW9vZFJhd0Rlc2NyaXB0b3IucGVyU3ltYm9sLCByZWZzKTtcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyAtLS0tLS0tLSBidWlsZCBNRUEgd2VpZ2h0cyAobGVnYWN5IGZ1bmN0aW9uIHVudG91Y2hlZClcbiAgICBjb25zdCBncmlkID0gYnVpbGRNZWFBdXgoe1xuICAgICAgY29pbnMsXG4gICAgICBpZFBjdDogaWRQY3RHcmlkLFxuICAgICAgYmFsYW5jZXMsXG4gICAgICBrOiBkaXZpc29yLFxuICAgICAgcnVsZXM6IERFRkFVTFRfVElFUl9SVUxFUyxcbiAgICAgIG1vb2RDb2VmZixcbiAgICB9KTtcblxuICAgIC8vIFBlcnNpc3Qgb2JzZXJ2YXRpb24gKGJlc3QtZWZmb3J0KVxuICAgIGNvbnN0IG9ic2VydmF0aW9uUGF5bG9hZCA9IHtcbiAgICAgIHNvdXJjZTogbW9vZFJhd0Rlc2NyaXB0b3Iuc291cmNlLFxuICAgICAgc3ltYm9sczogbW9vZFJhd0Rlc2NyaXB0b3Iuc3ltYm9scyxcbiAgICAgIHNpZ25hbHM6IG1vb2RSYXdEZXNjcmlwdG9yLnNpZ25hbHMsXG4gICAgICBpbnB1dHM6IG1vb2RJbnB1dHMsXG4gICAgICByZWZzLFxuICAgICAgcGVyU3ltYm9sOiBwZXJTeW1ib2xNb29kLFxuICAgIH07XG4gICAgc2F2ZU1vb2RPYnNlcnZhdGlvbihhcHBTZXNzaW9uSWQsIHRzTXMsIG1vb2RVVUlELCBtb29kQ29lZmYsIG9ic2VydmF0aW9uUGF5bG9hZCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgY29uc29sZS53YXJuKFwiW21vby1hdXhdIG1vb2Qgb2JzZXJ2YXRpb24gc2tpcHBlZDpcIiwgZXJyKTtcbiAgICB9KTtcblxuICAgIC8vIC0tLS0tLS0tIG1hc2sgdW5hdmFpbGFibGUgc3ltYm9scy9wYWlyc1xuICAgIGlmIChhbGxvd2VkU3ltYm9scy5zaXplKSB7XG4gICAgICBtYXNrVW5hdmFpbGFibGVNYXRyaXgoZ3JpZCwgYWxsb3dlZFN5bWJvbHMpO1xuICAgICAgbWFza1VuYXZhaWxhYmxlTWF0cml4KGlkUGN0R3JpZCwgYWxsb3dlZFN5bWJvbHMpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tIHJlc3BvbnNlXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAge1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgdHNfbXM6IHRzTXMsXG4gICAgICAgIGNvaW5zLFxuICAgICAgICBrOiBkaXZpc29yLFxuICAgICAgICBncmlkLFxuICAgICAgICBpZF9wY3Q6IGlkUGN0R3JpZCxcbiAgICAgICAgYmFsYW5jZXMsXG4gICAgICAgIG1vb2Q6IHtcbiAgICAgICAgICBjb2VmZjogbW9vZENvZWZmLFxuICAgICAgICAgIHV1aWQ6IG1vb2RVVUlELFxuICAgICAgICAgIGlucHV0czogbW9vZElucHV0cyxcbiAgICAgICAgICByZWZzLFxuICAgICAgICAgIHJhdzogbW9vZFJhd0Rlc2NyaXB0b3IsXG4gICAgICAgICAgcGVyU3ltYm9sOiBwZXJTeW1ib2xNb29kLFxuICAgICAgICB9LFxuICAgICAgICBzb3VyY2VzOiB7XG4gICAgICAgICAgY29pbnM6IGNvaW5zU291cmNlLFxuICAgICAgICAgIGlkX3BjdDogaWRQY3RTb3VyY2UsXG4gICAgICAgICAgYmFsYW5jZXM6IGJhbGFuY2VTb3VyY2UsXG4gICAgICAgICAgbW9vZDogbW9vZFJhd0Rlc2NyaXB0b3Iuc291cmNlLFxuICAgICAgICB9LFxuICAgICAgICBhdmFpbGFiaWxpdHk6IHtcbiAgICAgICAgICBzeW1ib2xzOiBhdmFpbGFiaWxpdHkuc3ltYm9scyxcbiAgICAgICAgICBwYWlyczogYXZhaWxhYmlsaXR5LnBhaXJzLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHsgaGVhZGVyczogQ0FDSEVfSEVBREVSUyB9LFxuICAgICk7XG4gIH0gY2F0Y2ggKGVycjogdW5rbm93bikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogU3RyaW5nKGVycik7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBvazogZmFsc2UsIGVycm9yOiBtZXNzYWdlIH0sXG4gICAgICB7IHN0YXR1czogNTAwLCBoZWFkZXJzOiBDQUNIRV9IRUFERVJTIH0sXG4gICAgKTtcbiAgfVxufVxuXG4vLyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgaGVscGVycyAodW5jaGFuZ2VkICsgc21hbGwgYWRkaXRpb25zKVxuXG5mdW5jdGlvbiB0b051bSh4OiBzdHJpbmcgfCBudWxsKTogbnVtYmVyIHwgbnVsbCB7XG4gIGlmICh4ID09IG51bGwpIHJldHVybiBudWxsO1xuICBjb25zdCBuID0gTnVtYmVyKHgpO1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG4pID8gbiA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvaW5TeW1ib2wocmF3OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmIChyYXcgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHRyaW1tZWQgPSBTdHJpbmcocmF3KS50cmltKCkudG9VcHBlckNhc2UoKTtcbiAgcmV0dXJuIHRyaW1tZWQgPyB0cmltbWVkIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gc3BsaXRTeW1ib2xQYWlyKHN5bWJvbDogc3RyaW5nKTogeyBiYXNlOiBzdHJpbmc7IHF1b3RlOiBzdHJpbmcgfSB8IG51bGwge1xuICBjb25zdCB1cHBlciA9IFN0cmluZyhzeW1ib2wgPz8gXCJcIikudHJpbSgpLnRvVXBwZXJDYXNlKCk7XG4gIGlmICghdXBwZXIpIHJldHVybiBudWxsO1xuICBjb25zdCBjb21tb25zID0gW1wiVVNEVFwiLCBcIlVTRFwiLCBcIlVTRENcIiwgXCJCVVNEXCIsIFwiRVVSXCIsIFwiQlRDXCIsIFwiRVRIXCIsIFwiQk5CXCIsIFwiQlJMXCJdO1xuICBmb3IgKGNvbnN0IHF1b3RlIG9mIGNvbW1vbnMpIHtcbiAgICBpZiAodXBwZXIuZW5kc1dpdGgocXVvdGUpICYmIHVwcGVyLmxlbmd0aCA+IHF1b3RlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHsgYmFzZTogdXBwZXIuc2xpY2UoMCwgLXF1b3RlLmxlbmd0aCksIHF1b3RlIH07XG4gICAgfVxuICB9XG4gIGlmICh1cHBlci5sZW5ndGggPj0gNikge1xuICAgIHJldHVybiB7IGJhc2U6IHVwcGVyLnNsaWNlKDAsIHVwcGVyLmxlbmd0aCAtIDQpLCBxdW90ZTogdXBwZXIuc2xpY2UoLTQpIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbnR5cGUgTW9vZFNpZ25hbHMgPSB7XG4gIGdmbURlbHRhUGN0OiBudW1iZXI7XG4gIHRlbmRlbmN5UmF3OiBudW1iZXI7XG4gIHN3YXBSYXc6IG51bWJlcjtcbiAgc3ltYm9sczogc3RyaW5nW107XG4gIHBlclN5bWJvbDogU3ltYm9sTW9vZFNpZ25hbHNbXTtcbn07XG5cbmZ1bmN0aW9uIGRlcml2ZU1vb2RTeW1ib2xzKGNvaW5zOiBzdHJpbmdbXSwgYWxsb3dlZDogU2V0PHN0cmluZz4pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBBcnJheS5mcm9tKFxuICAgIG5ldyBTZXQoY29pbnMubWFwKChjb2luKSA9PiBub3JtYWxpemVDb2luU3ltYm9sKGNvaW4pKS5maWx0ZXIoKGMpOiBjIGlzIHN0cmluZyA9PiBCb29sZWFuKGMpKSlcbiAgKTtcbiAgY29uc3QgZGVzaXJlZDogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChjb25zdCBiYXNlIG9mIG5vcm1hbGl6ZWQpIHtcbiAgICBjb25zdCBwcmVmZXJyZWQgPSBgJHtiYXNlfVVTRFRgO1xuICAgIGlmIChiYXNlICE9PSBcIlVTRFRcIiAmJiBhbGxvd2VkLmhhcyhwcmVmZXJyZWQpKSBkZXNpcmVkLnB1c2gocHJlZmVycmVkKTtcbiAgfVxuICBmb3IgKGNvbnN0IGJhc2Ugb2Ygbm9ybWFsaXplZCkge1xuICAgIGZvciAoY29uc3QgcXVvdGUgb2Ygbm9ybWFsaXplZCkge1xuICAgICAgaWYgKGJhc2UgPT09IHF1b3RlKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHN5bWJvbCA9IGAke2Jhc2V9JHtxdW90ZX1gO1xuICAgICAgaWYgKGFsbG93ZWQuaGFzKHN5bWJvbCkpIGRlc2lyZWQucHVzaChzeW1ib2wpO1xuICAgIH1cbiAgfVxuICBpZiAoIWRlc2lyZWQubGVuZ3RoICYmIGFsbG93ZWQuc2l6ZSkge1xuICAgIGZvciAoY29uc3Qgc3ltYm9sIG9mIGFsbG93ZWQpIGRlc2lyZWQucHVzaChTdHJpbmcoc3ltYm9sID8/IFwiXCIpLnRvVXBwZXJDYXNlKCkpO1xuICB9XG4gIGNvbnN0IHVuaXF1ZSA9IEFycmF5LmZyb20obmV3IFNldChkZXNpcmVkLm1hcCgocykgPT4gU3RyaW5nKHMgPz8gXCJcIikudG9VcHBlckNhc2UoKSkuZmlsdGVyKEJvb2xlYW4pKSk7XG4gIHJldHVybiB1bmlxdWUuc2xpY2UoMCwgTUFYX01PT0RfU1lNQk9MUyk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUGVyU3ltYm9sTW9vZChkZXRhaWxzOiBTeW1ib2xNb29kU2lnbmFsc1tdLCByZWZzOiBNb29kUmVmZXJlbnRpYWxzKSB7XG4gIGNvbnN0IG91dDogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywge1xuICAgIGNvZWZmOiBudW1iZXI7XG4gICAgdXVpZDogc3RyaW5nO1xuICAgIGlucHV0czogTW9vZElucHV0cztcbiAgICByYXc6IFN5bWJvbE1vb2RTaWduYWxzO1xuICB9Pj4gPSB7fTtcbiAgZm9yIChjb25zdCBkZXRhaWwgb2YgZGV0YWlscyA/PyBbXSkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVNb29kSW5wdXRzKFxuICAgICAge1xuICAgICAgICBnZm1EZWx0YVBjdDogZGV0YWlsLmdmbURlbHRhUGN0LFxuICAgICAgICB0ZW5kZW5jeVJhdzogZGV0YWlsLnRlbmRlbmN5UmF3LFxuICAgICAgICBzd2FwUmF3OiBkZXRhaWwuc3dhcFJhdyxcbiAgICAgIH0sXG4gICAgICByZWZzXG4gICAgKTtcbiAgICBjb25zdCB7IGNvZWZmLCBidWNrZXRzIH0gPSBjb21wdXRlTW9vZENvZWZmVjEobm9ybWFsaXplZCk7XG4gICAgY29uc3QgdXVpZCA9IG1vb2RVVUlERnJvbUJ1Y2tldHMoYnVja2V0cyk7XG4gICAgY29uc3QgcXVvdGUgPSBkZXRhaWwucXVvdGU7XG4gICAgY29uc3QgYmFzZSA9IGRldGFpbC5iYXNlO1xuICAgIGlmICghcXVvdGUgfHwgIWJhc2UpIGNvbnRpbnVlO1xuICAgIChvdXRbcXVvdGVdID8/PSB7fSlbYmFzZV0gPSB7XG4gICAgICBjb2VmZixcbiAgICAgIHV1aWQsXG4gICAgICBpbnB1dHM6IG5vcm1hbGl6ZWQsXG4gICAgICByYXc6IGRldGFpbCxcbiAgICB9O1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVNb29kU2lnbmFsc0Zyb21TdHJBdXgoXG4gIHN5bWJvbHM6IHN0cmluZ1tdLFxuICB3aW5kb3c6IFNhbXBsaW5nV2luZG93S2V5XG4pOiBQcm9taXNlPE1vb2RTaWduYWxzPiB7XG4gIGNvbnN0IHVuaXF1ZSA9IEFycmF5LmZyb20obmV3IFNldChzeW1ib2xzLm1hcCgocykgPT4gU3RyaW5nKHMgPz8gXCJcIikudG9VcHBlckNhc2UoKSkuZmlsdGVyKEJvb2xlYW4pKSk7XG4gIGlmICghdW5pcXVlLmxlbmd0aCkge1xuICAgIHJldHVybiB7IGdmbURlbHRhUGN0OiAwLCB0ZW5kZW5jeVJhdzogMCwgc3dhcFJhdzogMCwgc3ltYm9sczogW10sIHBlclN5bWJvbDogW10gfTtcbiAgfVxuICBjb25zdCBsaW1pdGVkID0gdW5pcXVlLnNsaWNlKDAsIE1BWF9NT09EX1NZTUJPTFMpO1xuICBjb25zdCByZXN1bHRzID0gYXdhaXQgY29tcHV0ZVNhbXBsZWRNZXRyaWNzKGxpbWl0ZWQsIHtcbiAgICB3aW5kb3csXG4gICAgYmluczogU1RSX01PT0RfQklOUyxcbiAgICBzdGF0czogREVGQVVMVF9NT09EX1NUQVRTLFxuICB9KTtcbiAgY29uc3QgZmFsbGJhY2tUYXJnZXRzOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGNvbnN0IHN5bWJvbCBvZiBsaW1pdGVkKSB7XG4gICAgY29uc3QgZW50cnkgPSByZXN1bHRzW3N5bWJvbF07XG4gICAgaWYgKCFlbnRyeSB8fCAhZW50cnkub2spIHtcbiAgICAgIGZhbGxiYWNrVGFyZ2V0cy5wdXNoKHN5bWJvbCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdGVuZGVuY3lTY29yZSA9IE51bWJlcihlbnRyeS5zdGF0cy52ZWN0b3JzPy50ZW5kZW5jeT8ubWV0cmljcz8uc2NvcmUpO1xuICAgIGNvbnN0IHN3YXBTY29yZSA9IE51bWJlcihlbnRyeS5zdGF0cy52ZWN0b3JzPy5zd2FwPy5zY29yZSk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodGVuZGVuY3lTY29yZSkgfHwgIU51bWJlci5pc0Zpbml0ZShzd2FwU2NvcmUpKSB7XG4gICAgICBmYWxsYmFja1RhcmdldHMucHVzaChzeW1ib2wpO1xuICAgIH1cbiAgfVxuICBjb25zdCBmYWxsYmFja01hcCA9IGZhbGxiYWNrVGFyZ2V0cy5sZW5ndGhcbiAgICA/IGF3YWl0IGZldGNoV2luZG93VmVjdG9yRmFsbGJhY2tzKGZhbGxiYWNrVGFyZ2V0cywgd2luZG93KVxuICAgIDoge307XG4gIGxldCBnZm1OdW0gPSAwO1xuICBsZXQgZ2ZtRGVuID0gMDtcbiAgbGV0IHRlbmROdW0gPSAwO1xuICBsZXQgdGVuZERlbiA9IDA7XG4gIGxldCBzd2FwTnVtID0gMDtcbiAgbGV0IHN3YXBEZW4gPSAwO1xuICBjb25zdCB1c2VkOiBzdHJpbmdbXSA9IFtdO1xuICBjb25zdCBwZXJTeW1ib2w6IFN5bWJvbE1vb2RTaWduYWxzW10gPSBbXTtcbiAgZm9yIChjb25zdCBzeW1ib2wgb2YgbGltaXRlZCkge1xuICAgIGNvbnN0IGVudHJ5ID0gcmVzdWx0c1tzeW1ib2xdO1xuICAgIGNvbnN0IGZhbGxiYWNrID0gZmFsbGJhY2tNYXBbc3ltYm9sXTtcbiAgICBpZiAoKCFlbnRyeSB8fCAhZW50cnkub2spICYmICFmYWxsYmFjaykgY29udGludWU7XG4gICAgY29uc3Qgd2VpZ2h0ID0gZW50cnkgJiYgZW50cnkub2tcbiAgICAgID8gTWF0aC5tYXgoMSwgTnVtYmVyKGVudHJ5Lm1ldGE/Lm4gPz8gMCkgfHwgMSlcbiAgICAgIDogTWF0aC5tYXgoMSwgTnVtYmVyKGZhbGxiYWNrPy53ZWlnaHQgPz8gMSkpO1xuICAgIGxldCB1c2VkU3ltYm9sID0gZmFsc2U7XG4gICAgY29uc3QgZ2ZtUGN0ID0gZW50cnkgJiYgZW50cnkub2sgPyBOdW1iZXIoZW50cnkuc3RhdHMuZGVsdGFHZm1QY3QpIDogTmFOO1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZ2ZtUGN0KSkge1xuICAgICAgZ2ZtTnVtICs9IChnZm1QY3QgLyAxMDApICogd2VpZ2h0O1xuICAgICAgZ2ZtRGVuICs9IHdlaWdodDtcbiAgICAgIHVzZWRTeW1ib2wgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgdGVuZGVuY3lTY29yZSA9IGVudHJ5ICYmIGVudHJ5Lm9rXG4gICAgICA/IE51bWJlcihlbnRyeS5zdGF0cy52ZWN0b3JzPy50ZW5kZW5jeT8ubWV0cmljcz8uc2NvcmUpXG4gICAgICA6IE5hTjtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh0ZW5kZW5jeVNjb3JlKSAmJiBmYWxsYmFjaykge1xuICAgICAgY29uc3QgZmJUZW5kZW5jeSA9IE51bWJlcihmYWxsYmFjay50ZW5kZW5jeSk7XG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGZiVGVuZGVuY3kpKSB0ZW5kZW5jeVNjb3JlID0gZmJUZW5kZW5jeTtcbiAgICB9XG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZSh0ZW5kZW5jeVNjb3JlKSkge1xuICAgICAgdGVuZE51bSArPSAodGVuZGVuY3lTY29yZSAvIDEwMCkgKiB3ZWlnaHQ7XG4gICAgICB0ZW5kRGVuICs9IHdlaWdodDtcbiAgICAgIHVzZWRTeW1ib2wgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgc3dhcFNjb3JlID0gZW50cnkgJiYgZW50cnkub2tcbiAgICAgID8gTnVtYmVyKGVudHJ5LnN0YXRzLnZlY3RvcnM/LnN3YXA/LnNjb3JlKVxuICAgICAgOiBOYU47XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoc3dhcFNjb3JlKSAmJiBmYWxsYmFjaykge1xuICAgICAgY29uc3QgZmJTd2FwID0gTnVtYmVyKGZhbGxiYWNrLnN3YXApO1xuICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShmYlN3YXApKSBzd2FwU2NvcmUgPSBmYlN3YXA7XG4gICAgfVxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc3dhcFNjb3JlKSkge1xuICAgICAgc3dhcE51bSArPSAoc3dhcFNjb3JlIC8gMTAwKSAqIHdlaWdodDtcbiAgICAgIHN3YXBEZW4gKz0gd2VpZ2h0O1xuICAgICAgdXNlZFN5bWJvbCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHBhaXIgPSBzcGxpdFN5bWJvbFBhaXIoc3ltYm9sKTtcbiAgICBpZiAocGFpciAmJiAoTnVtYmVyLmlzRmluaXRlKGdmbVBjdCkgfHwgTnVtYmVyLmlzRmluaXRlKHRlbmRlbmN5U2NvcmUpIHx8IE51bWJlci5pc0Zpbml0ZShzd2FwU2NvcmUpKSkge1xuICAgICAgcGVyU3ltYm9sLnB1c2goe1xuICAgICAgICBzeW1ib2wsXG4gICAgICAgIGJhc2U6IHBhaXIuYmFzZSxcbiAgICAgICAgcXVvdGU6IHBhaXIucXVvdGUsXG4gICAgICAgIHdlaWdodCxcbiAgICAgICAgZ2ZtRGVsdGFQY3Q6IE51bWJlci5pc0Zpbml0ZShnZm1QY3QpID8gZ2ZtUGN0IC8gMTAwIDogMCxcbiAgICAgICAgdGVuZGVuY3lSYXc6IE51bWJlci5pc0Zpbml0ZSh0ZW5kZW5jeVNjb3JlKSA/IHRlbmRlbmN5U2NvcmUgLyAxMDAgOiAwLFxuICAgICAgICBzd2FwUmF3OiBOdW1iZXIuaXNGaW5pdGUoc3dhcFNjb3JlKSA/IHN3YXBTY29yZSAvIDEwMCA6IDAsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHVzZWRTeW1ib2wpIHVzZWQucHVzaChzeW1ib2wpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2ZtRGVsdGFQY3Q6IGdmbURlbiA/IGdmbU51bSAvIGdmbURlbiA6IDAsXG4gICAgdGVuZGVuY3lSYXc6IHRlbmREZW4gPyB0ZW5kTnVtIC8gdGVuZERlbiA6IDAsXG4gICAgc3dhcFJhdzogc3dhcERlbiA/IHN3YXBOdW0gLyBzd2FwRGVuIDogMCxcbiAgICBzeW1ib2xzOiB1c2VkLFxuICAgIHBlclN5bWJvbCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVkdXBlQ29pbnMobGlzdDogQXJyYXk8c3RyaW5nPik6IHN0cmluZ1tdIHtcbiAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBjb25zdCBvdXQ6IHN0cmluZ1tdID0gW107XG4gIGZvciAoY29uc3QgaXRlbSBvZiBsaXN0KSB7XG4gICAgY29uc3Qgbm9ybSA9IG5vcm1hbGl6ZUNvaW5TeW1ib2woaXRlbSk7XG4gICAgaWYgKCFub3JtIHx8IHNlZW4uaGFzKG5vcm0pKSBjb250aW51ZTtcbiAgICBzZWVuLmFkZChub3JtKTtcbiAgICBvdXQucHVzaChub3JtKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBlbXB0eUJhbGFuY2VzKGNvaW5zOiBzdHJpbmdbXSk6IEJhbGFuY2VzTWFwIHtcbiAgY29uc3Qgb3V0OiBCYWxhbmNlc01hcCA9IHt9O1xuICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnMpIG91dFtjb2luXSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGNvaW5zRnJvbUdyaWQoZ3JpZDogSWRQY3RHcmlkKTogc3RyaW5nW10ge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgZm9yIChjb25zdCBiYXNlIG9mIE9iamVjdC5rZXlzKGdyaWQgPz8ge30pKSB7XG4gICAgaWYgKGJhc2UpIHNldC5hZGQoYmFzZSk7XG4gICAgY29uc3Qgcm93ID0gZ3JpZD8uW2Jhc2VdID8/IHt9O1xuICAgIGZvciAoY29uc3QgcXVvdGUgb2YgT2JqZWN0LmtleXMocm93KSkge1xuICAgICAgaWYgKHF1b3RlKSBzZXQuYWRkKHF1b3RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlSWRQY3RHcmlkKGdyaWQ6IElkUGN0R3JpZCwgY29pbnM6IHN0cmluZ1tdKTogSWRQY3RHcmlkIHtcbiAgZm9yIChjb25zdCBiYXNlIG9mIGNvaW5zKSB7XG4gICAgaWYgKCFncmlkW2Jhc2VdKSBncmlkW2Jhc2VdID0ge307XG4gICAgZm9yIChjb25zdCBxdW90ZSBvZiBjb2lucykge1xuICAgICAgaWYgKGJhc2UgPT09IHF1b3RlKSB7XG4gICAgICAgIGdyaWRbYmFzZV1bcXVvdGVdID0gbnVsbDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByYXcgPSBOdW1iZXIoZ3JpZFtiYXNlXVtxdW90ZV0pO1xuICAgICAgZ3JpZFtiYXNlXVtxdW90ZV0gPSBOdW1iZXIuaXNGaW5pdGUocmF3KSA/IHJhdyA6IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBncmlkO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlQ29pbnModXJsOiBVUkwpOiBQcm9taXNlPHsgY29pbnM6IHN0cmluZ1tdOyBzb3VyY2U6IHN0cmluZyB9PiB7XG4gIGNvbnN0IGNvaW5zUGFyYW0gPSB1cmwuc2VhcmNoUGFyYW1zLmdldChcImNvaW5zXCIpO1xuICBpZiAoY29pbnNQYXJhbSkge1xuICAgIGNvbnN0IHRva2VucyA9IGNvaW5zUGFyYW1cbiAgICAgIC5zcGxpdCgvWyxcXHNdKy8pXG4gICAgICAubWFwKCh0b2tlbikgPT4gdG9rZW4udHJpbSgpLnRvVXBwZXJDYXNlKCkpXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGNvbnN0IGNvaW5zID0gZGVkdXBlQ29pbnModG9rZW5zKTtcbiAgICBpZiAoY29pbnMubGVuZ3RoKSByZXR1cm4geyBjb2lucywgc291cmNlOiBcInF1ZXJ5XCIgfTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3Qgc2V0dGluZ3NDb2lucyA9IGF3YWl0IHJlc29sdmVDb2luc0Zyb21TZXR0aW5ncygpO1xuICAgIGNvbnN0IGNvaW5zID0gZGVkdXBlQ29pbnMoc2V0dGluZ3NDb2lucyk7XG4gICAgaWYgKGNvaW5zLmxlbmd0aCkgcmV0dXJuIHsgY29pbnMsIHNvdXJjZTogXCJzZXR0aW5nc1wiIH07XG4gIH0gY2F0Y2gge1xuICAgIC8vIGlnbm9yZSBwYXJzZSBlcnJvcnMgZnJvbSBjb29raWVzL3Nlc3Npb25cbiAgfVxuXG4gIHJldHVybiB7IGNvaW5zOiBbLi4uREVGQVVMVF9DT0lOU10sIHNvdXJjZTogXCJmYWxsYmFja1wiIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRCYWxhbmNlc0Zyb21MZWRnZXIoY29pbnM6IHN0cmluZ1tdKTogUHJvbWlzZTxCYWxhbmNlUmVhZFJlc3VsdD4ge1xuICBpZiAoIWNvaW5zLmxlbmd0aCkgcmV0dXJuIHsgYmFsYW5jZXM6IHt9LCBzb3VyY2U6IFwiZW1wdHlcIiB9O1xuXG4gIGNvbnN0IHRhcmdldHMgPSBjb2lucy5tYXAoKGNvaW4pID0+IGNvaW4udG9VcHBlckNhc2UoKSk7XG4gIGNvbnN0IHplcm9zID0gZW1wdHlCYWxhbmNlcyh0YXJnZXRzKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHsgcm93cyB9ID0gYXdhaXQgZGIucXVlcnk8eyBhc3NldDogc3RyaW5nOyBhbW91bnQ6IHN0cmluZyB8IG51bWJlciB9PihcbiAgICAgIGBTRUxFQ1QgYXNzZXQsIGFtb3VudFxuICAgICAgICAgRlJPTSB3YWxsZXRfYmFsYW5jZXNfbGF0ZXN0XG4gICAgICAgIFdIRVJFIGFzc2V0ID0gQU5ZKCQxOjp0ZXh0W10pYCxcbiAgICAgIFt0YXJnZXRzXSxcbiAgICApO1xuICAgIGlmIChyb3dzPy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGJhbGFuY2VzID0geyAuLi56ZXJvcyB9O1xuICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgICBjb25zdCBhc3NldCA9IG5vcm1hbGl6ZUNvaW5TeW1ib2wocm93LmFzc2V0KTtcbiAgICAgICAgaWYgKCFhc3NldCkgY29udGludWU7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IE51bWJlcihyb3cuYW1vdW50KTtcbiAgICAgICAgYmFsYW5jZXNbYXNzZXRdID0gTnVtYmVyLmlzRmluaXRlKGFtb3VudCkgPyBhbW91bnQgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgYmFsYW5jZXMsIHNvdXJjZTogXCJ3YWxsZXRfYmFsYW5jZXNfbGF0ZXN0XCIgfTtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIC8vIHByZWZlcnJlZCB2aWV3IG1heSBub3QgZXhpc3Q7IGZhbGwgdGhyb3VnaFxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IHJvd3MgfSA9IGF3YWl0IGRiLnF1ZXJ5PHsgYXNzZXQ6IHN0cmluZzsgYW1vdW50OiBzdHJpbmcgfCBudW1iZXIgfT4oXG4gICAgICBgU0VMRUNUIERJU1RJTkNUIE9OIChhc3NldCkgYXNzZXQsIGFtb3VudFxuICAgICAgICAgRlJPTSBiYWxhbmNlc1xuICAgICAgICBXSEVSRSBhc3NldCA9IEFOWSgkMTo6dGV4dFtdKVxuICAgICAgICBPUkRFUiBCWSBhc3NldCwgdHNfZXBvY2hfbXMgREVTQ2AsXG4gICAgICBbdGFyZ2V0c10sXG4gICAgKTtcbiAgICBpZiAocm93cz8ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBiYWxhbmNlcyA9IHsgLi4uemVyb3MgfTtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgY29uc3QgYXNzZXQgPSBub3JtYWxpemVDb2luU3ltYm9sKHJvdy5hc3NldCk7XG4gICAgICAgIGlmICghYXNzZXQpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBhbW91bnQgPSBOdW1iZXIocm93LmFtb3VudCk7XG4gICAgICAgIGJhbGFuY2VzW2Fzc2V0XSA9IE51bWJlci5pc0Zpbml0ZShhbW91bnQpID8gYW1vdW50IDogMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGJhbGFuY2VzLCBzb3VyY2U6IFwiYmFsYW5jZXNcIiB9O1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgLy8gb3B0aW9uYWwgaGlzdG9yaWNhbCB0YWJsZTsgZmFsbCB0aHJvdWdoXG4gIH1cblxuICByZXR1cm4geyBiYWxhbmNlczogemVyb3MsIHNvdXJjZTogXCJmYWxsYmFjazp6ZXJvXCIgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZElkUGN0R3JpZChjb2luczogc3RyaW5nW10sIHRzTXM6IG51bWJlcik6IFByb21pc2U8SWRQY3RSZWFkUmVzdWx0PiB7XG4gIGNvbnN0IHRhcmdldHMgPSBjb2lucy5tYXAoKGNvaW4pID0+IGNvaW4udG9VcHBlckNhc2UoKSk7XG4gIGNvbnN0IGJhc2VHcmlkOiBJZFBjdEdyaWQgPSB7fTtcbiAgZm9yIChjb25zdCBiYXNlIG9mIHRhcmdldHMpIHtcbiAgICBiYXNlR3JpZFtiYXNlXSA9IHt9O1xuICAgIGZvciAoY29uc3QgcXVvdGUgb2YgdGFyZ2V0cykgYmFzZUdyaWRbYmFzZV1bcXVvdGVdID0gYmFzZSA9PT0gcXVvdGUgPyBudWxsIDogMDtcbiAgfVxuXG4gIGlmICghdGFyZ2V0cy5sZW5ndGgpIHJldHVybiB7IGdyaWQ6IGJhc2VHcmlkLCBzb3VyY2U6IFwiZW1wdHlcIiB9O1xuXG4gIGNvbnN0IGFwcGx5SWRQY3RSb3dzID0gKHJvd3M6IEFycmF5PHsgYmFzZTogc3RyaW5nOyBxdW90ZTogc3RyaW5nOyB2YWx1ZTogbnVtYmVyIH0+LCBzb3VyY2U6IHN0cmluZykgPT4ge1xuICAgIGlmICghcm93cz8ubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICBjb25zdCBiYXNlID0gbm9ybWFsaXplQ29pblN5bWJvbChyb3cuYmFzZSk7XG4gICAgICBjb25zdCBxdW90ZSA9IG5vcm1hbGl6ZUNvaW5TeW1ib2wocm93LnF1b3RlKTtcbiAgICAgIGlmICghYmFzZSB8fCAhcXVvdGUgfHwgYmFzZSA9PT0gcXVvdGUpIGNvbnRpbnVlO1xuICAgICAgaWYgKCFiYXNlR3JpZFtiYXNlXSkgYmFzZUdyaWRbYmFzZV0gPSB7fTtcbiAgICAgIGNvbnN0IGlkcCA9IE51bWJlcihyb3cudmFsdWUpO1xuICAgICAgYmFzZUdyaWRbYmFzZV1bcXVvdGVdID0gTnVtYmVyLmlzRmluaXRlKGlkcCkgPyBpZHAgOiAwO1xuICAgIH1cbiAgICByZXR1cm4geyBncmlkOiBlbnN1cmVJZFBjdEdyaWQoYmFzZUdyaWQsIHRhcmdldHMpLCBzb3VyY2UgfTtcbiAgfTtcblxuICB0cnkge1xuICAgIGNvbnN0IG1hdHJpY2VzUGF5bG9hZCA9IGF3YWl0IGJ1aWxkTWF0cmljZXNMYXRlc3RQYXlsb2FkKHsgY29pbnM6IHRhcmdldHMgfSk7XG4gICAgaWYgKG1hdHJpY2VzUGF5bG9hZC5vaykge1xuICAgICAgY29uc3QgdmFsdWVzID0gbWF0cmljZXNQYXlsb2FkLm1hdHJpY2VzLmlkX3BjdD8udmFsdWVzID8/IHt9O1xuICAgICAgbGV0IHBvcHVsYXRlZCA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBiYXNlIG9mIHRhcmdldHMpIHtcbiAgICAgICAgY29uc3Qgcm93ID0gdmFsdWVzW2Jhc2VdID8/IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHF1b3RlIG9mIHRhcmdldHMpIHtcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gcXVvdGUpIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IG51bSA9IE51bWJlcihyb3c/LltxdW90ZV0pO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG51bSkpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICghYmFzZUdyaWRbYmFzZV0pIGJhc2VHcmlkW2Jhc2VdID0ge307XG4gICAgICAgICAgYmFzZUdyaWRbYmFzZV1bcXVvdGVdID0gbnVtO1xuICAgICAgICAgIHBvcHVsYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb3B1bGF0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgZ3JpZDogZW5zdXJlSWRQY3RHcmlkKGJhc2VHcmlkLCB0YXJnZXRzKSwgc291cmNlOiBcIm1hdHJpY2VzLmxhdGVzdFwiIH07XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgICAvLyBmYWxsIGJhY2sgdG8gREIgc291cmNlc1xuICB9XG5cbiAgaWYgKE51bWJlci5pc0Zpbml0ZSh0c01zKSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHJvd3MgfSA9IGF3YWl0IGRiLnF1ZXJ5PHsgYmFzZTogc3RyaW5nOyBxdW90ZTogc3RyaW5nOyB2YWx1ZTogbnVtYmVyIH0+KFxuICAgICAgICBgU0VMRUNUIERJU1RJTkNUIE9OIChiYXNlLCBxdW90ZSkgYmFzZSwgcXVvdGUsIHZhbHVlXG4gICAgICAgICAgIEZST00gbWF0cmljZXMuZHluX3ZhbHVlc1xuICAgICAgICAgIFdIRVJFIG1hdHJpeF90eXBlID0gJ2lkX3BjdCdcbiAgICAgICAgICAgIEFORCB0c19tcyA8PSAkMVxuICAgICAgICAgICAgQU5EIGJhc2UgPSBBTlkoJDI6OnRleHRbXSlcbiAgICAgICAgICAgIEFORCBxdW90ZSA9IEFOWSgkMjo6dGV4dFtdKVxuICAgICAgICAgIE9SREVSIEJZIGJhc2UsIHF1b3RlLCB0c19tcyBERVNDYCxcbiAgICAgICAgW3RzTXMsIHRhcmdldHNdLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGFwcGxpZWQgPSBhcHBseUlkUGN0Um93cyhyb3dzLCBcIm1hdHJpY2VzLmR5bl92YWx1ZXNcIik7XG4gICAgICBpZiAoYXBwbGllZCkgcmV0dXJuIGFwcGxpZWQ7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBmYWxsIGJhY2sgdG8gb3RoZXIgc291cmNlc1xuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyByb3dzIH0gPSBhd2FpdCBkYi5xdWVyeTx7IGJhc2U6IHN0cmluZzsgcXVvdGU6IHN0cmluZzsgdmFsdWU6IG51bWJlciB9PihcbiAgICAgIGBTRUxFQ1QgRElTVElOQ1QgT04gKGJhc2UsIHF1b3RlKSBiYXNlLCBxdW90ZSwgdmFsdWVcbiAgICAgICAgIEZST00gbWF0cmljZXMuZHluX3ZhbHVlc1xuICAgICAgICBXSEVSRSBtYXRyaXhfdHlwZSA9ICdpZF9wY3QnXG4gICAgICAgICAgQU5EIGJhc2UgPSBBTlkoJDE6OnRleHRbXSlcbiAgICAgICAgICBBTkQgcXVvdGUgPSBBTlkoJDE6OnRleHRbXSlcbiAgICAgICAgT1JERVIgQlkgYmFzZSwgcXVvdGUsIHRzX21zIERFU0NgLFxuICAgICAgW3RhcmdldHNdLFxuICAgICk7XG4gICAgY29uc3QgYXBwbGllZCA9IGFwcGx5SWRQY3RSb3dzKHJvd3MsIFwibWF0cmljZXMuZHluX3ZhbHVlc1wiKTtcbiAgICBpZiAoYXBwbGllZCkgcmV0dXJuIGFwcGxpZWQ7XG4gIH0gY2F0Y2gge1xuICAgIC8vIGNvbnRpbnVlIHdpdGggbGVnYWN5IGZhbGxiYWNrc1xuICB9XG5cbiAgaWYgKE51bWJlci5pc0Zpbml0ZSh0c01zKSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHJvd3MgfSA9IGF3YWl0IGRiLnF1ZXJ5PHsgYmFzZTogc3RyaW5nOyBxdW90ZTogc3RyaW5nOyBpZF9wY3Q6IG51bWJlciB9PihcbiAgICAgICAgYFNFTEVDVCBESVNUSU5DVCBPTiAoYmFzZSwgcXVvdGUpIGJhc2UsIHF1b3RlLCBpZF9wY3RcbiAgICAgICAgICAgRlJPTSBpZF9wY3RfcGFpcnNcbiAgICAgICAgICBXSEVSRSB0c19lcG9jaF9tcyA8PSAkMVxuICAgICAgICAgICAgQU5EIGJhc2UgPSBBTlkoJDI6OnRleHRbXSlcbiAgICAgICAgICAgIEFORCBxdW90ZSA9IEFOWSgkMjo6dGV4dFtdKVxuICAgICAgICAgIE9SREVSIEJZIGJhc2UsIHF1b3RlLCB0c19lcG9jaF9tcyBERVNDYCxcbiAgICAgICAgW3RzTXMsIHRhcmdldHNdLFxuICAgICAgKTtcbiAgICAgIGlmIChyb3dzPy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgICAgIGNvbnN0IGJhc2UgPSBub3JtYWxpemVDb2luU3ltYm9sKHJvdy5iYXNlKTtcbiAgICAgICAgICBjb25zdCBxdW90ZSA9IG5vcm1hbGl6ZUNvaW5TeW1ib2wocm93LnF1b3RlKTtcbiAgICAgICAgICBpZiAoIWJhc2UgfHwgIXF1b3RlIHx8IGJhc2UgPT09IHF1b3RlKSBjb250aW51ZTtcbiAgICAgICAgICBjb25zdCBpZHAgPSBOdW1iZXIocm93LmlkX3BjdCk7XG4gICAgICAgICAgaWYgKCFiYXNlR3JpZFtiYXNlXSkgYmFzZUdyaWRbYmFzZV0gPSB7fTtcbiAgICAgICAgICBiYXNlR3JpZFtiYXNlXVtxdW90ZV0gPSBOdW1iZXIuaXNGaW5pdGUoaWRwKSA/IGlkcCA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZ3JpZDogZW5zdXJlSWRQY3RHcmlkKGJhc2VHcmlkLCB0YXJnZXRzKSwgc291cmNlOiBcImlkX3BjdF9wYWlyc1wiIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBmYWxsIGJhY2sgdG8gbGF0ZXN0IHZpZXdcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgcm93cyB9ID0gYXdhaXQgZGIucXVlcnk8eyBiYXNlOiBzdHJpbmc7IHF1b3RlOiBzdHJpbmc7IGlkX3BjdDogbnVtYmVyIH0+KFxuICAgICAgYFNFTEVDVCBiYXNlLCBxdW90ZSwgaWRfcGN0XG4gICAgICAgICBGUk9NIGlkX3BjdF9sYXRlc3RcbiAgICAgICAgV0hFUkUgYmFzZSA9IEFOWSgkMTo6dGV4dFtdKVxuICAgICAgICAgIEFORCBxdW90ZSA9IEFOWSgkMTo6dGV4dFtdKWAsXG4gICAgICBbdGFyZ2V0c10sXG4gICAgKTtcbiAgICBpZiAocm93cz8ubGVuZ3RoKSB7XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBub3JtYWxpemVDb2luU3ltYm9sKHJvdy5iYXNlKTtcbiAgICAgICAgY29uc3QgcXVvdGUgPSBub3JtYWxpemVDb2luU3ltYm9sKHJvdy5xdW90ZSk7XG4gICAgICAgIGlmICghYmFzZSB8fCAhcXVvdGUgfHwgYmFzZSA9PT0gcXVvdGUpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBpZHAgPSBOdW1iZXIocm93LmlkX3BjdCk7XG4gICAgICAgIGlmICghYmFzZUdyaWRbYmFzZV0pIGJhc2VHcmlkW2Jhc2VdID0ge307XG4gICAgICAgIGJhc2VHcmlkW2Jhc2VdW3F1b3RlXSA9IE51bWJlci5pc0Zpbml0ZShpZHApID8gaWRwIDogMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGdyaWQ6IGVuc3VyZUlkUGN0R3JpZChiYXNlR3JpZCwgdGFyZ2V0cyksIHNvdXJjZTogXCJpZF9wY3RfbGF0ZXN0XCIgfTtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byBtZXRyaWNzIHRhYmxlXG4gIH1cblxuICBjb25zdCBtZXRyaWNLZXlzOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGNvbnN0IGJhc2Ugb2YgdGFyZ2V0cykge1xuICAgIGZvciAoY29uc3QgcXVvdGUgb2YgdGFyZ2V0cykge1xuICAgICAgaWYgKGJhc2UgPT09IHF1b3RlKSBjb250aW51ZTtcbiAgICAgIG1ldHJpY0tleXMucHVzaChgaWRfcGN0OiR7YmFzZX18JHtxdW90ZX1gKTtcbiAgICB9XG4gIH1cblxuICBpZiAobWV0cmljS2V5cy5sZW5ndGgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyByb3dzIH0gPSBhd2FpdCBkYi5xdWVyeTx7IG1ldHJpY19rZXk6IHN0cmluZzsgdmFsdWU6IG51bWJlciB9PihcbiAgICAgICAgYFNFTEVDVCBESVNUSU5DVCBPTiAobWV0cmljX2tleSkgbWV0cmljX2tleSwgdmFsdWVcbiAgICAgICAgICAgRlJPTSBtZXRyaWNzXG4gICAgICAgICAgV0hFUkUgbWV0cmljX2tleSA9IEFOWSgkMTo6dGV4dFtdKVxuICAgICAgICAgIE9SREVSIEJZIG1ldHJpY19rZXksIHRzX2Vwb2NoX21zIERFU0NgLFxuICAgICAgICBbbWV0cmljS2V5c10sXG4gICAgICApO1xuICAgICAgaWYgKHJvd3M/Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gU3RyaW5nKHJvdy5tZXRyaWNfa2V5ID8/IFwiXCIpO1xuICAgICAgICAgIGNvbnN0IFssIHBheWxvYWRdID0ga2V5LnNwbGl0KFwiaWRfcGN0OlwiKTtcbiAgICAgICAgICBpZiAoIXBheWxvYWQpIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IFtiYXNlUmF3LCBxdW90ZVJhd10gPSBwYXlsb2FkLnNwbGl0KFwifFwiKTtcbiAgICAgICAgICBjb25zdCBiYXNlID0gbm9ybWFsaXplQ29pblN5bWJvbChiYXNlUmF3KTtcbiAgICAgICAgICBjb25zdCBxdW90ZSA9IG5vcm1hbGl6ZUNvaW5TeW1ib2wocXVvdGVSYXcpO1xuICAgICAgICAgIGlmICghYmFzZSB8fCAhcXVvdGUgfHwgYmFzZSA9PT0gcXVvdGUpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICghYmFzZUdyaWRbYmFzZV0pIGJhc2VHcmlkW2Jhc2VdID0ge307XG4gICAgICAgICAgY29uc3QgaWRwID0gTnVtYmVyKHJvdy52YWx1ZSk7XG4gICAgICAgICAgYmFzZUdyaWRbYmFzZV1bcXVvdGVdID0gTnVtYmVyLmlzRmluaXRlKGlkcCkgPyBpZHAgOiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGdyaWQ6IGVuc3VyZUlkUGN0R3JpZChiYXNlR3JpZCwgdGFyZ2V0cyksIHNvdXJjZTogXCJtZXRyaWNzXCIgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIGlnbm9yZSBhbmQgZmFsbCBiYWNrIHRvIHplcm9zXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgZ3JpZDogZW5zdXJlSWRQY3RHcmlkKGJhc2VHcmlkLCB0YXJnZXRzKSwgc291cmNlOiBcImZhbGxiYWNrOnplcm9cIiB9O1xufVxuXG50eXBlIFZlY3RvckZhbGxiYWNrU3RhdHMgPSB7XG4gIHN5bWJvbDogc3RyaW5nO1xuICB0ZW5kZW5jeTogbnVtYmVyIHwgbnVsbDtcbiAgc3dhcDogbnVtYmVyIHwgbnVsbDtcbiAgd2VpZ2h0OiBudW1iZXI7XG59O1xuXG5hc3luYyBmdW5jdGlvbiBmZXRjaFdpbmRvd1ZlY3RvckZhbGxiYWNrcyhcbiAgc3ltYm9sczogc3RyaW5nW10sXG4gIHdpbmRvdzogU2FtcGxpbmdXaW5kb3dLZXlcbik6IFByb21pc2U8UmVjb3JkPHN0cmluZywgVmVjdG9yRmFsbGJhY2tTdGF0cz4+IHtcbiAgY29uc3QgdGFyZ2V0cyA9IEFycmF5LmZyb20oXG4gICAgbmV3IFNldChcbiAgICAgIHN5bWJvbHNcbiAgICAgICAgLm1hcCgoc3ltKSA9PiBub3JtYWxpemVDb2luU3ltYm9sKHN5bSkpXG4gICAgICAgIC5maWx0ZXIoKHN5bSk6IHN5bSBpcyBzdHJpbmcgPT4gQm9vbGVhbihzeW0pKVxuICAgIClcbiAgKTtcbiAgaWYgKCF0YXJnZXRzLmxlbmd0aCkgcmV0dXJuIHt9O1xuXG4gIHR5cGUgUm93ID0ge1xuICAgIHN5bWJvbDogc3RyaW5nO1xuICAgIHZfdGVuZF9jbG9zZTogbnVtYmVyIHwgbnVsbDtcbiAgICB2X3N3YXBfY2xvc2U6IG51bWJlciB8IG51bGw7XG4gICAgY3ljbGVzX2NvdW50OiBudW1iZXIgfCBudWxsO1xuICB9O1xuXG4gIHRyeSB7XG4gICAgY29uc3QgeyByb3dzIH0gPSBhd2FpdCBkYi5xdWVyeTxSb3c+KFxuICAgICAgYHNlbGVjdCBzeW1ib2wsIHZfdGVuZF9jbG9zZSwgdl9zd2FwX2Nsb3NlLCBjeWNsZXNfY291bnRcbiAgICAgICAgIGZyb20gc3RyX2F1eC52X2xhdGVzdF93aW5kb3dzXG4gICAgICAgIHdoZXJlIHdpbmRvd19sYWJlbCA9ICQxXG4gICAgICAgICAgYW5kIHN5bWJvbCA9IGFueSgkMjo6dGV4dFtdKWAsXG4gICAgICBbd2luZG93LCB0YXJnZXRzXVxuICAgICk7XG4gICAgY29uc3Qgb3V0OiBSZWNvcmQ8c3RyaW5nLCBWZWN0b3JGYWxsYmFja1N0YXRzPiA9IHt9O1xuICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MgPz8gW10pIHtcbiAgICAgIGNvbnN0IHN5bWJvbCA9IG5vcm1hbGl6ZUNvaW5TeW1ib2wocm93LnN5bWJvbCk7XG4gICAgICBpZiAoIXN5bWJvbCkgY29udGludWU7XG4gICAgICBvdXRbc3ltYm9sXSA9IHtcbiAgICAgICAgc3ltYm9sLFxuICAgICAgICB0ZW5kZW5jeTogdG9OdW0ocm93LnZfdGVuZF9jbG9zZSksXG4gICAgICAgIHN3YXA6IHRvTnVtKHJvdy52X3N3YXBfY2xvc2UpLFxuICAgICAgICB3ZWlnaHQ6IE1hdGgubWF4KDEsIE51bWJlcihyb3cuY3ljbGVzX2NvdW50KSB8fCAxKSxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsImRiIiwiYnVpbGRNZWFBdXgiLCJzYXZlTW9vZE9ic2VydmF0aW9uIiwiREVGQVVMVF9USUVSX1JVTEVTIiwicmVzb2x2ZVBhaXJBdmFpbGFiaWxpdHkiLCJtYXNrVW5hdmFpbGFibGVNYXRyaXgiLCJyZXNvbHZlQ29pbnNGcm9tU2V0dGluZ3MiLCJjb21wdXRlU2FtcGxlZE1ldHJpY3MiLCJidWlsZE1hdHJpY2VzTGF0ZXN0UGF5bG9hZCIsIm5vcm1hbGl6ZU1vb2RJbnB1dHMiLCJjb21wdXRlTW9vZENvZWZmVjEiLCJtb29kVVVJREZyb21CdWNrZXRzIiwiZHluYW1pYyIsInJldmFsaWRhdGUiLCJDQUNIRV9IRUFERVJTIiwiREVGQVVMVF9DT0lOUyIsIkRFRkFVTFRfQVBQX1NFU1NJT04iLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBQX1NFU1NJT05fSUQiLCJTVFJfTU9PRF9XSU5ET1ciLCJNT09fQVVYX1NUUl9XSU5ET1ciLCJTVFJfTU9PRF9CSU5TIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJNT09fQVVYX1NUUl9CSU5TIiwiTWF0aCIsIm1heCIsImZsb29yIiwiTUFYX01PT0RfU1lNQk9MUyIsIk1PT19BVVhfU1lNQk9MX0xJTUlUIiwiREVGQVVMVF9NT09EX1NUQVRTIiwiaWRociIsImFscGhhIiwic01pbiIsInNtb290aCIsInRvcEsiLCJlcHNHZm1QY3QiLCJlcHNCZm1QY3QiLCJ2U2NhbGUiLCJ0ZW5kZW5jeVdpbiIsInRlbmRlbmN5Tm9ybSIsInN3YXBBbHBoYSIsIkdFVCIsInJlcSIsInVybCIsIlVSTCIsImFwcFNlc3Npb25JZCIsInNlYXJjaFBhcmFtcyIsImdldCIsInNsaWNlIiwidHNQYXJhbSIsInRzTXMiLCJEYXRlIiwibm93IiwiY29pbnMiLCJpbml0aWFsQ29pbnMiLCJzb3VyY2UiLCJjb2luc1NvdXJjZSIsInJlc29sdmVDb2lucyIsImdyaWQiLCJpZFBjdEdyaWRSYXciLCJpZFBjdFNvdXJjZSIsInJlYWRJZFBjdEdyaWQiLCJkZWR1cGVkQ29pbnMiLCJkZWR1cGVDb2lucyIsImNvaW5zRnJvbUdyaWQiLCJsZW5ndGgiLCJqc29uIiwib2siLCJrIiwiaGVhZGVycyIsImluY2x1ZGVzIiwiYXZhaWxhYmlsaXR5IiwiYWxsb3dlZFN5bWJvbHMiLCJzZXQiLCJtb29kU3ltYm9scyIsImRlcml2ZU1vb2RTeW1ib2xzIiwiaWRQY3RHcmlkIiwiZW5zdXJlSWRQY3RHcmlkIiwiYmFsYW5jZXMiLCJiYWxhbmNlU291cmNlIiwicmVhZEJhbGFuY2VzRnJvbUxlZGdlciIsImtQYXJhbSIsImRpdmlzb3IiLCJxX2dmbURlbHRhUGN0IiwidG9OdW0iLCJxX3RlbmRlbmN5UmF3IiwicV9zd2FwUmF3IiwicmVmcyIsImdmbVNjYWxlIiwidnRNdSIsInZ0U2lnbWEiLCJ2c011IiwidnNTaWdtYSIsInZzQWxwaGEiLCJoYXZlUmF3IiwibWFudWFsU2lnbmFscyIsImdmbURlbHRhUGN0IiwidGVuZGVuY3lSYXciLCJzd2FwUmF3IiwiZGVyaXZlZFNpZ25hbHMiLCJjb21wdXRlTW9vZFNpZ25hbHNGcm9tU3RyQXV4IiwiY2F0Y2giLCJzeW1ib2xzIiwibW9vZFJhd0Rlc2NyaXB0b3IiLCJzaWduYWxzIiwicGVyU3ltYm9sIiwibW9vZElucHV0cyIsImNvZWZmIiwibW9vZENvZWZmIiwiYnVja2V0cyIsIm1vb2RVVUlEIiwicGVyU3ltYm9sTW9vZCIsImJ1aWxkUGVyU3ltYm9sTW9vZCIsImlkUGN0IiwicnVsZXMiLCJvYnNlcnZhdGlvblBheWxvYWQiLCJpbnB1dHMiLCJlcnIiLCJjb25zb2xlIiwid2FybiIsInNpemUiLCJ0c19tcyIsImlkX3BjdCIsIm1vb2QiLCJ1dWlkIiwicmF3Iiwic291cmNlcyIsInBhaXJzIiwibWVzc2FnZSIsIkVycm9yIiwiU3RyaW5nIiwiZXJyb3IiLCJzdGF0dXMiLCJ4IiwibiIsIm5vcm1hbGl6ZUNvaW5TeW1ib2wiLCJ0cmltbWVkIiwidHJpbSIsInRvVXBwZXJDYXNlIiwic3BsaXRTeW1ib2xQYWlyIiwic3ltYm9sIiwidXBwZXIiLCJjb21tb25zIiwicXVvdGUiLCJlbmRzV2l0aCIsImJhc2UiLCJhbGxvd2VkIiwibm9ybWFsaXplZCIsIkFycmF5IiwiZnJvbSIsIlNldCIsIm1hcCIsImNvaW4iLCJmaWx0ZXIiLCJjIiwiQm9vbGVhbiIsImRlc2lyZWQiLCJwcmVmZXJyZWQiLCJoYXMiLCJwdXNoIiwidW5pcXVlIiwicyIsImRldGFpbHMiLCJvdXQiLCJkZXRhaWwiLCJ3aW5kb3ciLCJsaW1pdGVkIiwicmVzdWx0cyIsImJpbnMiLCJzdGF0cyIsImZhbGxiYWNrVGFyZ2V0cyIsImVudHJ5IiwidGVuZGVuY3lTY29yZSIsInZlY3RvcnMiLCJ0ZW5kZW5jeSIsIm1ldHJpY3MiLCJzY29yZSIsInN3YXBTY29yZSIsInN3YXAiLCJmYWxsYmFja01hcCIsImZldGNoV2luZG93VmVjdG9yRmFsbGJhY2tzIiwiZ2ZtTnVtIiwiZ2ZtRGVuIiwidGVuZE51bSIsInRlbmREZW4iLCJzd2FwTnVtIiwic3dhcERlbiIsInVzZWQiLCJmYWxsYmFjayIsIndlaWdodCIsIm1ldGEiLCJ1c2VkU3ltYm9sIiwiZ2ZtUGN0IiwiZGVsdGFHZm1QY3QiLCJOYU4iLCJmYlRlbmRlbmN5IiwiZmJTd2FwIiwicGFpciIsImxpc3QiLCJzZWVuIiwiaXRlbSIsIm5vcm0iLCJhZGQiLCJlbXB0eUJhbGFuY2VzIiwiT2JqZWN0Iiwia2V5cyIsInJvdyIsImNvaW5zUGFyYW0iLCJ0b2tlbnMiLCJzcGxpdCIsInRva2VuIiwic2V0dGluZ3NDb2lucyIsInRhcmdldHMiLCJ6ZXJvcyIsInJvd3MiLCJxdWVyeSIsImFzc2V0IiwiYW1vdW50IiwiYmFzZUdyaWQiLCJhcHBseUlkUGN0Um93cyIsImlkcCIsInZhbHVlIiwibWF0cmljZXNQYXlsb2FkIiwidmFsdWVzIiwibWF0cmljZXMiLCJwb3B1bGF0ZWQiLCJudW0iLCJhcHBsaWVkIiwibWV0cmljS2V5cyIsImtleSIsIm1ldHJpY19rZXkiLCJwYXlsb2FkIiwiYmFzZVJhdyIsInF1b3RlUmF3Iiwic3ltIiwidl90ZW5kX2Nsb3NlIiwidl9zd2FwX2Nsb3NlIiwiY3ljbGVzX2NvdW50Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/moo-aux/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/db/db.ts":
/*!***************************!*\
  !*** ./src/core/db/db.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearOpeningCache: () => (/* binding */ clearOpeningCache),\n/* harmony export */   commitMatrixGrid: () => (/* binding */ commitMatrixGrid),\n/* harmony export */   countRowsAt: () => (/* binding */ countRowsAt),\n/* harmony export */   db: () => (/* reexport safe */ _pool_server__WEBPACK_IMPORTED_MODULE_0__.db),\n/* harmony export */   ensureOpening: () => (/* binding */ ensureOpening),\n/* harmony export */   getLatestByType: () => (/* binding */ getLatestByType),\n/* harmony export */   getLatestTsForType: () => (/* binding */ getLatestTsForType),\n/* harmony export */   getMatrixStageTableIdent: () => (/* binding */ getMatrixStageTableIdent),\n/* harmony export */   getNearestTsAtOrBefore: () => (/* binding */ getNearestTsAtOrBefore),\n/* harmony export */   getOpeningFromDb: () => (/* binding */ getOpeningFromDb),\n/* harmony export */   getPool: () => (/* reexport safe */ _pool_server__WEBPACK_IMPORTED_MODULE_0__.getPool),\n/* harmony export */   getPrevSnapshotByType: () => (/* binding */ getPrevSnapshotByType),\n/* harmony export */   getPrevValue: () => (/* binding */ getPrevValue),\n/* harmony export */   getSnapshotByType: () => (/* binding */ getSnapshotByType),\n/* harmony export */   persistLiveMatricesSlice: () => (/* binding */ persistLiveMatricesSlice),\n/* harmony export */   query: () => (/* reexport safe */ _pool_server__WEBPACK_IMPORTED_MODULE_0__.query),\n/* harmony export */   runDbTool: () => (/* binding */ runDbTool),\n/* harmony export */   stageMatrixGrid: () => (/* binding */ stageMatrixGrid),\n/* harmony export */   upsertMatrixRows: () => (/* binding */ upsertMatrixRows),\n/* harmony export */   withClient: () => (/* reexport safe */ _pool_server__WEBPACK_IMPORTED_MODULE_0__.withClient)\n/* harmony export */ });\n/* harmony import */ var _pool_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pool_server */ \"(rsc)/./src/core/db/pool_server.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pool_server__WEBPACK_IMPORTED_MODULE_0__]);\n_pool_server__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n// src/core/db/db.ts\n\n\n/** ------- Dynamics matrices (kept signatures) ------- */ // Optional env override; defaults to our canonical table\nconst RAW_TABLE = process.env.MATRIX_TABLE || \"matrices.dyn_values\";\n// Prevent SQL injection on identifier\nfunction asIdent(name) {\n    const parts = String(name).split(\".\").filter(Boolean);\n    if (!parts.length) throw new Error(`Invalid table identifier: ${name}`);\n    return parts.map((part)=>{\n        if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(part)) {\n            throw new Error(`Invalid table identifier: ${name}`);\n        }\n        return `\"${part}\"`;\n    }).join(\".\");\n}\nconst TABLE = asIdent(RAW_TABLE);\nconst RAW_STAGE_TABLE = process.env.MATRIX_STAGE_TABLE || \"matrices.dyn_values_stage\";\nconst RAW_COMMIT_TABLE = process.env.MATRIX_COMMIT_TABLE || process.env.MATRIX_TABLE || \"matrices.dyn_values\";\nconst STAGE_TABLE_CANDIDATES = Array.from(new Set([\n    process.env.MATRIX_STAGE_TABLE,\n    \"matrices.dyn_values_stage\",\n    \"public.dyn_matrix_values_stage\"\n].filter(Boolean)));\nconst MATRIX_TABLE_CANDIDATES = Array.from(new Set([\n    process.env.MATRIX_COMMIT_TABLE,\n    process.env.MATRIX_TABLE,\n    \"matrices.dyn_values\",\n    \"public.dyn_matrix_values\"\n].filter(Boolean)));\nfunction splitQualifiedName(name) {\n    const parts = String(name).split(\".\");\n    if (parts.length === 1) return {\n        schema: \"public\",\n        relation: parts[0]\n    };\n    const relation = parts.pop();\n    return {\n        schema: parts.join(\".\"),\n        relation\n    };\n}\nasync function ensureMatrixTables(client) {\n    await client.query(`CREATE SCHEMA IF NOT EXISTS matrices`);\n    await client.query(`\n    DO $$\n    BEGIN\n      IF EXISTS (\n        SELECT 1\n        FROM pg_class c\n        JOIN pg_namespace n ON n.oid = c.relnamespace\n        WHERE n.nspname = 'matrices'\n          AND c.relname = 'dyn_values'\n          AND c.relkind IN ('v','m')\n      ) THEN\n        EXECUTE 'DROP VIEW IF EXISTS matrices.dyn_values CASCADE';\n      END IF;\n      IF EXISTS (\n        SELECT 1\n        FROM pg_class c\n        JOIN pg_namespace n ON n.oid = c.relnamespace\n        WHERE n.nspname = 'matrices'\n          AND c.relname = 'dyn_values_stage'\n          AND c.relkind IN ('v','m')\n      ) THEN\n        EXECUTE 'DROP VIEW IF EXISTS matrices.dyn_values_stage CASCADE';\n      END IF;\n    END\n    $$;\n  `);\n    await client.query(`\n    CREATE TABLE IF NOT EXISTS matrices.dyn_values (\n      ts_ms        bigint           NOT NULL,\n      matrix_type  text             NOT NULL CHECK (matrix_type IN ('benchmark','delta','pct24h','id_pct','pct_drv','ref','pct_ref')),\n      base         text             NOT NULL,\n      quote        text             NOT NULL,\n      value        double precision NOT NULL,\n      meta         jsonb            NOT NULL DEFAULT '{}'::jsonb,\n      created_at   timestamptz      NOT NULL DEFAULT now(),\n      PRIMARY KEY (ts_ms, matrix_type, base, quote)\n    )\n  `);\n    await client.query(`\n    CREATE INDEX IF NOT EXISTS idx_matrices_dyn_values_pair\n      ON matrices.dyn_values (matrix_type, base, quote, ts_ms DESC)\n  `);\n    await client.query(`\n    CREATE TABLE IF NOT EXISTS matrices.dyn_values_stage (\n      ts_ms         bigint           NOT NULL,\n      matrix_type   text             NOT NULL,\n      base          text             NOT NULL,\n      quote         text             NOT NULL,\n      value         double precision NOT NULL,\n      meta          jsonb            NOT NULL DEFAULT '{}'::jsonb,\n      app_session_id text,\n      created_at    timestamptz      NOT NULL DEFAULT now(),\n      PRIMARY KEY (ts_ms, matrix_type, base, quote)\n    )\n  `);\n}\nasync function findExistingTable(client, candidates) {\n    for (const raw of candidates){\n        const { schema, relation } = splitQualifiedName(raw);\n        const { rows } = await client.query(`\n        SELECT c.relkind AS kind\n          FROM pg_class c\n          JOIN pg_namespace n ON n.oid = c.relnamespace\n         WHERE n.nspname = $1 AND c.relname = $2\n      `, [\n            schema,\n            relation\n        ]);\n        const kind = rows[0]?.kind;\n        if (kind && (kind === \"r\" || kind === \"p\")) {\n            return {\n                raw,\n                ident: asIdent(raw),\n                kind\n            };\n        }\n    }\n    return null;\n}\nlet cachedStageInfo = null;\nlet cachedMatrixInfo = null;\nasync function ensureStageInfo(client) {\n    if (cachedStageInfo) return cachedStageInfo;\n    let info = await findExistingTable(client, [\n        RAW_STAGE_TABLE,\n        ...STAGE_TABLE_CANDIDATES\n    ]) ?? await findExistingTable(client, STAGE_TABLE_CANDIDATES);\n    if (!info) {\n        await ensureMatrixTables(client);\n        info = await findExistingTable(client, [\n            RAW_STAGE_TABLE,\n            ...STAGE_TABLE_CANDIDATES\n        ]) ?? await findExistingTable(client, STAGE_TABLE_CANDIDATES);\n        if (!info) {\n            throw new Error(`Matrix stage table not found. Checked: ${[\n                RAW_STAGE_TABLE,\n                ...STAGE_TABLE_CANDIDATES\n            ].filter(Boolean).join(\", \")}`);\n        }\n    }\n    cachedStageInfo = info;\n    return info;\n}\nasync function ensureMatrixInfo(client) {\n    if (cachedMatrixInfo) return cachedMatrixInfo;\n    let info = await findExistingTable(client, [\n        RAW_COMMIT_TABLE,\n        ...MATRIX_TABLE_CANDIDATES\n    ]) ?? await findExistingTable(client, MATRIX_TABLE_CANDIDATES);\n    if (!info) {\n        await ensureMatrixTables(client);\n        info = await findExistingTable(client, [\n            RAW_COMMIT_TABLE,\n            ...MATRIX_TABLE_CANDIDATES\n        ]) ?? await findExistingTable(client, MATRIX_TABLE_CANDIDATES);\n        if (!info) {\n            throw new Error(`Matrix values table not found. Checked: ${[\n                RAW_COMMIT_TABLE,\n                ...MATRIX_TABLE_CANDIDATES\n            ].filter(Boolean).join(\", \")}`);\n        }\n    }\n    if (!info) {\n        throw new Error(`Matrix values table not found. Checked: ${[\n            RAW_COMMIT_TABLE,\n            ...MATRIX_TABLE_CANDIDATES\n        ].filter(Boolean).join(\", \")}`);\n    }\n    cachedMatrixInfo = info;\n    return info;\n}\nfunction dedupeUpper(xs) {\n    if (!xs?.length) return [];\n    const out = [];\n    const seen = new Set();\n    for (const x of xs){\n        const up = String(x ?? \"\").trim().toUpperCase();\n        if (!up || seen.has(up)) continue;\n        seen.add(up);\n        out.push(up);\n    }\n    return out;\n}\nasync function getMatrixStageTableIdent(client) {\n    if (cachedStageInfo) return cachedStageInfo.ident;\n    const useClient = client ?? await _pool_server__WEBPACK_IMPORTED_MODULE_0__.db.connect();\n    const release = !client;\n    try {\n        const info = await ensureStageInfo(useClient);\n        return info.ident;\n    } finally{\n        if (release) useClient.release();\n    }\n}\nasync function getMatrixValuesTableIdent(client) {\n    const info = await ensureMatrixInfo(client);\n    return info.ident;\n}\n/** Bulk upsert directly into main table (bypasses stage/commit) */ async function upsertMatrixRows(rows) {\n    if (!rows.length) return;\n    const client = await _pool_server__WEBPACK_IMPORTED_MODULE_0__.db.connect();\n    try {\n        const values = [];\n        const chunks = rows.map((r, i)=>{\n            const j = i * 6;\n            values.push(r.ts_ms, r.matrix_type, r.base, r.quote, r.value, JSON.stringify(r.meta ?? {}));\n            return `($${j + 1}, $${j + 2}, $${j + 3}, $${j + 4}, $${j + 5}, $${j + 6})`;\n        }).join(\",\");\n        const sql = `\n      INSERT INTO ${TABLE} (ts_ms, matrix_type, base, quote, value, meta)\n      VALUES ${chunks}\n      ON CONFLICT (ts_ms, matrix_type, base, quote)\n      DO UPDATE SET value = EXCLUDED.value, meta = EXCLUDED.meta;\n    `;\n        await client.query(sql, values);\n    } finally{\n        client.release();\n    }\n}\n/** Snapshots & lookups */ async function getLatestByType(matrix_type, coins) {\n    const client = await _pool_server__WEBPACK_IMPORTED_MODULE_0__.db.connect();\n    try {\n        const { rows } = await client.query(`SELECT ts_ms FROM ${TABLE} WHERE matrix_type=$1 ORDER BY ts_ms DESC LIMIT 1`, [\n            matrix_type\n        ]);\n        if (!rows.length) return {\n            ts_ms: null,\n            values: []\n        };\n        const ts_ms = Number(rows[0].ts_ms);\n        const { rows: vals } = await client.query(`SELECT base, quote, value FROM ${TABLE}\n       WHERE matrix_type=$1 AND ts_ms=$2 AND base = ANY($3) AND quote = ANY($3)`, [\n            matrix_type,\n            ts_ms,\n            coins\n        ]);\n        return {\n            ts_ms,\n            values: vals\n        };\n    } finally{\n        client.release();\n    }\n}\nasync function getPrevValue(matrix_type, base, quote, beforeTs) {\n    const { rows } = await _pool_server__WEBPACK_IMPORTED_MODULE_0__.db.query(`SELECT value FROM ${TABLE}\n     WHERE matrix_type=$1 AND base=$2 AND quote=$3 AND ts_ms < $4\n     ORDER BY ts_ms DESC LIMIT 1`, [\n        matrix_type,\n        base,\n        quote,\n        beforeTs\n    ]);\n    return rows.length ? Number(rows[0].value) : null;\n}\nasync function getLatestTsForType(matrix_type) {\n    const { rows } = await _pool_server__WEBPACK_IMPORTED_MODULE_0__.db.query(`SELECT MAX(ts_ms) AS ts_ms FROM ${TABLE} WHERE matrix_type=$1`, [\n        matrix_type\n    ]);\n    const v = rows[0]?.ts_ms;\n    return v == null ? null : Number(v);\n}\nasync function getNearestTsAtOrBefore(matrix_type, ts_ms) {\n    const { rows } = await _pool_server__WEBPACK_IMPORTED_MODULE_0__.db.query(`SELECT ts_ms FROM ${TABLE}\n     WHERE matrix_type=$1 AND ts_ms <= $2\n     ORDER BY ts_ms DESC LIMIT 1`, [\n        matrix_type,\n        ts_ms\n    ]);\n    const v = rows[0]?.ts_ms;\n    return v == null ? null : Number(v);\n}\nasync function getSnapshotByType(matrix_type, ts_ms, coins) {\n    const { rows } = await _pool_server__WEBPACK_IMPORTED_MODULE_0__.db.query(`SELECT base, quote, value FROM ${TABLE}\n     WHERE matrix_type=$1 AND ts_ms=$2 AND base = ANY($3) AND quote = ANY($3)`, [\n        matrix_type,\n        ts_ms,\n        coins\n    ]);\n    return rows;\n}\nasync function getPrevSnapshotByType(matrix_type, beforeTs, coins) {\n    const { rows } = await _pool_server__WEBPACK_IMPORTED_MODULE_0__.db.query(`SELECT DISTINCT ON (base, quote) base, quote, value\n       FROM ${TABLE}\n      WHERE matrix_type=$1\n        AND ts_ms < $2\n        AND base  = ANY($3)\n        AND quote = ANY($3)\n   ORDER BY base, quote, ts_ms DESC`, [\n        matrix_type,\n        beforeTs,\n        coins\n    ]);\n    return rows;\n}\nasync function countRowsAt(matrix_type, ts_ms) {\n    const { rows } = await _pool_server__WEBPACK_IMPORTED_MODULE_0__.db.query(`SELECT count(*)::int AS n FROM ${TABLE} WHERE matrix_type=$1 AND ts_ms=$2`, [\n        matrix_type,\n        ts_ms\n    ]);\n    return rows[0]?.n ?? 0;\n}\nconst openingCache = new Map();\nconst keyStr = (k)=>`${k.base}:${k.quote ?? \"USDT\"}:${k.window ?? \"1h\"}:${k.appSessionId ?? \"global\"}`;\n/** Read last opening for a (base,quote,window,session) from STR-AUX; fallback to compat view */ async function getOpeningFromDb(k) {\n    // Source of truth: strategy_aux.str_aux_session with opening_stamp = TRUE\n    const q1 = `\n    SELECT opening_ts AS ts, opening_price AS price\n      FROM strategy_aux.str_aux_session\n     WHERE pair_base=$1 AND pair_quote=$2 AND window_key=$3\n       AND ($4::text IS NULL OR app_session_id=$4)\n       AND opening_stamp = TRUE\n  ORDER BY opening_ts DESC\n     LIMIT 1\n  `;\n    const r1 = await _pool_server__WEBPACK_IMPORTED_MODULE_0__.db.query(q1, [\n        k.base,\n        k.quote ?? \"USDT\",\n        k.window ?? \"1h\",\n        k.appSessionId ?? null\n    ]);\n    if (r1.rows.length) {\n        return {\n            price: Number(r1.rows[0].price),\n            ts: Number(r1.rows[0].ts)\n        };\n    }\n    // Compatibility view (kept for older code paths)\n    const q2 = `SELECT session_ts AS ts, opening_price AS price\n                FROM session_openings\n            ORDER BY session_ts DESC\n               LIMIT 1`;\n    const r2 = await _pool_server__WEBPACK_IMPORTED_MODULE_0__.db.query(q2);\n    if (r2.rows.length) {\n        return {\n            price: Number(r2.rows[0].price),\n            ts: Number(r2.rows[0].ts)\n        };\n    }\n    return null;\n}\n/**\r\n * Ensure an opening exists + cache it for this process.\r\n * If you pass openingTs/openingPrice, we try to upsert via the SQL function `upsert_str_aux_opening` (if present).\r\n */ async function ensureOpening(k, opts = {}) {\n    const ck = keyStr(k);\n    const hit = openingCache.get(ck);\n    if (hit) return hit;\n    // If given explicit opening, try to persist (no-op if the function doesn't exist).\n    if (opts.openingPrice != null && opts.openingTs != null) {\n        try {\n            await _pool_server__WEBPACK_IMPORTED_MODULE_0__.db.query(`SELECT upsert_str_aux_opening($1,$2,$3,$4,$5,$6,$7)`, [\n                k.base,\n                k.quote ?? \"USDT\",\n                k.window ?? \"1h\",\n                k.appSessionId ?? \"global\",\n                opts.openingTs,\n                opts.openingPrice,\n                `idem:${k.base}:${k.quote ?? \"USDT\"}:${k.window ?? \"1h\"}:${k.appSessionId ?? \"global\"}:${opts.openingTs}`\n            ]);\n        } catch  {}\n    }\n    const row = await getOpeningFromDb(k);\n    if (row) {\n        openingCache.set(ck, row);\n        return row;\n    }\n    return null;\n}\nfunction clearOpeningCache(k) {\n    if (!k) return openingCache.clear();\n    openingCache.delete(keyStr(k));\n}\n/** Internal: iterate off-diagonal cells that have finite numbers */ function* cellsOf(coins, values) {\n    for (const b of coins){\n        for (const q of coins){\n            if (b === q) continue;\n            const v = values?.[b]?.[q];\n            if (v == null || Number.isNaN(Number(v))) continue;\n            yield {\n                base: b,\n                quote: q,\n                value: Number(v)\n            };\n        }\n    }\n}\n/** Stage all cells for a (matrix_type, ts_ms). Overwrites on conflict in STAGE. */ async function stageMatrixGrid(opts) {\n    const { appSessionId, matrixType, tsMs, coins, values, meta, client: external } = opts;\n    const client = external ?? await _pool_server__WEBPACK_IMPORTED_MODULE_0__.db.connect();\n    const release = !external;\n    try {\n        const rows = Array.from(cellsOf(coins, values));\n        if (!rows.length) return {\n            ok: true,\n            staged: 0\n        };\n        const metaJson = JSON.stringify(meta ?? {});\n        const stageInfo = await ensureStageInfo(client);\n        const text = `\n      INSERT INTO ${stageInfo.ident}\n        (ts_ms, matrix_type, base, quote, value, meta, app_session_id)\n      VALUES ${rows.map((_, i)=>`($1,$2,$${i * 3 + 3},$${i * 3 + 4},$${i * 3 + 5},$${rows.length * 3 + 3},$${rows.length * 3 + 4})`).join(\",\")}\n      ON CONFLICT (ts_ms, matrix_type, base, quote)\n      DO UPDATE SET value = EXCLUDED.value, meta = EXCLUDED.meta, app_session_id = EXCLUDED.app_session_id\n    `;\n        const params = [\n            tsMs,\n            matrixType\n        ];\n        for (const r of rows)params.push(r.base, r.quote, r.value);\n        params.push(metaJson, appSessionId);\n        await client.query(text, params);\n        return {\n            ok: true,\n            staged: rows.length\n        };\n    } finally{\n        if (release) client.release();\n    }\n}\n/** Publish staged rows into main table + cycle_document + ledger (see DDL) */ async function commitMatrixGrid(opts) {\n    const { matrixType, tsMs, coins, client: external } = opts;\n    const client = external ?? await _pool_server__WEBPACK_IMPORTED_MODULE_0__.db.connect();\n    const release = !external;\n    const manageTx = !external;\n    try {\n        if (manageTx) await client.query(\"BEGIN\");\n        const stageInfo = await ensureStageInfo(client);\n        const matrixTable = await getMatrixValuesTableIdent(client);\n        const stageRows = await client.query(`SELECT base, quote\n         FROM ${stageInfo.ident}\n        WHERE ts_ms = $1 AND matrix_type = $2`, [\n            tsMs,\n            matrixType\n        ]);\n        const stagedCells = stageRows.rowCount ?? stageRows.rows.length;\n        const coinsFromStage = new Set();\n        for (const row of stageRows.rows){\n            const base = String(row.base ?? \"\").toUpperCase();\n            const quote = String(row.quote ?? \"\").toUpperCase();\n            if (base) coinsFromStage.add(base);\n            if (quote) coinsFromStage.add(quote);\n        }\n        const eligibleCoins = coins?.length && dedupeUpper(coins).length ? dedupeUpper(coins) : Array.from(coinsFromStage);\n        const expectedCells = eligibleCoins.length * Math.max(eligibleCoins.length - 1, 0);\n        await client.query(`\n      INSERT INTO ${matrixTable}\n        (ts_ms, matrix_type, base, quote, value, meta)\n      SELECT ts_ms, matrix_type, base, quote, value, meta\n        FROM ${stageInfo.ident}\n       WHERE ts_ms = $1 AND matrix_type = $2\n      ON CONFLICT (ts_ms, matrix_type, base, quote)\n      DO UPDATE SET value = EXCLUDED.value, meta = EXCLUDED.meta\n    `, [\n            tsMs,\n            matrixType\n        ]);\n        const stagedPairs = new Set(stageRows.rows.map((row)=>{\n            const base = String(row.base ?? \"\").toUpperCase();\n            const quote = String(row.quote ?? \"\").toUpperCase();\n            if (!base || !quote || base === quote) return null;\n            return `${base}${quote}`;\n        }).filter(Boolean));\n        let missingCount = 0;\n        for (const base of eligibleCoins){\n            for (const quote of eligibleCoins){\n                if (base === quote) continue;\n                if (!stagedPairs.has(`${base}${quote}`)) missingCount += 1;\n            }\n        }\n        if (manageTx) await client.query(\"COMMIT\");\n        return {\n            ok: true,\n            matrix_type: matrixType,\n            ts_ms: tsMs,\n            expected_cells: expectedCells,\n            staged_cells: stagedCells,\n            missing_count: missingCount,\n            complete: missingCount === 0 && stagedCells === expectedCells\n        };\n    } catch (err) {\n        if (manageTx) await client.query(\"ROLLBACK\");\n        throw err;\n    } finally{\n        if (release) client.release();\n    }\n}\n/** Convenience: read prev benchmark grid for a coin set (paired map) */ async function mapPrevBenchmark(beforeTs, coins) {\n    const prev = await getPrevSnapshotByType(\"benchmark\", beforeTs, coins);\n    const m = new Map();\n    for (const r of prev)m.set(`${r.base}/${r.quote}`, Number(r.value));\n    return m;\n}\n/**\r\n * Persist the current live slices for the active coin-universe:\r\n *  - benchmark (full NN)\r\n *  - pct24h   (as-is from live)\r\n *  - id_pct   (derived vs prev benchmark so pct_drv has history on next tick)\r\n *\r\n * All three use the SAME ts_ms to keep slices aligned.\r\n */ async function persistLiveMatricesSlice(opts) {\n    const { appSessionId, coins, tsMs, benchmark, pct24h, idemPrefix } = opts;\n    // 1) stage+commit benchmark\n    await stageMatrixGrid({\n        appSessionId,\n        matrixType: \"benchmark\",\n        tsMs,\n        coins,\n        values: benchmark,\n        meta: {\n            source: \"live\"\n        }\n    });\n    await commitMatrixGrid({\n        appSessionId,\n        matrixType: \"benchmark\",\n        tsMs,\n        coins,\n        idem: `${idemPrefix ?? \"benchmark\"}:${tsMs}`\n    });\n    // 2) stage+commit pct24h (optional)\n    if (pct24h) {\n        await stageMatrixGrid({\n            appSessionId,\n            matrixType: \"pct24h\",\n            tsMs,\n            coins,\n            values: pct24h,\n            meta: {\n                source: \"live\"\n            }\n        });\n        await commitMatrixGrid({\n            appSessionId,\n            matrixType: \"pct24h\",\n            tsMs,\n            coins,\n            idem: `${idemPrefix ?? \"pct24h\"}:${tsMs}`\n        });\n    }\n    // 3) derive id_pct vs prev(benchmark) and persist\n    const prevMap = await mapPrevBenchmark(tsMs, coins);\n    const idObj = {};\n    for (const b of coins){\n        idObj[b] = {};\n        for (const q of coins){\n            if (b === q) continue;\n            const now = benchmark?.[b]?.[q];\n            const prev = prevMap.get(`${b}/${q}`);\n            if (now == null || prev == null || Math.abs(prev) < 1e-300) {\n                idObj[b][q] = null;\n            } else {\n                idObj[b][q] = (Number(now) - prev) / prev; // id_pct = (bm_new - bm_prev)/bm_prev\n            }\n        }\n    }\n    await stageMatrixGrid({\n        appSessionId,\n        matrixType: \"id_pct\",\n        tsMs,\n        coins,\n        values: idObj,\n        meta: {\n            source: \"derived@db\",\n            base: \"prev(benchmark)\"\n        }\n    });\n    await commitMatrixGrid({\n        appSessionId,\n        matrixType: \"id_pct\",\n        tsMs,\n        coins,\n        idem: `${idemPrefix ?? \"id_pct\"}:${tsMs}`\n    });\n}\nconst BASE_STEP = {\n    name: \"BASE DDLs\",\n    files: [\n        \"00_extensions.sql\",\n        \"01_settings.sql\",\n        \"02_market.sql\",\n        \"03_docs.sql\",\n        \"04_matrices.sql\",\n        \"05_str_aux.sql\",\n        \"06_cin_aux_core.sql\",\n        \"07_cin_aux_runtime.sql\",\n        \"08_cin_aux_functions.sql\",\n        \"09_ops.sql\",\n        \"09_ingest.sql\",\n        \"10_helpers.sql\",\n        \"11_views_latest.sql\"\n    ]\n};\nconst PATCH_STEP = {\n    name: \"PATCH SET v1\",\n    files: [\n        \"01_settings_patches.sql\",\n        \"02_market_patches.sql\",\n        \"03_docs_patches.sql\",\n        \"04_matrices_patches.sql\",\n        \"05_str_aux_patches.sql\",\n        \"06_cin_aux_core_patches.sql\",\n        \"07_cin_aux_runtime_patches.sql\",\n        \"08_cin_aux_functions_patches.sql\",\n        \"09_mea_dynamics_patches.sql\",\n        \"10_ops_patches.sql\",\n        \"11_remove_bootstrap.sql\"\n    ]\n};\nconst SEED_STEP = {\n    name: \"SEEDS\",\n    files: [\n        \"01_seed.sql\",\n        \"02_seed_jobs.sql\"\n    ]\n};\nconst VERIFY_STEP = {\n    name: \"VERIFY\",\n    files: [\n        \"03_verify.sql\"\n    ]\n};\nasync function spawnCommand(cmd, args, env) {\n    const { spawn } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! node:child_process */ \"node:child_process\", 23));\n    return new Promise((resolve, reject)=>{\n        const child = spawn(cmd, args, {\n            stdio: \"inherit\",\n            env\n        });\n        child.on(\"error\", reject);\n        child.on(\"exit\", (code)=>code === 0 ? resolve() : reject(new Error(`${cmd} exited with ${code}`)));\n    });\n}\nasync function runDbTool(argv = typeof process !== \"undefined\" ? process.argv.slice(2) : [], opts = {}) {\n    const [{ resolve, join }, fs, dotenv] = await Promise.all([\n        Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! node:path */ \"node:path\", 23)),\n        Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! node:fs */ \"node:fs\", 23)),\n        __webpack_require__.e(/*! import() */ \"vendor-chunks/dotenv@17.2.2\").then(__webpack_require__.t.bind(__webpack_require__, /*! dotenv */ \"(rsc)/./node_modules/.pnpm/dotenv@17.2.2/node_modules/dotenv/lib/main.js\", 23))\n    ]);\n    const ROOT = resolve(process.cwd(), opts.root ?? \"db\");\n    const ENV_FILE = join(ROOT, \".env.db\");\n    if (fs.existsSync(ENV_FILE)) {\n        dotenv.config({\n            path: ENV_FILE\n        });\n    }\n    const pg = {\n        host: process.env.PGHOST ?? \"localhost\",\n        port: String(process.env.PGPORT ?? \"5432\"),\n        db: process.env.PGDATABASE ?? \"postgres\",\n        user: process.env.PGUSER ?? \"postgres\",\n        pass: process.env.PGPASSWORD ?? \"\"\n    };\n    const fileExists = (file)=>fs.existsSync(join(ROOT, file));\n    async function ensurePsql() {\n        await spawnCommand(\"psql\", [\n            \"--version\"\n        ]);\n    }\n    async function execSql(file) {\n        if (!fileExists(file)) return;\n        const full = join(ROOT, file);\n        await spawnCommand(\"psql\", [\n            \"-X\",\n            \"-v\",\n            \"ON_ERROR_STOP=1\",\n            \"-h\",\n            pg.host,\n            \"-p\",\n            pg.port,\n            \"-U\",\n            pg.user,\n            \"-d\",\n            pg.db,\n            \"-f\",\n            full\n        ], {\n            ...process.env,\n            PGPASSWORD: pg.pass\n        });\n    }\n    async function runStep(step) {\n        console.log(`\\n=== ${step.name} ===`);\n        for (const file of step.files){\n            if (!fileExists(file)) continue;\n            console.log(`-> ${file}`);\n            await execSql(file);\n        }\n    }\n    async function ensureDb() {\n        const sql = `DO $$\n     BEGIN\n       IF NOT EXISTS (SELECT 1 FROM pg_database WHERE datname = '${pg.db}') THEN\n         EXECUTE 'CREATE DATABASE ${pg.db}';\n       END IF;\n     END$$;`;\n        await spawnCommand(\"psql\", [\n            \"-X\",\n            \"-v\",\n            \"ON_ERROR_STOP=1\",\n            \"-h\",\n            pg.host,\n            \"-p\",\n            pg.port,\n            \"-U\",\n            pg.user,\n            \"-d\",\n            \"postgres\",\n            \"-c\",\n            sql\n        ], {\n            ...process.env,\n            PGPASSWORD: pg.pass\n        });\n    }\n    function usage() {\n        console.log(`\nUsage:\n  pnpm db:apply     # base DDLs + patches\n  pnpm db:seed      # seeds (universe/timing/session/jobs)\n  pnpm db:verify    # quick checks\n  pnpm db:all       # ensure DB, apply, seed, verify\n  pnpm db:psql      # open interactive psql to PGDATABASE\n\nENV: read from db/.env.db (PGHOST, PGPORT, PGDATABASE, PGUSER, PGPASSWORD)\n`.trim());\n    }\n    const [cmd = \"\"] = argv;\n    await ensurePsql();\n    if (cmd === \"apply\") {\n        await runStep(BASE_STEP);\n        await runStep(PATCH_STEP);\n        console.log(\"[ok] apply complete\");\n        return;\n    }\n    if (cmd === \"seed\") {\n        await runStep(SEED_STEP);\n        console.log(\"[ok] seed complete\");\n        return;\n    }\n    if (cmd === \"verify\") {\n        await runStep(VERIFY_STEP);\n        console.log(\"[ok] verify complete\");\n        return;\n    }\n    if (cmd === \"all\") {\n        await ensureDb();\n        await runStep(BASE_STEP);\n        await runStep(PATCH_STEP);\n        await runStep(SEED_STEP);\n        await runStep(VERIFY_STEP);\n        console.log(\"[ok] all done\");\n        return;\n    }\n    if (cmd === \"psql\") {\n        await spawnCommand(\"psql\", [\n            \"-h\",\n            pg.host,\n            \"-p\",\n            pg.port,\n            \"-U\",\n            pg.user,\n            \"-d\",\n            pg.db\n        ], {\n            ...process.env,\n            PGPASSWORD: pg.pass\n        });\n        return;\n    }\n    usage();\n    throw new Error(`Unknown db command \"${cmd}\"`);\n}\nasync function maybeRunDbToolFromCli() {\n    if (typeof process === \"undefined\" || !process.argv?.[1]) return;\n    try {\n        const { pathToFileURL } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! node:url */ \"node:url\", 23));\n        if (\"file:///H:/Users/Gus/source/repo/dynamics/dynamics-b/cryptopi-dynamics/src/core/db/db.ts\" !== pathToFileURL(process.argv[1]).href) return;\n    } catch  {\n        return;\n    }\n    try {\n        await runDbTool(process.argv.slice(2));\n    } catch (err) {\n        console.error(err);\n        process.exitCode = 1;\n    }\n}\nvoid maybeRunDbToolFromCli();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFBUUMsR0FBRyxDQUFDO1FBQ1o7SUFDRjtJQUVBLElBQUl6QyxRQUFRLFFBQVE7UUFDbEIsTUFBTUQsYUFDSixRQUNBO1lBQUM7WUFBTXdCLEdBQUdDLElBQUk7WUFBRTtZQUFNRCxHQUFHRyxJQUFJO1lBQUU7WUFBTUgsR0FBR00sSUFBSTtZQUFFO1lBQU1OLEdBQUdoTSxFQUFFO1NBQUMsRUFDMUQ7WUFBRSxHQUFHSyxRQUFRQyxHQUFHO1lBQUVtTSxZQUFZVCxHQUFHUSxJQUFJO1FBQUM7UUFFeEM7SUFDRjtJQUVBWTtJQUNBLE1BQU0sSUFBSXBNLE1BQU0sQ0FBQyxvQkFBb0IsRUFBRXlKLElBQUksQ0FBQyxDQUFDO0FBQy9DO0FBRUEsZUFBZTRDO0lBQ2IsSUFBSSxPQUFPaE4sWUFBWSxlQUFlLENBQUNBLFFBQVErSyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUU7SUFDMUQsSUFBSTtRQUNGLE1BQU0sRUFBRWtDLGFBQWEsRUFBRSxHQUFHLE1BQU0sc0hBQWtCO1FBQ2xELElBQUksMEZBQWUsS0FBS0EsY0FBY2pOLFFBQVErSyxJQUFJLENBQUMsRUFBRSxFQUFHb0MsSUFBSSxFQUFFO0lBQ2hFLEVBQUUsT0FBTTtRQUNOO0lBQ0Y7SUFFQSxJQUFJO1FBQ0YsTUFBTXJDLFVBQVU5SyxRQUFRK0ssSUFBSSxDQUFDQyxLQUFLLENBQUM7SUFDckMsRUFBRSxPQUFPaEMsS0FBSztRQUNaNEQsUUFBUVEsS0FBSyxDQUFDcEU7UUFDZGhKLFFBQVFxTixRQUFRLEdBQUc7SUFDckI7QUFDRjtBQUVBLEtBQUtMIiwic291cmNlcyI6WyJIOlxcVXNlcnNcXEd1c1xcc291cmNlXFxyZXBvXFxkeW5hbWljc1xcZHluYW1pY3MtYlxcY3J5cHRvcGktZHluYW1pY3NcXHNyY1xcY29yZVxcZGJcXGRiLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb3JlL2RiL2RiLnRzXHJcbmltcG9ydCB0eXBlIHsgUG9vbENsaWVudCwgUXVlcnlSZXN1bHQsIFF1ZXJ5UmVzdWx0Um93IH0gZnJvbSBcInBnXCI7XHJcbmltcG9ydCB7IGRiLCBnZXRQb29sLCBxdWVyeSwgd2l0aENsaWVudCB9IGZyb20gXCIuL3Bvb2xfc2VydmVyXCI7XHJcblxyXG5leHBvcnQgeyBkYiwgZ2V0UG9vbCwgcXVlcnksIHdpdGhDbGllbnQgfSBmcm9tIFwiLi9wb29sX3NlcnZlclwiO1xyXG5cclxuLyoqIC0tLS0tLS0gRHluYW1pY3MgbWF0cmljZXMgKGtlcHQgc2lnbmF0dXJlcykgLS0tLS0tLSAqL1xyXG4vLyBPcHRpb25hbCBlbnYgb3ZlcnJpZGU7IGRlZmF1bHRzIHRvIG91ciBjYW5vbmljYWwgdGFibGVcbmNvbnN0IFJBV19UQUJMRSA9IHByb2Nlc3MuZW52Lk1BVFJJWF9UQUJMRSB8fCBcIm1hdHJpY2VzLmR5bl92YWx1ZXNcIjtcblxuLy8gUHJldmVudCBTUUwgaW5qZWN0aW9uIG9uIGlkZW50aWZpZXJcbmZ1bmN0aW9uIGFzSWRlbnQobmFtZTogc3RyaW5nKSB7XG4gIGNvbnN0IHBhcnRzID0gU3RyaW5nKG5hbWUpLnNwbGl0KFwiLlwiKS5maWx0ZXIoQm9vbGVhbik7XG4gIGlmICghcGFydHMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdGFibGUgaWRlbnRpZmllcjogJHtuYW1lfWApO1xuICByZXR1cm4gcGFydHMubWFwKChwYXJ0KSA9PiB7XG4gICAgaWYgKCEvXltBLVphLXpfXVtBLVphLXowLTlfXSokLy50ZXN0KHBhcnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdGFibGUgaWRlbnRpZmllcjogJHtuYW1lfWApO1xuICAgIH1cbiAgICByZXR1cm4gYFwiJHtwYXJ0fVwiYDtcbiAgfSkuam9pbihcIi5cIik7XG59XG5jb25zdCBUQUJMRSA9IGFzSWRlbnQoUkFXX1RBQkxFKTtcblxuY29uc3QgUkFXX1NUQUdFX1RBQkxFID1cbiAgcHJvY2Vzcy5lbnYuTUFUUklYX1NUQUdFX1RBQkxFIHx8IFwibWF0cmljZXMuZHluX3ZhbHVlc19zdGFnZVwiO1xuY29uc3QgUkFXX0NPTU1JVF9UQUJMRSA9XG4gIHByb2Nlc3MuZW52Lk1BVFJJWF9DT01NSVRfVEFCTEUgfHxcbiAgcHJvY2Vzcy5lbnYuTUFUUklYX1RBQkxFIHx8XG4gIFwibWF0cmljZXMuZHluX3ZhbHVlc1wiO1xuXG5jb25zdCBTVEFHRV9UQUJMRV9DQU5ESURBVEVTID0gQXJyYXkuZnJvbShcbiAgbmV3IFNldChcbiAgICBbXG4gICAgICBwcm9jZXNzLmVudi5NQVRSSVhfU1RBR0VfVEFCTEUsXG4gICAgICBcIm1hdHJpY2VzLmR5bl92YWx1ZXNfc3RhZ2VcIixcbiAgICAgIFwicHVibGljLmR5bl9tYXRyaXhfdmFsdWVzX3N0YWdlXCIsXG4gICAgXS5maWx0ZXIoQm9vbGVhbikgYXMgc3RyaW5nW11cbiAgKVxuKTtcblxuY29uc3QgTUFUUklYX1RBQkxFX0NBTkRJREFURVMgPSBBcnJheS5mcm9tKFxuICBuZXcgU2V0KFxuICAgIFtcbiAgICAgIHByb2Nlc3MuZW52Lk1BVFJJWF9DT01NSVRfVEFCTEUsXG4gICAgICBwcm9jZXNzLmVudi5NQVRSSVhfVEFCTEUsXG4gICAgICBcIm1hdHJpY2VzLmR5bl92YWx1ZXNcIixcbiAgICAgIFwicHVibGljLmR5bl9tYXRyaXhfdmFsdWVzXCIsXG4gICAgXS5maWx0ZXIoQm9vbGVhbikgYXMgc3RyaW5nW11cbiAgKVxuKTtcblxudHlwZSBSZWxhdGlvbkluZm8gPSB7IHJhdzogc3RyaW5nOyBpZGVudDogc3RyaW5nOyBraW5kOiBzdHJpbmcgfTtcblxuZnVuY3Rpb24gc3BsaXRRdWFsaWZpZWROYW1lKG5hbWU6IHN0cmluZyk6IHsgc2NoZW1hOiBzdHJpbmc7IHJlbGF0aW9uOiBzdHJpbmcgfSB7XG4gIGNvbnN0IHBhcnRzID0gU3RyaW5nKG5hbWUpLnNwbGl0KFwiLlwiKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHsgc2NoZW1hOiBcInB1YmxpY1wiLCByZWxhdGlvbjogcGFydHNbMF0hIH07XG4gIGNvbnN0IHJlbGF0aW9uID0gcGFydHMucG9wKCkhO1xuICByZXR1cm4geyBzY2hlbWE6IHBhcnRzLmpvaW4oXCIuXCIpLCByZWxhdGlvbiB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBlbnN1cmVNYXRyaXhUYWJsZXMoY2xpZW50OiBQb29sQ2xpZW50KSB7XG4gIGF3YWl0IGNsaWVudC5xdWVyeShgQ1JFQVRFIFNDSEVNQSBJRiBOT1QgRVhJU1RTIG1hdHJpY2VzYCk7XG4gIGF3YWl0IGNsaWVudC5xdWVyeShgXG4gICAgRE8gJCRcbiAgICBCRUdJTlxuICAgICAgSUYgRVhJU1RTIChcbiAgICAgICAgU0VMRUNUIDFcbiAgICAgICAgRlJPTSBwZ19jbGFzcyBjXG4gICAgICAgIEpPSU4gcGdfbmFtZXNwYWNlIG4gT04gbi5vaWQgPSBjLnJlbG5hbWVzcGFjZVxuICAgICAgICBXSEVSRSBuLm5zcG5hbWUgPSAnbWF0cmljZXMnXG4gICAgICAgICAgQU5EIGMucmVsbmFtZSA9ICdkeW5fdmFsdWVzJ1xuICAgICAgICAgIEFORCBjLnJlbGtpbmQgSU4gKCd2JywnbScpXG4gICAgICApIFRIRU5cbiAgICAgICAgRVhFQ1VURSAnRFJPUCBWSUVXIElGIEVYSVNUUyBtYXRyaWNlcy5keW5fdmFsdWVzIENBU0NBREUnO1xuICAgICAgRU5EIElGO1xuICAgICAgSUYgRVhJU1RTIChcbiAgICAgICAgU0VMRUNUIDFcbiAgICAgICAgRlJPTSBwZ19jbGFzcyBjXG4gICAgICAgIEpPSU4gcGdfbmFtZXNwYWNlIG4gT04gbi5vaWQgPSBjLnJlbG5hbWVzcGFjZVxuICAgICAgICBXSEVSRSBuLm5zcG5hbWUgPSAnbWF0cmljZXMnXG4gICAgICAgICAgQU5EIGMucmVsbmFtZSA9ICdkeW5fdmFsdWVzX3N0YWdlJ1xuICAgICAgICAgIEFORCBjLnJlbGtpbmQgSU4gKCd2JywnbScpXG4gICAgICApIFRIRU5cbiAgICAgICAgRVhFQ1VURSAnRFJPUCBWSUVXIElGIEVYSVNUUyBtYXRyaWNlcy5keW5fdmFsdWVzX3N0YWdlIENBU0NBREUnO1xuICAgICAgRU5EIElGO1xuICAgIEVORFxuICAgICQkO1xuICBgKTtcbiAgYXdhaXQgY2xpZW50LnF1ZXJ5KGBcbiAgICBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyBtYXRyaWNlcy5keW5fdmFsdWVzIChcbiAgICAgIHRzX21zICAgICAgICBiaWdpbnQgICAgICAgICAgIE5PVCBOVUxMLFxuICAgICAgbWF0cml4X3R5cGUgIHRleHQgICAgICAgICAgICAgTk9UIE5VTEwgQ0hFQ0sgKG1hdHJpeF90eXBlIElOICgnYmVuY2htYXJrJywnZGVsdGEnLCdwY3QyNGgnLCdpZF9wY3QnLCdwY3RfZHJ2JywncmVmJywncGN0X3JlZicpKSxcbiAgICAgIGJhc2UgICAgICAgICB0ZXh0ICAgICAgICAgICAgIE5PVCBOVUxMLFxuICAgICAgcXVvdGUgICAgICAgIHRleHQgICAgICAgICAgICAgTk9UIE5VTEwsXG4gICAgICB2YWx1ZSAgICAgICAgZG91YmxlIHByZWNpc2lvbiBOT1QgTlVMTCxcbiAgICAgIG1ldGEgICAgICAgICBqc29uYiAgICAgICAgICAgIE5PVCBOVUxMIERFRkFVTFQgJ3t9Jzo6anNvbmIsXG4gICAgICBjcmVhdGVkX2F0ICAgdGltZXN0YW1wdHogICAgICBOT1QgTlVMTCBERUZBVUxUIG5vdygpLFxuICAgICAgUFJJTUFSWSBLRVkgKHRzX21zLCBtYXRyaXhfdHlwZSwgYmFzZSwgcXVvdGUpXG4gICAgKVxuICBgKTtcbiAgYXdhaXQgY2xpZW50LnF1ZXJ5KGBcbiAgICBDUkVBVEUgSU5ERVggSUYgTk9UIEVYSVNUUyBpZHhfbWF0cmljZXNfZHluX3ZhbHVlc19wYWlyXG4gICAgICBPTiBtYXRyaWNlcy5keW5fdmFsdWVzIChtYXRyaXhfdHlwZSwgYmFzZSwgcXVvdGUsIHRzX21zIERFU0MpXG4gIGApO1xuICBhd2FpdCBjbGllbnQucXVlcnkoYFxuICAgIENSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTIG1hdHJpY2VzLmR5bl92YWx1ZXNfc3RhZ2UgKFxuICAgICAgdHNfbXMgICAgICAgICBiaWdpbnQgICAgICAgICAgIE5PVCBOVUxMLFxuICAgICAgbWF0cml4X3R5cGUgICB0ZXh0ICAgICAgICAgICAgIE5PVCBOVUxMLFxuICAgICAgYmFzZSAgICAgICAgICB0ZXh0ICAgICAgICAgICAgIE5PVCBOVUxMLFxuICAgICAgcXVvdGUgICAgICAgICB0ZXh0ICAgICAgICAgICAgIE5PVCBOVUxMLFxuICAgICAgdmFsdWUgICAgICAgICBkb3VibGUgcHJlY2lzaW9uIE5PVCBOVUxMLFxuICAgICAgbWV0YSAgICAgICAgICBqc29uYiAgICAgICAgICAgIE5PVCBOVUxMIERFRkFVTFQgJ3t9Jzo6anNvbmIsXG4gICAgICBhcHBfc2Vzc2lvbl9pZCB0ZXh0LFxuICAgICAgY3JlYXRlZF9hdCAgICB0aW1lc3RhbXB0eiAgICAgIE5PVCBOVUxMIERFRkFVTFQgbm93KCksXG4gICAgICBQUklNQVJZIEtFWSAodHNfbXMsIG1hdHJpeF90eXBlLCBiYXNlLCBxdW90ZSlcbiAgICApXG4gIGApO1xufVxuXG5hc3luYyBmdW5jdGlvbiBmaW5kRXhpc3RpbmdUYWJsZShcbiAgY2xpZW50OiBQb29sQ2xpZW50LFxuICBjYW5kaWRhdGVzOiBzdHJpbmdbXVxuKTogUHJvbWlzZTxSZWxhdGlvbkluZm8gfCBudWxsPiB7XG4gIGZvciAoY29uc3QgcmF3IG9mIGNhbmRpZGF0ZXMpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgcmVsYXRpb24gfSA9IHNwbGl0UXVhbGlmaWVkTmFtZShyYXcpO1xuICAgIGNvbnN0IHsgcm93cyB9ID0gYXdhaXQgY2xpZW50LnF1ZXJ5PHsga2luZD86IHN0cmluZyB9PihcbiAgICAgIGBcbiAgICAgICAgU0VMRUNUIGMucmVsa2luZCBBUyBraW5kXG4gICAgICAgICAgRlJPTSBwZ19jbGFzcyBjXG4gICAgICAgICAgSk9JTiBwZ19uYW1lc3BhY2UgbiBPTiBuLm9pZCA9IGMucmVsbmFtZXNwYWNlXG4gICAgICAgICBXSEVSRSBuLm5zcG5hbWUgPSAkMSBBTkQgYy5yZWxuYW1lID0gJDJcbiAgICAgIGAsXG4gICAgICBbc2NoZW1hLCByZWxhdGlvbl1cbiAgICApO1xuICAgIGNvbnN0IGtpbmQgPSByb3dzWzBdPy5raW5kO1xuICAgIGlmIChraW5kICYmIChraW5kID09PSBcInJcIiB8fCBraW5kID09PSBcInBcIikpIHtcbiAgICAgIHJldHVybiB7IHJhdywgaWRlbnQ6IGFzSWRlbnQocmF3KSwga2luZCB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxubGV0IGNhY2hlZFN0YWdlSW5mbzogUmVsYXRpb25JbmZvIHwgbnVsbCA9IG51bGw7XG5sZXQgY2FjaGVkTWF0cml4SW5mbzogUmVsYXRpb25JbmZvIHwgbnVsbCA9IG51bGw7XG5cbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZVN0YWdlSW5mbyhjbGllbnQ6IFBvb2xDbGllbnQpOiBQcm9taXNlPFJlbGF0aW9uSW5mbz4ge1xuICBpZiAoY2FjaGVkU3RhZ2VJbmZvKSByZXR1cm4gY2FjaGVkU3RhZ2VJbmZvO1xuICBsZXQgaW5mbyA9XG4gICAgKGF3YWl0IGZpbmRFeGlzdGluZ1RhYmxlKGNsaWVudCwgW1JBV19TVEFHRV9UQUJMRSwgLi4uU1RBR0VfVEFCTEVfQ0FORElEQVRFU10pKSA/P1xuICAgIChhd2FpdCBmaW5kRXhpc3RpbmdUYWJsZShjbGllbnQsIFNUQUdFX1RBQkxFX0NBTkRJREFURVMpKTtcbiAgaWYgKCFpbmZvKSB7XG4gICAgYXdhaXQgZW5zdXJlTWF0cml4VGFibGVzKGNsaWVudCk7XG4gICAgaW5mbyA9XG4gICAgICAoYXdhaXQgZmluZEV4aXN0aW5nVGFibGUoY2xpZW50LCBbUkFXX1NUQUdFX1RBQkxFLCAuLi5TVEFHRV9UQUJMRV9DQU5ESURBVEVTXSkpID8/XG4gICAgICAoYXdhaXQgZmluZEV4aXN0aW5nVGFibGUoY2xpZW50LCBTVEFHRV9UQUJMRV9DQU5ESURBVEVTKSk7XG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBNYXRyaXggc3RhZ2UgdGFibGUgbm90IGZvdW5kLiBDaGVja2VkOiAke1tcbiAgICAgICAgICBSQVdfU1RBR0VfVEFCTEUsXG4gICAgICAgICAgLi4uU1RBR0VfVEFCTEVfQ0FORElEQVRFUyxcbiAgICAgICAgXVxuICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAuam9pbihcIiwgXCIpfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNhY2hlZFN0YWdlSW5mbyA9IGluZm87XG4gIHJldHVybiBpbmZvO1xufVxuXG5hc3luYyBmdW5jdGlvbiBlbnN1cmVNYXRyaXhJbmZvKGNsaWVudDogUG9vbENsaWVudCk6IFByb21pc2U8UmVsYXRpb25JbmZvPiB7XG4gIGlmIChjYWNoZWRNYXRyaXhJbmZvKSByZXR1cm4gY2FjaGVkTWF0cml4SW5mbztcbiAgbGV0IGluZm8gPVxuICAgIChhd2FpdCBmaW5kRXhpc3RpbmdUYWJsZShjbGllbnQsIFtSQVdfQ09NTUlUX1RBQkxFLCAuLi5NQVRSSVhfVEFCTEVfQ0FORElEQVRFU10pKSA/P1xuICAgIChhd2FpdCBmaW5kRXhpc3RpbmdUYWJsZShjbGllbnQsIE1BVFJJWF9UQUJMRV9DQU5ESURBVEVTKSk7XG4gIGlmICghaW5mbykge1xuICAgIGF3YWl0IGVuc3VyZU1hdHJpeFRhYmxlcyhjbGllbnQpO1xuICAgIGluZm8gPVxuICAgICAgKGF3YWl0IGZpbmRFeGlzdGluZ1RhYmxlKGNsaWVudCwgW1JBV19DT01NSVRfVEFCTEUsIC4uLk1BVFJJWF9UQUJMRV9DQU5ESURBVEVTXSkpID8/XG4gICAgICAoYXdhaXQgZmluZEV4aXN0aW5nVGFibGUoY2xpZW50LCBNQVRSSVhfVEFCTEVfQ0FORElEQVRFUykpO1xuICAgIGlmICghaW5mbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTWF0cml4IHZhbHVlcyB0YWJsZSBub3QgZm91bmQuIENoZWNrZWQ6ICR7W1xuICAgICAgICAgIFJBV19DT01NSVRfVEFCTEUsXG4gICAgICAgICAgLi4uTUFUUklYX1RBQkxFX0NBTkRJREFURVMsXG4gICAgICAgIF1cbiAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgLmpvaW4oXCIsIFwiKX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoIWluZm8pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgTWF0cml4IHZhbHVlcyB0YWJsZSBub3QgZm91bmQuIENoZWNrZWQ6ICR7W1xuICAgICAgICBSQVdfQ09NTUlUX1RBQkxFLFxuICAgICAgICAuLi5NQVRSSVhfVEFCTEVfQ0FORElEQVRFUyxcbiAgICAgIF1cbiAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAuam9pbihcIiwgXCIpfWBcbiAgICApO1xuICB9XG4gIGNhY2hlZE1hdHJpeEluZm8gPSBpbmZvO1xuICByZXR1cm4gaW5mbztcbn1cblxuZnVuY3Rpb24gZGVkdXBlVXBwZXIoeHM6IHJlYWRvbmx5IHN0cmluZ1tdIHwgdW5kZWZpbmVkIHwgbnVsbCk6IHN0cmluZ1tdIHtcbiAgaWYgKCF4cz8ubGVuZ3RoKSByZXR1cm4gW107XG4gIGNvbnN0IG91dDogc3RyaW5nW10gPSBbXTtcbiAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBmb3IgKGNvbnN0IHggb2YgeHMpIHtcbiAgICBjb25zdCB1cCA9IFN0cmluZyh4ID8/IFwiXCIpLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xuICAgIGlmICghdXAgfHwgc2Vlbi5oYXModXApKSBjb250aW51ZTtcbiAgICBzZWVuLmFkZCh1cCk7XG4gICAgb3V0LnB1c2godXApO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNYXRyaXhTdGFnZVRhYmxlSWRlbnQoXG4gIGNsaWVudD86IFBvb2xDbGllbnRcbik6IFByb21pc2U8c3RyaW5nPiB7XG4gIGlmIChjYWNoZWRTdGFnZUluZm8pIHJldHVybiBjYWNoZWRTdGFnZUluZm8uaWRlbnQ7XG4gIGNvbnN0IHVzZUNsaWVudCA9IGNsaWVudCA/PyAoYXdhaXQgZGIuY29ubmVjdCgpKTtcbiAgY29uc3QgcmVsZWFzZSA9ICFjbGllbnQ7XG4gIHRyeSB7XG4gICAgY29uc3QgaW5mbyA9IGF3YWl0IGVuc3VyZVN0YWdlSW5mbyh1c2VDbGllbnQpO1xuICAgIHJldHVybiBpbmZvLmlkZW50O1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChyZWxlYXNlKSB1c2VDbGllbnQucmVsZWFzZSgpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldE1hdHJpeFZhbHVlc1RhYmxlSWRlbnQoXG4gIGNsaWVudDogUG9vbENsaWVudFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgaW5mbyA9IGF3YWl0IGVuc3VyZU1hdHJpeEluZm8oY2xpZW50KTtcbiAgcmV0dXJuIGluZm8uaWRlbnQ7XG59XG5cclxuLyoqIE1hdHJpeCB0eXBlIHVuaW9uIChhbGlnbnMgd2l0aCBEREwpICovXHJcbmV4cG9ydCB0eXBlIE1hdHJpeFR5cGUgPSBcImJlbmNobWFya1wiIHwgXCJkZWx0YVwiIHwgXCJwY3QyNGhcIiB8IFwiaWRfcGN0XCIgfCBcInBjdF9kcnZcIiB8IFwicmVmXCIgfCBcInBjdF9yZWZcIjtcclxuXHJcbi8qKiBCdWxrIHVwc2VydCBkaXJlY3RseSBpbnRvIG1haW4gdGFibGUgKGJ5cGFzc2VzIHN0YWdlL2NvbW1pdCkgKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwc2VydE1hdHJpeFJvd3Mocm93czoge1xyXG4gIHRzX21zOiBudW1iZXI7XHJcbiAgbWF0cml4X3R5cGU6IE1hdHJpeFR5cGU7XHJcbiAgYmFzZTogc3RyaW5nOyBxdW90ZTogc3RyaW5nOyB2YWx1ZTogbnVtYmVyO1xyXG4gIG1ldGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xyXG59W10pIHtcclxuICBpZiAoIXJvd3MubGVuZ3RoKSByZXR1cm47XHJcbiAgY29uc3QgY2xpZW50ID0gYXdhaXQgZGIuY29ubmVjdCgpO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB2YWx1ZXM6IGFueVtdID0gW107XHJcbiAgICBjb25zdCBjaHVua3MgPSByb3dzLm1hcCgociwgaSkgPT4ge1xyXG4gICAgICBjb25zdCBqID0gaSAqIDY7XHJcbiAgICAgIHZhbHVlcy5wdXNoKHIudHNfbXMsIHIubWF0cml4X3R5cGUsIHIuYmFzZSwgci5xdW90ZSwgci52YWx1ZSwgSlNPTi5zdHJpbmdpZnkoci5tZXRhID8/IHt9KSk7XHJcbiAgICAgIHJldHVybiBgKCQke2orMX0sICQke2orMn0sICQke2orM30sICQke2orNH0sICQke2orNX0sICQke2orNn0pYDtcclxuICAgIH0pLmpvaW4oXCIsXCIpO1xyXG5cclxuICAgIGNvbnN0IHNxbCA9IGBcclxuICAgICAgSU5TRVJUIElOVE8gJHtUQUJMRX0gKHRzX21zLCBtYXRyaXhfdHlwZSwgYmFzZSwgcXVvdGUsIHZhbHVlLCBtZXRhKVxyXG4gICAgICBWQUxVRVMgJHtjaHVua3N9XHJcbiAgICAgIE9OIENPTkZMSUNUICh0c19tcywgbWF0cml4X3R5cGUsIGJhc2UsIHF1b3RlKVxyXG4gICAgICBETyBVUERBVEUgU0VUIHZhbHVlID0gRVhDTFVERUQudmFsdWUsIG1ldGEgPSBFWENMVURFRC5tZXRhO1xyXG4gICAgYDtcclxuICAgIGF3YWl0IGNsaWVudC5xdWVyeShzcWwsIHZhbHVlcyk7XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIGNsaWVudC5yZWxlYXNlKCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKiogU25hcHNob3RzICYgbG9va3VwcyAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TGF0ZXN0QnlUeXBlKG1hdHJpeF90eXBlOiBzdHJpbmcsIGNvaW5zOiBzdHJpbmdbXSkge1xyXG4gIGNvbnN0IGNsaWVudCA9IGF3YWl0IGRiLmNvbm5lY3QoKTtcclxuICB0cnkge1xyXG4gICAgY29uc3QgeyByb3dzIH0gPSBhd2FpdCBjbGllbnQucXVlcnkoXHJcbiAgICAgIGBTRUxFQ1QgdHNfbXMgRlJPTSAke1RBQkxFfSBXSEVSRSBtYXRyaXhfdHlwZT0kMSBPUkRFUiBCWSB0c19tcyBERVNDIExJTUlUIDFgLFxyXG4gICAgICBbbWF0cml4X3R5cGVdXHJcbiAgICApO1xyXG4gICAgaWYgKCFyb3dzLmxlbmd0aCkgcmV0dXJuIHsgdHNfbXM6IG51bGwsIHZhbHVlczogW10gYXMgYW55W10gfTtcclxuICAgIGNvbnN0IHRzX21zID0gTnVtYmVyKHJvd3NbMF0udHNfbXMpO1xyXG4gICAgY29uc3QgeyByb3dzOiB2YWxzIH0gPSBhd2FpdCBjbGllbnQucXVlcnkoXHJcbiAgICAgIGBTRUxFQ1QgYmFzZSwgcXVvdGUsIHZhbHVlIEZST00gJHtUQUJMRX1cclxuICAgICAgIFdIRVJFIG1hdHJpeF90eXBlPSQxIEFORCB0c19tcz0kMiBBTkQgYmFzZSA9IEFOWSgkMykgQU5EIHF1b3RlID0gQU5ZKCQzKWAsXHJcbiAgICAgIFttYXRyaXhfdHlwZSwgdHNfbXMsIGNvaW5zXVxyXG4gICAgKTtcclxuICAgIHJldHVybiB7IHRzX21zLCB2YWx1ZXM6IHZhbHMgfTtcclxuICB9IGZpbmFsbHkgeyBjbGllbnQucmVsZWFzZSgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcmV2VmFsdWUobWF0cml4X3R5cGU6IHN0cmluZywgYmFzZTogc3RyaW5nLCBxdW90ZTogc3RyaW5nLCBiZWZvcmVUczogbnVtYmVyKSB7XHJcbiAgY29uc3QgeyByb3dzIH0gPSBhd2FpdCBkYi5xdWVyeShcclxuICAgIGBTRUxFQ1QgdmFsdWUgRlJPTSAke1RBQkxFfVxyXG4gICAgIFdIRVJFIG1hdHJpeF90eXBlPSQxIEFORCBiYXNlPSQyIEFORCBxdW90ZT0kMyBBTkQgdHNfbXMgPCAkNFxyXG4gICAgIE9SREVSIEJZIHRzX21zIERFU0MgTElNSVQgMWAsXHJcbiAgICBbbWF0cml4X3R5cGUsIGJhc2UsIHF1b3RlLCBiZWZvcmVUc11cclxuICApO1xyXG4gIHJldHVybiByb3dzLmxlbmd0aCA/IE51bWJlcihyb3dzWzBdLnZhbHVlKSA6IG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRMYXRlc3RUc0ZvclR5cGUobWF0cml4X3R5cGU6IHN0cmluZykge1xyXG4gIGNvbnN0IHsgcm93cyB9ID0gYXdhaXQgZGIucXVlcnkoXHJcbiAgICBgU0VMRUNUIE1BWCh0c19tcykgQVMgdHNfbXMgRlJPTSAke1RBQkxFfSBXSEVSRSBtYXRyaXhfdHlwZT0kMWAsXHJcbiAgICBbbWF0cml4X3R5cGVdXHJcbiAgKTtcclxuICBjb25zdCB2ID0gcm93c1swXT8udHNfbXM7XHJcbiAgcmV0dXJuIHYgPT0gbnVsbCA/IG51bGwgOiBOdW1iZXIodik7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXROZWFyZXN0VHNBdE9yQmVmb3JlKG1hdHJpeF90eXBlOiBzdHJpbmcsIHRzX21zOiBudW1iZXIpIHtcclxuICBjb25zdCB7IHJvd3MgfSA9IGF3YWl0IGRiLnF1ZXJ5KFxyXG4gICAgYFNFTEVDVCB0c19tcyBGUk9NICR7VEFCTEV9XHJcbiAgICAgV0hFUkUgbWF0cml4X3R5cGU9JDEgQU5EIHRzX21zIDw9ICQyXHJcbiAgICAgT1JERVIgQlkgdHNfbXMgREVTQyBMSU1JVCAxYCxcclxuICAgIFttYXRyaXhfdHlwZSwgdHNfbXNdXHJcbiAgKTtcclxuICBjb25zdCB2ID0gcm93c1swXT8udHNfbXM7XHJcbiAgcmV0dXJuIHYgPT0gbnVsbCA/IG51bGwgOiBOdW1iZXIodik7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTbmFwc2hvdEJ5VHlwZShtYXRyaXhfdHlwZTogc3RyaW5nLCB0c19tczogbnVtYmVyLCBjb2luczogc3RyaW5nW10pIHtcclxuICBjb25zdCB7IHJvd3MgfSA9IGF3YWl0IGRiLnF1ZXJ5KFxyXG4gICAgYFNFTEVDVCBiYXNlLCBxdW90ZSwgdmFsdWUgRlJPTSAke1RBQkxFfVxyXG4gICAgIFdIRVJFIG1hdHJpeF90eXBlPSQxIEFORCB0c19tcz0kMiBBTkQgYmFzZSA9IEFOWSgkMykgQU5EIHF1b3RlID0gQU5ZKCQzKWAsXHJcbiAgICBbbWF0cml4X3R5cGUsIHRzX21zLCBjb2luc11cclxuICApO1xyXG4gIHJldHVybiByb3dzIGFzIHsgYmFzZTpzdHJpbmc7IHF1b3RlOnN0cmluZzsgdmFsdWU6bnVtYmVyIH1bXTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFByZXZTbmFwc2hvdEJ5VHlwZShtYXRyaXhfdHlwZTogc3RyaW5nLCBiZWZvcmVUczogbnVtYmVyLCBjb2luczogc3RyaW5nW10pIHtcclxuICBjb25zdCB7IHJvd3MgfSA9IGF3YWl0IGRiLnF1ZXJ5KFxyXG4gICAgYFNFTEVDVCBESVNUSU5DVCBPTiAoYmFzZSwgcXVvdGUpIGJhc2UsIHF1b3RlLCB2YWx1ZVxyXG4gICAgICAgRlJPTSAke1RBQkxFfVxyXG4gICAgICBXSEVSRSBtYXRyaXhfdHlwZT0kMVxyXG4gICAgICAgIEFORCB0c19tcyA8ICQyXHJcbiAgICAgICAgQU5EIGJhc2UgID0gQU5ZKCQzKVxyXG4gICAgICAgIEFORCBxdW90ZSA9IEFOWSgkMylcclxuICAgT1JERVIgQlkgYmFzZSwgcXVvdGUsIHRzX21zIERFU0NgLFxyXG4gICAgW21hdHJpeF90eXBlLCBiZWZvcmVUcywgY29pbnNdXHJcbiAgKTtcclxuICByZXR1cm4gcm93cyBhcyB7IGJhc2U6IHN0cmluZzsgcXVvdGU6IHN0cmluZzsgdmFsdWU6IG51bWJlciB9W107XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb3VudFJvd3NBdChtYXRyaXhfdHlwZTogc3RyaW5nLCB0c19tczogbnVtYmVyKSB7XHJcbiAgY29uc3QgeyByb3dzIH0gPSBhd2FpdCBkYi5xdWVyeShcclxuICAgIGBTRUxFQ1QgY291bnQoKik6OmludCBBUyBuIEZST00gJHtUQUJMRX0gV0hFUkUgbWF0cml4X3R5cGU9JDEgQU5EIHRzX21zPSQyYCxcclxuICAgIFttYXRyaXhfdHlwZSwgdHNfbXNdXHJcbiAgKTtcclxuICByZXR1cm4gcm93c1swXT8ubiA/PyAwO1xyXG59XHJcblxyXG5cclxuLy8g4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIE9wZW5pbmcgaGVscGVycyAoREIgKyBjYWNoZSkg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXHJcbnR5cGUgT3BlbmluZ0tleSA9IHsgYmFzZTogc3RyaW5nOyBxdW90ZT86IHN0cmluZzsgd2luZG93Pzogc3RyaW5nOyBhcHBTZXNzaW9uSWQ/OiBzdHJpbmcgfTtcclxuY29uc3Qgb3BlbmluZ0NhY2hlID0gbmV3IE1hcDxzdHJpbmcsIHsgcHJpY2U6IG51bWJlcjsgdHM6IG51bWJlciB9PigpO1xyXG5jb25zdCBrZXlTdHIgPSAoazogT3BlbmluZ0tleSkgPT5cclxuICBgJHtrLmJhc2V9OiR7ay5xdW90ZSA/PyBcIlVTRFRcIn06JHtrLndpbmRvdyA/PyBcIjFoXCJ9OiR7ay5hcHBTZXNzaW9uSWQgPz8gXCJnbG9iYWxcIn1gO1xyXG5cclxuLyoqIFJlYWQgbGFzdCBvcGVuaW5nIGZvciBhIChiYXNlLHF1b3RlLHdpbmRvdyxzZXNzaW9uKSBmcm9tIFNUUi1BVVg7IGZhbGxiYWNrIHRvIGNvbXBhdCB2aWV3ICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRPcGVuaW5nRnJvbURiKFxyXG4gIGs6IE9wZW5pbmdLZXlcclxuKTogUHJvbWlzZTx7IHByaWNlOiBudW1iZXI7IHRzOiBudW1iZXIgfSB8IG51bGw+IHtcclxuICAvLyBTb3VyY2Ugb2YgdHJ1dGg6IHN0cmF0ZWd5X2F1eC5zdHJfYXV4X3Nlc3Npb24gd2l0aCBvcGVuaW5nX3N0YW1wID0gVFJVRVxyXG4gIGNvbnN0IHExID0gYFxyXG4gICAgU0VMRUNUIG9wZW5pbmdfdHMgQVMgdHMsIG9wZW5pbmdfcHJpY2UgQVMgcHJpY2VcclxuICAgICAgRlJPTSBzdHJhdGVneV9hdXguc3RyX2F1eF9zZXNzaW9uXHJcbiAgICAgV0hFUkUgcGFpcl9iYXNlPSQxIEFORCBwYWlyX3F1b3RlPSQyIEFORCB3aW5kb3dfa2V5PSQzXHJcbiAgICAgICBBTkQgKCQ0Ojp0ZXh0IElTIE5VTEwgT1IgYXBwX3Nlc3Npb25faWQ9JDQpXHJcbiAgICAgICBBTkQgb3BlbmluZ19zdGFtcCA9IFRSVUVcclxuICBPUkRFUiBCWSBvcGVuaW5nX3RzIERFU0NcclxuICAgICBMSU1JVCAxXHJcbiAgYDtcclxuICBjb25zdCByMSA9IGF3YWl0IGRiLnF1ZXJ5KHExLCBbay5iYXNlLCBrLnF1b3RlID8/IFwiVVNEVFwiLCBrLndpbmRvdyA/PyBcIjFoXCIsIGsuYXBwU2Vzc2lvbklkID8/IG51bGxdKTtcclxuICBpZiAocjEucm93cy5sZW5ndGgpIHtcclxuICAgIHJldHVybiB7IHByaWNlOiBOdW1iZXIocjEucm93c1swXS5wcmljZSksIHRzOiBOdW1iZXIocjEucm93c1swXS50cykgfTtcclxuICB9XHJcblxyXG4gIC8vIENvbXBhdGliaWxpdHkgdmlldyAoa2VwdCBmb3Igb2xkZXIgY29kZSBwYXRocylcclxuICBjb25zdCBxMiA9IGBTRUxFQ1Qgc2Vzc2lvbl90cyBBUyB0cywgb3BlbmluZ19wcmljZSBBUyBwcmljZVxyXG4gICAgICAgICAgICAgICAgRlJPTSBzZXNzaW9uX29wZW5pbmdzXHJcbiAgICAgICAgICAgIE9SREVSIEJZIHNlc3Npb25fdHMgREVTQ1xyXG4gICAgICAgICAgICAgICBMSU1JVCAxYDtcclxuICBjb25zdCByMiA9IGF3YWl0IGRiLnF1ZXJ5KHEyKTtcclxuICBpZiAocjIucm93cy5sZW5ndGgpIHtcclxuICAgIHJldHVybiB7IHByaWNlOiBOdW1iZXIocjIucm93c1swXS5wcmljZSksIHRzOiBOdW1iZXIocjIucm93c1swXS50cykgfTtcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnN1cmUgYW4gb3BlbmluZyBleGlzdHMgKyBjYWNoZSBpdCBmb3IgdGhpcyBwcm9jZXNzLlxyXG4gKiBJZiB5b3UgcGFzcyBvcGVuaW5nVHMvb3BlbmluZ1ByaWNlLCB3ZSB0cnkgdG8gdXBzZXJ0IHZpYSB0aGUgU1FMIGZ1bmN0aW9uIGB1cHNlcnRfc3RyX2F1eF9vcGVuaW5nYCAoaWYgcHJlc2VudCkuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5zdXJlT3BlbmluZyhcclxuICBrOiBPcGVuaW5nS2V5LFxyXG4gIG9wdHM6IHsgb3BlbmluZ1RzPzogbnVtYmVyOyBvcGVuaW5nUHJpY2U/OiBudW1iZXI7IGV0YVBjdD86IG51bWJlcjsgZXBzU2hpZnRQY3Q/OiBudW1iZXI7IEs/OiBudW1iZXIgfSA9IHt9XHJcbikge1xyXG4gIGNvbnN0IGNrID0ga2V5U3RyKGspO1xyXG4gIGNvbnN0IGhpdCA9IG9wZW5pbmdDYWNoZS5nZXQoY2spO1xyXG4gIGlmIChoaXQpIHJldHVybiBoaXQ7XHJcblxyXG4gIC8vIElmIGdpdmVuIGV4cGxpY2l0IG9wZW5pbmcsIHRyeSB0byBwZXJzaXN0IChuby1vcCBpZiB0aGUgZnVuY3Rpb24gZG9lc24ndCBleGlzdCkuXHJcbiAgaWYgKG9wdHMub3BlbmluZ1ByaWNlICE9IG51bGwgJiYgb3B0cy5vcGVuaW5nVHMgIT0gbnVsbCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgZGIucXVlcnkoXHJcbiAgICAgICAgYFNFTEVDVCB1cHNlcnRfc3RyX2F1eF9vcGVuaW5nKCQxLCQyLCQzLCQ0LCQ1LCQ2LCQ3KWAsXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgay5iYXNlLCBrLnF1b3RlID8/IFwiVVNEVFwiLCBrLndpbmRvdyA/PyBcIjFoXCIsIGsuYXBwU2Vzc2lvbklkID8/IFwiZ2xvYmFsXCIsXHJcbiAgICAgICAgICBvcHRzLm9wZW5pbmdUcywgb3B0cy5vcGVuaW5nUHJpY2UsXHJcbiAgICAgICAgICBgaWRlbToke2suYmFzZX06JHtrLnF1b3RlID8/IFwiVVNEVFwifToke2sud2luZG93ID8/IFwiMWhcIn06JHtrLmFwcFNlc3Npb25JZCA/PyBcImdsb2JhbFwifToke29wdHMub3BlbmluZ1RzfWBcclxuICAgICAgICBdXHJcbiAgICAgICk7XHJcbiAgICB9IGNhdGNoIHsgLyogZnVuY3Rpb24gbWF5IG5vdCBleGlzdCB5ZXQ7IGl0J3MgZmluZSAqLyB9XHJcbiAgfVxyXG5cclxuICBjb25zdCByb3cgPSBhd2FpdCBnZXRPcGVuaW5nRnJvbURiKGspO1xyXG4gIGlmIChyb3cpIHtcclxuICAgIG9wZW5pbmdDYWNoZS5zZXQoY2ssIHJvdyk7XHJcbiAgICByZXR1cm4gcm93O1xyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyT3BlbmluZ0NhY2hlKGs/OiBPcGVuaW5nS2V5KSB7XHJcbiAgaWYgKCFrKSByZXR1cm4gb3BlbmluZ0NhY2hlLmNsZWFyKCk7XHJcbiAgb3BlbmluZ0NhY2hlLmRlbGV0ZShrZXlTdHIoaykpO1xyXG59XHJcblxyXG5cclxuLy8g4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIE1hdHJpY2VzIFNUQUdFL0NPTU1JVCBoZWxwZXJzIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgFxyXG4vKiogR3JpZCBvYmplY3Qgc2hhcGUgdXNlZCBhY3Jvc3MgZmVhdHVyZXMgKEJBU0UgLT4gUVVPVEUgLT4gdmFsdWV8bnVsbCkgKi9cclxuZXhwb3J0IHR5cGUgTWF0cml4R3JpZE9iamVjdCA9IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIG51bWJlciB8IG51bGw+PjtcclxuXHJcbi8qKiBJbnRlcm5hbDogaXRlcmF0ZSBvZmYtZGlhZ29uYWwgY2VsbHMgdGhhdCBoYXZlIGZpbml0ZSBudW1iZXJzICovXHJcbmZ1bmN0aW9uKiBjZWxsc09mKGNvaW5zOiBzdHJpbmdbXSwgdmFsdWVzOiBNYXRyaXhHcmlkT2JqZWN0KSB7XHJcbiAgZm9yIChjb25zdCBiIG9mIGNvaW5zKSB7XHJcbiAgICBmb3IgKGNvbnN0IHEgb2YgY29pbnMpIHtcclxuICAgICAgaWYgKGIgPT09IHEpIGNvbnRpbnVlO1xyXG4gICAgICBjb25zdCB2ID0gdmFsdWVzPy5bYl0/LltxXTtcclxuICAgICAgaWYgKHYgPT0gbnVsbCB8fCBOdW1iZXIuaXNOYU4oTnVtYmVyKHYpKSkgY29udGludWU7XHJcbiAgICAgIHlpZWxkIHsgYmFzZTogYiwgcXVvdGU6IHEsIHZhbHVlOiBOdW1iZXIodikgfTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKiBTdGFnZSBhbGwgY2VsbHMgZm9yIGEgKG1hdHJpeF90eXBlLCB0c19tcykuIE92ZXJ3cml0ZXMgb24gY29uZmxpY3QgaW4gU1RBR0UuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFnZU1hdHJpeEdyaWQob3B0czoge1xuICBhcHBTZXNzaW9uSWQ6IHN0cmluZztcbiAgbWF0cml4VHlwZTogTWF0cml4VHlwZTtcbiAgdHNNczogbnVtYmVyO1xuICBjb2luczogc3RyaW5nW107XG4gIHZhbHVlczogTWF0cml4R3JpZE9iamVjdDtcbiAgbWV0YT86IGFueTtcbiAgY2xpZW50PzogUG9vbENsaWVudDtcbn0pIHtcbiAgY29uc3QgeyBhcHBTZXNzaW9uSWQsIG1hdHJpeFR5cGUsIHRzTXMsIGNvaW5zLCB2YWx1ZXMsIG1ldGEsIGNsaWVudDogZXh0ZXJuYWwgfSA9XG4gICAgb3B0cztcbiAgY29uc3QgY2xpZW50ID0gZXh0ZXJuYWwgPz8gKGF3YWl0IGRiLmNvbm5lY3QoKSk7XG4gIGNvbnN0IHJlbGVhc2UgPSAhZXh0ZXJuYWw7XG4gIHRyeSB7XG4gICAgY29uc3Qgcm93cyA9IEFycmF5LmZyb20oY2VsbHNPZihjb2lucywgdmFsdWVzKSk7XG4gICAgaWYgKCFyb3dzLmxlbmd0aCkgcmV0dXJuIHsgb2s6IHRydWUsIHN0YWdlZDogMCB9O1xuXG4gICAgY29uc3QgbWV0YUpzb24gPSBKU09OLnN0cmluZ2lmeShtZXRhID8/IHt9KTtcbiAgICBjb25zdCBzdGFnZUluZm8gPSBhd2FpdCBlbnN1cmVTdGFnZUluZm8oY2xpZW50KTtcbiAgICBjb25zdCB0ZXh0ID0gYFxuICAgICAgSU5TRVJUIElOVE8gJHtzdGFnZUluZm8uaWRlbnR9XG4gICAgICAgICh0c19tcywgbWF0cml4X3R5cGUsIGJhc2UsIHF1b3RlLCB2YWx1ZSwgbWV0YSwgYXBwX3Nlc3Npb25faWQpXG4gICAgICBWQUxVRVMgJHtyb3dzXG4gICAgICAgIC5tYXAoXG4gICAgICAgICAgKF8sIGkpID0+XG4gICAgICAgICAgICBgKCQxLCQyLCQke2kgKiAzICsgM30sJCR7aSAqIDMgKyA0fSwkJHtpICogMyArIDV9LCQke1xuICAgICAgICAgICAgICByb3dzLmxlbmd0aCAqIDMgKyAzXG4gICAgICAgICAgICB9LCQke3Jvd3MubGVuZ3RoICogMyArIDR9KWBcbiAgICAgICAgKVxuICAgICAgICAuam9pbihcIixcIil9XG4gICAgICBPTiBDT05GTElDVCAodHNfbXMsIG1hdHJpeF90eXBlLCBiYXNlLCBxdW90ZSlcbiAgICAgIERPIFVQREFURSBTRVQgdmFsdWUgPSBFWENMVURFRC52YWx1ZSwgbWV0YSA9IEVYQ0xVREVELm1ldGEsIGFwcF9zZXNzaW9uX2lkID0gRVhDTFVERUQuYXBwX3Nlc3Npb25faWRcbiAgICBgO1xuICAgIGNvbnN0IHBhcmFtczogYW55W10gPSBbdHNNcywgbWF0cml4VHlwZV07XG4gICAgZm9yIChjb25zdCByIG9mIHJvd3MpIHBhcmFtcy5wdXNoKHIuYmFzZSwgci5xdW90ZSwgci52YWx1ZSk7XG4gICAgcGFyYW1zLnB1c2gobWV0YUpzb24sIGFwcFNlc3Npb25JZCk7XG4gICAgYXdhaXQgY2xpZW50LnF1ZXJ5KHRleHQsIHBhcmFtcyk7XG4gICAgcmV0dXJuIHsgb2s6IHRydWUsIHN0YWdlZDogcm93cy5sZW5ndGggfTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAocmVsZWFzZSkgY2xpZW50LnJlbGVhc2UoKTtcbiAgfVxufVxuXG4vKiogUHVibGlzaCBzdGFnZWQgcm93cyBpbnRvIG1haW4gdGFibGUgKyBjeWNsZV9kb2N1bWVudCArIGxlZGdlciAoc2VlIERETCkgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb21taXRNYXRyaXhHcmlkKG9wdHM6IHtcbiAgYXBwU2Vzc2lvbklkOiBzdHJpbmc7XG4gIG1hdHJpeFR5cGU6IE1hdHJpeFR5cGU7XG4gIHRzTXM6IG51bWJlcjtcbiAgY29pbnM/OiBzdHJpbmdbXTtcbiAgaWRlbT86IHN0cmluZyB8IG51bGw7XG4gIGNsaWVudD86IFBvb2xDbGllbnQ7XG59KSB7XG4gIGNvbnN0IHsgbWF0cml4VHlwZSwgdHNNcywgY29pbnMsIGNsaWVudDogZXh0ZXJuYWwgfSA9IG9wdHM7XG4gIGNvbnN0IGNsaWVudCA9IGV4dGVybmFsID8/IChhd2FpdCBkYi5jb25uZWN0KCkpO1xuICBjb25zdCByZWxlYXNlID0gIWV4dGVybmFsO1xuICBjb25zdCBtYW5hZ2VUeCA9ICFleHRlcm5hbDtcbiAgdHJ5IHtcbiAgICBpZiAobWFuYWdlVHgpIGF3YWl0IGNsaWVudC5xdWVyeShcIkJFR0lOXCIpO1xuXG4gICAgY29uc3Qgc3RhZ2VJbmZvID0gYXdhaXQgZW5zdXJlU3RhZ2VJbmZvKGNsaWVudCk7XG4gICAgY29uc3QgbWF0cml4VGFibGUgPSBhd2FpdCBnZXRNYXRyaXhWYWx1ZXNUYWJsZUlkZW50KGNsaWVudCk7XG5cbiAgICBjb25zdCBzdGFnZVJvd3MgPSBhd2FpdCBjbGllbnQucXVlcnk8eyBiYXNlOiBzdHJpbmc7IHF1b3RlOiBzdHJpbmcgfT4oXG4gICAgICBgU0VMRUNUIGJhc2UsIHF1b3RlXG4gICAgICAgICBGUk9NICR7c3RhZ2VJbmZvLmlkZW50fVxuICAgICAgICBXSEVSRSB0c19tcyA9ICQxIEFORCBtYXRyaXhfdHlwZSA9ICQyYCxcbiAgICAgIFt0c01zLCBtYXRyaXhUeXBlXVxuICAgICk7XG5cbiAgICBjb25zdCBzdGFnZWRDZWxscyA9IHN0YWdlUm93cy5yb3dDb3VudCA/PyBzdGFnZVJvd3Mucm93cy5sZW5ndGg7XG5cbiAgICBjb25zdCBjb2luc0Zyb21TdGFnZSA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGZvciAoY29uc3Qgcm93IG9mIHN0YWdlUm93cy5yb3dzKSB7XG4gICAgICBjb25zdCBiYXNlID0gU3RyaW5nKHJvdy5iYXNlID8/IFwiXCIpLnRvVXBwZXJDYXNlKCk7XG4gICAgICBjb25zdCBxdW90ZSA9IFN0cmluZyhyb3cucXVvdGUgPz8gXCJcIikudG9VcHBlckNhc2UoKTtcbiAgICAgIGlmIChiYXNlKSBjb2luc0Zyb21TdGFnZS5hZGQoYmFzZSk7XG4gICAgICBpZiAocXVvdGUpIGNvaW5zRnJvbVN0YWdlLmFkZChxdW90ZSk7XG4gICAgfVxuXG4gICAgY29uc3QgZWxpZ2libGVDb2lucyA9XG4gICAgICBjb2lucz8ubGVuZ3RoICYmIGRlZHVwZVVwcGVyKGNvaW5zKS5sZW5ndGhcbiAgICAgICAgPyBkZWR1cGVVcHBlcihjb2lucylcbiAgICAgICAgOiBBcnJheS5mcm9tKGNvaW5zRnJvbVN0YWdlKTtcblxuICAgIGNvbnN0IGV4cGVjdGVkQ2VsbHMgPVxuICAgICAgZWxpZ2libGVDb2lucy5sZW5ndGggKiBNYXRoLm1heChlbGlnaWJsZUNvaW5zLmxlbmd0aCAtIDEsIDApO1xuXG4gICAgYXdhaXQgY2xpZW50LnF1ZXJ5KFxuICAgICAgYFxuICAgICAgSU5TRVJUIElOVE8gJHttYXRyaXhUYWJsZX1cbiAgICAgICAgKHRzX21zLCBtYXRyaXhfdHlwZSwgYmFzZSwgcXVvdGUsIHZhbHVlLCBtZXRhKVxuICAgICAgU0VMRUNUIHRzX21zLCBtYXRyaXhfdHlwZSwgYmFzZSwgcXVvdGUsIHZhbHVlLCBtZXRhXG4gICAgICAgIEZST00gJHtzdGFnZUluZm8uaWRlbnR9XG4gICAgICAgV0hFUkUgdHNfbXMgPSAkMSBBTkQgbWF0cml4X3R5cGUgPSAkMlxuICAgICAgT04gQ09ORkxJQ1QgKHRzX21zLCBtYXRyaXhfdHlwZSwgYmFzZSwgcXVvdGUpXG4gICAgICBETyBVUERBVEUgU0VUIHZhbHVlID0gRVhDTFVERUQudmFsdWUsIG1ldGEgPSBFWENMVURFRC5tZXRhXG4gICAgYCxcbiAgICAgIFt0c01zLCBtYXRyaXhUeXBlXVxuICAgICk7XG5cbiAgICBjb25zdCBzdGFnZWRQYWlycyA9IG5ldyBTZXQoXG4gICAgICBzdGFnZVJvd3Mucm93c1xuICAgICAgICAubWFwKChyb3cpID0+IHtcbiAgICAgICAgICBjb25zdCBiYXNlID0gU3RyaW5nKHJvdy5iYXNlID8/IFwiXCIpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgY29uc3QgcXVvdGUgPSBTdHJpbmcocm93LnF1b3RlID8/IFwiXCIpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKCFiYXNlIHx8ICFxdW90ZSB8fCBiYXNlID09PSBxdW90ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgcmV0dXJuIGAke2Jhc2V94oaSJHtxdW90ZX1gO1xuICAgICAgICB9KVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pIGFzIHN0cmluZ1tdXG4gICAgKTtcblxuICAgIGxldCBtaXNzaW5nQ291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgYmFzZSBvZiBlbGlnaWJsZUNvaW5zKSB7XG4gICAgICBmb3IgKGNvbnN0IHF1b3RlIG9mIGVsaWdpYmxlQ29pbnMpIHtcbiAgICAgICAgaWYgKGJhc2UgPT09IHF1b3RlKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFzdGFnZWRQYWlycy5oYXMoYCR7YmFzZX3ihpIke3F1b3RlfWApKSBtaXNzaW5nQ291bnQgKz0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWFuYWdlVHgpIGF3YWl0IGNsaWVudC5xdWVyeShcIkNPTU1JVFwiKTtcblxuICAgIHJldHVybiB7XG4gICAgICBvazogdHJ1ZSxcbiAgICAgIG1hdHJpeF90eXBlOiBtYXRyaXhUeXBlLFxuICAgICAgdHNfbXM6IHRzTXMsXG4gICAgICBleHBlY3RlZF9jZWxsczogZXhwZWN0ZWRDZWxscyxcbiAgICAgIHN0YWdlZF9jZWxsczogc3RhZ2VkQ2VsbHMsXG4gICAgICBtaXNzaW5nX2NvdW50OiBtaXNzaW5nQ291bnQsXG4gICAgICBjb21wbGV0ZTogbWlzc2luZ0NvdW50ID09PSAwICYmIHN0YWdlZENlbGxzID09PSBleHBlY3RlZENlbGxzLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChtYW5hZ2VUeCkgYXdhaXQgY2xpZW50LnF1ZXJ5KFwiUk9MTEJBQ0tcIik7XG4gICAgdGhyb3cgZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChyZWxlYXNlKSBjbGllbnQucmVsZWFzZSgpO1xuICB9XG59XG5cclxuLyoqIENvbnZlbmllbmNlOiByZWFkIHByZXYgYmVuY2htYXJrIGdyaWQgZm9yIGEgY29pbiBzZXQgKHBhaXJlZCBtYXApICovXHJcbmFzeW5jIGZ1bmN0aW9uIG1hcFByZXZCZW5jaG1hcmsoYmVmb3JlVHM6IG51bWJlciwgY29pbnM6IHN0cmluZ1tdKSB7XHJcbiAgY29uc3QgcHJldiA9IGF3YWl0IGdldFByZXZTbmFwc2hvdEJ5VHlwZShcImJlbmNobWFya1wiLCBiZWZvcmVUcywgY29pbnMpO1xyXG4gIGNvbnN0IG0gPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xyXG4gIGZvciAoY29uc3QgciBvZiBwcmV2KSBtLnNldChgJHtyLmJhc2V9LyR7ci5xdW90ZX1gLCBOdW1iZXIoci52YWx1ZSkpO1xyXG4gIHJldHVybiBtO1xyXG59XHJcblxyXG4vKipcclxuICogUGVyc2lzdCB0aGUgY3VycmVudCBsaXZlIHNsaWNlcyBmb3IgdGhlIGFjdGl2ZSBjb2luLXVuaXZlcnNlOlxyXG4gKiAgLSBiZW5jaG1hcmsgKGZ1bGwgTsOXTilcclxuICogIC0gcGN0MjRoICAgKGFzLWlzIGZyb20gbGl2ZSlcclxuICogIC0gaWRfcGN0ICAgKGRlcml2ZWQgdnMgcHJldiBiZW5jaG1hcmsgc28gcGN0X2RydiBoYXMgaGlzdG9yeSBvbiBuZXh0IHRpY2spXHJcbiAqXHJcbiAqIEFsbCB0aHJlZSB1c2UgdGhlIFNBTUUgdHNfbXMgdG8ga2VlcCBzbGljZXMgYWxpZ25lZC5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwZXJzaXN0TGl2ZU1hdHJpY2VzU2xpY2Uob3B0czoge1xuICBhcHBTZXNzaW9uSWQ6IHN0cmluZztcbiAgY29pbnM6IHN0cmluZ1tdO1xuICB0c01zOiBudW1iZXI7XG4gIGJlbmNobWFyazogTWF0cml4R3JpZE9iamVjdDtcbiAgcGN0MjRoPzogTWF0cml4R3JpZE9iamVjdDtcclxuICBpZGVtUHJlZml4Pzogc3RyaW5nO1xyXG59KSB7XHJcbiAgY29uc3QgeyBhcHBTZXNzaW9uSWQsIGNvaW5zLCB0c01zLCBiZW5jaG1hcmssIHBjdDI0aCwgaWRlbVByZWZpeCB9ID0gb3B0cztcclxuXHJcbiAgLy8gMSkgc3RhZ2UrY29tbWl0IGJlbmNobWFya1xyXG4gIGF3YWl0IHN0YWdlTWF0cml4R3JpZCh7XHJcbiAgICBhcHBTZXNzaW9uSWQsXHJcbiAgICBtYXRyaXhUeXBlOiBcImJlbmNobWFya1wiLFxyXG4gICAgdHNNcyxcclxuICAgIGNvaW5zLFxyXG4gICAgdmFsdWVzOiBiZW5jaG1hcmssXHJcbiAgICBtZXRhOiB7IHNvdXJjZTogXCJsaXZlXCIgfVxyXG4gIH0pO1xyXG4gIGF3YWl0IGNvbW1pdE1hdHJpeEdyaWQoe1xyXG4gICAgYXBwU2Vzc2lvbklkLFxyXG4gICAgbWF0cml4VHlwZTogXCJiZW5jaG1hcmtcIixcclxuICAgIHRzTXMsXHJcbiAgICBjb2lucyxcclxuICAgIGlkZW06IGAke2lkZW1QcmVmaXggPz8gXCJiZW5jaG1hcmtcIn06JHt0c01zfWBcclxuICB9KTtcclxuXHJcbiAgLy8gMikgc3RhZ2UrY29tbWl0IHBjdDI0aCAob3B0aW9uYWwpXHJcbiAgaWYgKHBjdDI0aCkge1xyXG4gICAgYXdhaXQgc3RhZ2VNYXRyaXhHcmlkKHtcclxuICAgICAgYXBwU2Vzc2lvbklkLFxyXG4gICAgICBtYXRyaXhUeXBlOiBcInBjdDI0aFwiLFxyXG4gICAgICB0c01zLFxyXG4gICAgICBjb2lucyxcclxuICAgICAgdmFsdWVzOiBwY3QyNGgsXHJcbiAgICAgIG1ldGE6IHsgc291cmNlOiBcImxpdmVcIiB9XHJcbiAgICB9KTtcclxuICAgIGF3YWl0IGNvbW1pdE1hdHJpeEdyaWQoe1xyXG4gICAgICBhcHBTZXNzaW9uSWQsXHJcbiAgICAgIG1hdHJpeFR5cGU6IFwicGN0MjRoXCIsXHJcbiAgICAgIHRzTXMsXHJcbiAgICAgIGNvaW5zLFxyXG4gICAgICBpZGVtOiBgJHtpZGVtUHJlZml4ID8/IFwicGN0MjRoXCJ9OiR7dHNNc31gXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIDMpIGRlcml2ZSBpZF9wY3QgdnMgcHJldihiZW5jaG1hcmspIGFuZCBwZXJzaXN0XHJcbiAgY29uc3QgcHJldk1hcCA9IGF3YWl0IG1hcFByZXZCZW5jaG1hcmsodHNNcywgY29pbnMpO1xyXG4gIGNvbnN0IGlkT2JqOiBNYXRyaXhHcmlkT2JqZWN0ID0ge307XHJcbiAgZm9yIChjb25zdCBiIG9mIGNvaW5zKSB7XHJcbiAgICBpZE9ialtiXSA9IHt9IGFzIFJlY29yZDxzdHJpbmcsIG51bWJlciB8IG51bGw+O1xyXG4gICAgZm9yIChjb25zdCBxIG9mIGNvaW5zKSB7XHJcbiAgICAgIGlmIChiID09PSBxKSBjb250aW51ZTtcclxuICAgICAgY29uc3Qgbm93ID0gYmVuY2htYXJrPy5bYl0/LltxXTtcclxuICAgICAgY29uc3QgcHJldiA9IHByZXZNYXAuZ2V0KGAke2J9LyR7cX1gKTtcclxuICAgICAgaWYgKG5vdyA9PSBudWxsIHx8IHByZXYgPT0gbnVsbCB8fCBNYXRoLmFicyhwcmV2KSA8IDFlLTMwMCkge1xyXG4gICAgICAgIGlkT2JqW2JdW3FdID0gbnVsbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZE9ialtiXVtxXSA9IChOdW1iZXIobm93KSAtIHByZXYpIC8gcHJldjsgLy8gaWRfcGN0ID0gKGJtX25ldyAtIGJtX3ByZXYpL2JtX3ByZXZcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBhd2FpdCBzdGFnZU1hdHJpeEdyaWQoe1xyXG4gICAgYXBwU2Vzc2lvbklkLFxyXG4gICAgbWF0cml4VHlwZTogXCJpZF9wY3RcIixcclxuICAgIHRzTXMsXHJcbiAgICBjb2lucyxcclxuICAgIHZhbHVlczogaWRPYmosXHJcbiAgICBtZXRhOiB7IHNvdXJjZTogXCJkZXJpdmVkQGRiXCIsIGJhc2U6IFwicHJldihiZW5jaG1hcmspXCIgfVxyXG4gIH0pO1xyXG4gIGF3YWl0IGNvbW1pdE1hdHJpeEdyaWQoe1xuICAgIGFwcFNlc3Npb25JZCxcbiAgICBtYXRyaXhUeXBlOiBcImlkX3BjdFwiLFxuICAgIHRzTXMsXG4gICAgY29pbnMsXG4gICAgaWRlbTogYCR7aWRlbVByZWZpeCA/PyBcImlkX3BjdFwifToke3RzTXN9YFxuICB9KTtcbn1cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgQ0xJIHV0aWxpdGllcyAoZm9ybWVyIGRiLm10cykgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxudHlwZSBTdGVwID0geyBuYW1lOiBzdHJpbmc7IGZpbGVzOiBzdHJpbmdbXSB9O1xuXG5jb25zdCBCQVNFX1NURVA6IFN0ZXAgPSB7XG4gIG5hbWU6IFwiQkFTRSBERExzXCIsXG4gIGZpbGVzOiBbXG4gICAgXCIwMF9leHRlbnNpb25zLnNxbFwiLFxuICAgIFwiMDFfc2V0dGluZ3Muc3FsXCIsXG4gICAgXCIwMl9tYXJrZXQuc3FsXCIsXG4gICAgXCIwM19kb2NzLnNxbFwiLFxuICAgIFwiMDRfbWF0cmljZXMuc3FsXCIsXG4gICAgXCIwNV9zdHJfYXV4LnNxbFwiLFxuICAgIFwiMDZfY2luX2F1eF9jb3JlLnNxbFwiLFxuICAgIFwiMDdfY2luX2F1eF9ydW50aW1lLnNxbFwiLFxuICAgIFwiMDhfY2luX2F1eF9mdW5jdGlvbnMuc3FsXCIsXG4gICAgXCIwOV9vcHMuc3FsXCIsXG4gICAgXCIwOV9pbmdlc3Quc3FsXCIsXG4gICAgXCIxMF9oZWxwZXJzLnNxbFwiLFxuICAgIFwiMTFfdmlld3NfbGF0ZXN0LnNxbFwiLFxuICBdLFxufTtcblxuY29uc3QgUEFUQ0hfU1RFUDogU3RlcCA9IHtcbiAgbmFtZTogXCJQQVRDSCBTRVQgdjFcIixcbiAgZmlsZXM6IFtcbiAgICBcIjAxX3NldHRpbmdzX3BhdGNoZXMuc3FsXCIsXG4gICAgXCIwMl9tYXJrZXRfcGF0Y2hlcy5zcWxcIixcbiAgICBcIjAzX2RvY3NfcGF0Y2hlcy5zcWxcIixcbiAgICBcIjA0X21hdHJpY2VzX3BhdGNoZXMuc3FsXCIsXG4gICAgXCIwNV9zdHJfYXV4X3BhdGNoZXMuc3FsXCIsXG4gICAgXCIwNl9jaW5fYXV4X2NvcmVfcGF0Y2hlcy5zcWxcIixcbiAgICBcIjA3X2Npbl9hdXhfcnVudGltZV9wYXRjaGVzLnNxbFwiLFxuICAgIFwiMDhfY2luX2F1eF9mdW5jdGlvbnNfcGF0Y2hlcy5zcWxcIixcbiAgICBcIjA5X21lYV9keW5hbWljc19wYXRjaGVzLnNxbFwiLFxuICAgIFwiMTBfb3BzX3BhdGNoZXMuc3FsXCIsXG4gICAgXCIxMV9yZW1vdmVfYm9vdHN0cmFwLnNxbFwiLFxuICBdLFxufTtcblxuY29uc3QgU0VFRF9TVEVQOiBTdGVwID0geyBuYW1lOiBcIlNFRURTXCIsIGZpbGVzOiBbXCIwMV9zZWVkLnNxbFwiLCBcIjAyX3NlZWRfam9icy5zcWxcIl0gfTtcbmNvbnN0IFZFUklGWV9TVEVQOiBTdGVwID0geyBuYW1lOiBcIlZFUklGWVwiLCBmaWxlczogW1wiMDNfdmVyaWZ5LnNxbFwiXSB9O1xuXG5hc3luYyBmdW5jdGlvbiBzcGF3bkNvbW1hbmQoY21kOiBzdHJpbmcsIGFyZ3M6IHN0cmluZ1tdLCBlbnY/OiBOb2RlSlMuUHJvY2Vzc0Vudikge1xuICBjb25zdCB7IHNwYXduIH0gPSBhd2FpdCBpbXBvcnQoXCJub2RlOmNoaWxkX3Byb2Nlc3NcIik7XG4gIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgY2hpbGQgPSBzcGF3bihjbWQsIGFyZ3MsIHsgc3RkaW86IFwiaW5oZXJpdFwiLCBlbnYgfSk7XG4gICAgY2hpbGQub24oXCJlcnJvclwiLCByZWplY3QpO1xuICAgIGNoaWxkLm9uKFwiZXhpdFwiLCAoY29kZSkgPT4gKGNvZGUgPT09IDAgPyByZXNvbHZlKCkgOiByZWplY3QobmV3IEVycm9yKGAke2NtZH0gZXhpdGVkIHdpdGggJHtjb2RlfWApKSkpO1xuICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1bkRiVG9vbChcbiAgYXJndjogc3RyaW5nW10gPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiA/IHByb2Nlc3MuYXJndi5zbGljZSgyKSA6IFtdLFxuICBvcHRzOiB7IHJvb3Q/OiBzdHJpbmcgfSA9IHt9LFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IFt7IHJlc29sdmUsIGpvaW4gfSwgZnMsIGRvdGVudl0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgaW1wb3J0KFwibm9kZTpwYXRoXCIpLFxuICAgIGltcG9ydChcIm5vZGU6ZnNcIiksXG4gICAgaW1wb3J0KFwiZG90ZW52XCIpLFxuICBdKTtcblxuICBjb25zdCBST09UID0gcmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCBvcHRzLnJvb3QgPz8gXCJkYlwiKTtcbiAgY29uc3QgRU5WX0ZJTEUgPSBqb2luKFJPT1QsIFwiLmVudi5kYlwiKTtcbiAgaWYgKGZzLmV4aXN0c1N5bmMoRU5WX0ZJTEUpKSB7XG4gICAgZG90ZW52LmNvbmZpZyh7IHBhdGg6IEVOVl9GSUxFIH0pO1xuICB9XG5cbiAgY29uc3QgcGcgPSB7XG4gICAgaG9zdDogcHJvY2Vzcy5lbnYuUEdIT1NUID8/IFwibG9jYWxob3N0XCIsXG4gICAgcG9ydDogU3RyaW5nKHByb2Nlc3MuZW52LlBHUE9SVCA/PyBcIjU0MzJcIiksXG4gICAgZGI6IHByb2Nlc3MuZW52LlBHREFUQUJBU0UgPz8gXCJwb3N0Z3Jlc1wiLFxuICAgIHVzZXI6IHByb2Nlc3MuZW52LlBHVVNFUiA/PyBcInBvc3RncmVzXCIsXG4gICAgcGFzczogcHJvY2Vzcy5lbnYuUEdQQVNTV09SRCA/PyBcIlwiLFxuICB9O1xuXG4gIGNvbnN0IGZpbGVFeGlzdHMgPSAoZmlsZTogc3RyaW5nKSA9PiBmcy5leGlzdHNTeW5jKGpvaW4oUk9PVCwgZmlsZSkpO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGVuc3VyZVBzcWwoKSB7XG4gICAgYXdhaXQgc3Bhd25Db21tYW5kKFwicHNxbFwiLCBbXCItLXZlcnNpb25cIl0pO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gZXhlY1NxbChmaWxlOiBzdHJpbmcpIHtcbiAgICBpZiAoIWZpbGVFeGlzdHMoZmlsZSkpIHJldHVybjtcbiAgICBjb25zdCBmdWxsID0gam9pbihST09ULCBmaWxlKTtcbiAgICBhd2FpdCBzcGF3bkNvbW1hbmQoXG4gICAgICBcInBzcWxcIixcbiAgICAgIFtcbiAgICAgICAgXCItWFwiLFxuICAgICAgICBcIi12XCIsXG4gICAgICAgIFwiT05fRVJST1JfU1RPUD0xXCIsXG4gICAgICAgIFwiLWhcIixcbiAgICAgICAgcGcuaG9zdCxcbiAgICAgICAgXCItcFwiLFxuICAgICAgICBwZy5wb3J0LFxuICAgICAgICBcIi1VXCIsXG4gICAgICAgIHBnLnVzZXIsXG4gICAgICAgIFwiLWRcIixcbiAgICAgICAgcGcuZGIsXG4gICAgICAgIFwiLWZcIixcbiAgICAgICAgZnVsbCxcbiAgICAgIF0sXG4gICAgICB7IC4uLnByb2Nlc3MuZW52LCBQR1BBU1NXT1JEOiBwZy5wYXNzIH0sXG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHJ1blN0ZXAoc3RlcDogU3RlcCkge1xuICAgIGNvbnNvbGUubG9nKGBcXG49PT0gJHtzdGVwLm5hbWV9ID09PWApO1xuICAgIGZvciAoY29uc3QgZmlsZSBvZiBzdGVwLmZpbGVzKSB7XG4gICAgICBpZiAoIWZpbGVFeGlzdHMoZmlsZSkpIGNvbnRpbnVlO1xuICAgICAgY29uc29sZS5sb2coYC0+ICR7ZmlsZX1gKTtcbiAgICAgIGF3YWl0IGV4ZWNTcWwoZmlsZSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gZW5zdXJlRGIoKSB7XG4gICAgY29uc3Qgc3FsID0gYERPICQkXG4gICAgIEJFR0lOXG4gICAgICAgSUYgTk9UIEVYSVNUUyAoU0VMRUNUIDEgRlJPTSBwZ19kYXRhYmFzZSBXSEVSRSBkYXRuYW1lID0gJyR7cGcuZGJ9JykgVEhFTlxuICAgICAgICAgRVhFQ1VURSAnQ1JFQVRFIERBVEFCQVNFICR7cGcuZGJ9JztcbiAgICAgICBFTkQgSUY7XG4gICAgIEVORCQkO2A7XG4gICAgYXdhaXQgc3Bhd25Db21tYW5kKFxuICAgICAgXCJwc3FsXCIsXG4gICAgICBbXG4gICAgICAgIFwiLVhcIixcbiAgICAgICAgXCItdlwiLFxuICAgICAgICBcIk9OX0VSUk9SX1NUT1A9MVwiLFxuICAgICAgICBcIi1oXCIsXG4gICAgICAgIHBnLmhvc3QsXG4gICAgICAgIFwiLXBcIixcbiAgICAgICAgcGcucG9ydCxcbiAgICAgICAgXCItVVwiLFxuICAgICAgICBwZy51c2VyLFxuICAgICAgICBcIi1kXCIsXG4gICAgICAgIFwicG9zdGdyZXNcIixcbiAgICAgICAgXCItY1wiLFxuICAgICAgICBzcWwsXG4gICAgICBdLFxuICAgICAgeyAuLi5wcm9jZXNzLmVudiwgUEdQQVNTV09SRDogcGcucGFzcyB9LFxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiB1c2FnZSgpIHtcbiAgICBjb25zb2xlLmxvZyhgXG5Vc2FnZTpcbiAgcG5wbSBkYjphcHBseSAgICAgIyBiYXNlIERETHMgKyBwYXRjaGVzXG4gIHBucG0gZGI6c2VlZCAgICAgICMgc2VlZHMgKHVuaXZlcnNlL3RpbWluZy9zZXNzaW9uL2pvYnMpXG4gIHBucG0gZGI6dmVyaWZ5ICAgICMgcXVpY2sgY2hlY2tzXG4gIHBucG0gZGI6YWxsICAgICAgICMgZW5zdXJlIERCLCBhcHBseSwgc2VlZCwgdmVyaWZ5XG4gIHBucG0gZGI6cHNxbCAgICAgICMgb3BlbiBpbnRlcmFjdGl2ZSBwc3FsIHRvIFBHREFUQUJBU0VcblxuRU5WOiByZWFkIGZyb20gZGIvLmVudi5kYiAoUEdIT1NULCBQR1BPUlQsIFBHREFUQUJBU0UsIFBHVVNFUiwgUEdQQVNTV09SRClcbmAudHJpbSgpKTtcbiAgfVxuXG4gIGNvbnN0IFtjbWQgPSBcIlwiXSA9IGFyZ3Y7XG4gIGF3YWl0IGVuc3VyZVBzcWwoKTtcblxuICBpZiAoY21kID09PSBcImFwcGx5XCIpIHtcbiAgICBhd2FpdCBydW5TdGVwKEJBU0VfU1RFUCk7XG4gICAgYXdhaXQgcnVuU3RlcChQQVRDSF9TVEVQKTtcbiAgICBjb25zb2xlLmxvZyhcIltva10gYXBwbHkgY29tcGxldGVcIik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNtZCA9PT0gXCJzZWVkXCIpIHtcbiAgICBhd2FpdCBydW5TdGVwKFNFRURfU1RFUCk7XG4gICAgY29uc29sZS5sb2coXCJbb2tdIHNlZWQgY29tcGxldGVcIik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNtZCA9PT0gXCJ2ZXJpZnlcIikge1xuICAgIGF3YWl0IHJ1blN0ZXAoVkVSSUZZX1NURVApO1xuICAgIGNvbnNvbGUubG9nKFwiW29rXSB2ZXJpZnkgY29tcGxldGVcIik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNtZCA9PT0gXCJhbGxcIikge1xuICAgIGF3YWl0IGVuc3VyZURiKCk7XG4gICAgYXdhaXQgcnVuU3RlcChCQVNFX1NURVApO1xuICAgIGF3YWl0IHJ1blN0ZXAoUEFUQ0hfU1RFUCk7XG4gICAgYXdhaXQgcnVuU3RlcChTRUVEX1NURVApO1xuICAgIGF3YWl0IHJ1blN0ZXAoVkVSSUZZX1NURVApO1xuICAgIGNvbnNvbGUubG9nKFwiW29rXSBhbGwgZG9uZVwiKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY21kID09PSBcInBzcWxcIikge1xuICAgIGF3YWl0IHNwYXduQ29tbWFuZChcbiAgICAgIFwicHNxbFwiLFxuICAgICAgW1wiLWhcIiwgcGcuaG9zdCwgXCItcFwiLCBwZy5wb3J0LCBcIi1VXCIsIHBnLnVzZXIsIFwiLWRcIiwgcGcuZGJdLFxuICAgICAgeyAuLi5wcm9jZXNzLmVudiwgUEdQQVNTV09SRDogcGcucGFzcyB9LFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdXNhZ2UoKTtcbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRiIGNvbW1hbmQgXCIke2NtZH1cImApO1xufVxuXG5hc3luYyBmdW5jdGlvbiBtYXliZVJ1bkRiVG9vbEZyb21DbGkoKSB7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhcHJvY2Vzcy5hcmd2Py5bMV0pIHJldHVybjtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IHBhdGhUb0ZpbGVVUkwgfSA9IGF3YWl0IGltcG9ydChcIm5vZGU6dXJsXCIpO1xuICAgIGlmIChpbXBvcnQubWV0YS51cmwgIT09IHBhdGhUb0ZpbGVVUkwocHJvY2Vzcy5hcmd2WzFdISkuaHJlZikgcmV0dXJuO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cnkge1xuICAgIGF3YWl0IHJ1bkRiVG9vbChwcm9jZXNzLmFyZ3Yuc2xpY2UoMikpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgcHJvY2Vzcy5leGl0Q29kZSA9IDE7XG4gIH1cbn1cblxudm9pZCBtYXliZVJ1bkRiVG9vbEZyb21DbGkoKTtcbiJdLCJuYW1lcyI6WyJkYiIsImdldFBvb2wiLCJxdWVyeSIsIndpdGhDbGllbnQiLCJSQVdfVEFCTEUiLCJwcm9jZXNzIiwiZW52IiwiTUFUUklYX1RBQkxFIiwiYXNJZGVudCIsIm5hbWUiLCJwYXJ0cyIsIlN0cmluZyIsInNwbGl0IiwiZmlsdGVyIiwiQm9vbGVhbiIsImxlbmd0aCIsIkVycm9yIiwibWFwIiwicGFydCIsInRlc3QiLCJqb2luIiwiVEFCTEUiLCJSQVdfU1RBR0VfVEFCTEUiLCJNQVRSSVhfU1RBR0VfVEFCTEUiLCJSQVdfQ09NTUlUX1RBQkxFIiwiTUFUUklYX0NPTU1JVF9UQUJMRSIsIlNUQUdFX1RBQkxFX0NBTkRJREFURVMiLCJBcnJheSIsImZyb20iLCJTZXQiLCJNQVRSSVhfVEFCTEVfQ0FORElEQVRFUyIsInNwbGl0UXVhbGlmaWVkTmFtZSIsInNjaGVtYSIsInJlbGF0aW9uIiwicG9wIiwiZW5zdXJlTWF0cml4VGFibGVzIiwiY2xpZW50IiwiZmluZEV4aXN0aW5nVGFibGUiLCJjYW5kaWRhdGVzIiwicmF3Iiwicm93cyIsImtpbmQiLCJpZGVudCIsImNhY2hlZFN0YWdlSW5mbyIsImNhY2hlZE1hdHJpeEluZm8iLCJlbnN1cmVTdGFnZUluZm8iLCJpbmZvIiwiZW5zdXJlTWF0cml4SW5mbyIsImRlZHVwZVVwcGVyIiwieHMiLCJvdXQiLCJzZWVuIiwieCIsInVwIiwidHJpbSIsInRvVXBwZXJDYXNlIiwiaGFzIiwiYWRkIiwicHVzaCIsImdldE1hdHJpeFN0YWdlVGFibGVJZGVudCIsInVzZUNsaWVudCIsImNvbm5lY3QiLCJyZWxlYXNlIiwiZ2V0TWF0cml4VmFsdWVzVGFibGVJZGVudCIsInVwc2VydE1hdHJpeFJvd3MiLCJ2YWx1ZXMiLCJjaHVua3MiLCJyIiwiaSIsImoiLCJ0c19tcyIsIm1hdHJpeF90eXBlIiwiYmFzZSIsInF1b3RlIiwidmFsdWUiLCJKU09OIiwic3RyaW5naWZ5IiwibWV0YSIsInNxbCIsImdldExhdGVzdEJ5VHlwZSIsImNvaW5zIiwiTnVtYmVyIiwidmFscyIsImdldFByZXZWYWx1ZSIsImJlZm9yZVRzIiwiZ2V0TGF0ZXN0VHNGb3JUeXBlIiwidiIsImdldE5lYXJlc3RUc0F0T3JCZWZvcmUiLCJnZXRTbmFwc2hvdEJ5VHlwZSIsImdldFByZXZTbmFwc2hvdEJ5VHlwZSIsImNvdW50Um93c0F0IiwibiIsIm9wZW5pbmdDYWNoZSIsIk1hcCIsImtleVN0ciIsImsiLCJ3aW5kb3ciLCJhcHBTZXNzaW9uSWQiLCJnZXRPcGVuaW5nRnJvbURiIiwicTEiLCJyMSIsInByaWNlIiwidHMiLCJxMiIsInIyIiwiZW5zdXJlT3BlbmluZyIsIm9wdHMiLCJjayIsImhpdCIsImdldCIsIm9wZW5pbmdQcmljZSIsIm9wZW5pbmdUcyIsInJvdyIsInNldCIsImNsZWFyT3BlbmluZ0NhY2hlIiwiY2xlYXIiLCJkZWxldGUiLCJjZWxsc09mIiwiYiIsInEiLCJpc05hTiIsInN0YWdlTWF0cml4R3JpZCIsIm1hdHJpeFR5cGUiLCJ0c01zIiwiZXh0ZXJuYWwiLCJvayIsInN0YWdlZCIsIm1ldGFKc29uIiwic3RhZ2VJbmZvIiwidGV4dCIsIl8iLCJwYXJhbXMiLCJjb21taXRNYXRyaXhHcmlkIiwibWFuYWdlVHgiLCJtYXRyaXhUYWJsZSIsInN0YWdlUm93cyIsInN0YWdlZENlbGxzIiwicm93Q291bnQiLCJjb2luc0Zyb21TdGFnZSIsImVsaWdpYmxlQ29pbnMiLCJleHBlY3RlZENlbGxzIiwiTWF0aCIsIm1heCIsInN0YWdlZFBhaXJzIiwibWlzc2luZ0NvdW50IiwiZXhwZWN0ZWRfY2VsbHMiLCJzdGFnZWRfY2VsbHMiLCJtaXNzaW5nX2NvdW50IiwiY29tcGxldGUiLCJlcnIiLCJtYXBQcmV2QmVuY2htYXJrIiwicHJldiIsIm0iLCJwZXJzaXN0TGl2ZU1hdHJpY2VzU2xpY2UiLCJiZW5jaG1hcmsiLCJwY3QyNGgiLCJpZGVtUHJlZml4Iiwic291cmNlIiwiaWRlbSIsInByZXZNYXAiLCJpZE9iaiIsIm5vdyIsImFicyIsIkJBU0VfU1RFUCIsImZpbGVzIiwiUEFUQ0hfU1RFUCIsIlNFRURfU1RFUCIsIlZFUklGWV9TVEVQIiwic3Bhd25Db21tYW5kIiwiY21kIiwiYXJncyIsInNwYXduIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjaGlsZCIsInN0ZGlvIiwib24iLCJjb2RlIiwicnVuRGJUb29sIiwiYXJndiIsInNsaWNlIiwiZnMiLCJkb3RlbnYiLCJhbGwiLCJST09UIiwiY3dkIiwicm9vdCIsIkVOVl9GSUxFIiwiZXhpc3RzU3luYyIsImNvbmZpZyIsInBhdGgiLCJwZyIsImhvc3QiLCJQR0hPU1QiLCJwb3J0IiwiUEdQT1JUIiwiUEdEQVRBQkFTRSIsInVzZXIiLCJQR1VTRVIiLCJwYXNzIiwiUEdQQVNTV09SRCIsImZpbGVFeGlzdHMiLCJmaWxlIiwiZW5zdXJlUHNxbCIsImV4ZWNTcWwiLCJmdWxsIiwicnVuU3RlcCIsInN0ZXAiLCJjb25zb2xlIiwibG9nIiwiZW5zdXJlRGIiLCJ1c2FnZSIsIm1heWJlUnVuRGJUb29sRnJvbUNsaSIsInBhdGhUb0ZpbGVVUkwiLCJ1cmwiLCJocmVmIiwiZXJyb3IiLCJleGl0Q29kZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/core/db/db.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/db/pool_server.ts":
/*!************************************!*\
  !*** ./src/core/db/pool_server.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_SEARCH_PATH: () => (/* binding */ DEFAULT_SEARCH_PATH),\n/* harmony export */   TABLES: () => (/* binding */ TABLES),\n/* harmony export */   appendAppLedger: () => (/* binding */ appendAppLedger),\n/* harmony export */   appendTransferLedger: () => (/* binding */ appendTransferLedger),\n/* harmony export */   db: () => (/* binding */ db),\n/* harmony export */   getAppLedgerSince: () => (/* binding */ getAppLedgerSince),\n/* harmony export */   getDb: () => (/* binding */ getDb),\n/* harmony export */   getPool: () => (/* binding */ getPool),\n/* harmony export */   listTransferLegs: () => (/* binding */ listTransferLegs),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   serverDb: () => (/* binding */ serverDb),\n/* harmony export */   withClient: () => (/* binding */ withClient)\n/* harmony export */ });\n/* harmony import */ var pg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pg */ \"pg\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([pg__WEBPACK_IMPORTED_MODULE_0__]);\npg__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * Unified PG pool + convenience helpers + lightweight ledgers.\n * This replaces the old pool/server/ledger trio with a single source of truth.\n */ /*  Environment helpers  */ function asBool(v, fallback = false) {\n    if (v == null) return fallback;\n    const s = String(v).trim().toLowerCase();\n    return s === \"1\" || s === \"true\" || s === \"yes\" || s === \"on\";\n}\n/*  Pool configuration  */ const useUrl = !!process.env.DATABASE_URL;\nconst baseConfig = useUrl ? {\n    connectionString: String(process.env.DATABASE_URL)\n} : {\n    host: String(process.env.PGHOST ?? \"localhost\"),\n    port: Number(process.env.PGPORT ?? 1026),\n    user: String(process.env.PGUSER ?? \"postgres\"),\n    password: String(process.env.PGPASSWORD ?? \"gus\"),\n    database: String(process.env.PGDATABASE ?? \"cryptopie\")\n};\nconst poolConfig = {\n    ...baseConfig,\n    max: Number(process.env.DB_POOL_MAX ?? process.env.PGPOOL_MAX ?? 10),\n    idleTimeoutMillis: Number(process.env.DB_IDLE_MS ?? 45000),\n    connectionTimeoutMillis: Number(process.env.DB_CONN_TIMEOUT_MS ?? 5000),\n    ssl: asBool(process.env.DB_SSL ?? process.env.PGSSL) ? {\n        rejectUnauthorized: false\n    } : undefined\n};\nconst SESSION_STATEMENT_TIMEOUT = Number(process.env.DB_STATEMENT_TIMEOUT_MS ?? 15000);\nconst SESSION_IDLE_TX_TIMEOUT = Number(process.env.DB_IDLE_TX_TIMEOUT_MS ?? 15000);\nconst SESSION_TZ = String(process.env.DB_TIMEZONE ?? \"UTC\").replace(/'/g, \"''\");\nconst DEFAULT_SEARCH_PATH = [\n    \"settings\",\n    \"market\",\n    \"docs\",\n    \"matrices\",\n    \"str_aux\",\n    \"cin_aux\",\n    \"mea_dynamics\",\n    \"ingest\",\n    \"ops\",\n    \"public\"\n].join(\", \");\nfunction ensurePool() {\n    if (!global.__core_pg_pool__) {\n        const pool = new pg__WEBPACK_IMPORTED_MODULE_0__.Pool(poolConfig);\n        pool.on(\"connect\", (client)=>{\n            const bootstrap = [\n                `SET statement_timeout = ${SESSION_STATEMENT_TIMEOUT}`,\n                `SET idle_in_transaction_session_timeout = ${SESSION_IDLE_TX_TIMEOUT}`,\n                `SET TIME ZONE '${SESSION_TZ}'`,\n                `SET search_path = ${DEFAULT_SEARCH_PATH}`\n            ];\n            for (const statement of bootstrap){\n                void client.query(statement).catch(()=>{\n                /* ignore bootstrap failures so the pool stays usable */ });\n            }\n        });\n        global.__core_pg_pool__ = pool;\n    }\n    return global.__core_pg_pool__;\n}\nfunction getPool() {\n    return ensurePool();\n}\nfunction getDb() {\n    return ensurePool();\n}\n/*  Query helpers  */ async function withClient(fn) {\n    const client = await ensurePool().connect();\n    try {\n        return await fn(client);\n    } finally{\n        client.release();\n    }\n}\nasync function query(text, params) {\n    return ensurePool().query(text, params);\n}\nconst db = ensurePool();\nconst serverDb = {\n    query (text, params) {\n        return ensurePool().query(text, params);\n    }\n};\n/*  Table constants  */ const TABLES = {\n    matrices: process.env.MATRIX_TABLE || \"matrices.dyn_values\",\n    matricesStage: process.env.MATRIX_STAGE_TABLE || \"matrices.dyn_values_stage\",\n    ledger: process.env.APP_LEDGER_TABLE || \"ops.app_ledger\",\n    transfers: process.env.TRANSFER_LEDGER_TABLE || \"ops.transfer_ledger\"\n};\n/** Safe insert; ignores missing table or duplicate key. */ async function appendAppLedger(e) {\n    const sql = `\n    INSERT INTO ${TABLES.ledger}\n      (topic, event, payload, session_id, idempotency_key, ts_epoch_ms)\n    VALUES ($1,$2,$3,$4,$5,$6)\n    ON CONFLICT (idempotency_key) DO NOTHING\n  `;\n    try {\n        await query(sql, [\n            e.topic,\n            e.event,\n            e.payload ?? null,\n            e.session_id ?? null,\n            e.idempotency_key ?? null,\n            e.ts_epoch_ms\n        ]);\n    } catch (err) {\n        if (err?.code === \"42P01\") {\n            console.warn(\"appendAppLedger: ledger table missing (ops.app_ledger). Skipping log.\");\n            return;\n        }\n        throw err;\n    }\n}\nasync function getAppLedgerSince(sinceMs, topic) {\n    try {\n        const { rows } = await query(`SELECT * FROM ${TABLES.ledger}\n        WHERE ts_epoch_ms >= $1\n          AND ($2::text IS NULL OR topic = $2)\n     ORDER BY ts_epoch_ms ASC`, [\n            sinceMs,\n            topic ?? null\n        ]);\n        return rows;\n    } catch (err) {\n        if (err?.code === \"42P01\") {\n            console.warn(\"getAppLedgerSince: ledger table missing (ops.app_ledger).\");\n            return [];\n        }\n        throw err;\n    }\n}\n/*  Transfer ledger helpers  */ async function appendTransferLedger(row) {\n    const q = `\n    INSERT INTO ${TABLES.transfers} (\n      app_session_id, cycle_ts, leg_seq, route_id, intent_id,\n      from_symbol, to_symbol, qty_from, qty_to,\n      price_from_usdt, price_to_usdt, fee_usdt, exec_ts, tx_id\n    )\n    VALUES (\n      $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,COALESCE($12,0),$13,$14\n    )\n    ON CONFLICT (app_session_id, cycle_ts, leg_seq) DO NOTHING\n  `;\n    try {\n        await query(q, [\n            row.app_session_id,\n            row.cycle_ts,\n            row.leg_seq,\n            row.route_id ?? null,\n            row.intent_id ?? null,\n            row.from_symbol,\n            row.to_symbol,\n            row.qty_from,\n            row.qty_to,\n            row.price_from_usdt,\n            row.price_to_usdt,\n            row.fee_usdt ?? 0,\n            row.exec_ts,\n            row.tx_id ?? null\n        ]);\n    } catch (err) {\n        if (err?.code === \"42P01\") {\n            console.warn(\"appendTransferLedger: transfer_ledger table missing (ops.transfer_ledger).\");\n            return;\n        }\n        throw err;\n    }\n}\nasync function listTransferLegs(app_session_id, opts) {\n    const { rows } = await query(`SELECT * FROM ${TABLES.transfers}\n      WHERE app_session_id = $1\n        AND ($2::bigint IS NULL OR cycle_ts < $2)\n   ORDER BY cycle_ts DESC, leg_seq DESC\n      LIMIT $3`, [\n        app_session_id,\n        opts?.before ?? null,\n        opts?.limit ?? 200\n    ]);\n    return rows;\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixDQUFDLEVBQ1g7UUFBQ3FCO1FBQWdCZSxNQUFNQyxVQUFVO1FBQU1ELE1BQU1FLFNBQVM7S0FBSTtJQUU1RCxPQUFPckI7QUFDVCIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGNvcmVcXGRiXFxwb29sX3NlcnZlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb29sLCB0eXBlIFBvb2xDbGllbnQsIHR5cGUgUXVlcnlSZXN1bHQsIHR5cGUgUXVlcnlSZXN1bHRSb3cgfSBmcm9tIFwicGdcIjtcblxuLyoqXG4gKiBVbmlmaWVkIFBHIHBvb2wgKyBjb252ZW5pZW5jZSBoZWxwZXJzICsgbGlnaHR3ZWlnaHQgbGVkZ2Vycy5cbiAqIFRoaXMgcmVwbGFjZXMgdGhlIG9sZCBwb29sL3NlcnZlci9sZWRnZXIgdHJpbyB3aXRoIGEgc2luZ2xlIHNvdXJjZSBvZiB0cnV0aC5cbiAqL1xuXG4vKiDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgRW52aXJvbm1lbnQgaGVscGVycyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgKi9cbmZ1bmN0aW9uIGFzQm9vbCh2OiB1bmtub3duLCBmYWxsYmFjayA9IGZhbHNlKTogYm9vbGVhbiB7XG4gIGlmICh2ID09IG51bGwpIHJldHVybiBmYWxsYmFjaztcbiAgY29uc3QgcyA9IFN0cmluZyh2KS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIHMgPT09IFwiMVwiIHx8IHMgPT09IFwidHJ1ZVwiIHx8IHMgPT09IFwieWVzXCIgfHwgcyA9PT0gXCJvblwiO1xufVxuXG4vKiDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgUG9vbCBjb25maWd1cmF0aW9uIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCAqL1xuY29uc3QgdXNlVXJsID0gISFwcm9jZXNzLmVudi5EQVRBQkFTRV9VUkw7XG5jb25zdCBiYXNlQ29uZmlnID0gdXNlVXJsXG4gID8geyBjb25uZWN0aW9uU3RyaW5nOiBTdHJpbmcocHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMKSB9XG4gIDoge1xuICAgICAgaG9zdDogU3RyaW5nKHByb2Nlc3MuZW52LlBHSE9TVCA/PyBcImxvY2FsaG9zdFwiKSxcbiAgICAgIHBvcnQ6IE51bWJlcihwcm9jZXNzLmVudi5QR1BPUlQgPz8gMTAyNiksXG4gICAgICB1c2VyOiBTdHJpbmcocHJvY2Vzcy5lbnYuUEdVU0VSID8/IFwicG9zdGdyZXNcIiksXG4gICAgICBwYXNzd29yZDogU3RyaW5nKHByb2Nlc3MuZW52LlBHUEFTU1dPUkQgPz8gXCJndXNcIiksXG4gICAgICBkYXRhYmFzZTogU3RyaW5nKHByb2Nlc3MuZW52LlBHREFUQUJBU0UgPz8gXCJjcnlwdG9waWVcIiksXG4gICAgfTtcblxuY29uc3QgcG9vbENvbmZpZyA9IHtcbiAgLi4uYmFzZUNvbmZpZyxcbiAgbWF4OiBOdW1iZXIocHJvY2Vzcy5lbnYuREJfUE9PTF9NQVggPz8gcHJvY2Vzcy5lbnYuUEdQT09MX01BWCA/PyAxMCksXG4gIGlkbGVUaW1lb3V0TWlsbGlzOiBOdW1iZXIocHJvY2Vzcy5lbnYuREJfSURMRV9NUyA/PyA0NV8wMDApLFxuICBjb25uZWN0aW9uVGltZW91dE1pbGxpczogTnVtYmVyKHByb2Nlc3MuZW52LkRCX0NPTk5fVElNRU9VVF9NUyA/PyA1XzAwMCksXG4gIHNzbDogYXNCb29sKHByb2Nlc3MuZW52LkRCX1NTTCA/PyBwcm9jZXNzLmVudi5QR1NTTClcbiAgICA/IHsgcmVqZWN0VW5hdXRob3JpemVkOiBmYWxzZSBhcyBjb25zdCB9XG4gICAgOiB1bmRlZmluZWQsXG59O1xuXG5jb25zdCBTRVNTSU9OX1NUQVRFTUVOVF9USU1FT1VUID0gTnVtYmVyKHByb2Nlc3MuZW52LkRCX1NUQVRFTUVOVF9USU1FT1VUX01TID8/IDE1XzAwMCk7XG5jb25zdCBTRVNTSU9OX0lETEVfVFhfVElNRU9VVCA9IE51bWJlcihwcm9jZXNzLmVudi5EQl9JRExFX1RYX1RJTUVPVVRfTVMgPz8gMTVfMDAwKTtcbmNvbnN0IFNFU1NJT05fVFogPSBTdHJpbmcocHJvY2Vzcy5lbnYuREJfVElNRVpPTkUgPz8gXCJVVENcIikucmVwbGFjZSgvJy9nLCBcIicnXCIpO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VBUkNIX1BBVEggPSBbXG4gIFwic2V0dGluZ3NcIixcbiAgXCJtYXJrZXRcIixcbiAgXCJkb2NzXCIsXG4gIFwibWF0cmljZXNcIixcbiAgXCJzdHJfYXV4XCIsXG4gIFwiY2luX2F1eFwiLFxuICBcIm1lYV9keW5hbWljc1wiLFxuICBcImluZ2VzdFwiLFxuICBcIm9wc1wiLFxuICBcInB1YmxpY1wiLFxuXS5qb2luKFwiLCBcIik7XG5cbi8qIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBQb29sIHNpbmdsZXRvbiDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgKi9cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhclxuICB2YXIgX19jb3JlX3BnX3Bvb2xfXzogUG9vbCB8IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZW5zdXJlUG9vbCgpOiBQb29sIHtcbiAgaWYgKCFnbG9iYWwuX19jb3JlX3BnX3Bvb2xfXykge1xuICAgIGNvbnN0IHBvb2wgPSBuZXcgUG9vbChwb29sQ29uZmlnIGFzIGFueSk7XG4gICAgcG9vbC5vbihcImNvbm5lY3RcIiwgKGNsaWVudDogUG9vbENsaWVudCkgPT4ge1xuICAgICAgY29uc3QgYm9vdHN0cmFwID0gW1xuICAgICAgICBgU0VUIHN0YXRlbWVudF90aW1lb3V0ID0gJHtTRVNTSU9OX1NUQVRFTUVOVF9USU1FT1VUfWAsXG4gICAgICAgIGBTRVQgaWRsZV9pbl90cmFuc2FjdGlvbl9zZXNzaW9uX3RpbWVvdXQgPSAke1NFU1NJT05fSURMRV9UWF9USU1FT1VUfWAsXG4gICAgICAgIGBTRVQgVElNRSBaT05FICcke1NFU1NJT05fVFp9J2AsXG4gICAgICAgIGBTRVQgc2VhcmNoX3BhdGggPSAke0RFRkFVTFRfU0VBUkNIX1BBVEh9YCxcbiAgICAgIF07XG4gICAgICBmb3IgKGNvbnN0IHN0YXRlbWVudCBvZiBib290c3RyYXApIHtcbiAgICAgICAgdm9pZCBjbGllbnQucXVlcnkoc3RhdGVtZW50KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgLyogaWdub3JlIGJvb3RzdHJhcCBmYWlsdXJlcyBzbyB0aGUgcG9vbCBzdGF5cyB1c2FibGUgKi9cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZ2xvYmFsLl9fY29yZV9wZ19wb29sX18gPSBwb29sO1xuICB9XG4gIHJldHVybiBnbG9iYWwuX19jb3JlX3BnX3Bvb2xfXyE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb29sKCk6IFBvb2wge1xuICByZXR1cm4gZW5zdXJlUG9vbCgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldERiKCk6IFBvb2wge1xuICByZXR1cm4gZW5zdXJlUG9vbCgpO1xufVxuXG4vKiDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgUXVlcnkgaGVscGVycyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3aXRoQ2xpZW50PFQ+KGZuOiAoY2xpZW50OiBQb29sQ2xpZW50KSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gIGNvbnN0IGNsaWVudCA9IGF3YWl0IGVuc3VyZVBvb2woKS5jb25uZWN0KCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGZuKGNsaWVudCk7XG4gIH0gZmluYWxseSB7XG4gICAgY2xpZW50LnJlbGVhc2UoKTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcXVlcnk8VCBleHRlbmRzIFF1ZXJ5UmVzdWx0Um93ID0gUXVlcnlSZXN1bHRSb3c+KFxuICB0ZXh0OiBzdHJpbmcsXG4gIHBhcmFtcz86IGFueVtdLFxuKTogUHJvbWlzZTxRdWVyeVJlc3VsdDxUPj4ge1xuICByZXR1cm4gZW5zdXJlUG9vbCgpLnF1ZXJ5PFQ+KHRleHQsIHBhcmFtcyk7XG59XG5cbmV4cG9ydCBjb25zdCBkYjogUG9vbCA9IGVuc3VyZVBvb2woKTtcbmV4cG9ydCBjb25zdCBzZXJ2ZXJEYiA9IHtcbiAgcXVlcnk8VCA9IGFueT4odGV4dDogc3RyaW5nLCBwYXJhbXM/OiBhbnlbXSkge1xuICAgIHJldHVybiBlbnN1cmVQb29sKCkucXVlcnk8VD4odGV4dCwgcGFyYW1zKTtcbiAgfSxcbn07XG5cbi8qIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBUYWJsZSBjb25zdGFudHMg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAICovXG5leHBvcnQgY29uc3QgVEFCTEVTID0ge1xuICBtYXRyaWNlczogcHJvY2Vzcy5lbnYuTUFUUklYX1RBQkxFIHx8IFwibWF0cmljZXMuZHluX3ZhbHVlc1wiLFxuICBtYXRyaWNlc1N0YWdlOiBwcm9jZXNzLmVudi5NQVRSSVhfU1RBR0VfVEFCTEUgfHwgXCJtYXRyaWNlcy5keW5fdmFsdWVzX3N0YWdlXCIsXG4gIGxlZGdlcjogcHJvY2Vzcy5lbnYuQVBQX0xFREdFUl9UQUJMRSB8fCBcIm9wcy5hcHBfbGVkZ2VyXCIsXG4gIHRyYW5zZmVyczogcHJvY2Vzcy5lbnYuVFJBTlNGRVJfTEVER0VSX1RBQkxFIHx8IFwib3BzLnRyYW5zZmVyX2xlZGdlclwiLFxufSBhcyBjb25zdDtcblxuLyog4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIExlZGdlciBoZWxwZXJzIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCAqL1xuZXhwb3J0IHR5cGUgQXBwTGVkZ2VyRXZlbnQgPSB7XG4gIHRvcGljOiBzdHJpbmc7ICAgICAgICAgICAgICAvLyBlLmcuIFwicGlwZWxpbmVcIlxuICBldmVudDogc3RyaW5nOyAgICAgICAgICAgICAgLy8gZS5nLiBcImR5bl9tYXRyaXhfdXBzZXJ0XCJcbiAgcGF5bG9hZD86IHVua25vd247XG4gIHNlc3Npb25faWQ/OiBzdHJpbmc7XG4gIGlkZW1wb3RlbmN5X2tleT86IHN0cmluZztcbiAgdHNfZXBvY2hfbXM6IG51bWJlcjtcbn07XG5cbi8qKiBTYWZlIGluc2VydDsgaWdub3JlcyBtaXNzaW5nIHRhYmxlIG9yIGR1cGxpY2F0ZSBrZXkuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXBwZW5kQXBwTGVkZ2VyKGU6IEFwcExlZGdlckV2ZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHNxbCA9IGBcbiAgICBJTlNFUlQgSU5UTyAke1RBQkxFUy5sZWRnZXJ9XG4gICAgICAodG9waWMsIGV2ZW50LCBwYXlsb2FkLCBzZXNzaW9uX2lkLCBpZGVtcG90ZW5jeV9rZXksIHRzX2Vwb2NoX21zKVxuICAgIFZBTFVFUyAoJDEsJDIsJDMsJDQsJDUsJDYpXG4gICAgT04gQ09ORkxJQ1QgKGlkZW1wb3RlbmN5X2tleSkgRE8gTk9USElOR1xuICBgO1xuICB0cnkge1xuICAgIGF3YWl0IHF1ZXJ5KHNxbCwgW1xuICAgICAgZS50b3BpYyxcbiAgICAgIGUuZXZlbnQsXG4gICAgICBlLnBheWxvYWQgPz8gbnVsbCxcbiAgICAgIGUuc2Vzc2lvbl9pZCA/PyBudWxsLFxuICAgICAgZS5pZGVtcG90ZW5jeV9rZXkgPz8gbnVsbCxcbiAgICAgIGUudHNfZXBvY2hfbXMsXG4gICAgXSk7XG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgaWYgKGVycj8uY29kZSA9PT0gXCI0MlAwMVwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJhcHBlbmRBcHBMZWRnZXI6IGxlZGdlciB0YWJsZSBtaXNzaW5nIChvcHMuYXBwX2xlZGdlcikuIFNraXBwaW5nIGxvZy5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QXBwTGVkZ2VyU2luY2Uoc2luY2VNczogbnVtYmVyLCB0b3BpYz86IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHsgcm93cyB9ID0gYXdhaXQgcXVlcnkoXG4gICAgICBgU0VMRUNUICogRlJPTSAke1RBQkxFUy5sZWRnZXJ9XG4gICAgICAgIFdIRVJFIHRzX2Vwb2NoX21zID49ICQxXG4gICAgICAgICAgQU5EICgkMjo6dGV4dCBJUyBOVUxMIE9SIHRvcGljID0gJDIpXG4gICAgIE9SREVSIEJZIHRzX2Vwb2NoX21zIEFTQ2AsXG4gICAgICBbc2luY2VNcywgdG9waWMgPz8gbnVsbF0sXG4gICAgKTtcbiAgICByZXR1cm4gcm93cztcbiAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICBpZiAoZXJyPy5jb2RlID09PSBcIjQyUDAxXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcImdldEFwcExlZGdlclNpbmNlOiBsZWRnZXIgdGFibGUgbWlzc2luZyAob3BzLmFwcF9sZWRnZXIpLlwiKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbi8qIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBUcmFuc2ZlciBsZWRnZXIgaGVscGVycyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhcHBlbmRUcmFuc2ZlckxlZGdlcihyb3c6IHtcbiAgYXBwX3Nlc3Npb25faWQ6IHN0cmluZztcbiAgY3ljbGVfdHM6IG51bWJlcjtcbiAgbGVnX3NlcTogbnVtYmVyO1xuICByb3V0ZV9pZD86IHN0cmluZyB8IG51bGw7XG4gIGludGVudF9pZD86IHN0cmluZyB8IG51bGw7XG4gIGZyb21fc3ltYm9sOiBzdHJpbmc7XG4gIHRvX3N5bWJvbDogc3RyaW5nO1xuICBxdHlfZnJvbTogbnVtYmVyO1xuICBxdHlfdG86IG51bWJlcjtcbiAgcHJpY2VfZnJvbV91c2R0OiBudW1iZXI7XG4gIHByaWNlX3RvX3VzZHQ6IG51bWJlcjtcbiAgZmVlX3VzZHQ/OiBudW1iZXI7XG4gIGV4ZWNfdHM6IG51bWJlcjtcbiAgdHhfaWQ/OiBzdHJpbmcgfCBudWxsO1xufSk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBxID0gYFxuICAgIElOU0VSVCBJTlRPICR7VEFCTEVTLnRyYW5zZmVyc30gKFxuICAgICAgYXBwX3Nlc3Npb25faWQsIGN5Y2xlX3RzLCBsZWdfc2VxLCByb3V0ZV9pZCwgaW50ZW50X2lkLFxuICAgICAgZnJvbV9zeW1ib2wsIHRvX3N5bWJvbCwgcXR5X2Zyb20sIHF0eV90byxcbiAgICAgIHByaWNlX2Zyb21fdXNkdCwgcHJpY2VfdG9fdXNkdCwgZmVlX3VzZHQsIGV4ZWNfdHMsIHR4X2lkXG4gICAgKVxuICAgIFZBTFVFUyAoXG4gICAgICAkMSwkMiwkMywkNCwkNSwkNiwkNywkOCwkOSwkMTAsJDExLENPQUxFU0NFKCQxMiwwKSwkMTMsJDE0XG4gICAgKVxuICAgIE9OIENPTkZMSUNUIChhcHBfc2Vzc2lvbl9pZCwgY3ljbGVfdHMsIGxlZ19zZXEpIERPIE5PVEhJTkdcbiAgYDtcbiAgdHJ5IHtcbiAgICBhd2FpdCBxdWVyeShxLCBbXG4gICAgICByb3cuYXBwX3Nlc3Npb25faWQsXG4gICAgICByb3cuY3ljbGVfdHMsXG4gICAgICByb3cubGVnX3NlcSxcbiAgICAgIHJvdy5yb3V0ZV9pZCA/PyBudWxsLFxuICAgICAgcm93LmludGVudF9pZCA/PyBudWxsLFxuICAgICAgcm93LmZyb21fc3ltYm9sLFxuICAgICAgcm93LnRvX3N5bWJvbCxcbiAgICAgIHJvdy5xdHlfZnJvbSxcbiAgICAgIHJvdy5xdHlfdG8sXG4gICAgICByb3cucHJpY2VfZnJvbV91c2R0LFxuICAgICAgcm93LnByaWNlX3RvX3VzZHQsXG4gICAgICByb3cuZmVlX3VzZHQgPz8gMCxcbiAgICAgIHJvdy5leGVjX3RzLFxuICAgICAgcm93LnR4X2lkID8/IG51bGwsXG4gICAgXSk7XG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgaWYgKGVycj8uY29kZSA9PT0gXCI0MlAwMVwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJhcHBlbmRUcmFuc2ZlckxlZGdlcjogdHJhbnNmZXJfbGVkZ2VyIHRhYmxlIG1pc3NpbmcgKG9wcy50cmFuc2Zlcl9sZWRnZXIpLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsaXN0VHJhbnNmZXJMZWdzKFxuICBhcHBfc2Vzc2lvbl9pZDogc3RyaW5nLFxuICBvcHRzPzogeyBiZWZvcmU/OiBudW1iZXI7IGxpbWl0PzogbnVtYmVyIH0sXG4pIHtcbiAgY29uc3QgeyByb3dzIH0gPSBhd2FpdCBxdWVyeShcbiAgICBgU0VMRUNUICogRlJPTSAke1RBQkxFUy50cmFuc2ZlcnN9XG4gICAgICBXSEVSRSBhcHBfc2Vzc2lvbl9pZCA9ICQxXG4gICAgICAgIEFORCAoJDI6OmJpZ2ludCBJUyBOVUxMIE9SIGN5Y2xlX3RzIDwgJDIpXG4gICBPUkRFUiBCWSBjeWNsZV90cyBERVNDLCBsZWdfc2VxIERFU0NcbiAgICAgIExJTUlUICQzYCxcbiAgICBbYXBwX3Nlc3Npb25faWQsIG9wdHM/LmJlZm9yZSA/PyBudWxsLCBvcHRzPy5saW1pdCA/PyAyMDBdLFxuICApO1xuICByZXR1cm4gcm93cztcbn1cblxuZXhwb3J0IHR5cGUgeyBQb29sLCBQb29sQ2xpZW50LCBRdWVyeVJlc3VsdCwgUXVlcnlSZXN1bHRSb3cgfTtcbiJdLCJuYW1lcyI6WyJQb29sIiwiYXNCb29sIiwidiIsImZhbGxiYWNrIiwicyIsIlN0cmluZyIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsInVzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJEQVRBQkFTRV9VUkwiLCJiYXNlQ29uZmlnIiwiY29ubmVjdGlvblN0cmluZyIsImhvc3QiLCJQR0hPU1QiLCJwb3J0IiwiTnVtYmVyIiwiUEdQT1JUIiwidXNlciIsIlBHVVNFUiIsInBhc3N3b3JkIiwiUEdQQVNTV09SRCIsImRhdGFiYXNlIiwiUEdEQVRBQkFTRSIsInBvb2xDb25maWciLCJtYXgiLCJEQl9QT09MX01BWCIsIlBHUE9PTF9NQVgiLCJpZGxlVGltZW91dE1pbGxpcyIsIkRCX0lETEVfTVMiLCJjb25uZWN0aW9uVGltZW91dE1pbGxpcyIsIkRCX0NPTk5fVElNRU9VVF9NUyIsInNzbCIsIkRCX1NTTCIsIlBHU1NMIiwicmVqZWN0VW5hdXRob3JpemVkIiwidW5kZWZpbmVkIiwiU0VTU0lPTl9TVEFURU1FTlRfVElNRU9VVCIsIkRCX1NUQVRFTUVOVF9USU1FT1VUX01TIiwiU0VTU0lPTl9JRExFX1RYX1RJTUVPVVQiLCJEQl9JRExFX1RYX1RJTUVPVVRfTVMiLCJTRVNTSU9OX1RaIiwiREJfVElNRVpPTkUiLCJyZXBsYWNlIiwiREVGQVVMVF9TRUFSQ0hfUEFUSCIsImpvaW4iLCJlbnN1cmVQb29sIiwiZ2xvYmFsIiwiX19jb3JlX3BnX3Bvb2xfXyIsInBvb2wiLCJvbiIsImNsaWVudCIsImJvb3RzdHJhcCIsInN0YXRlbWVudCIsInF1ZXJ5IiwiY2F0Y2giLCJnZXRQb29sIiwiZ2V0RGIiLCJ3aXRoQ2xpZW50IiwiZm4iLCJjb25uZWN0IiwicmVsZWFzZSIsInRleHQiLCJwYXJhbXMiLCJkYiIsInNlcnZlckRiIiwiVEFCTEVTIiwibWF0cmljZXMiLCJNQVRSSVhfVEFCTEUiLCJtYXRyaWNlc1N0YWdlIiwiTUFUUklYX1NUQUdFX1RBQkxFIiwibGVkZ2VyIiwiQVBQX0xFREdFUl9UQUJMRSIsInRyYW5zZmVycyIsIlRSQU5TRkVSX0xFREdFUl9UQUJMRSIsImFwcGVuZEFwcExlZGdlciIsImUiLCJzcWwiLCJ0b3BpYyIsImV2ZW50IiwicGF5bG9hZCIsInNlc3Npb25faWQiLCJpZGVtcG90ZW5jeV9rZXkiLCJ0c19lcG9jaF9tcyIsImVyciIsImNvZGUiLCJjb25zb2xlIiwid2FybiIsImdldEFwcExlZGdlclNpbmNlIiwic2luY2VNcyIsInJvd3MiLCJhcHBlbmRUcmFuc2ZlckxlZGdlciIsInJvdyIsInEiLCJhcHBfc2Vzc2lvbl9pZCIsImN5Y2xlX3RzIiwibGVnX3NlcSIsInJvdXRlX2lkIiwiaW50ZW50X2lkIiwiZnJvbV9zeW1ib2wiLCJ0b19zeW1ib2wiLCJxdHlfZnJvbSIsInF0eV90byIsInByaWNlX2Zyb21fdXNkdCIsInByaWNlX3RvX3VzZHQiLCJmZWVfdXNkdCIsImV4ZWNfdHMiLCJ0eF9pZCIsImxpc3RUcmFuc2ZlckxlZ3MiLCJvcHRzIiwiYmVmb3JlIiwibGltaXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/core/db/pool_server.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/matrices/liveFromSources.ts":
/*!*******************************************************!*\
  !*** ./src/core/features/matrices/liveFromSources.ts ***!
  \*******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   liveFromSources: () => (/* binding */ liveFromSources)\n/* harmony export */ });\n/* harmony import */ var _core_sources_binance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/sources/binance */ \"(rsc)/./src/core/sources/binance.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_sources_binance__WEBPACK_IMPORTED_MODULE_0__]);\n_core_sources_binance__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n// src/core/features/matrices/liveFromSources.ts\n// Build live benchmark & pct24h using YOUR binance.ts without changing it.\n// We pre-filter symbols with listSymbolsByQuote('USDT') so /24hr bulk never 400s.\n\nconst normCoins = (xs)=>{\n    const out = [];\n    const seen = new Set();\n    for (const x of xs){\n        const u = String(x || \"\").toUpperCase().trim();\n        if (!u || seen.has(u)) continue;\n        seen.add(u);\n        out.push(u);\n    }\n    if (!seen.has(\"USDT\")) out.push(\"USDT\");\n    return out;\n};\nconst makeGrid = (coins, fn)=>{\n    const out = {};\n    for (const b of coins){\n        out[b] = {};\n        for (const q of coins){\n            if (b === q) continue;\n            out[b][q] = fn(b, q);\n        }\n    }\n    return out;\n};\nasync function liveFromSources(requestedCoins) {\n    // normalize + ensure USDT present\n    const seed = normCoins(requestedCoins);\n    // Step 1: Build desired USDT symbols for seed\n    const desired = (0,_core_sources_binance__WEBPACK_IMPORTED_MODULE_0__.usdtSymbolsFor)(seed); // [\"BTCUSDT\",\"ETHUSDT\",...]\n    // Step 2: Ask Binance which USDT symbols actually exist (TRADING)\n    // Keeping this call here (read-only) guarantees no 400s later.\n    const tradableSet = new Set(await (0,_core_sources_binance__WEBPACK_IMPORTED_MODULE_0__.listSymbolsByQuote)(\"USDT\"));\n    // Step 3: Filter desired symbols down to the tradable set before calling bulk 24hr\n    const symbols = desired.filter((s)=>tradableSet.has(s));\n    // If nothing valid (unlikely), return a minimal payload to avoid 500s.\n    if (!symbols.length) {\n        const now = Date.now();\n        return {\n            ok: true,\n            coins: [\n                \"USDT\"\n            ],\n            matrices: {\n                benchmark: {\n                    ts: now,\n                    prevTs: null,\n                    values: {},\n                    flags: {\n                        source: \"binance:empty\"\n                    }\n                },\n                pct24h: {\n                    ts: now,\n                    prevTs: null,\n                    values: {},\n                    flags: {\n                        source: \"binance:empty\"\n                    }\n                }\n            }\n        };\n    }\n    // Step 4: Bulk fetch once using your helper (kept unchanged)\n    const arr = await (0,_core_sources_binance__WEBPACK_IMPORTED_MODULE_0__.fetch24hAll)(symbols);\n    const by = (0,_core_sources_binance__WEBPACK_IMPORTED_MODULE_0__.mapTickerBySymbol)(arr);\n    // Step 5: Build per-coin USDT price & pct24h\n    const price = {\n        USDT: 1\n    };\n    const pct = {\n        USDT: 0\n    }; // percent units\n    for (const sym of symbols){\n        // sym like \"BTCUSDT\" -> coin = \"BTC\"\n        const coin = sym.endsWith(\"USDT\") ? sym.slice(0, -4) : undefined;\n        if (!coin) continue;\n        const t = by[sym];\n        const last = t?.lastPrice != null ? Number(t.lastPrice) : Number(t?.weightedAvgPrice);\n        const pct24 = t?.priceChangePercent != null ? Number(t.priceChangePercent) : NaN;\n        if (Number.isFinite(last)) {\n            price[coin] = last; // coin in USDT\n            pct[coin] = Number.isFinite(pct24) ? pct24 : 0; // still in percent units\n        }\n    }\n    // Keep only coins we actually got a price for (+USDT)\n    const coins = [\n        \"USDT\",\n        ...Object.keys(price).filter((c)=>c !== \"USDT\")\n    ];\n    const now = Date.now();\n    // benchmark = price_b / price_q\n    const benchmark = {\n        ts: now,\n        prevTs: null,\n        values: makeGrid(coins, (b, q)=>{\n            const pb = price[b] ?? (b === \"USDT\" ? 1 : NaN);\n            const pq = price[q] ?? (q === \"USDT\" ? 1 : NaN);\n            if (!Number.isFinite(pb) || !Number.isFinite(pq) || pq === 0) return null;\n            return pb / pq;\n        }),\n        flags: {\n            source: \"binance:usdt-legs\"\n        }\n    };\n    // pct24h(pair) ~ ((1+rb)/(1+rq)) - 1, with rb/rq as DECIMALS from per-coin percent\n    const pct24h = {\n        ts: now,\n        prevTs: null,\n        values: makeGrid(coins, (b, q)=>{\n            const rb = b === \"USDT\" ? 0 : (pct[b] ?? NaN) / 100;\n            const rq = q === \"USDT\" ? 0 : (pct[q] ?? NaN) / 100;\n            if (!Number.isFinite(rb) || !Number.isFinite(rq)) return null;\n            const nb = 1 + rb, nq = 1 + rq;\n            if (nq === 0) return null;\n            return nb / nq - 1;\n        }),\n        flags: {\n            source: \"binance:usdt-legs\"\n        }\n    };\n    return {\n        ok: true,\n        coins,\n        matrices: {\n            benchmark,\n            pct24h\n        }\n    };\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9tYXRyaWNlcy9saXZlRnJvbVNvdXJjZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxnREFBZ0Q7QUFDaEQsMkVBQTJFO0FBQzNFLGtGQUFrRjtBQU9sRDtBQUtoQyxNQUFNSSxZQUFZLENBQUNDO0lBQ2pCLE1BQU1DLE1BQWdCLEVBQUU7SUFDeEIsTUFBTUMsT0FBTyxJQUFJQztJQUNqQixLQUFLLE1BQU1DLEtBQUtKLEdBQUk7UUFDbEIsTUFBTUssSUFBSUMsT0FBT0YsS0FBSyxJQUFJRyxXQUFXLEdBQUdDLElBQUk7UUFDNUMsSUFBSSxDQUFDSCxLQUFLSCxLQUFLTyxHQUFHLENBQUNKLElBQUk7UUFDdkJILEtBQUtRLEdBQUcsQ0FBQ0w7UUFBSUosSUFBSVUsSUFBSSxDQUFDTjtJQUN4QjtJQUNBLElBQUksQ0FBQ0gsS0FBS08sR0FBRyxDQUFDLFNBQVNSLElBQUlVLElBQUksQ0FBQztJQUNoQyxPQUFPVjtBQUNUO0FBRUEsTUFBTVcsV0FBVyxDQUEwQkMsT0FBaUJDO0lBQzFELE1BQU1iLE1BQWlCLENBQUM7SUFDeEIsS0FBSyxNQUFNYyxLQUFLRixNQUFPO1FBQ3JCWixHQUFHLENBQUNjLEVBQUUsR0FBRyxDQUFDO1FBQ1YsS0FBSyxNQUFNQyxLQUFLSCxNQUFPO1lBQ3JCLElBQUlFLE1BQU1DLEdBQUc7WUFDYmYsR0FBRyxDQUFDYyxFQUFFLENBQUNDLEVBQUUsR0FBR0YsR0FBR0MsR0FBR0M7UUFDcEI7SUFDRjtJQUNBLE9BQU9mO0FBQ1Q7QUFFTyxlQUFlZ0IsZ0JBQWdCQyxjQUF3QjtJQUM1RCxrQ0FBa0M7SUFDbEMsTUFBTUMsT0FBT3BCLFVBQVVtQjtJQUV2Qiw4Q0FBOEM7SUFDOUMsTUFBTUUsVUFBVXRCLHFFQUFjQSxDQUFDcUIsT0FBTyw0QkFBNEI7SUFFbEUsa0VBQWtFO0lBQ2xFLCtEQUErRDtJQUMvRCxNQUFNRSxjQUFjLElBQUlsQixJQUFJLE1BQU1SLHlFQUFrQkEsQ0FBQztJQUVyRCxtRkFBbUY7SUFDbkYsTUFBTTJCLFVBQVVGLFFBQVFHLE1BQU0sQ0FBQyxDQUFDQyxJQUFNSCxZQUFZWixHQUFHLENBQUNlO0lBRXRELHVFQUF1RTtJQUN2RSxJQUFJLENBQUNGLFFBQVFHLE1BQU0sRUFBRTtRQUNuQixNQUFNQyxNQUFNQyxLQUFLRCxHQUFHO1FBQ3BCLE9BQU87WUFDTEUsSUFBSTtZQUNKZixPQUFPO2dCQUFDO2FBQU87WUFDZmdCLFVBQVU7Z0JBQ1JDLFdBQVc7b0JBQUVDLElBQUlMO29CQUFLTSxRQUFRO29CQUFNQyxRQUFRLENBQUM7b0JBQUdDLE9BQU87d0JBQUVDLFFBQVE7b0JBQWdCO2dCQUFFO2dCQUNuRkMsUUFBVztvQkFBRUwsSUFBSUw7b0JBQUtNLFFBQVE7b0JBQU1DLFFBQVEsQ0FBQztvQkFBR0MsT0FBTzt3QkFBRUMsUUFBUTtvQkFBZ0I7Z0JBQUU7WUFDckY7UUFDRjtJQUNGO0lBRUEsNkRBQTZEO0lBQzdELE1BQU1FLE1BQU0sTUFBTXpDLGtFQUFXQSxDQUFDMEI7SUFDOUIsTUFBTWdCLEtBQU16Qyx3RUFBaUJBLENBQUN3QztJQUU5Qiw2Q0FBNkM7SUFDN0MsTUFBTUUsUUFBZ0M7UUFBRUMsTUFBTTtJQUFFO0lBQ2hELE1BQU1DLE1BQWdDO1FBQUVELE1BQU07SUFBRSxHQUFHLGdCQUFnQjtJQUVuRSxLQUFLLE1BQU1FLE9BQU9wQixRQUFTO1FBQ3pCLHFDQUFxQztRQUNyQyxNQUFNcUIsT0FBT0QsSUFBSUUsUUFBUSxDQUFDLFVBQVVGLElBQUlHLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBS0M7UUFDdkQsSUFBSSxDQUFDSCxNQUFNO1FBQ1gsTUFBTUksSUFBSVQsRUFBRSxDQUFDSSxJQUFJO1FBQ2pCLE1BQU1NLE9BQU9ELEdBQUdFLGFBQWEsT0FBT0MsT0FBT0gsRUFBRUUsU0FBUyxJQUFJQyxPQUFPSCxHQUFHSTtRQUNwRSxNQUFNQyxRQUFRTCxHQUFHTSxzQkFBc0IsT0FBT0gsT0FBT0gsRUFBRU0sa0JBQWtCLElBQUlDO1FBRTdFLElBQUlKLE9BQU9LLFFBQVEsQ0FBQ1AsT0FBTztZQUN6QlQsS0FBSyxDQUFDSSxLQUFLLEdBQUdLLE1BQU0sZUFBZTtZQUNuQ1AsR0FBRyxDQUFDRSxLQUFLLEdBQUtPLE9BQU9LLFFBQVEsQ0FBQ0gsU0FBU0EsUUFBUSxHQUFHLHlCQUF5QjtRQUM3RTtJQUNGO0lBRUEsc0RBQXNEO0lBQ3RELE1BQU12QyxRQUFRO1FBQUM7V0FBVzJDLE9BQU9DLElBQUksQ0FBQ2xCLE9BQU9oQixNQUFNLENBQUNtQyxDQUFBQSxJQUFLQSxNQUFNO0tBQVE7SUFFdkUsTUFBTWhDLE1BQU1DLEtBQUtELEdBQUc7SUFFcEIsZ0NBQWdDO0lBQ2hDLE1BQU1JLFlBQWlCO1FBQ3JCQyxJQUFJTDtRQUNKTSxRQUFRO1FBQ1JDLFFBQVFyQixTQUFTQyxPQUFPLENBQUNFLEdBQUdDO1lBQzFCLE1BQU0yQyxLQUFLcEIsS0FBSyxDQUFDeEIsRUFBRSxJQUFLQSxDQUFBQSxNQUFNLFNBQVMsSUFBSXVDLEdBQUU7WUFDN0MsTUFBTU0sS0FBS3JCLEtBQUssQ0FBQ3ZCLEVBQUUsSUFBS0EsQ0FBQUEsTUFBTSxTQUFTLElBQUlzQyxHQUFFO1lBQzdDLElBQUksQ0FBQ0osT0FBT0ssUUFBUSxDQUFDSSxPQUFPLENBQUNULE9BQU9LLFFBQVEsQ0FBQ0ssT0FBT0EsT0FBTyxHQUFHLE9BQU87WUFDckUsT0FBT0QsS0FBS0M7UUFDZDtRQUNBMUIsT0FBTztZQUFFQyxRQUFRO1FBQW9CO0lBQ3ZDO0lBRUEsbUZBQW1GO0lBQ25GLE1BQU1DLFNBQWM7UUFDbEJMLElBQUlMO1FBQ0pNLFFBQVE7UUFDUkMsUUFBUXJCLFNBQVNDLE9BQU8sQ0FBQ0UsR0FBR0M7WUFDMUIsTUFBTTZDLEtBQUs5QyxNQUFNLFNBQVMsSUFBSSxDQUFDMEIsR0FBRyxDQUFDMUIsRUFBRSxJQUFJdUMsR0FBRSxJQUFLO1lBQ2hELE1BQU1RLEtBQUs5QyxNQUFNLFNBQVMsSUFBSSxDQUFDeUIsR0FBRyxDQUFDekIsRUFBRSxJQUFJc0MsR0FBRSxJQUFLO1lBQ2hELElBQUksQ0FBQ0osT0FBT0ssUUFBUSxDQUFDTSxPQUFPLENBQUNYLE9BQU9LLFFBQVEsQ0FBQ08sS0FBSyxPQUFPO1lBQ3pELE1BQU1DLEtBQUssSUFBSUYsSUFBSUcsS0FBSyxJQUFJRjtZQUM1QixJQUFJRSxPQUFPLEdBQUcsT0FBTztZQUNyQixPQUFPLEtBQU1BLEtBQU07UUFDckI7UUFDQTlCLE9BQU87WUFBRUMsUUFBUTtRQUFvQjtJQUN2QztJQUVBLE9BQU87UUFDTFAsSUFBSTtRQUNKZjtRQUNBZ0IsVUFBVTtZQUFFQztZQUFXTTtRQUFPO0lBQ2hDO0FBQ0YiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxjb3JlXFxmZWF0dXJlc1xcbWF0cmljZXNcXGxpdmVGcm9tU291cmNlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29yZS9mZWF0dXJlcy9tYXRyaWNlcy9saXZlRnJvbVNvdXJjZXMudHNcclxuLy8gQnVpbGQgbGl2ZSBiZW5jaG1hcmsgJiBwY3QyNGggdXNpbmcgWU9VUiBiaW5hbmNlLnRzIHdpdGhvdXQgY2hhbmdpbmcgaXQuXHJcbi8vIFdlIHByZS1maWx0ZXIgc3ltYm9scyB3aXRoIGxpc3RTeW1ib2xzQnlRdW90ZSgnVVNEVCcpIHNvIC8yNGhyIGJ1bGsgbmV2ZXIgNDAwcy5cclxuXHJcbmltcG9ydCB7XHJcbiAgbGlzdFN5bWJvbHNCeVF1b3RlLFxyXG4gIGZldGNoMjRoQWxsLFxyXG4gIG1hcFRpY2tlckJ5U3ltYm9sLFxyXG4gIHVzZHRTeW1ib2xzRm9yLFxyXG59IGZyb20gXCJAL2NvcmUvc291cmNlcy9iaW5hbmNlXCI7XHJcblxyXG50eXBlIE1hdFZhbHVlcyA9IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIG51bWJlciB8IG51bGw+PjtcclxudHlwZSBNYXQgPSB7IHRzOiBudW1iZXI7IHByZXZUczogbnVtYmVyIHwgbnVsbDsgdmFsdWVzOiBNYXRWYWx1ZXM7IGZsYWdzPzogYW55IH07XHJcblxyXG5jb25zdCBub3JtQ29pbnMgPSAoeHM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgY29uc3Qgb3V0OiBzdHJpbmdbXSA9IFtdO1xyXG4gIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICBmb3IgKGNvbnN0IHggb2YgeHMpIHtcclxuICAgIGNvbnN0IHUgPSBTdHJpbmcoeCB8fCBcIlwiKS50b1VwcGVyQ2FzZSgpLnRyaW0oKTtcclxuICAgIGlmICghdSB8fCBzZWVuLmhhcyh1KSkgY29udGludWU7XHJcbiAgICBzZWVuLmFkZCh1KTsgb3V0LnB1c2godSk7XHJcbiAgfVxyXG4gIGlmICghc2Vlbi5oYXMoXCJVU0RUXCIpKSBvdXQucHVzaChcIlVTRFRcIik7XHJcbiAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbmNvbnN0IG1ha2VHcmlkID0gPFQgZXh0ZW5kcyBudW1iZXIgfCBudWxsPihjb2luczogc3RyaW5nW10sIGZuOiAoYjpzdHJpbmcscTpzdHJpbmcpPT5UKTogTWF0VmFsdWVzID0+IHtcclxuICBjb25zdCBvdXQ6IE1hdFZhbHVlcyA9IHt9O1xyXG4gIGZvciAoY29uc3QgYiBvZiBjb2lucykge1xyXG4gICAgb3V0W2JdID0ge30gYXMgYW55O1xyXG4gICAgZm9yIChjb25zdCBxIG9mIGNvaW5zKSB7XHJcbiAgICAgIGlmIChiID09PSBxKSBjb250aW51ZTtcclxuICAgICAgb3V0W2JdW3FdID0gZm4oYiwgcSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbGl2ZUZyb21Tb3VyY2VzKHJlcXVlc3RlZENvaW5zOiBzdHJpbmdbXSkge1xyXG4gIC8vIG5vcm1hbGl6ZSArIGVuc3VyZSBVU0RUIHByZXNlbnRcclxuICBjb25zdCBzZWVkID0gbm9ybUNvaW5zKHJlcXVlc3RlZENvaW5zKTtcclxuXHJcbiAgLy8gU3RlcCAxOiBCdWlsZCBkZXNpcmVkIFVTRFQgc3ltYm9scyBmb3Igc2VlZFxyXG4gIGNvbnN0IGRlc2lyZWQgPSB1c2R0U3ltYm9sc0ZvcihzZWVkKTsgLy8gW1wiQlRDVVNEVFwiLFwiRVRIVVNEVFwiLC4uLl1cclxuXHJcbiAgLy8gU3RlcCAyOiBBc2sgQmluYW5jZSB3aGljaCBVU0RUIHN5bWJvbHMgYWN0dWFsbHkgZXhpc3QgKFRSQURJTkcpXHJcbiAgLy8gS2VlcGluZyB0aGlzIGNhbGwgaGVyZSAocmVhZC1vbmx5KSBndWFyYW50ZWVzIG5vIDQwMHMgbGF0ZXIuXHJcbiAgY29uc3QgdHJhZGFibGVTZXQgPSBuZXcgU2V0KGF3YWl0IGxpc3RTeW1ib2xzQnlRdW90ZShcIlVTRFRcIikpO1xyXG5cclxuICAvLyBTdGVwIDM6IEZpbHRlciBkZXNpcmVkIHN5bWJvbHMgZG93biB0byB0aGUgdHJhZGFibGUgc2V0IGJlZm9yZSBjYWxsaW5nIGJ1bGsgMjRoclxuICBjb25zdCBzeW1ib2xzID0gZGVzaXJlZC5maWx0ZXIoKHMpID0+IHRyYWRhYmxlU2V0LmhhcyhzKSk7XG5cclxuICAvLyBJZiBub3RoaW5nIHZhbGlkICh1bmxpa2VseSksIHJldHVybiBhIG1pbmltYWwgcGF5bG9hZCB0byBhdm9pZCA1MDBzLlxyXG4gIGlmICghc3ltYm9scy5sZW5ndGgpIHtcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBvazogdHJ1ZSxcclxuICAgICAgY29pbnM6IFtcIlVTRFRcIl0sXHJcbiAgICAgIG1hdHJpY2VzOiB7XHJcbiAgICAgICAgYmVuY2htYXJrOiB7IHRzOiBub3csIHByZXZUczogbnVsbCwgdmFsdWVzOiB7fSwgZmxhZ3M6IHsgc291cmNlOiBcImJpbmFuY2U6ZW1wdHlcIiB9IH0sXHJcbiAgICAgICAgcGN0MjRoOiAgICB7IHRzOiBub3csIHByZXZUczogbnVsbCwgdmFsdWVzOiB7fSwgZmxhZ3M6IHsgc291cmNlOiBcImJpbmFuY2U6ZW1wdHlcIiB9IH0sXHJcbiAgICAgIH1cclxuICAgIH0gYXMgY29uc3Q7XHJcbiAgfVxyXG5cclxuICAvLyBTdGVwIDQ6IEJ1bGsgZmV0Y2ggb25jZSB1c2luZyB5b3VyIGhlbHBlciAoa2VwdCB1bmNoYW5nZWQpXHJcbiAgY29uc3QgYXJyID0gYXdhaXQgZmV0Y2gyNGhBbGwoc3ltYm9scyk7XHJcbiAgY29uc3QgYnkgID0gbWFwVGlja2VyQnlTeW1ib2woYXJyKTtcclxuXHJcbiAgLy8gU3RlcCA1OiBCdWlsZCBwZXItY29pbiBVU0RUIHByaWNlICYgcGN0MjRoXHJcbiAgY29uc3QgcHJpY2U6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7IFVTRFQ6IDEgfTtcclxuICBjb25zdCBwY3Q6ICAgUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHsgVVNEVDogMCB9OyAvLyBwZXJjZW50IHVuaXRzXHJcblxyXG4gIGZvciAoY29uc3Qgc3ltIG9mIHN5bWJvbHMpIHtcclxuICAgIC8vIHN5bSBsaWtlIFwiQlRDVVNEVFwiIC0+IGNvaW4gPSBcIkJUQ1wiXHJcbiAgICBjb25zdCBjb2luID0gc3ltLmVuZHNXaXRoKFwiVVNEVFwiKSA/IHN5bS5zbGljZSgwLCAtNCkgOiB1bmRlZmluZWQ7XHJcbiAgICBpZiAoIWNvaW4pIGNvbnRpbnVlO1xyXG4gICAgY29uc3QgdCA9IGJ5W3N5bV07XHJcbiAgICBjb25zdCBsYXN0ID0gdD8ubGFzdFByaWNlICE9IG51bGwgPyBOdW1iZXIodC5sYXN0UHJpY2UpIDogTnVtYmVyKHQ/LndlaWdodGVkQXZnUHJpY2UpO1xyXG4gICAgY29uc3QgcGN0MjQgPSB0Py5wcmljZUNoYW5nZVBlcmNlbnQgIT0gbnVsbCA/IE51bWJlcih0LnByaWNlQ2hhbmdlUGVyY2VudCkgOiBOYU47XHJcblxyXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShsYXN0KSkge1xyXG4gICAgICBwcmljZVtjb2luXSA9IGxhc3Q7IC8vIGNvaW4gaW4gVVNEVFxyXG4gICAgICBwY3RbY29pbl0gICA9IE51bWJlci5pc0Zpbml0ZShwY3QyNCkgPyBwY3QyNCA6IDA7IC8vIHN0aWxsIGluIHBlcmNlbnQgdW5pdHNcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEtlZXAgb25seSBjb2lucyB3ZSBhY3R1YWxseSBnb3QgYSBwcmljZSBmb3IgKCtVU0RUKVxyXG4gIGNvbnN0IGNvaW5zID0gW1wiVVNEVFwiLCAuLi5PYmplY3Qua2V5cyhwcmljZSkuZmlsdGVyKGMgPT4gYyAhPT0gXCJVU0RUXCIpXTtcclxuXHJcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgLy8gYmVuY2htYXJrID0gcHJpY2VfYiAvIHByaWNlX3FcclxuICBjb25zdCBiZW5jaG1hcms6IE1hdCA9IHtcclxuICAgIHRzOiBub3csXHJcbiAgICBwcmV2VHM6IG51bGwsXHJcbiAgICB2YWx1ZXM6IG1ha2VHcmlkKGNvaW5zLCAoYiwgcSkgPT4ge1xyXG4gICAgICBjb25zdCBwYiA9IHByaWNlW2JdID8/IChiID09PSBcIlVTRFRcIiA/IDEgOiBOYU4pO1xyXG4gICAgICBjb25zdCBwcSA9IHByaWNlW3FdID8/IChxID09PSBcIlVTRFRcIiA/IDEgOiBOYU4pO1xyXG4gICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShwYikgfHwgIU51bWJlci5pc0Zpbml0ZShwcSkgfHwgcHEgPT09IDApIHJldHVybiBudWxsO1xyXG4gICAgICByZXR1cm4gcGIgLyBwcTtcclxuICAgIH0pLFxyXG4gICAgZmxhZ3M6IHsgc291cmNlOiBcImJpbmFuY2U6dXNkdC1sZWdzXCIgfSxcclxuICB9O1xyXG5cclxuICAvLyBwY3QyNGgocGFpcikgfiAoKDErcmIpLygxK3JxKSkgLSAxLCB3aXRoIHJiL3JxIGFzIERFQ0lNQUxTIGZyb20gcGVyLWNvaW4gcGVyY2VudFxyXG4gIGNvbnN0IHBjdDI0aDogTWF0ID0ge1xyXG4gICAgdHM6IG5vdyxcclxuICAgIHByZXZUczogbnVsbCxcclxuICAgIHZhbHVlczogbWFrZUdyaWQoY29pbnMsIChiLCBxKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJiID0gYiA9PT0gXCJVU0RUXCIgPyAwIDogKHBjdFtiXSA/PyBOYU4pIC8gMTAwO1xyXG4gICAgICBjb25zdCBycSA9IHEgPT09IFwiVVNEVFwiID8gMCA6IChwY3RbcV0gPz8gTmFOKSAvIDEwMDtcclxuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocmIpIHx8ICFOdW1iZXIuaXNGaW5pdGUocnEpKSByZXR1cm4gbnVsbDtcclxuICAgICAgY29uc3QgbmIgPSAxICsgcmIsIG5xID0gMSArIHJxO1xyXG4gICAgICBpZiAobnEgPT09IDApIHJldHVybiBudWxsO1xyXG4gICAgICByZXR1cm4gKG5iIC8gbnEpIC0gMTtcclxuICAgIH0pLFxyXG4gICAgZmxhZ3M6IHsgc291cmNlOiBcImJpbmFuY2U6dXNkdC1sZWdzXCIgfSxcclxuICB9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgb2s6IHRydWUsXHJcbiAgICBjb2lucyxcclxuICAgIG1hdHJpY2VzOiB7IGJlbmNobWFyaywgcGN0MjRoIH0sXHJcbiAgfSBhcyBjb25zdDtcclxufVxyXG5cclxuIl0sIm5hbWVzIjpbImxpc3RTeW1ib2xzQnlRdW90ZSIsImZldGNoMjRoQWxsIiwibWFwVGlja2VyQnlTeW1ib2wiLCJ1c2R0U3ltYm9sc0ZvciIsIm5vcm1Db2lucyIsInhzIiwib3V0Iiwic2VlbiIsIlNldCIsIngiLCJ1IiwiU3RyaW5nIiwidG9VcHBlckNhc2UiLCJ0cmltIiwiaGFzIiwiYWRkIiwicHVzaCIsIm1ha2VHcmlkIiwiY29pbnMiLCJmbiIsImIiLCJxIiwibGl2ZUZyb21Tb3VyY2VzIiwicmVxdWVzdGVkQ29pbnMiLCJzZWVkIiwiZGVzaXJlZCIsInRyYWRhYmxlU2V0Iiwic3ltYm9scyIsImZpbHRlciIsInMiLCJsZW5ndGgiLCJub3ciLCJEYXRlIiwib2siLCJtYXRyaWNlcyIsImJlbmNobWFyayIsInRzIiwicHJldlRzIiwidmFsdWVzIiwiZmxhZ3MiLCJzb3VyY2UiLCJwY3QyNGgiLCJhcnIiLCJieSIsInByaWNlIiwiVVNEVCIsInBjdCIsInN5bSIsImNvaW4iLCJlbmRzV2l0aCIsInNsaWNlIiwidW5kZWZpbmVkIiwidCIsImxhc3QiLCJsYXN0UHJpY2UiLCJOdW1iZXIiLCJ3ZWlnaHRlZEF2Z1ByaWNlIiwicGN0MjQiLCJwcmljZUNoYW5nZVBlcmNlbnQiLCJOYU4iLCJpc0Zpbml0ZSIsIk9iamVjdCIsImtleXMiLCJjIiwicGIiLCJwcSIsInJiIiwicnEiLCJuYiIsIm5xIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/matrices/liveFromSources.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/matrices/opening.ts":
/*!***********************************************!*\
  !*** ./src/core/features/matrices/opening.ts ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchOpeningGridFromView: () => (/* binding */ fetchOpeningGridFromView),\n/* harmony export */   getOpeningPairValue: () => (/* binding */ getOpeningPairValue)\n/* harmony export */ });\n/* harmony import */ var _core_db_db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/db/db */ \"(rsc)/./src/core/db/db.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_db_db__WEBPACK_IMPORTED_MODULE_0__]);\n_core_db_db__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n// src/core/features/matrices/opening.ts\n// Opening grid helper backed by market.klines (Binance-ingested data).\n\nconst makeGrid = (n)=>Array.from({\n        length: n\n    }, ()=>Array(n).fill(null));\nconst DEFAULT_WINDOW = \"1h\";\n// Optional helper: pull opening timestamp from strategy helper when available.\nasync function resolveOpeningTs(appSessionId, window) {\n    try {\n        const { rows } = await _core_db_db__WEBPACK_IMPORTED_MODULE_0__.db.query(`select ts_ms from get_session_opening_ts($1::text, $2::text) limit 1`, [\n            appSessionId ?? null,\n            window\n        ]);\n        if (rows?.[0]?.ts_ms) return Number(rows[0].ts_ms);\n    } catch  {\n    // helper may not exist; swallow.\n    }\n    return null;\n}\nasync function fetchOpeningGridFromView(args) {\n    const coins = Array.from(new Set(args.coins.map((c)=>c.toUpperCase())));\n    const n = coins.length;\n    const windowLabel = (args.window ?? DEFAULT_WINDOW).toLowerCase();\n    const pivot = (args.quote ?? \"USDT\").toUpperCase();\n    let openingTs = args.openingTs ?? null;\n    if (!openingTs) {\n        openingTs = await resolveOpeningTs(args.appSessionId ?? null, windowLabel);\n    }\n    const grid = makeGrid(n);\n    if (!n) {\n        return {\n            ts: openingTs ?? 0,\n            grid\n        };\n    }\n    const targetSymbols = new Set();\n    for (const coin of coins){\n        if (coin === pivot) continue;\n        targetSymbols.add(`${coin}${pivot}`);\n        targetSymbols.add(`${pivot}${coin}`);\n    }\n    if (!targetSymbols.size) {\n        return {\n            ts: openingTs ?? 0,\n            grid\n        };\n    }\n    const startDate = openingTs != null ? new Date(openingTs) : null;\n    const candidateWindows = Array.from(new Set([\n        windowLabel,\n        \"1m\"\n    ]));\n    const { rows } = await _core_db_db__WEBPACK_IMPORTED_MODULE_0__.db.query(`\n    SELECT\n      k.symbol,\n      (public._split_symbol(k.symbol)).base AS base,\n      (public._split_symbol(k.symbol)).quote AS quote,\n      k.close_price,\n      k.close_time,\n      k.window_label\n    FROM market.klines k\n    WHERE k.symbol = ANY($1::text[])\n      AND k.window_label = ANY($2::text[])\n      AND ($3::timestamptz IS NULL OR k.close_time >= $3::timestamptz)\n    ORDER BY\n      k.symbol,\n      CASE WHEN k.window_label = $4 THEN 0 ELSE 1 END,\n      k.close_time ASC\n    `, [\n        Array.from(targetSymbols),\n        candidateWindows,\n        startDate,\n        windowLabel\n    ]);\n    const seen = new Set();\n    let effectiveTs = openingTs ?? 0;\n    const priceMap = new Map();\n    priceMap.set(pivot, 1);\n    for (const row of rows){\n        const symbol = String(row.symbol ?? \"\").toUpperCase();\n        if (!symbol || seen.has(symbol)) continue;\n        const base = String(row.base ?? \"\").toUpperCase();\n        const quote = String(row.quote ?? \"\").toUpperCase();\n        const price = Number(row.close_price);\n        if (!Number.isFinite(price)) continue;\n        if (quote === pivot) {\n            priceMap.set(base, price);\n        } else if (base === pivot && Math.abs(price) > 1e-12) {\n            priceMap.set(quote, 1 / price);\n        } else {\n            continue;\n        }\n        seen.add(symbol);\n        const tsMs = Date.parse(row.close_time);\n        if (Number.isFinite(tsMs) && tsMs > effectiveTs) {\n            effectiveTs = tsMs;\n        }\n    }\n    for(let i = 0; i < n; i++){\n        const baseCoin = coins[i];\n        const basePrice = priceMap.get(baseCoin) ?? null;\n        for(let j = 0; j < n; j++){\n            if (i === j) continue;\n            const quoteCoin = coins[j];\n            const quotePrice = priceMap.get(quoteCoin) ?? null;\n            if (basePrice != null && quotePrice != null && Number.isFinite(basePrice) && Number.isFinite(quotePrice) && Math.abs(quotePrice) > 1e-12) {\n                grid[i][j] = basePrice / quotePrice;\n            } else {\n                grid[i][j] = null;\n            }\n        }\n    }\n    return {\n        ts: effectiveTs,\n        grid\n    };\n}\nasync function getOpeningPairValue(args) {\n    const { base, quote } = args;\n    const { grid, ts } = await fetchOpeningGridFromView({\n        coins: [\n            base.toUpperCase(),\n            quote.toUpperCase()\n        ],\n        quote: quote.toUpperCase(),\n        appSessionId: args.appSessionId ?? null,\n        window: args.window ?? DEFAULT_WINDOW,\n        openingTs: args.openingTs\n    });\n    return {\n        ts,\n        price: grid?.[0]?.[1] ?? null\n    };\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9tYXRyaWNlcy9vcGVuaW5nLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLHdDQUF3QztBQUN4Qyx1RUFBdUU7QUFFckM7QUFXbEMsTUFBTUMsV0FBVyxDQUFDQyxJQUNoQkMsTUFBTUMsSUFBSSxDQUFDO1FBQUVDLFFBQVFIO0lBQUUsR0FBRyxJQUFNQyxNQUFNRCxHQUFHSSxJQUFJLENBQUM7QUFFaEQsTUFBTUMsaUJBQWlCO0FBRXZCLCtFQUErRTtBQUMvRSxlQUFlQyxpQkFDYkMsWUFBdUMsRUFDdkNDLE1BQWM7SUFFZCxJQUFJO1FBQ0YsTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBRyxNQUFNWCwyQ0FBRUEsQ0FBQ1ksS0FBSyxDQUM3QixDQUFDLG9FQUFvRSxDQUFDLEVBQ3RFO1lBQUNILGdCQUFnQjtZQUFNQztTQUFPO1FBRWhDLElBQUlDLE1BQU0sQ0FBQyxFQUFFLEVBQUVFLE9BQU8sT0FBT0MsT0FBT0gsSUFBSSxDQUFDLEVBQUUsQ0FBQ0UsS0FBSztJQUNuRCxFQUFFLE9BQU07SUFDTixpQ0FBaUM7SUFDbkM7SUFDQSxPQUFPO0FBQ1Q7QUFFTyxlQUFlRSx5QkFDcEJDLElBQWlCO0lBRWpCLE1BQU1DLFFBQVFkLE1BQU1DLElBQUksQ0FBQyxJQUFJYyxJQUFJRixLQUFLQyxLQUFLLENBQUNFLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxFQUFFQyxXQUFXO0lBQ3BFLE1BQU1uQixJQUFJZSxNQUFNWixNQUFNO0lBQ3RCLE1BQU1pQixjQUFjLENBQUNOLEtBQUtOLE1BQU0sSUFBSUgsY0FBYSxFQUFHZ0IsV0FBVztJQUMvRCxNQUFNQyxRQUFRLENBQUNSLEtBQUtTLEtBQUssSUFBSSxNQUFLLEVBQUdKLFdBQVc7SUFFaEQsSUFBSUssWUFBWVYsS0FBS1UsU0FBUyxJQUFJO0lBQ2xDLElBQUksQ0FBQ0EsV0FBVztRQUNkQSxZQUFZLE1BQU1sQixpQkFBaUJRLEtBQUtQLFlBQVksSUFBSSxNQUFNYTtJQUNo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O1FBQ0Y7SUFDRjtJQUVBLE9BQU87UUFBRTlCLElBQUlTO1FBQWFWO0lBQUs7QUFDakM7QUFFTyxlQUFla0Msb0JBQW9CN0MsSUFNekM7SUFDQyxNQUFNLEVBQUU2QixJQUFJLEVBQUVwQixLQUFLLEVBQUUsR0FBR1Q7SUFDeEIsTUFBTSxFQUFFVyxJQUFJLEVBQUVDLEVBQUUsRUFBRSxHQUFHLE1BQU1iLHlCQUF5QjtRQUNsREUsT0FBTztZQUFDNEIsS0FBS3hCLFdBQVc7WUFBSUksTUFBTUosV0FBVztTQUFHO1FBQ2hESSxPQUFPQSxNQUFNSixXQUFXO1FBQ3hCWixjQUFjTyxLQUFLUCxZQUFZLElBQUk7UUFDbkNDLFFBQVFNLEtBQUtOLE1BQU0sSUFBSUg7UUFDdkJtQixXQUFXVixLQUFLVSxTQUFTO0lBQzNCO0lBQ0EsT0FBTztRQUFFRTtRQUFJa0IsT0FBT25CLE1BQU0sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLElBQUk7SUFBSztBQUM3QyIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGNvcmVcXGZlYXR1cmVzXFxtYXRyaWNlc1xcb3BlbmluZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29yZS9mZWF0dXJlcy9tYXRyaWNlcy9vcGVuaW5nLnRzXG4vLyBPcGVuaW5nIGdyaWQgaGVscGVyIGJhY2tlZCBieSBtYXJrZXQua2xpbmVzIChCaW5hbmNlLWluZ2VzdGVkIGRhdGEpLlxuXG5pbXBvcnQgeyBkYiB9IGZyb20gXCJAL2NvcmUvZGIvZGJcIjtcblxuZXhwb3J0IHR5cGUgT3BlbmluZ0FyZ3MgPSB7XG4gIGNvaW5zOiBzdHJpbmdbXTsgICAgICAgICAgIC8vIHVwcGVyY2FzZSBjb2luIHVuaXZlcnNlXG4gIHF1b3RlPzogc3RyaW5nOyAgICAgICAgICAgIC8vIGRlZmF1bHQgXCJVU0RUXCJcbiAgYXBwU2Vzc2lvbklkPzogc3RyaW5nIHwgbnVsbDtcbiAgd2luZG93Pzogc3RyaW5nOyAgICAgICAgICAgLy8gZS5nLiBcIjFoXCJcbiAgb3BlbmluZ1RzPzogbnVtYmVyOyAgICAgICAgLy8gb3B0aW9uYWwgb3ZlcnJpZGUgKG1zKVxufTtcblxudHlwZSBHcmlkID0gKG51bWJlciB8IG51bGwpW11bXTtcbmNvbnN0IG1ha2VHcmlkID0gKG46IG51bWJlcikgPT5cbiAgQXJyYXkuZnJvbSh7IGxlbmd0aDogbiB9LCAoKSA9PiBBcnJheShuKS5maWxsKG51bGwgYXMgbnVtYmVyIHwgbnVsbCkpO1xuXG5jb25zdCBERUZBVUxUX1dJTkRPVyA9IFwiMWhcIjtcblxuLy8gT3B0aW9uYWwgaGVscGVyOiBwdWxsIG9wZW5pbmcgdGltZXN0YW1wIGZyb20gc3RyYXRlZ3kgaGVscGVyIHdoZW4gYXZhaWxhYmxlLlxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZU9wZW5pbmdUcyhcbiAgYXBwU2Vzc2lvbklkOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkLFxuICB3aW5kb3c6IHN0cmluZ1xuKTogUHJvbWlzZTxudW1iZXIgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyByb3dzIH0gPSBhd2FpdCBkYi5xdWVyeTx7IHRzX21zOiBzdHJpbmcgfT4oXG4gICAgICBgc2VsZWN0IHRzX21zIGZyb20gZ2V0X3Nlc3Npb25fb3BlbmluZ190cygkMTo6dGV4dCwgJDI6OnRleHQpIGxpbWl0IDFgLFxuICAgICAgW2FwcFNlc3Npb25JZCA/PyBudWxsLCB3aW5kb3ddXG4gICAgKTtcbiAgICBpZiAocm93cz8uWzBdPy50c19tcykgcmV0dXJuIE51bWJlcihyb3dzWzBdLnRzX21zKTtcbiAgfSBjYXRjaCB7XG4gICAgLy8gaGVscGVyIG1heSBub3QgZXhpc3Q7IHN3YWxsb3cuXG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaE9wZW5pbmdHcmlkRnJvbVZpZXcoXG4gIGFyZ3M6IE9wZW5pbmdBcmdzXG4pOiBQcm9taXNlPHsgdHM6IG51bWJlcjsgZ3JpZDogR3JpZCB9PiB7XG4gIGNvbnN0IGNvaW5zID0gQXJyYXkuZnJvbShuZXcgU2V0KGFyZ3MuY29pbnMubWFwKChjKSA9PiBjLnRvVXBwZXJDYXNlKCkpKSk7XG4gIGNvbnN0IG4gPSBjb2lucy5sZW5ndGg7XG4gIGNvbnN0IHdpbmRvd0xhYmVsID0gKGFyZ3Mud2luZG93ID8/IERFRkFVTFRfV0lORE9XKS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBwaXZvdCA9IChhcmdzLnF1b3RlID8/IFwiVVNEVFwiKS50b1VwcGVyQ2FzZSgpO1xuXG4gIGxldCBvcGVuaW5nVHMgPSBhcmdzLm9wZW5pbmdUcyA/PyBudWxsO1xuICBpZiAoIW9wZW5pbmdUcykge1xuICAgIG9wZW5pbmdUcyA9IGF3YWl0IHJlc29sdmVPcGVuaW5nVHMoYXJncy5hcHBTZXNzaW9uSWQgPz8gbnVsbCwgd2luZG93TGFiZWwpO1xuICB9XG5cbiAgY29uc3QgZ3JpZCA9IG1ha2VHcmlkKG4pO1xuICBpZiAoIW4pIHtcbiAgICByZXR1cm4geyB0czogb3BlbmluZ1RzID8/IDAsIGdyaWQgfTtcbiAgfVxuXG4gIGNvbnN0IHRhcmdldFN5bWJvbHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgZm9yIChjb25zdCBjb2luIG9mIGNvaW5zKSB7XG4gICAgaWYgKGNvaW4gPT09IHBpdm90KSBjb250aW51ZTtcbiAgICB0YXJnZXRTeW1ib2xzLmFkZChgJHtjb2lufSR7cGl2b3R9YCk7XG4gICAgdGFyZ2V0U3ltYm9scy5hZGQoYCR7cGl2b3R9JHtjb2lufWApO1xuICB9XG5cbiAgaWYgKCF0YXJnZXRTeW1ib2xzLnNpemUpIHtcbiAgICByZXR1cm4geyB0czogb3BlbmluZ1RzID8/IDAsIGdyaWQgfTtcbiAgfVxuXG4gIGNvbnN0IHN0YXJ0RGF0ZSA9IG9wZW5pbmdUcyAhPSBudWxsID8gbmV3IERhdGUob3BlbmluZ1RzKSA6IG51bGw7XG4gIGNvbnN0IGNhbmRpZGF0ZVdpbmRvd3MgPSBBcnJheS5mcm9tKG5ldyBTZXQoW3dpbmRvd0xhYmVsLCBcIjFtXCJdKSk7XG5cbiAgY29uc3QgeyByb3dzIH0gPSBhd2FpdCBkYi5xdWVyeTx7XG4gICAgc3ltYm9sOiBzdHJpbmc7XG4gICAgYmFzZTogc3RyaW5nIHwgbnVsbDtcbiAgICBxdW90ZTogc3RyaW5nIHwgbnVsbDtcbiAgICBjbG9zZV9wcmljZTogc3RyaW5nO1xuICAgIGNsb3NlX3RpbWU6IHN0cmluZztcbiAgICB3aW5kb3dfbGFiZWw6IHN0cmluZztcbiAgfT4oXG4gICAgYFxuICAgIFNFTEVDVFxuICAgICAgay5zeW1ib2wsXG4gICAgICAocHVibGljLl9zcGxpdF9zeW1ib2woay5zeW1ib2wpKS5iYXNlIEFTIGJhc2UsXG4gICAgICAocHVibGljLl9zcGxpdF9zeW1ib2woay5zeW1ib2wpKS5xdW90ZSBBUyBxdW90ZSxcbiAgICAgIGsuY2xvc2VfcHJpY2UsXG4gICAgICBrLmNsb3NlX3RpbWUsXG4gICAgICBrLndpbmRvd19sYWJlbFxuICAgIEZST00gbWFya2V0LmtsaW5lcyBrXG4gICAgV0hFUkUgay5zeW1ib2wgPSBBTlkoJDE6OnRleHRbXSlcbiAgICAgIEFORCBrLndpbmRvd19sYWJlbCA9IEFOWSgkMjo6dGV4dFtdKVxuICAgICAgQU5EICgkMzo6dGltZXN0YW1wdHogSVMgTlVMTCBPUiBrLmNsb3NlX3RpbWUgPj0gJDM6OnRpbWVzdGFtcHR6KVxuICAgIE9SREVSIEJZXG4gICAgICBrLnN5bWJvbCxcbiAgICAgIENBU0UgV0hFTiBrLndpbmRvd19sYWJlbCA9ICQ0IFRIRU4gMCBFTFNFIDEgRU5ELFxuICAgICAgay5jbG9zZV90aW1lIEFTQ1xuICAgIGAsXG4gICAgW0FycmF5LmZyb20odGFyZ2V0U3ltYm9scyksIGNhbmRpZGF0ZVdpbmRvd3MsIHN0YXJ0RGF0ZSwgd2luZG93TGFiZWxdXG4gICk7XG5cbiAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBsZXQgZWZmZWN0aXZlVHMgPSBvcGVuaW5nVHMgPz8gMDtcbiAgY29uc3QgcHJpY2VNYXAgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuICBwcmljZU1hcC5zZXQocGl2b3QsIDEpO1xuXG4gIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICBjb25zdCBzeW1ib2wgPSBTdHJpbmcocm93LnN5bWJvbCA/PyBcIlwiKS50b1VwcGVyQ2FzZSgpO1xuICAgIGlmICghc3ltYm9sIHx8IHNlZW4uaGFzKHN5bWJvbCkpIGNvbnRpbnVlO1xuICAgIGNvbnN0IGJhc2UgPSBTdHJpbmcocm93LmJhc2UgPz8gXCJcIikudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBxdW90ZSA9IFN0cmluZyhyb3cucXVvdGUgPz8gXCJcIikudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBwcmljZSA9IE51bWJlcihyb3cuY2xvc2VfcHJpY2UpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHByaWNlKSkgY29udGludWU7XG5cbiAgICBpZiAocXVvdGUgPT09IHBpdm90KSB7XG4gICAgICBwcmljZU1hcC5zZXQoYmFzZSwgcHJpY2UpO1xuICAgIH0gZWxzZSBpZiAoYmFzZSA9PT0gcGl2b3QgJiYgTWF0aC5hYnMocHJpY2UpID4gMWUtMTIpIHtcbiAgICAgIHByaWNlTWFwLnNldChxdW90ZSwgMSAvIHByaWNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc2Vlbi5hZGQoc3ltYm9sKTtcblxuICAgIGNvbnN0IHRzTXMgPSBEYXRlLnBhcnNlKHJvdy5jbG9zZV90aW1lKTtcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHRzTXMpICYmIHRzTXMgPiBlZmZlY3RpdmVUcykge1xuICAgICAgZWZmZWN0aXZlVHMgPSB0c01zO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgY29uc3QgYmFzZUNvaW4gPSBjb2luc1tpXSE7XG4gICAgY29uc3QgYmFzZVByaWNlID0gcHJpY2VNYXAuZ2V0KGJhc2VDb2luKSA/PyBudWxsO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICBpZiAoaSA9PT0gaikgY29udGludWU7XG4gICAgICBjb25zdCBxdW90ZUNvaW4gPSBjb2luc1tqXSE7XG4gICAgICBjb25zdCBxdW90ZVByaWNlID0gcHJpY2VNYXAuZ2V0KHF1b3RlQ29pbikgPz8gbnVsbDtcbiAgICAgIGlmIChcbiAgICAgICAgYmFzZVByaWNlICE9IG51bGwgJiZcbiAgICAgICAgcXVvdGVQcmljZSAhPSBudWxsICYmXG4gICAgICAgIE51bWJlci5pc0Zpbml0ZShiYXNlUHJpY2UpICYmXG4gICAgICAgIE51bWJlci5pc0Zpbml0ZShxdW90ZVByaWNlKSAmJlxuICAgICAgICBNYXRoLmFicyhxdW90ZVByaWNlKSA+IDFlLTEyXG4gICAgICApIHtcbiAgICAgICAgZ3JpZFtpXVtqXSA9IGJhc2VQcmljZSAvIHF1b3RlUHJpY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncmlkW2ldW2pdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4geyB0czogZWZmZWN0aXZlVHMsIGdyaWQgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9wZW5pbmdQYWlyVmFsdWUoYXJnczoge1xuICBiYXNlOiBzdHJpbmc7XG4gIHF1b3RlOiBzdHJpbmc7XG4gIGFwcFNlc3Npb25JZD86IHN0cmluZyB8IG51bGw7XG4gIHdpbmRvdz86IHN0cmluZztcbiAgb3BlbmluZ1RzPzogbnVtYmVyO1xufSk6IFByb21pc2U8eyB0czogbnVtYmVyIHwgbnVsbDsgcHJpY2U6IG51bWJlciB8IG51bGwgfT4ge1xuICBjb25zdCB7IGJhc2UsIHF1b3RlIH0gPSBhcmdzO1xuICBjb25zdCB7IGdyaWQsIHRzIH0gPSBhd2FpdCBmZXRjaE9wZW5pbmdHcmlkRnJvbVZpZXcoe1xuICAgIGNvaW5zOiBbYmFzZS50b1VwcGVyQ2FzZSgpLCBxdW90ZS50b1VwcGVyQ2FzZSgpXSxcbiAgICBxdW90ZTogcXVvdGUudG9VcHBlckNhc2UoKSxcbiAgICBhcHBTZXNzaW9uSWQ6IGFyZ3MuYXBwU2Vzc2lvbklkID8/IG51bGwsXG4gICAgd2luZG93OiBhcmdzLndpbmRvdyA/PyBERUZBVUxUX1dJTkRPVyxcbiAgICBvcGVuaW5nVHM6IGFyZ3Mub3BlbmluZ1RzLFxuICB9KTtcbiAgcmV0dXJuIHsgdHMsIHByaWNlOiBncmlkPy5bMF0/LlsxXSA/PyBudWxsIH07XG59XG4iXSwibmFtZXMiOlsiZGIiLCJtYWtlR3JpZCIsIm4iLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJmaWxsIiwiREVGQVVMVF9XSU5ET1ciLCJyZXNvbHZlT3BlbmluZ1RzIiwiYXBwU2Vzc2lvbklkIiwid2luZG93Iiwicm93cyIsInF1ZXJ5IiwidHNfbXMiLCJOdW1iZXIiLCJmZXRjaE9wZW5pbmdHcmlkRnJvbVZpZXciLCJhcmdzIiwiY29pbnMiLCJTZXQiLCJtYXAiLCJjIiwidG9VcHBlckNhc2UiLCJ3aW5kb3dMYWJlbCIsInRvTG93ZXJDYXNlIiwicGl2b3QiLCJxdW90ZSIsIm9wZW5pbmdUcyIsImdyaWQiLCJ0cyIsInRhcmdldFN5bWJvbHMiLCJjb2luIiwiYWRkIiwic2l6ZSIsInN0YXJ0RGF0ZSIsIkRhdGUiLCJjYW5kaWRhdGVXaW5kb3dzIiwic2VlbiIsImVmZmVjdGl2ZVRzIiwicHJpY2VNYXAiLCJNYXAiLCJzZXQiLCJyb3ciLCJzeW1ib2wiLCJTdHJpbmciLCJoYXMiLCJiYXNlIiwicHJpY2UiLCJjbG9zZV9wcmljZSIsImlzRmluaXRlIiwiTWF0aCIsImFicyIsInRzTXMiLCJwYXJzZSIsImNsb3NlX3RpbWUiLCJpIiwiYmFzZUNvaW4iLCJiYXNlUHJpY2UiLCJnZXQiLCJqIiwicXVvdGVDb2luIiwicXVvdGVQcmljZSIsImdldE9wZW5pbmdQYWlyVmFsdWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/matrices/opening.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/moo-aux/grid.ts":
/*!*******************************************!*\
  !*** ./src/core/features/moo-aux/grid.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildMeaAux: () => (/* binding */ buildMeaAux),\n/* harmony export */   pickTierName: () => (/* binding */ pickTierName),\n/* harmony export */   toRenderableRows: () => (/* binding */ toRenderableRows)\n/* harmony export */ });\n/* harmony import */ var _tiers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tiers */ \"(rsc)/./src/core/features/moo-aux/tiers.ts\");\n// PATCH: src/core/features/moo-aux/grid.ts\n\nfunction pickTierName(idp, rules = _tiers__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TIER_RULES) {\n    const a = Math.abs(Number(idp || 0));\n    const r = rules.find((r)=>a >= r.minAbs && (r.maxAbs == null || a <= r.maxAbs));\n    return r?.name;\n}\nfunction buildMeaAux(params) {\n    const { coins, idPct, balances, coverage, rules = _tiers__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TIER_RULES } = params;\n    const k = Math.max(1, params.k ?? coins.length - 1);\n    const mood = Number.isFinite(params.moodCoeff ?? 1) ? params.moodCoeff : 1;\n    const out = {};\n    for (const base of coins){\n        const avail = balances[base] ?? 0;\n        const row = {};\n        for (const quote of coins){\n            if (quote === base) {\n                row[quote] = null;\n                continue;\n            }\n            if (coverage && coverage[base] && coverage[base][quote] === false) {\n                row[quote] = null;\n                continue;\n            }\n            const idp = idPct?.[base]?.[quote];\n            const w = (0,_tiers__WEBPACK_IMPORTED_MODULE_0__.getTierWeighting)(Number(idp ?? 0), rules); // legacy bin weight\n            const cell = avail * (1 / k) * w * mood; // APPLY mood here\n            row[quote] = Number.isFinite(cell) ? cell : 0;\n        }\n        out[base] = row;\n    }\n    return out;\n}\n// ...rest unchanged...\nfunction toRenderableRows(mea) {\n// keeps your existing shape (no change needed)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9tb28tYXV4L2dyaWQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLDJDQUEyQztBQUVvQjtBQU94RCxTQUFTRSxhQUFhQyxHQUFXLEVBQUVDLFFBQW9CSixzREFBa0I7SUFDOUUsTUFBTUssSUFBSUMsS0FBS0MsR0FBRyxDQUFDQyxPQUFPTCxPQUFPO0lBQ2pDLE1BQU1NLElBQUlMLE1BQU1NLElBQUksQ0FBQ0QsQ0FBQUEsSUFBS0osS0FBS0ksRUFBRUUsTUFBTSxJQUFLRixDQUFBQSxFQUFFRyxNQUFNLElBQUksUUFBUVAsS0FBS0ksRUFBRUcsTUFBTTtJQUM3RSxPQUFPSCxHQUFHSTtBQUNaO0FBRU8sU0FBU0MsWUFBWUMsTUFRM0I7SUFDQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLFFBQVEsRUFBRWYsUUFBUUosc0RBQWtCLEVBQUUsR0FBR2U7SUFDekUsTUFBTUssSUFBSWQsS0FBS2UsR0FBRyxDQUFDLEdBQUdOLE9BQU9LLENBQUMsSUFBSUosTUFBTU0sTUFBTSxHQUFHO0lBQ2pELE1BQU1DLE9BQU9mLE9BQU9nQixRQUFRLENBQUNULE9BQU9VLFNBQVMsSUFBSSxLQUFNVixPQUFPVSxTQUFTLEdBQWM7SUFFckYsTUFBTUMsTUFBa0IsQ0FBQztJQUN6QixLQUFLLE1BQU1DLFFBQVFYLE1BQU87UUFDeEIsTUFBTVksUUFBUVYsUUFBUSxDQUFDUyxLQUFLLElBQUk7UUFDaEMsTUFBTUUsTUFBcUMsQ0FBQztRQUM1QyxLQUFLLE1BQU1DLFNBQVNkLE1BQU87WUFDekIsSUFBSWMsVUFBVUgsTUFBTTtnQkFBRUUsR0FBRyxDQUFDQyxNQUFNLEdBQUc7Z0JBQU07WUFBVTtZQUNuRCxJQUFJWCxZQUFZQSxRQUFRLENBQUNRLEtBQUssSUFBSVIsUUFBUSxDQUFDUSxLQUFLLENBQUNHLE1BQU0sS0FBSyxPQUFPO2dCQUFFRCxHQUFHLENBQUNDLE1BQU0sR0FBRztnQkFBTTtZQUFVO1lBRWxHLE1BQU0zQixNQUFNYyxPQUFPLENBQUNVLEtBQUssRUFBRSxDQUFDRyxNQUFNO1lBQ2xDLE1BQU1DLElBQUk5Qix3REFBZ0JBLENBQUNPLE9BQU9MLE9BQU8sSUFBSUMsUUFBUSxvQkFBb0I7WUFDekUsTUFBTTRCLE9BQU9KLFFBQVMsS0FBSVIsQ0FBQUEsSUFBS1csSUFBSVIsTUFBTSxrQkFBa0I7WUFDM0RNLEdBQUcsQ0FBQ0MsTUFBTSxHQUFHdEIsT0FBT2dCLFFBQVEsQ0FBQ1EsUUFBUUEsT0FBTztRQUM5QztRQUNBTixHQUFHLENBQUNDLEtBQUssR0FBR0U7SUFDZDtJQUNBLE9BQU9IO0FBQ1Q7QUFFQSx1QkFBdUI7QUFFaEIsU0FBU08saUJBQWlCQyxHQUs5QjtBQUNELCtDQUErQztBQUNqRCIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGNvcmVcXGZlYXR1cmVzXFxtb28tYXV4XFxncmlkLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBBVENIOiBzcmMvY29yZS9mZWF0dXJlcy9tb28tYXV4L2dyaWQudHNcclxuaW1wb3J0IHR5cGUgeyBUaWVyUnVsZSB9IGZyb20gXCIuL3RpZXJzXCI7XHJcbmltcG9ydCB7IERFRkFVTFRfVElFUl9SVUxFUywgZ2V0VGllcldlaWdodGluZyB9IGZyb20gXCIuL3RpZXJzXCI7XHJcblxyXG5leHBvcnQgdHlwZSBJZFBjdEdyaWQgPSBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBudW1iZXIgfCBudWxsPj47XHJcbmV4cG9ydCB0eXBlIEJhbGFuY2VzTWFwID0gUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcclxuZXhwb3J0IHR5cGUgTWVhQXV4R3JpZCA9IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIG51bWJlciB8IG51bGw+PjtcclxuZXhwb3J0IHR5cGUgTWVhUGFpciA9IHsgYmFzZTogc3RyaW5nOyBxdW90ZTogc3RyaW5nOyB2YWx1ZTogbnVtYmVyOyBmcm96ZW4/OiBib29sZWFuIH07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcGlja1RpZXJOYW1lKGlkcDogbnVtYmVyLCBydWxlczogVGllclJ1bGVbXSA9IERFRkFVTFRfVElFUl9SVUxFUyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcbiAgY29uc3QgYSA9IE1hdGguYWJzKE51bWJlcihpZHAgfHwgMCkpO1xyXG4gIGNvbnN0IHIgPSBydWxlcy5maW5kKHIgPT4gYSA+PSByLm1pbkFicyAmJiAoci5tYXhBYnMgPT0gbnVsbCB8fCBhIDw9IHIubWF4QWJzKSk7XHJcbiAgcmV0dXJuIHI/Lm5hbWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBidWlsZE1lYUF1eChwYXJhbXM6IHtcclxuICBjb2luczogc3RyaW5nW107XHJcbiAgaWRQY3Q6IElkUGN0R3JpZDtcclxuICBiYWxhbmNlczogQmFsYW5jZXNNYXA7XHJcbiAgaz86IG51bWJlcjtcclxuICBydWxlcz86IFRpZXJSdWxlW107XHJcbiAgY292ZXJhZ2U/OiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPj47XHJcbiAgbW9vZENvZWZmPzogbnVtYmVyOyAvLyBORVdcclxufSk6IE1lYUF1eEdyaWQge1xyXG4gIGNvbnN0IHsgY29pbnMsIGlkUGN0LCBiYWxhbmNlcywgY292ZXJhZ2UsIHJ1bGVzID0gREVGQVVMVF9USUVSX1JVTEVTIH0gPSBwYXJhbXM7XHJcbiAgY29uc3QgayA9IE1hdGgubWF4KDEsIHBhcmFtcy5rID8/IGNvaW5zLmxlbmd0aCAtIDEpO1xyXG4gIGNvbnN0IG1vb2QgPSBOdW1iZXIuaXNGaW5pdGUocGFyYW1zLm1vb2RDb2VmZiA/PyAxKSA/IChwYXJhbXMubW9vZENvZWZmIGFzIG51bWJlcikgOiAxO1xyXG5cclxuICBjb25zdCBvdXQ6IE1lYUF1eEdyaWQgPSB7fTtcclxuICBmb3IgKGNvbnN0IGJhc2Ugb2YgY29pbnMpIHtcclxuICAgIGNvbnN0IGF2YWlsID0gYmFsYW5jZXNbYmFzZV0gPz8gMDtcclxuICAgIGNvbnN0IHJvdzogUmVjb3JkPHN0cmluZywgbnVtYmVyIHwgbnVsbD4gPSB7fTtcclxuICAgIGZvciAoY29uc3QgcXVvdGUgb2YgY29pbnMpIHtcclxuICAgICAgaWYgKHF1b3RlID09PSBiYXNlKSB7IHJvd1txdW90ZV0gPSBudWxsOyBjb250aW51ZTsgfVxyXG4gICAgICBpZiAoY292ZXJhZ2UgJiYgY292ZXJhZ2VbYmFzZV0gJiYgY292ZXJhZ2VbYmFzZV1bcXVvdGVdID09PSBmYWxzZSkgeyByb3dbcXVvdGVdID0gbnVsbDsgY29udGludWU7IH1cclxuXHJcbiAgICAgIGNvbnN0IGlkcCA9IGlkUGN0Py5bYmFzZV0/LltxdW90ZV07XHJcbiAgICAgIGNvbnN0IHcgPSBnZXRUaWVyV2VpZ2h0aW5nKE51bWJlcihpZHAgPz8gMCksIHJ1bGVzKTsgLy8gbGVnYWN5IGJpbiB3ZWlnaHRcclxuICAgICAgY29uc3QgY2VsbCA9IGF2YWlsICogKDEgLyBrKSAqIHcgKiBtb29kOyAvLyBBUFBMWSBtb29kIGhlcmVcclxuICAgICAgcm93W3F1b3RlXSA9IE51bWJlci5pc0Zpbml0ZShjZWxsKSA/IGNlbGwgOiAwO1xyXG4gICAgfVxyXG4gICAgb3V0W2Jhc2VdID0gcm93O1xyXG4gIH1cclxuICByZXR1cm4gb3V0O1xyXG59XHJcblxyXG4vLyAuLi5yZXN0IHVuY2hhbmdlZC4uLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvUmVuZGVyYWJsZVJvd3MobWVhOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCB7XHJcbiAgaWRfcGN0OiBudW1iZXI7XHJcbiAgd2VpZ2h0OiBudW1iZXI7XHJcbiAgdGllck5hbWU/OiBzdHJpbmc7XHJcbiAgaXNOdWxsPzogYm9vbGVhbjtcclxufT4+KXtcclxuICAvLyBrZWVwcyB5b3VyIGV4aXN0aW5nIHNoYXBlIChubyBjaGFuZ2UgbmVlZGVkKVxyXG59XHJcblxyXG4iXSwibmFtZXMiOlsiREVGQVVMVF9USUVSX1JVTEVTIiwiZ2V0VGllcldlaWdodGluZyIsInBpY2tUaWVyTmFtZSIsImlkcCIsInJ1bGVzIiwiYSIsIk1hdGgiLCJhYnMiLCJOdW1iZXIiLCJyIiwiZmluZCIsIm1pbkFicyIsIm1heEFicyIsIm5hbWUiLCJidWlsZE1lYUF1eCIsInBhcmFtcyIsImNvaW5zIiwiaWRQY3QiLCJiYWxhbmNlcyIsImNvdmVyYWdlIiwiayIsIm1heCIsImxlbmd0aCIsIm1vb2QiLCJpc0Zpbml0ZSIsIm1vb2RDb2VmZiIsIm91dCIsImJhc2UiLCJhdmFpbCIsInJvdyIsInF1b3RlIiwidyIsImNlbGwiLCJ0b1JlbmRlcmFibGVSb3dzIiwibWVhIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/moo-aux/grid.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/moo-aux/measures.ts":
/*!***********************************************!*\
  !*** ./src/core/features/moo-aux/measures.ts ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assembleMoodInputs: () => (/* binding */ assembleMoodInputs),\n/* harmony export */   buildMeaAux: () => (/* reexport safe */ _grid__WEBPACK_IMPORTED_MODULE_1__.buildMeaAux),\n/* harmony export */   buildMeaAuxForCycle: () => (/* reexport safe */ _grid__WEBPACK_IMPORTED_MODULE_1__.buildMeaAuxForCycle),\n/* harmony export */   computeMoodCoeffUsingCurrentMetrics: () => (/* binding */ computeMoodCoeffUsingCurrentMetrics),\n/* harmony export */   getManyMetrics: () => (/* binding */ getManyMetrics),\n/* harmony export */   getMetric: () => (/* binding */ getMetric),\n/* harmony export */   saveMoodObservation: () => (/* binding */ saveMoodObservation),\n/* harmony export */   toRenderableRows: () => (/* reexport safe */ _grid__WEBPACK_IMPORTED_MODULE_1__.toRenderableRows)\n/* harmony export */ });\n/* harmony import */ var _core_db_db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/db/db */ \"(rsc)/./src/core/db/db.ts\");\n/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./grid */ \"(rsc)/./src/core/features/moo-aux/grid.ts\");\n/* harmony import */ var _mood_formula__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mood-formula */ \"(rsc)/./src/core/features/moo-aux/mood-formula.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_db_db__WEBPACK_IMPORTED_MODULE_0__]);\n_core_db_db__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n// src/core/features/moo-aux/measures.ts\n\n\n/** ---------- retrieval: generic metric fetchers ---------- */ async function getMetric(metricKey, ts_ms) {\n    try {\n        const { rows } = await _core_db_db__WEBPACK_IMPORTED_MODULE_0__.db.query(`SELECT value FROM metrics\n       WHERE metric_key=$1 AND ts_epoch_ms <= $2\n       ORDER BY ts_epoch_ms DESC\n       LIMIT 1`, [\n            metricKey,\n            ts_ms\n        ]);\n        return rows.length ? Number(rows[0].value) : null;\n    } catch  {\n        return null;\n    }\n}\nasync function getManyMetrics(keys, ts_ms) {\n    const out = {};\n    await Promise.all(keys.map(async (k)=>{\n        out[k] = await getMetric(k, ts_ms);\n    }));\n    return out;\n}\nasync function assembleMoodInputs(ts_ms) {\n    const keys = [\n        \"GFMdelta\",\n        \"vSwap\",\n        \"Inertia\",\n        \"Disruption\",\n        \"Amp\",\n        \"Volt\",\n        \"id_pct:global\"\n    ];\n    const got = await getManyMetrics(keys, ts_ms);\n    return {\n        GFMdelta: got[\"GFMdelta\"],\n        vSwap: got[\"vSwap\"],\n        Inertia: got[\"Inertia\"],\n        Disrupt: got[\"Disruption\"],\n        Amp: got[\"Amp\"],\n        Volt: got[\"Volt\"],\n        id_pct: got[\"id_pct:global\"]\n    };\n}\n/** ---------- register (persist) ---------- */ async function saveMoodObservation(appSessionId, ts_ms, moodLabel, weight, payload) {\n    try {\n        await _core_db_db__WEBPACK_IMPORTED_MODULE_0__.db.query(`INSERT INTO mea_mood_observations (app_session_id, ts_ms, mn_label, weight, payload)\n       VALUES ($1,$2,$3,$4,$5)\n       ON CONFLICT (app_session_id, ts_ms) DO UPDATE\n       SET mn_label=EXCLUDED.mn_label, weight=EXCLUDED.weight, payload=EXCLUDED.payload`, [\n            appSessionId,\n            ts_ms,\n            moodLabel,\n            weight ?? null,\n            JSON.stringify(payload ?? null)\n        ]);\n    } catch  {}\n}\n// PATCH: src/core/features/moo-aux/measures.ts\n\nasync function computeMoodCoeffUsingCurrentMetrics(ts_ms) {\n    const m = await assembleMoodInputs(ts_ms); // already exists\n    const { coeff, buckets } = (0,_mood_formula__WEBPACK_IMPORTED_MODULE_2__.computeMoodCoeffV1)({\n        vTendency: m.Inertia ?? m.id_pct ?? 0,\n        GFM: (m.GFMdelta ?? 0) + 1,\n        vSwap: m.vSwap ?? 0\n    });\n    return {\n        coeff,\n        buckets\n    };\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9tb28tYXV4L21lYXN1cmVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsd0NBQXdDO0FBQ047QUFFMEM7QUFHNUUsNkRBQTZELEdBQ3RELGVBQWVJLFVBQVVDLFNBQWlCLEVBQUVDLEtBQWE7SUFDOUQsSUFBSTtRQUNGLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEdBQUcsTUFBTVAsMkNBQUVBLENBQUNRLEtBQUssQ0FDN0IsQ0FBQzs7O2NBR08sQ0FBQyxFQUNUO1lBQUNIO1lBQVdDO1NBQU07UUFFcEIsT0FBT0MsS0FBS0UsTUFBTSxHQUFHQyxPQUFPSCxJQUFJLENBQUMsRUFBRSxDQUFDSSxLQUFLLElBQUk7SUFDL0MsRUFBRSxPQUFNO1FBQUUsT0FBTztJQUFNO0FBQ3pCO0FBRU8sZUFBZUMsZUFBZUMsSUFBYyxFQUFFUCxLQUFhO0lBQ2hFLE1BQU1RLE1BQXFDLENBQUM7SUFDNUMsTUFBTUMsUUFBUUMsR0FBRyxDQUFDSCxLQUFLSSxHQUFHLENBQUMsT0FBT0M7UUFBUUosR0FBRyxDQUFDSSxFQUFFLEdBQUcsTUFBTWQsVUFBVWMsR0FBR1o7SUFBUTtJQUM5RSxPQUFPUTtBQUNUO0FBYU8sZUFBZUssbUJBQW1CYixLQUFhO0lBQ3BELE1BQU1PLE9BQU87UUFBQztRQUFXO1FBQVE7UUFBVTtRQUFhO1FBQU07UUFBTztLQUFnQjtJQUNyRixNQUFNTyxNQUFPLE1BQU1SLGVBQWVDLE1BQU1QO0lBQ3hDLE9BQU87UUFDTGUsVUFBVUQsR0FBRyxDQUFDLFdBQVc7UUFDekJFLE9BQVVGLEdBQUcsQ0FBQyxRQUFRO1FBQ3RCRyxTQUFVSCxHQUFHLENBQUMsVUFBVTtRQUN4QkksU0FBVUosR0FBRyxDQUFDLGFBQWE7UUFDM0JLLEtBQVVMLEdBQUcsQ0FBQyxNQUFNO1FBQ3BCTSxNQUFVTixHQUFHLENBQUMsT0FBTztRQUNyQk8sUUFBVVAsR0FBRyxDQUFDLGdCQUFnQjtJQUNoQztBQUNGO0FBRUEsNkNBQTZDLEdBQ3RDLGVBQWVRLG9CQUFvQkMsWUFBb0IsRUFBRXZCLEtBQWEsRUFBRXdCLFNBQWlCLEVBQUVDLE1BQXFCLEVBQUVDLE9BQWdCO0lBQ3ZJLElBQUk7UUFDRixNQUFNaEMsMkNBQUVBLENBQUNRLEtBQUssQ0FDWixDQUFDOzs7dUZBR2dGLENBQUMsRUFDbEY7WUFBQ3FCO1lBQWN2QjtZQUFPd0I7WUFBV0MsVUFBVTtZQUFNRSxLQUFLQyxTQUFTLENBQUNGLFdBQVc7U0FBTTtJQUVyRixFQUFFLE9BQU0sQ0FBdUI7QUFDakM7QUFFQSwrQ0FBK0M7QUFDSztBQUU3QyxlQUFlSSxvQ0FBb0M5QixLQUFhO0lBR3JFLE1BQU0rQixJQUFJLE1BQU1sQixtQkFBbUJiLFFBQVEsaUJBQWlCO0lBQzVELE1BQU0sRUFBRWdDLEtBQUssRUFBRUMsT0FBTyxFQUFFLEdBQUdKLGlFQUFrQkEsQ0FBQztRQUM1Q0ssV0FBV0gsRUFBRWQsT0FBTyxJQUFJYyxFQUFFVixNQUFNLElBQUk7UUFDcENjLEtBQUssQ0FBQ0osRUFBRWhCLFFBQVEsSUFBSSxLQUFLO1FBQ3pCQyxPQUFPZSxFQUFFZixLQUFLLElBQUk7SUFDcEI7SUFDQSxPQUFPO1FBQUVnQjtRQUFPQztJQUFRO0FBQzFCIiwic291cmNlcyI6WyJIOlxcVXNlcnNcXEd1c1xcc291cmNlXFxyZXBvXFxkeW5hbWljc1xcZHluYW1pY3MtYlxcY3J5cHRvcGktZHluYW1pY3NcXHNyY1xcY29yZVxcZmVhdHVyZXNcXG1vby1hdXhcXG1lYXN1cmVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb3JlL2ZlYXR1cmVzL21vby1hdXgvbWVhc3VyZXMudHNcclxuaW1wb3J0IHsgZGIgfSBmcm9tIFwiQC9jb3JlL2RiL2RiXCI7XHJcblxyXG5leHBvcnQgeyBidWlsZE1lYUF1eCwgYnVpbGRNZWFBdXhGb3JDeWNsZSwgdG9SZW5kZXJhYmxlUm93cyB9IGZyb20gXCIuL2dyaWRcIjtcclxuZXhwb3J0IHR5cGUgeyBJZFBjdEdyaWQsIEJhbGFuY2VzTWFwLCBNZWFBdXhHcmlkLCBNZWFQYWlyLCBNZWFSb3cgfSBmcm9tIFwiLi9ncmlkXCI7XHJcblxyXG4vKiogLS0tLS0tLS0tLSByZXRyaWV2YWw6IGdlbmVyaWMgbWV0cmljIGZldGNoZXJzIC0tLS0tLS0tLS0gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1ldHJpYyhtZXRyaWNLZXk6IHN0cmluZywgdHNfbXM6IG51bWJlcik6IFByb21pc2U8bnVtYmVyIHwgbnVsbD4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IHJvd3MgfSA9IGF3YWl0IGRiLnF1ZXJ5PHsgdmFsdWU6IG51bWJlciB9PihcclxuICAgICAgYFNFTEVDVCB2YWx1ZSBGUk9NIG1ldHJpY3NcclxuICAgICAgIFdIRVJFIG1ldHJpY19rZXk9JDEgQU5EIHRzX2Vwb2NoX21zIDw9ICQyXHJcbiAgICAgICBPUkRFUiBCWSB0c19lcG9jaF9tcyBERVNDXHJcbiAgICAgICBMSU1JVCAxYCxcclxuICAgICAgW21ldHJpY0tleSwgdHNfbXNdXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIHJvd3MubGVuZ3RoID8gTnVtYmVyKHJvd3NbMF0udmFsdWUpIDogbnVsbDtcclxuICB9IGNhdGNoIHsgcmV0dXJuIG51bGw7IH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1hbnlNZXRyaWNzKGtleXM6IHN0cmluZ1tdLCB0c19tczogbnVtYmVyKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBudW1iZXIgfCBudWxsPj4ge1xyXG4gIGNvbnN0IG91dDogUmVjb3JkPHN0cmluZywgbnVtYmVyIHwgbnVsbD4gPSB7fTtcclxuICBhd2FpdCBQcm9taXNlLmFsbChrZXlzLm1hcChhc3luYyAoaykgPT4geyBvdXRba10gPSBhd2FpdCBnZXRNZXRyaWMoaywgdHNfbXMpOyB9KSk7XHJcbiAgcmV0dXJuIG91dDtcclxufVxyXG5cclxuLyoqIC0tLS0tLS0tLS0gY2FsYzogYXNzZW1ibGUgbW9vZCBpbnB1dHMgLS0tLS0tLS0tLSAqL1xyXG5leHBvcnQgdHlwZSBNb29kSW5wdXRzID0ge1xyXG4gIEdGTWRlbHRhOiBudW1iZXIgfCBudWxsO1xyXG4gIHZTd2FwOiAgICBudW1iZXIgfCBudWxsO1xyXG4gIEluZXJ0aWE6ICBudW1iZXIgfCBudWxsO1xyXG4gIERpc3J1cHQ6ICBudW1iZXIgfCBudWxsO1xyXG4gIEFtcDogICAgICBudW1iZXIgfCBudWxsO1xyXG4gIFZvbHQ6ICAgICBudW1iZXIgfCBudWxsO1xyXG4gIGlkX3BjdD86ICBudW1iZXIgfCBudWxsO1xyXG59O1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzc2VtYmxlTW9vZElucHV0cyh0c19tczogbnVtYmVyKTogUHJvbWlzZTxNb29kSW5wdXRzPiB7XHJcbiAgY29uc3Qga2V5cyA9IFtcIkdGTWRlbHRhXCIsXCJ2U3dhcFwiLFwiSW5lcnRpYVwiLFwiRGlzcnVwdGlvblwiLFwiQW1wXCIsXCJWb2x0XCIsXCJpZF9wY3Q6Z2xvYmFsXCJdO1xyXG4gIGNvbnN0IGdvdCAgPSBhd2FpdCBnZXRNYW55TWV0cmljcyhrZXlzLCB0c19tcyk7XHJcbiAgcmV0dXJuIHtcclxuICAgIEdGTWRlbHRhOiBnb3RbXCJHRk1kZWx0YVwiXSxcclxuICAgIHZTd2FwOiAgICBnb3RbXCJ2U3dhcFwiXSxcclxuICAgIEluZXJ0aWE6ICBnb3RbXCJJbmVydGlhXCJdLFxyXG4gICAgRGlzcnVwdDogIGdvdFtcIkRpc3J1cHRpb25cIl0sXHJcbiAgICBBbXA6ICAgICAgZ290W1wiQW1wXCJdLFxyXG4gICAgVm9sdDogICAgIGdvdFtcIlZvbHRcIl0sXHJcbiAgICBpZF9wY3Q6ICAgZ290W1wiaWRfcGN0Omdsb2JhbFwiXSxcclxuICB9O1xyXG59XHJcblxyXG4vKiogLS0tLS0tLS0tLSByZWdpc3RlciAocGVyc2lzdCkgLS0tLS0tLS0tLSAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZU1vb2RPYnNlcnZhdGlvbihhcHBTZXNzaW9uSWQ6IHN0cmluZywgdHNfbXM6IG51bWJlciwgbW9vZExhYmVsOiBzdHJpbmcsIHdlaWdodDogbnVtYmVyIHwgbnVsbCwgcGF5bG9hZDogdW5rbm93bikge1xyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBkYi5xdWVyeShcclxuICAgICAgYElOU0VSVCBJTlRPIG1lYV9tb29kX29ic2VydmF0aW9ucyAoYXBwX3Nlc3Npb25faWQsIHRzX21zLCBtbl9sYWJlbCwgd2VpZ2h0LCBwYXlsb2FkKVxyXG4gICAgICAgVkFMVUVTICgkMSwkMiwkMywkNCwkNSlcclxuICAgICAgIE9OIENPTkZMSUNUIChhcHBfc2Vzc2lvbl9pZCwgdHNfbXMpIERPIFVQREFURVxyXG4gICAgICAgU0VUIG1uX2xhYmVsPUVYQ0xVREVELm1uX2xhYmVsLCB3ZWlnaHQ9RVhDTFVERUQud2VpZ2h0LCBwYXlsb2FkPUVYQ0xVREVELnBheWxvYWRgLFxyXG4gICAgICBbYXBwU2Vzc2lvbklkLCB0c19tcywgbW9vZExhYmVsLCB3ZWlnaHQgPz8gbnVsbCwgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCA/PyBudWxsKV1cclxuICAgICk7XHJcbiAgfSBjYXRjaCB7IC8qIG9wdGlvbmFsIHRhYmxlICovIH1cclxufVxyXG5cclxuLy8gUEFUQ0g6IHNyYy9jb3JlL2ZlYXR1cmVzL21vby1hdXgvbWVhc3VyZXMudHNcclxuaW1wb3J0IHsgY29tcHV0ZU1vb2RDb2VmZlYxIH0gZnJvbSBcIi4vbW9vZC1mb3JtdWxhXCI7XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZU1vb2RDb2VmZlVzaW5nQ3VycmVudE1ldHJpY3ModHNfbXM6IG51bWJlcik6IFByb21pc2U8e1xyXG4gIGNvZWZmOiBudW1iZXI7IGJ1Y2tldHM6IHsgdlRlbmRlbmN5SWR4OiBudW1iZXI7IEdGTUlkeDogbnVtYmVyOyB2U3dhcElkeDogbnVtYmVyIH07XHJcbn0+IHtcclxuICBjb25zdCBtID0gYXdhaXQgYXNzZW1ibGVNb29kSW5wdXRzKHRzX21zKTsgLy8gYWxyZWFkeSBleGlzdHNcclxuICBjb25zdCB7IGNvZWZmLCBidWNrZXRzIH0gPSBjb21wdXRlTW9vZENvZWZmVjEoe1xyXG4gICAgdlRlbmRlbmN5OiBtLkluZXJ0aWEgPz8gbS5pZF9wY3QgPz8gMCwgLy8gaWYgeW91IG1hcCB2VGVuZGVuY3kgZWxzZXdoZXJlLCBhZGp1c3QgaGVyZVxyXG4gICAgR0ZNOiAobS5HRk1kZWx0YSA/PyAwKSArIDEsICAgICAgICAgICAgLy8gaWYgeW91ciBHRk1kZWx0YSBpcyBkZWx0YSB2cyAxLjAsIHNoaWZ0IGludG8gWzAuOC4uMS4yXVxyXG4gICAgdlN3YXA6IG0udlN3YXAgPz8gMCxcclxuICB9KTtcclxuICByZXR1cm4geyBjb2VmZiwgYnVja2V0cyB9O1xyXG59XHJcblxyXG4iXSwibmFtZXMiOlsiZGIiLCJidWlsZE1lYUF1eCIsImJ1aWxkTWVhQXV4Rm9yQ3ljbGUiLCJ0b1JlbmRlcmFibGVSb3dzIiwiZ2V0TWV0cmljIiwibWV0cmljS2V5IiwidHNfbXMiLCJyb3dzIiwicXVlcnkiLCJsZW5ndGgiLCJOdW1iZXIiLCJ2YWx1ZSIsImdldE1hbnlNZXRyaWNzIiwia2V5cyIsIm91dCIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJrIiwiYXNzZW1ibGVNb29kSW5wdXRzIiwiZ290IiwiR0ZNZGVsdGEiLCJ2U3dhcCIsIkluZXJ0aWEiLCJEaXNydXB0IiwiQW1wIiwiVm9sdCIsImlkX3BjdCIsInNhdmVNb29kT2JzZXJ2YXRpb24iLCJhcHBTZXNzaW9uSWQiLCJtb29kTGFiZWwiLCJ3ZWlnaHQiLCJwYXlsb2FkIiwiSlNPTiIsInN0cmluZ2lmeSIsImNvbXB1dGVNb29kQ29lZmZWMSIsImNvbXB1dGVNb29kQ29lZmZVc2luZ0N1cnJlbnRNZXRyaWNzIiwibSIsImNvZWZmIiwiYnVja2V0cyIsInZUZW5kZW5jeSIsIkdGTSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/moo-aux/measures.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/moo-aux/mood-formula.ts":
/*!***************************************************!*\
  !*** ./src/core/features/moo-aux/mood-formula.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   computeMoodCoeffV1: () => (/* binding */ computeMoodCoeffV1)\n/* harmony export */ });\n// Implements: mood = (vTendency / GFM) + vSwap\n// with vTendency in [0.4..1.2], GFM in [0.8..1.2], vSwap in [0.5..+0.5] (signed)\n// plus 6 up/down niches for vTendency, 4 up/down for GFM, 6 up/down for vSwap.\nfunction clamp(x, lo, hi) {\n    return Math.min(Math.max(x, lo), hi);\n}\nfunction binSigned(x, boundaries, upCount, downCount) {\n    // boundaries are non-negative increasing, applied to abs(x)\n    const a = Math.abs(x);\n    let idx = 0;\n    while(idx < boundaries.length && a > boundaries[idx])idx++;\n    // idx  [0..boundaries.length] maps to 0..N-1 inside each side\n    if (x >= 0) return Math.min(idx, upCount - 1);\n    // shift to \"down\" band space\n    return upCount + Math.min(idx, downCount - 1);\n}\n// --- bucket specs (tuneable, deterministic) ---\nconst V_TEND_MIN = 0.4, V_TEND_MAX = 1.2; // foundational range\nconst GFM_MIN = 0.8, GFM_MAX = 1.2;\nconst V_SWAP_MAX = 0.5; // magnitude cap\n// Build equal-width cut points for convenience:\nfunction eqCuts(min, max, parts) {\n    const step = (max - min) / parts;\n    return Array.from({\n        length: parts - 1\n    }, (_, i)=>min + step * (i + 1));\n}\nconst vTendCuts = eqCuts(0, V_TEND_MAX, 6); // absolute buckets, zero handled by sign\nconst gfmCuts = eqCuts(0, GFM_MAX, 4);\nconst vSwapCuts = eqCuts(0, V_SWAP_MAX, 6);\n// Signed clamps\nfunction clampRanges(i) {\n    const vTendency = i.vTendency ?? 0;\n    const GFM = i.GFM ?? 1; // neutral if missing\n    const vSwap = i.vSwap ?? 0;\n    const vTendencyClamped = Math.sign(vTendency) * clamp(Math.abs(vTendency), 0, V_TEND_MAX);\n    const GFMClamped = clamp(GFM, GFM_MIN, GFM_MAX);\n    const vSwapClamped = Math.sign(vSwap) * clamp(Math.abs(vSwap), 0, V_SWAP_MAX);\n    return {\n        vTendencyClamped,\n        GFMClamped,\n        vSwapClamped\n    };\n}\nfunction computeMoodCoeffV1(i) {\n    const { vTendencyClamped, GFMClamped, vSwapClamped } = clampRanges(i);\n    // your formula:\n    // mood = (vTendency / GFM) + vSwap\n    // Then softly clamp to a sane engine range [0.2 .. 2.0]\n    let coeff = (vTendencyClamped || 0) / (GFMClamped || 1) + (vSwapClamped || 0);\n    coeff = clamp(coeff, 0.2, 2.0);\n    // resolve niches\n    const vTendencyIdx = binSigned(vTendencyClamped, vTendCuts, 6, 6);\n    const GFMIdx = binSigned(GFMClamped - 1 /* center around 1.0 */ , gfmCuts, 4, 4);\n    const vSwapIdx = binSigned(vSwapClamped, vSwapCuts, 6, 6);\n    const buckets = {\n        vTendencyIdx,\n        GFMIdx,\n        vSwapIdx\n    };\n    return {\n        coeff,\n        buckets\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9tb28tYXV4L21vb2QtZm9ybXVsYS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLCtDQUErQztBQUMvQyxrRkFBa0Y7QUFDbEYsa0ZBQWtGO0FBYzNFLFNBQVNBLE1BQU1DLENBQVMsRUFBRUMsRUFBVSxFQUFFQyxFQUFVO0lBQ3JELE9BQU9DLEtBQUtDLEdBQUcsQ0FBQ0QsS0FBS0UsR0FBRyxDQUFDTCxHQUFHQyxLQUFLQztBQUNuQztBQUVBLFNBQVNJLFVBQ1BOLENBQVMsRUFDVE8sVUFBb0IsRUFDcEJDLE9BQWUsRUFDZkMsU0FBaUI7SUFFakIsNERBQTREO0lBQzVELE1BQU1DLElBQUlQLEtBQUtRLEdBQUcsQ0FBQ1g7SUFDbkIsSUFBSVksTUFBTTtJQUNWLE1BQU9BLE1BQU1MLFdBQVdNLE1BQU0sSUFBSUgsSUFBSUgsVUFBVSxDQUFDSyxJQUFJLENBQUVBO0lBQ3ZELCtEQUErRDtJQUMvRCxJQUFJWixLQUFLLEdBQUcsT0FBT0csS0FBS0MsR0FBRyxDQUFDUSxLQUFLSixVQUFVO0lBQzNDLDZCQUE2QjtJQUM3QixPQUFPQSxVQUFVTCxLQUFLQyxHQUFHLENBQUNRLEtBQUtILFlBQVk7QUFDN0M7QUFFQSxpREFBaUQ7QUFDakQsTUFBTUssYUFBYSxLQUFLQyxhQUFhLEtBQUsscUJBQXFCO0FBQy9ELE1BQU1DLFVBQVUsS0FBS0MsVUFBVTtBQUMvQixNQUFNQyxhQUFhLEtBQUssZ0JBQWdCO0FBRXhDLGdEQUFnRDtBQUNoRCxTQUFTQyxPQUFPZixHQUFXLEVBQUVDLEdBQVcsRUFBRWUsS0FBYTtJQUNyRCxNQUFNQyxPQUFPLENBQUNoQixNQUFNRCxHQUFFLElBQUtnQjtJQUMzQixPQUFPRSxNQUFNQyxJQUFJLENBQUM7UUFBRVYsUUFBUU8sUUFBUTtJQUFFLEdBQUcsQ0FBQ0ksR0FBR0MsSUFBTXJCLE1BQU1pQixPQUFRSSxDQUFBQSxJQUFJO0FBQ3ZFO0FBQ0EsTUFBTUMsWUFBWVAsT0FBTyxHQUFHSixZQUFZLElBQUkseUNBQXlDO0FBQ3JGLE1BQU1ZLFVBQVlSLE9BQU8sR0FBR0YsU0FBUztBQUNyQyxNQUFNVyxZQUFZVCxPQUFPLEdBQUdELFlBQVk7QUFFeEMsZ0JBQWdCO0FBQ2hCLFNBQVNXLFlBQVlKLENBQW9CO0lBQ3ZDLE1BQU1LLFlBQVlMLEVBQUVLLFNBQVMsSUFBSTtJQUNqQyxNQUFNQyxNQUFZTixFQUFFTSxHQUFHLElBQUksR0FBRyxxQkFBcUI7SUFDbkQsTUFBTUMsUUFBWVAsRUFBRU8sS0FBSyxJQUFJO0lBRTdCLE1BQU1DLG1CQUFtQjlCLEtBQUsrQixJQUFJLENBQUNKLGFBQWEvQixNQUFNSSxLQUFLUSxHQUFHLENBQUNtQixZQUFZLEdBQUdmO0lBQzlFLE1BQU1vQixhQUFtQnBDLE1BQU1nQyxLQUFLZixTQUFTQztJQUM3QyxNQUFNbUIsZUFBbUJqQyxLQUFLK0IsSUFBSSxDQUFDRixTQUFTakMsTUFBTUksS0FBS1EsR0FBRyxDQUFDcUIsUUFBUSxHQUFHZDtJQUN0RSxPQUFPO1FBQUVlO1FBQWtCRTtRQUFZQztJQUFhO0FBQ3REO0FBRU8sU0FBU0MsbUJBQW1CWixDQUFvQjtJQUNyRCxNQUFNLEVBQUVRLGdCQUFnQixFQUFFRSxVQUFVLEVBQUVDLFlBQVksRUFBRSxHQUFHUCxZQUFZSjtJQUVuRSxnQkFBZ0I7SUFDaEIsbUNBQW1DO0lBQ25DLHdEQUF3RDtJQUN4RCxJQUFJYSxRQUFRLENBQUdMLG9CQUFvQixLQUFNRSxDQUFBQSxjQUFjLEtBQVFDLENBQUFBLGdCQUFnQjtJQUMvRUUsUUFBUXZDLE1BQU11QyxPQUFPLEtBQUs7SUFFMUIsbUJBQW1CO0lBQ25CLE1BQU1DLGVBQWVqQyxVQUFVMkIsa0JBQWtCUCxXQUFXLEdBQUc7SUFDL0QsTUFBTWMsU0FBZWxDLFVBQVU2QixhQUFhLEVBQUUscUJBQXFCLEtBQUlSLFNBQVMsR0FBRztJQUNuRixNQUFNYyxXQUFlbkMsVUFBVThCLGNBQWNSLFdBQVcsR0FBRztJQUUzRCxNQUFNYyxVQUF1QjtRQUFFSDtRQUFjQztRQUFRQztJQUFTO0lBQzlELE9BQU87UUFBRUg7UUFBT0k7SUFBUTtBQUMxQiIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGNvcmVcXGZlYXR1cmVzXFxtb28tYXV4XFxtb29kLWZvcm11bGEudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wbGVtZW50czogbW9vZCA9ICh2VGVuZGVuY3kgLyBHRk0pICsgdlN3YXBcclxuLy8gd2l0aCB2VGVuZGVuY3kgaW4gWzAuNC4uMS4yXSwgR0ZNIGluIFswLjguLjEuMl0sIHZTd2FwIGluIFviiJIwLjUuLiswLjVdIChzaWduZWQpXHJcbi8vIHBsdXMgNsOXIHVwL2Rvd24gbmljaGVzIGZvciB2VGVuZGVuY3ksIDTDlyB1cC9kb3duIGZvciBHRk0sIDbDlyB1cC9kb3duIGZvciB2U3dhcC5cclxuXHJcbmV4cG9ydCB0eXBlIE1vb2RGb3JtdWxhSW5wdXRzID0ge1xyXG4gIHZUZW5kZW5jeTogbnVtYmVyIHwgbnVsbDsgLy8gdHJlbmQgaW50ZW5zaXR5IChzaWduZWQ7IGZvdW5kYXRpb25hbClcclxuICBHRk06IG51bWJlciB8IG51bGw7ICAgICAgIC8vIGdsb2JhbCBmbG93IG1vbWVudHVtIGZhY3RvciAo4omlMCBpZGVhbGx5KVxyXG4gIHZTd2FwOiBudW1iZXIgfCBudWxsOyAgICAgLy8gc3dhcCB2ZWxvY2l0eSAoc2lnbmVkKVxyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgTW9vZEJ1Y2tldHMgPSB7XHJcbiAgdlRlbmRlbmN5SWR4OiBudW1iZXI7IC8vIDAuLjUgKHVwKSwgNi4uMTEgKGRvd24pXHJcbiAgR0ZNSWR4OiBudW1iZXI7ICAgICAgIC8vIDAuLjMgKHVwKSwgNC4uNyAoZG93bilcclxuICB2U3dhcElkeDogbnVtYmVyOyAgICAgLy8gMC4uNSAodXApLCA2Li4xMSAoZG93bilcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCh4OiBudW1iZXIsIGxvOiBudW1iZXIsIGhpOiBudW1iZXIpIHtcclxuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoeCwgbG8pLCBoaSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJpblNpZ25lZChcclxuICB4OiBudW1iZXIsXHJcbiAgYm91bmRhcmllczogbnVtYmVyW10sXHJcbiAgdXBDb3VudDogbnVtYmVyLFxyXG4gIGRvd25Db3VudDogbnVtYmVyXHJcbikge1xyXG4gIC8vIGJvdW5kYXJpZXMgYXJlIG5vbi1uZWdhdGl2ZSBpbmNyZWFzaW5nLCBhcHBsaWVkIHRvIGFicyh4KVxyXG4gIGNvbnN0IGEgPSBNYXRoLmFicyh4KTtcclxuICBsZXQgaWR4ID0gMDtcclxuICB3aGlsZSAoaWR4IDwgYm91bmRhcmllcy5sZW5ndGggJiYgYSA+IGJvdW5kYXJpZXNbaWR4XSkgaWR4Kys7XHJcbiAgLy8gaWR4IOKIiCBbMC4uYm91bmRhcmllcy5sZW5ndGhdIG1hcHMgdG8gMC4uTi0xIGluc2lkZSBlYWNoIHNpZGVcclxuICBpZiAoeCA+PSAwKSByZXR1cm4gTWF0aC5taW4oaWR4LCB1cENvdW50IC0gMSk7XHJcbiAgLy8gc2hpZnQgdG8gXCJkb3duXCIgYmFuZCBzcGFjZVxyXG4gIHJldHVybiB1cENvdW50ICsgTWF0aC5taW4oaWR4LCBkb3duQ291bnQgLSAxKTtcclxufVxyXG5cclxuLy8gLS0tIGJ1Y2tldCBzcGVjcyAodHVuZWFibGUsIGRldGVybWluaXN0aWMpIC0tLVxyXG5jb25zdCBWX1RFTkRfTUlOID0gMC40LCBWX1RFTkRfTUFYID0gMS4yOyAvLyBmb3VuZGF0aW9uYWwgcmFuZ2VcclxuY29uc3QgR0ZNX01JTiA9IDAuOCwgR0ZNX01BWCA9IDEuMjtcclxuY29uc3QgVl9TV0FQX01BWCA9IDAuNTsgLy8gbWFnbml0dWRlIGNhcFxyXG5cclxuLy8gQnVpbGQgZXF1YWwtd2lkdGggY3V0IHBvaW50cyBmb3IgY29udmVuaWVuY2U6XHJcbmZ1bmN0aW9uIGVxQ3V0cyhtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIHBhcnRzOiBudW1iZXIpIHtcclxuICBjb25zdCBzdGVwID0gKG1heCAtIG1pbikgLyBwYXJ0cztcclxuICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogcGFydHMgLSAxIH0sIChfLCBpKSA9PiBtaW4gKyBzdGVwICogKGkgKyAxKSk7XHJcbn1cclxuY29uc3QgdlRlbmRDdXRzID0gZXFDdXRzKDAsIFZfVEVORF9NQVgsIDYpOyAvLyBhYnNvbHV0ZSBidWNrZXRzLCB6ZXJvIGhhbmRsZWQgYnkgc2lnblxyXG5jb25zdCBnZm1DdXRzICAgPSBlcUN1dHMoMCwgR0ZNX01BWCwgNCk7XHJcbmNvbnN0IHZTd2FwQ3V0cyA9IGVxQ3V0cygwLCBWX1NXQVBfTUFYLCA2KTtcclxuXHJcbi8vIFNpZ25lZCBjbGFtcHNcclxuZnVuY3Rpb24gY2xhbXBSYW5nZXMoaTogTW9vZEZvcm11bGFJbnB1dHMpIHtcclxuICBjb25zdCB2VGVuZGVuY3kgPSBpLnZUZW5kZW5jeSA/PyAwO1xyXG4gIGNvbnN0IEdGTSAgICAgICA9IGkuR0ZNID8/IDE7IC8vIG5ldXRyYWwgaWYgbWlzc2luZ1xyXG4gIGNvbnN0IHZTd2FwICAgICA9IGkudlN3YXAgPz8gMDtcclxuXHJcbiAgY29uc3QgdlRlbmRlbmN5Q2xhbXBlZCA9IE1hdGguc2lnbih2VGVuZGVuY3kpICogY2xhbXAoTWF0aC5hYnModlRlbmRlbmN5KSwgMCwgVl9URU5EX01BWCk7XHJcbiAgY29uc3QgR0ZNQ2xhbXBlZCAgICAgICA9IGNsYW1wKEdGTSwgR0ZNX01JTiwgR0ZNX01BWCk7XHJcbiAgY29uc3QgdlN3YXBDbGFtcGVkICAgICA9IE1hdGguc2lnbih2U3dhcCkgKiBjbGFtcChNYXRoLmFicyh2U3dhcCksIDAsIFZfU1dBUF9NQVgpO1xyXG4gIHJldHVybiB7IHZUZW5kZW5jeUNsYW1wZWQsIEdGTUNsYW1wZWQsIHZTd2FwQ2xhbXBlZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZU1vb2RDb2VmZlYxKGk6IE1vb2RGb3JtdWxhSW5wdXRzKSB7XHJcbiAgY29uc3QgeyB2VGVuZGVuY3lDbGFtcGVkLCBHRk1DbGFtcGVkLCB2U3dhcENsYW1wZWQgfSA9IGNsYW1wUmFuZ2VzKGkpO1xyXG5cclxuICAvLyB5b3VyIGZvcm11bGE6XHJcbiAgLy8gbW9vZCA9ICh2VGVuZGVuY3kgLyBHRk0pICsgdlN3YXBcclxuICAvLyBUaGVuIHNvZnRseSBjbGFtcCB0byBhIHNhbmUgZW5naW5lIHJhbmdlIFswLjIgLi4gMi4wXVxyXG4gIGxldCBjb2VmZiA9ICggKHZUZW5kZW5jeUNsYW1wZWQgfHwgMCkgLyAoR0ZNQ2xhbXBlZCB8fCAxKSApICsgKHZTd2FwQ2xhbXBlZCB8fCAwKTtcclxuICBjb2VmZiA9IGNsYW1wKGNvZWZmLCAwLjIsIDIuMCk7XHJcblxyXG4gIC8vIHJlc29sdmUg4oCcbmljaGVz4oCdXHJcbiAgY29uc3QgdlRlbmRlbmN5SWR4ID0gYmluU2lnbmVkKHZUZW5kZW5jeUNsYW1wZWQsIHZUZW5kQ3V0cywgNiwgNik7XHJcbiAgY29uc3QgR0ZNSWR4ICAgICAgID0gYmluU2lnbmVkKEdGTUNsYW1wZWQgLSAxIC8qIGNlbnRlciBhcm91bmQgMS4wICovLCBnZm1DdXRzLCA0LCA0KTtcclxuICBjb25zdCB2U3dhcElkeCAgICAgPSBiaW5TaWduZWQodlN3YXBDbGFtcGVkLCB2U3dhcEN1dHMsIDYsIDYpO1xyXG5cclxuICBjb25zdCBidWNrZXRzOiBNb29kQnVja2V0cyA9IHsgdlRlbmRlbmN5SWR4LCBHRk1JZHgsIHZTd2FwSWR4IH07XHJcbiAgcmV0dXJuIHsgY29lZmYsIGJ1Y2tldHMgfTtcclxufVxyXG4iXSwibmFtZXMiOlsiY2xhbXAiLCJ4IiwibG8iLCJoaSIsIk1hdGgiLCJtaW4iLCJtYXgiLCJiaW5TaWduZWQiLCJib3VuZGFyaWVzIiwidXBDb3VudCIsImRvd25Db3VudCIsImEiLCJhYnMiLCJpZHgiLCJsZW5ndGgiLCJWX1RFTkRfTUlOIiwiVl9URU5EX01BWCIsIkdGTV9NSU4iLCJHRk1fTUFYIiwiVl9TV0FQX01BWCIsImVxQ3V0cyIsInBhcnRzIiwic3RlcCIsIkFycmF5IiwiZnJvbSIsIl8iLCJpIiwidlRlbmRDdXRzIiwiZ2ZtQ3V0cyIsInZTd2FwQ3V0cyIsImNsYW1wUmFuZ2VzIiwidlRlbmRlbmN5IiwiR0ZNIiwidlN3YXAiLCJ2VGVuZGVuY3lDbGFtcGVkIiwic2lnbiIsIkdGTUNsYW1wZWQiLCJ2U3dhcENsYW1wZWQiLCJjb21wdXRlTW9vZENvZWZmVjEiLCJjb2VmZiIsInZUZW5kZW5jeUlkeCIsIkdGTUlkeCIsInZTd2FwSWR4IiwiYnVja2V0cyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/moo-aux/mood-formula.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/moo-aux/tiers.ts":
/*!********************************************!*\
  !*** ./src/core/features/moo-aux/tiers.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_TIER_RULES: () => (/* binding */ DEFAULT_TIER_RULES),\n/* harmony export */   MOOD_CLASS_ROWS: () => (/* binding */ MOOD_CLASS_ROWS),\n/* harmony export */   MOOD_CLASS_WEIGHTS: () => (/* binding */ MOOD_CLASS_WEIGHTS),\n/* harmony export */   getTierWeighting: () => (/* binding */ getTierWeighting)\n/* harmony export */ });\n// src/core/features/moo-aux/tiers.ts\n/** ---------- legacy MEA bins (id_pct  weight) ---------- */ // default bins (tune freely)\nconst DEFAULT_TIER_RULES = [\n    {\n        key: \"alpha\",\n        name: \"Alpha\",\n        minAbs: 0.00016,\n        maxAbs: 0.00032,\n        weight: 0.15\n    },\n    {\n        key: \"beta\",\n        name: \"Beta\",\n        minAbs: 0.00033,\n        maxAbs: 0.00045,\n        weight: 0.55\n    },\n    {\n        key: \"gamma\",\n        name: \"Gamma\",\n        minAbs: 0.00046,\n        maxAbs: 0.00076,\n        weight: 1.15\n    },\n    {\n        key: \"delta\",\n        name: \"Delta\",\n        minAbs: 0.00077,\n        maxAbs: 0.00120,\n        weight: 0.65\n    },\n    {\n        key: \"epsilon\",\n        name: \"Epsilon\",\n        minAbs: 0.00121,\n        maxAbs: null,\n        weight: 0.50\n    }\n];\nfunction getTierWeighting(id_pct, rules = DEFAULT_TIER_RULES) {\n    const a = Math.abs(Number(id_pct || 0));\n    const r = rules.find((r)=>a >= r.minAbs && (r.maxAbs == null || a <= r.maxAbs));\n    return r ? r.weight : 0;\n}\n/**\r\n * Base per-mood weights (mirror of engine presets).\r\n * These are normalized inside the engines at runtime; keep relative shape here.\r\n */ const MOOD_CLASS_WEIGHTS = {\n    std: {\n        vTendency: 0.28,\n        vSwap: 0.22,\n        Volt: 0.16,\n        Inertia: 0.14,\n        Amp: 0.10,\n        Disruption: 0.10\n    },\n    trl: {\n        vTendency: 0.40,\n        vSwap: 0.25,\n        Inertia: 0.18,\n        Volt: 0.07,\n        Amp: 0.05,\n        Disruption: 0.05\n    },\n    rev: {\n        vSwap: 0.34,\n        Disruption: 0.20,\n        Amp: 0.16,\n        vTendency: 0.16,\n        Volt: 0.08,\n        Inertia: 0.06\n    },\n    inj: {\n        GFMdelta: 0.38,\n        vSwap: 0.22,\n        Volt: 0.18,\n        Disruption: 0.12,\n        Inertia: 0.05,\n        Amp: 0.05\n    },\n    drn: {\n        GFMdelta: 0.36,\n        Volt: 0.22,\n        vSwap: 0.16,\n        Disruption: 0.12,\n        Inertia: 0.08,\n        Amp: 0.06\n    },\n    wnd: {\n        Inertia: 0.36,\n        Volt: 0.18,\n        Amp: 0.10,\n        vSwap: 0.12,\n        vTendency: 0.14,\n        Disruption: 0.10\n    },\n    emg: {\n        Disruption: 0.30,\n        Volt: 0.26,\n        vSwap: 0.20,\n        vTendency: 0.12,\n        Amp: 0.07,\n        Inertia: 0.05\n    },\n    stb: {\n        Inertia: 0.44,\n        vTendency: 0.18,\n        vSwap: 0.16,\n        Volt: 0.08,\n        Amp: 0.06,\n        Disruption: 0.08\n    },\n    flo: {\n        Amp: 0.30,\n        vSwap: 0.28,\n        Volt: 0.16,\n        vTendency: 0.12,\n        Disruption: 0.08,\n        Inertia: 0.06\n    }\n};\nconst MOOD_CLASS_ROWS = Object.keys(MOOD_CLASS_WEIGHTS).map((mn)=>({\n        mn,\n        weights: MOOD_CLASS_WEIGHTS[mn],\n        intervals: DEFAULT_TIER_RULES\n    }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9tb28tYXV4L3RpZXJzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxxQ0FBcUM7QUFFckMsNERBQTRELEdBUzVELDZCQUE2QjtBQUN0QixNQUFNQSxxQkFBaUM7SUFDNUM7UUFBRUMsS0FBSztRQUFXQyxNQUFNO1FBQVdDLFFBQVE7UUFBU0MsUUFBUTtRQUFTQyxRQUFRO0lBQUs7SUFDbEY7UUFBRUosS0FBSztRQUFXQyxNQUFNO1FBQVdDLFFBQVE7UUFBU0MsUUFBUTtRQUFTQyxRQUFRO0lBQUs7SUFDbEY7UUFBRUosS0FBSztRQUFXQyxNQUFNO1FBQVdDLFFBQVE7UUFBU0MsUUFBUTtRQUFTQyxRQUFRO0lBQUs7SUFDbEY7UUFBRUosS0FBSztRQUFXQyxNQUFNO1FBQVdDLFFBQVE7UUFBU0MsUUFBUTtRQUFTQyxRQUFRO0lBQUs7SUFDbEY7UUFBRUosS0FBSztRQUFXQyxNQUFNO1FBQVdDLFFBQVE7UUFBU0MsUUFBUTtRQUFVQyxRQUFRO0lBQUs7Q0FDcEYsQ0FBQztBQUVLLFNBQVNDLGlCQUFpQkMsTUFBYyxFQUFFQyxRQUFvQlIsa0JBQWtCO0lBQ3JGLE1BQU1TLElBQUlDLEtBQUtDLEdBQUcsQ0FBQ0MsT0FBT0wsVUFBVTtJQUNwQyxNQUFNTSxJQUFJTCxNQUFNTSxJQUFJLENBQUNELENBQUFBLElBQUtKLEtBQUtJLEVBQUVWLE1BQU0sSUFBS1UsQ0FBQUEsRUFBRVQsTUFBTSxJQUFJLFFBQVFLLEtBQUtJLEVBQUVULE1BQU07SUFDN0UsT0FBT1MsSUFBSUEsRUFBRVIsTUFBTSxHQUFHO0FBQ3hCO0FBU0E7OztDQUdDLEdBQ00sTUFBTVUscUJBQXFFO0lBQ2hGQyxLQUFJO1FBQUVDLFdBQVU7UUFBTUMsT0FBTTtRQUFNQyxNQUFLO1FBQU1DLFNBQVE7UUFBTUMsS0FBSTtRQUFNQyxZQUFXO0lBQUs7SUFDckZDLEtBQUk7UUFBRU4sV0FBVTtRQUFNQyxPQUFNO1FBQU1FLFNBQVE7UUFBTUQsTUFBSztRQUFNRSxLQUFJO1FBQU1DLFlBQVc7SUFBSztJQUNyRkUsS0FBSTtRQUFFTixPQUFNO1FBQU1JLFlBQVc7UUFBTUQsS0FBSTtRQUFNSixXQUFVO1FBQU1FLE1BQUs7UUFBTUMsU0FBUTtJQUFLO0lBQ3JGSyxLQUFJO1FBQUVDLFVBQVM7UUFBTVIsT0FBTTtRQUFNQyxNQUFLO1FBQU1HLFlBQVc7UUFBTUYsU0FBUTtRQUFNQyxLQUFJO0lBQUs7SUFDcEZNLEtBQUk7UUFBRUQsVUFBUztRQUFNUCxNQUFLO1FBQU1ELE9BQU07UUFBTUksWUFBVztRQUFNRixTQUFRO1FBQU1DLEtBQUk7SUFBSztJQUNwRk8sS0FBSTtRQUFFUixTQUFRO1FBQU1ELE1BQUs7UUFBTUUsS0FBSTtRQUFNSCxPQUFNO1FBQU1ELFdBQVU7UUFBTUssWUFBVztJQUFLO0lBQ3JGTyxLQUFJO1FBQUVQLFlBQVc7UUFBTUgsTUFBSztRQUFNRCxPQUFNO1FBQU1ELFdBQVU7UUFBTUksS0FBSTtRQUFNRCxTQUFRO0lBQUs7SUFDckZVLEtBQUk7UUFBRVYsU0FBUTtRQUFNSCxXQUFVO1FBQU1DLE9BQU07UUFBTUMsTUFBSztRQUFNRSxLQUFJO1FBQU1DLFlBQVc7SUFBSztJQUNyRlMsS0FBSTtRQUFFVixLQUFJO1FBQU1ILE9BQU07UUFBTUMsTUFBSztRQUFNRixXQUFVO1FBQU1LLFlBQVc7UUFBTUYsU0FBUTtJQUFLO0FBQ3ZGLEVBQUU7QUFZSyxNQUFNWSxrQkFBa0MsT0FBUUUsSUFBSSxDQUFDbkIsb0JBQTZCb0IsR0FBRyxDQUFDQyxDQUFBQSxLQUFPO1FBQ2xHQTtRQUNBQyxTQUFTdEIsa0JBQWtCLENBQUNxQixHQUFHO1FBQy9CRSxXQUFXdEM7SUFDYixJQUFJIiwic291cmNlcyI6WyJIOlxcVXNlcnNcXEd1c1xcc291cmNlXFxyZXBvXFxkeW5hbWljc1xcZHluYW1pY3MtYlxcY3J5cHRvcGktZHluYW1pY3NcXHNyY1xcY29yZVxcZmVhdHVyZXNcXG1vby1hdXhcXHRpZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb3JlL2ZlYXR1cmVzL21vby1hdXgvdGllcnMudHNcclxuXHJcbi8qKiAtLS0tLS0tLS0tIGxlZ2FjeSBNRUEgYmlucyAoaWRfcGN0IOKGkiB3ZWlnaHQpIC0tLS0tLS0tLS0gKi9cclxuZXhwb3J0IHR5cGUgVGllclJ1bGUgPSB7XHJcbiAgbWluQWJzOiBudW1iZXI7ICAgICAgICAgICAgICAgIC8vIGluY2x1c2l2ZVxyXG4gIG1heEFiczogbnVtYmVyIHwgbnVsbDsgICAgICAgICAvLyBpbmNsdXNpdmUgd2hlbiBudW1iZXI7IG51bGwgPT4gK+KInlxyXG4gIHdlaWdodDogbnVtYmVyOyAgICAgICAgICAgICAgICAvLyB1bnNpZ25lZCBiaW4gd2VpZ2h0XHJcbiAgbmFtZTogc3RyaW5nOyAgICAgICAgICAgICAgICAgIC8vIFwiQWxwaGFcIiB8IC4uLlxyXG4gIGtleTogXCJhbHBoYVwifFwiYmV0YVwifFwiZ2FtbWFcInxcImRlbHRhXCJ8XCJlcHNpbG9uXCI7XHJcbn07XHJcblxyXG4vLyBkZWZhdWx0IGJpbnMgKHR1bmUgZnJlZWx5KVxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9USUVSX1JVTEVTOiBUaWVyUnVsZVtdID0gW1xyXG4gIHsga2V5OiBcImFscGhhXCIsICAgbmFtZTogXCJBbHBoYVwiLCAgIG1pbkFiczogMC4wMDAxNiwgbWF4QWJzOiAwLjAwMDMyLCB3ZWlnaHQ6IDAuMTUgfSxcclxuICB7IGtleTogXCJiZXRhXCIsICAgIG5hbWU6IFwiQmV0YVwiLCAgICBtaW5BYnM6IDAuMDAwMzMsIG1heEFiczogMC4wMDA0NSwgd2VpZ2h0OiAwLjU1IH0sXHJcbiAgeyBrZXk6IFwiZ2FtbWFcIiwgICBuYW1lOiBcIkdhbW1hXCIsICAgbWluQWJzOiAwLjAwMDQ2LCBtYXhBYnM6IDAuMDAwNzYsIHdlaWdodDogMS4xNSB9LFxyXG4gIHsga2V5OiBcImRlbHRhXCIsICAgbmFtZTogXCJEZWx0YVwiLCAgIG1pbkFiczogMC4wMDA3NywgbWF4QWJzOiAwLjAwMTIwLCB3ZWlnaHQ6IDAuNjUgfSxcclxuICB7IGtleTogXCJlcHNpbG9uXCIsIG5hbWU6IFwiRXBzaWxvblwiLCBtaW5BYnM6IDAuMDAxMjEsIG1heEFiczogbnVsbCwgICAgIHdlaWdodDogMC41MCB9LFxyXG5dO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFRpZXJXZWlnaHRpbmcoaWRfcGN0OiBudW1iZXIsIHJ1bGVzOiBUaWVyUnVsZVtdID0gREVGQVVMVF9USUVSX1JVTEVTKTogbnVtYmVyIHtcclxuICBjb25zdCBhID0gTWF0aC5hYnMoTnVtYmVyKGlkX3BjdCB8fCAwKSk7XHJcbiAgY29uc3QgciA9IHJ1bGVzLmZpbmQociA9PiBhID49IHIubWluQWJzICYmIChyLm1heEFicyA9PSBudWxsIHx8IGEgPD0gci5tYXhBYnMpKTtcclxuICByZXR1cm4gciA/IHIud2VpZ2h0IDogMDtcclxufVxyXG5cclxuLyoqIC0tLS0tLS0tLS0gbW9vZCBjbGFzc2VzIChlbmdpbmUtYWxpZ25lZCkgLS0tLS0tLS0tLSAqL1xyXG5cclxuZXhwb3J0IHR5cGUgTW4gPSBcImlualwifFwiZHJuXCJ8XCJ0cmxcInxcInJldlwifFwid25kXCJ8XCJlbWdcInxcInN0ZFwifFwic3RiXCJ8XCJmbG9cIjtcclxuZXhwb3J0IHR5cGUgTWV0cmljS2V5ID1cclxuICB8IFwiR0ZNZGVsdGFcIiB8IFwidlN3YXBcIiB8IFwidlRlbmRlbmN5XCJcclxuICB8IFwiVm9sdFwiIHwgXCJJbmVydGlhXCIgfCBcIkRpc3J1cHRpb25cIiB8IFwiQW1wXCIgfCBcIk1FQVwiO1xyXG5cclxuLyoqXHJcbiAqIEJhc2UgcGVyLW1vb2Qgd2VpZ2h0cyAobWlycm9yIG9mIGVuZ2luZSBwcmVzZXRzKS5cclxuICogVGhlc2UgYXJlIG5vcm1hbGl6ZWQgaW5zaWRlIHRoZSBlbmdpbmVzIGF0IHJ1bnRpbWU7IGtlZXAgcmVsYXRpdmUgc2hhcGUgaGVyZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBNT09EX0NMQVNTX1dFSUdIVFM6IFJlY29yZDxNbiwgUGFydGlhbDxSZWNvcmQ8TWV0cmljS2V5LCBudW1iZXI+Pj4gPSB7XHJcbiAgc3RkOnsgdlRlbmRlbmN5OjAuMjgsIHZTd2FwOjAuMjIsIFZvbHQ6MC4xNiwgSW5lcnRpYTowLjE0LCBBbXA6MC4xMCwgRGlzcnVwdGlvbjowLjEwIH0sXHJcbiAgdHJsOnsgdlRlbmRlbmN5OjAuNDAsIHZTd2FwOjAuMjUsIEluZXJ0aWE6MC4xOCwgVm9sdDowLjA3LCBBbXA6MC4wNSwgRGlzcnVwdGlvbjowLjA1IH0sXHJcbiAgcmV2OnsgdlN3YXA6MC4zNCwgRGlzcnVwdGlvbjowLjIwLCBBbXA6MC4xNiwgdlRlbmRlbmN5OjAuMTYsIFZvbHQ6MC4wOCwgSW5lcnRpYTowLjA2IH0sXHJcbiAgaW5qOnsgR0ZNZGVsdGE6MC4zOCwgdlN3YXA6MC4yMiwgVm9sdDowLjE4LCBEaXNydXB0aW9uOjAuMTIsIEluZXJ0aWE6MC4wNSwgQW1wOjAuMDUgfSxcclxuICBkcm46eyBHRk1kZWx0YTowLjM2LCBWb2x0OjAuMjIsIHZTd2FwOjAuMTYsIERpc3J1cHRpb246MC4xMiwgSW5lcnRpYTowLjA4LCBBbXA6MC4wNiB9LFxyXG4gIHduZDp7IEluZXJ0aWE6MC4zNiwgVm9sdDowLjE4LCBBbXA6MC4xMCwgdlN3YXA6MC4xMiwgdlRlbmRlbmN5OjAuMTQsIERpc3J1cHRpb246MC4xMCB9LFxyXG4gIGVtZzp7IERpc3J1cHRpb246MC4zMCwgVm9sdDowLjI2LCB2U3dhcDowLjIwLCB2VGVuZGVuY3k6MC4xMiwgQW1wOjAuMDcsIEluZXJ0aWE6MC4wNSB9LFxyXG4gIHN0Yjp7IEluZXJ0aWE6MC40NCwgdlRlbmRlbmN5OjAuMTgsIHZTd2FwOjAuMTYsIFZvbHQ6MC4wOCwgQW1wOjAuMDYsIERpc3J1cHRpb246MC4wOCB9LFxyXG4gIGZsbzp7IEFtcDowLjMwLCB2U3dhcDowLjI4LCBWb2x0OjAuMTYsIHZUZW5kZW5jeTowLjEyLCBEaXNydXB0aW9uOjAuMDgsIEluZXJ0aWE6MC4wNiB9LFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE9wdGlvbmFsOiBwZXItbW9vZCDigJxpbnRlcnZhbCBsaW5lc+KAnSB5b3Ugd2FudCB0byBkaXNwbGF5IGluIFVJIG9yIHVzZSBmb3IgcmFuayBndWlkYW5jZS5cclxuICogRm9yIG5vdyB3ZSByZXVzZSB0aGUgaWRfcGN0IERFRkFVTFRfVElFUl9SVUxFUyBhcyB0aGUgcmVmZXJlbmNlIGxpbmUuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBNb29kQ2xhc3NSb3cgPSB7XHJcbiAgbW46IE1uO1xyXG4gIHdlaWdodHM6IFBhcnRpYWw8UmVjb3JkPE1ldHJpY0tleSwgbnVtYmVyPj47XHJcbiAgaW50ZXJ2YWxzOiBUaWVyUnVsZVtdOyAgICAgICAgICAvLyByZWZlcmVuY2UgYmFuZHMgYXR0YWNoZWQgdG8gdGhpcyBtb29kIHJvd1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IE1PT0RfQ0xBU1NfUk9XUzogTW9vZENsYXNzUm93W10gPSAoT2JqZWN0LmtleXMoTU9PRF9DTEFTU19XRUlHSFRTKSBhcyBNbltdKS5tYXAobW4gPT4gKHtcclxuICBtbixcclxuICB3ZWlnaHRzOiBNT09EX0NMQVNTX1dFSUdIVFNbbW5dLFxyXG4gIGludGVydmFsczogREVGQVVMVF9USUVSX1JVTEVTLFxyXG59KSk7XHJcblxyXG4iXSwibmFtZXMiOlsiREVGQVVMVF9USUVSX1JVTEVTIiwia2V5IiwibmFtZSIsIm1pbkFicyIsIm1heEFicyIsIndlaWdodCIsImdldFRpZXJXZWlnaHRpbmciLCJpZF9wY3QiLCJydWxlcyIsImEiLCJNYXRoIiwiYWJzIiwiTnVtYmVyIiwiciIsImZpbmQiLCJNT09EX0NMQVNTX1dFSUdIVFMiLCJzdGQiLCJ2VGVuZGVuY3kiLCJ2U3dhcCIsIlZvbHQiLCJJbmVydGlhIiwiQW1wIiwiRGlzcnVwdGlvbiIsInRybCIsInJldiIsImluaiIsIkdGTWRlbHRhIiwiZHJuIiwid25kIiwiZW1nIiwic3RiIiwiZmxvIiwiTU9PRF9DTEFTU19ST1dTIiwiT2JqZWN0Iiwia2V5cyIsIm1hcCIsIm1uIiwid2VpZ2h0cyIsImludGVydmFscyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/moo-aux/tiers.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/calc/executive.ts":
/*!*****************************************************!*\
  !*** ./src/core/features/str-aux/calc/executive.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeSampledMetrics: () => (/* binding */ computeSampledMetrics),\n/* harmony export */   computeSampledMetricsForSymbol: () => (/* binding */ computeSampledMetricsForSymbol),\n/* harmony export */   executeCalcAndUpdateSession: () => (/* binding */ executeCalcAndUpdateSession)\n/* harmony export */ });\n/* harmony import */ var _core_features_str_aux_frame_idhr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/features/str-aux/frame/idhr */ \"(rsc)/./src/core/features/str-aux/frame/idhr.ts\");\n/* harmony import */ var _core_features_str_aux_calc_tendency__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/core/features/str-aux/calc/tendency */ \"(rsc)/./src/core/features/str-aux/calc/tendency.ts\");\n/* harmony import */ var _core_features_str_aux_calc_metrics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/core/features/str-aux/calc/metrics */ \"(rsc)/./src/core/features/str-aux/calc/metrics.ts\");\n/* harmony import */ var _core_features_str_aux_frame_session__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/core/features/str-aux/frame/session */ \"(rsc)/./src/core/features/str-aux/frame/session.ts\");\n/* harmony import */ var _core_features_str_aux_calc_stats__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/core/features/str-aux/calc/stats */ \"(rsc)/./src/core/features/str-aux/calc/stats.ts\");\n/* harmony import */ var _core_features_str_aux_sampling__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/core/features/str-aux/sampling */ \"(rsc)/./src/core/features/str-aux/sampling/index.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_features_str_aux_sampling__WEBPACK_IMPORTED_MODULE_5__]);\n_core_features_str_aux_sampling__WEBPACK_IMPORTED_MODULE_5__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n// src/core/features/str-aux/calc/executive.ts\n // IDHR + gfm  :contentReference[oaicite:11]{index=11}\n // vectors     :contentReference[oaicite:12]{index=12}\n // inertia.    :contentReference[oaicite:13]{index=13}\n // session API :contentReference[oaicite:14]{index=14}\n\n\nfunction toSeries(payload) {\n    const ts = payload.snapshot.tick.cycleTs ?? payload.frames.cycleStart;\n    const out = {};\n    for (const p of payload.snapshot.points){\n        const price = Number(p.mid ?? NaN);\n        if (!Number.isFinite(price)) continue;\n        (out[p.symbol] ??= []).push({\n            ts,\n            price\n        });\n    }\n    return out;\n}\nfunction openingFromSeries(series) {\n    const first = series.find((p)=>Number.isFinite(p.price));\n    return {\n        benchmark: first ? first.price : null\n    };\n}\nfunction executeCalcAndUpdateSession(appSessionId, payload, seriesBuffers, pct24hMap) {\n    const res = [];\n    const seriesNow = toSeries(payload);\n    for (const [pair, pts] of Object.entries(seriesNow)){\n        // append into buffers\n        const buf = seriesBuffers[pair] = (seriesBuffers[pair] ?? []).concat(pts).slice(-3600);\n        const opening = openingFromSeries(buf);\n        const idhr = (0,_core_features_str_aux_frame_idhr__WEBPACK_IMPORTED_MODULE_0__.computeFM)(buf, opening); // returns { gfm, sigmaGlobal, zMeanAbs, nuclei }  :contentReference[oaicite:15]{index=15}\n        const gfmCalcPrice = Number.isFinite(idhr?.gfm) ? idhr.gfm : NaN;\n        // simple tendency from last N returns (use z as unitless)\n        const returns = buf.slice(-60).map((p, i, a)=>i ? 100 * (p.price / a[i - 1].price - 1) : 0).slice(1);\n        const vin = returns.length ? _core_features_str_aux_calc_tendency__WEBPACK_IMPORTED_MODULE_1__.vInner({\n            values: returns\n        }, {\n            scale: 100\n        }) : 0;\n        const vout = returns.length ? _core_features_str_aux_calc_tendency__WEBPACK_IMPORTED_MODULE_1__.vOuter([\n            {\n                values: returns\n            }\n        ], undefined, {\n            scale: 100\n        }) : 0;\n        const vt = returns.length ? _core_features_str_aux_calc_tendency__WEBPACK_IMPORTED_MODULE_1__.vTendencyFromSeries(returns, {\n            scale: 100\n        }).score : 0;\n        // inertia example: from returns only (window=returns.length)\n        const inertia = returns.length ? _core_features_str_aux_calc_metrics__WEBPACK_IMPORTED_MODULE_2__.inertiaFromReturns(returns, {\n            window: returns.length\n        }) : null;\n        // session update\n        const nowTs = payload.frames.cycleEnd ?? payload.snapshot.tick.cycleTs ?? Date.now();\n        const priceNow = buf[buf.length - 1]?.price ?? NaN;\n        const pct24hNow = Number(pct24hMap?.[pair] ?? 0);\n        const ss = (0,_core_features_str_aux_frame_session__WEBPACK_IMPORTED_MODULE_3__.getOrInitSymbolSession)(appSessionId, pair, opening.benchmark ?? priceNow ?? 0, nowTs);\n        const upd = (0,_core_features_str_aux_frame_session__WEBPACK_IMPORTED_MODULE_3__.updateSymbolSession)(ss, priceNow, nowTs, gfmCalcPrice, pct24hNow); // :contentReference[oaicite:17]{index=17}\n        res.push({\n            pair,\n            idhr: {\n                gfm: Number.isFinite(idhr.gfm) ? idhr.gfm : null,\n                sigmaGlobal: Number.isFinite(idhr.sigmaGlobal) ? idhr.sigmaGlobal : null,\n                zMeanAbs: Number.isFinite(idhr.zMeanAbs) ? idhr.zMeanAbs : null,\n                nuclei: idhr.nuclei ?? []\n            },\n            vectors: {\n                vInner: vin,\n                vOuter: vout,\n                vTendency: vt\n            },\n            metrics: {\n                inertia\n            },\n            session: {\n                uiEpoch: upd.uiEpoch,\n                gfmRefPrice: upd.gfmRefPrice,\n                gfmCalcPrice: upd.gfmCalcPrice,\n                gfmDeltaAbsPct: upd.gfmDeltaAbsPct\n            }\n        });\n    }\n    return res;\n}\nasync function computeSampledMetricsForSymbol(symbol, opts) {\n    const sampler = (0,_core_features_str_aux_sampling__WEBPACK_IMPORTED_MODULE_5__.getSamplingStore)();\n    let snapshot;\n    if (opts.collect === false) {\n        snapshot = sampler.snapshot(symbol);\n    } else {\n        try {\n            const collected = await sampler.collect(symbol);\n            snapshot = collected.snapshot;\n        } catch  {\n            snapshot = sampler.snapshot(symbol);\n        }\n    }\n    const sampling = (0,_core_features_str_aux_sampling__WEBPACK_IMPORTED_MODULE_5__.summarizeSnapshotWindow)(snapshot, opts.window);\n    const points = sampler.getPoints(symbol, opts.window);\n    const series = pointsToStatPoints(points);\n    if (!series.length) {\n        return {\n            ok: false,\n            symbol,\n            error: \"no_points\",\n            sampling\n        };\n    }\n    const bins = Math.max(1, Math.floor(opts.bins ?? 1));\n    const opening = series[0].price;\n    const statsOptions = {\n        ...opts.stats ?? {},\n        idhr: {\n            ...opts.stats?.idhr ?? {},\n            bins\n        }\n    };\n    const stats = (0,_core_features_str_aux_calc_stats__WEBPACK_IMPORTED_MODULE_4__.computeStats)(series, {\n        benchmark: opening\n    }, statsOptions);\n    const priceValues = series.map((p)=>p.price);\n    const priceMin = Math.min(...priceValues);\n    const priceMax = Math.max(...priceValues);\n    const benchValues = series.map((p)=>benchPct(opening, p.price));\n    const benchPctMin = Math.min(...benchValues);\n    const benchPctMax = Math.max(...benchValues);\n    const histogram = stats.histogram;\n    const lastPoint = series[series.length - 1];\n    const fallbackHistogram = ()=>{\n        const counts = makeCounts(series, opening, bins);\n        const total = counts.reduce((s, c)=>s + c, 0);\n        const probs = total > 0 ? counts.map((c)=>c / total) : counts.map(()=>0);\n        return {\n            counts,\n            edges: [],\n            probs,\n            densest: [],\n            muR: 0,\n            sigmaR: 0,\n            total,\n            binWidth: null,\n            rMin: null,\n            rMax: null,\n            returnsPct: []\n        };\n    };\n    const histOut = histogram && histogram.counts?.length ? {\n        counts: histogram.counts,\n        edges: histogram.edges,\n        probs: histogram.probs,\n        densest: histogram.densest,\n        muR: histogram.muR,\n        sigmaR: histogram.sigmaR,\n        total: histogram.total,\n        binWidth: histogram.edges.length > 1 ? histogram.edges[1] - histogram.edges[0] : null,\n        rMin: histogram.edges[0] ?? null,\n        rMax: histogram.edges[histogram.edges.length - 1] ?? null,\n        returnsPct: histogram.edges.map((r)=>{\n            const pct = Math.expm1(r) * 100;\n            return Number.isFinite(pct) ? pct : 0;\n        })\n    } : fallbackHistogram();\n    return {\n        ok: true,\n        symbol,\n        stats,\n        hist: histOut,\n        extrema: {\n            priceMin,\n            priceMax,\n            benchPctMin,\n            benchPctMax\n        },\n        meta: {\n            opening: stats.opening,\n            last: stats.last,\n            prev: stats.prev,\n            lastUpdateTs: lastPoint.ts,\n            n: series.length\n        },\n        sampling\n    };\n}\nasync function computeSampledMetrics(symbols, opts) {\n    const pairs = await Promise.all(symbols.map(async (sym)=>[\n            sym,\n            await computeSampledMetricsForSymbol(sym, opts)\n        ]));\n    const out = {};\n    for (const [sym, result] of pairs)out[sym] = result;\n    return out;\n}\nfunction pointsToStatPoints(points) {\n    return points.filter((p)=>Number.isFinite(p.mid) && p.mid > 0).map((p)=>{\n        const bid = Number.isFinite(p.bidVolume) ? p.bidVolume : 0;\n        const ask = Number.isFinite(p.askVolume) ? p.askVolume : 0;\n        return {\n            ts: p.ts,\n            price: p.mid,\n            volume: Math.max(0, bid + ask)\n        };\n    });\n}\nfunction makeCounts(points, opening, totalBins) {\n    const bins = Math.max(1, totalBins);\n    if (!points.length || !(opening > 0)) return Array(bins).fill(0);\n    const rets = points.map((p)=>Math.log(p.price / opening));\n    const min = Math.min(...rets);\n    const max = Math.max(...rets);\n    const lo = min === max ? min - 1e-6 : min;\n    const hi = min === max ? max + 1e-6 : max;\n    const counts = Array(bins).fill(0);\n    for (const r of rets){\n        const t = (r - lo) / (hi - lo);\n        const idx = Math.max(0, Math.min(bins - 1, Math.floor(t * bins)));\n        counts[idx] += 1;\n    }\n    return counts;\n}\nfunction benchPct(opening, cur) {\n    return 100 * (cur / opening - 1);\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L2NhbGMvZXhlY3V0aXZlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDhDQUE4QztBQUVpQixDQUFpQixzREFBc0Q7QUFDeEUsQ0FBTyxzREFBc0Q7QUFDL0QsQ0FBb0Isc0RBQXNEO0FBS3ZGLENBQTJDLHNEQUFzRDtBQU1wRztBQU9GO0FBSTFDLFNBQVNRLFNBQVNDLE9BQXlCO0lBQ3pDLE1BQU1DLEtBQUtELFFBQVFFLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDQyxPQUFPLElBQUlKLFFBQVFLLE1BQU0sQ0FBQ0MsVUFBVTtJQUNyRSxNQUFNQyxNQUFxQyxDQUFDO0lBQzVDLEtBQUssTUFBTUMsS0FBS1IsUUFBUUUsUUFBUSxDQUFDTyxNQUFNLENBQUU7UUFDdkMsTUFBTUMsUUFBUUMsT0FBT0gsRUFBRUksR0FBRyxJQUFJQztRQUM5QixJQUFJLENBQUNGLE9BQU9HLFFBQVEsQ0FBQ0osUUFBUTtRQUM1QkgsQ0FBQUEsR0FBRyxDQUFDQyxFQUFFTyxNQUFNLENBQUMsS0FBSyxFQUFFLEVBQUVDLElBQUksQ0FBQztZQUFFZjtZQUFJUztRQUFNO0lBQzFDO0lBQ0EsT0FBT0g7QUFDVDtBQUVBLFNBQVNVLGtCQUFrQkMsTUFBcUI7SUFDOUMsTUFBTUMsUUFBUUQsT0FBT0UsSUFBSSxDQUFDLENBQUNaLElBQU1HLE9BQU9HLFFBQVEsQ0FBQ04sRUFBRUUsS0FBSztJQUN4RCxPQUFPO1FBQUVXLFdBQVdGLFFBQVFBLE1BQU1ULEtBQUssR0FBRztJQUFLO0FBQ2pEO0FBYU8sU0FBU1ksNEJBQ2RDLFlBQW9CLEVBQ3BCdkIsT0FBeUIsRUFDekJ3QixhQUE0QyxFQUM1Q0MsU0FBa0M7SUFFbEMsTUFBTUMsTUFBb0IsRUFBRTtJQUM1QixNQUFNQyxZQUFZNUIsU0FBU0M7SUFFM0IsS0FBSyxNQUFNLENBQUM0QixNQUFNQyxJQUFJLElBQUlDLE9BQU9DLE9BQU8sQ0FBQ0osV0FBWTtRQUNuRCxzQkFB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QUNSLE9BQU8sR0FBR0MsS0FBS0UsS0FBSyxDQUFDNEQsSUFBSS9EO1FBQzFEaUIsTUFBTSxDQUFDK0MsSUFBSSxJQUFJO0lBQ2pCO0lBQ0EsT0FBTy9DO0FBQ1Q7QUFFQSxTQUFTTixTQUFTN0QsT0FBZSxFQUFFbUgsR0FBVztJQUM1QyxPQUFPLE1BQU8sT0FBT25ILFVBQVc7QUFDbEMiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxjb3JlXFxmZWF0dXJlc1xcc3RyLWF1eFxcY2FsY1xcZXhlY3V0aXZlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb3JlL2ZlYXR1cmVzL3N0ci1hdXgvY2FsYy9leGVjdXRpdmUudHNcclxuaW1wb3J0IHR5cGUgeyBTbmFwc2hvdFdpdGhSZWZzIH0gZnJvbSBcIi4uL2ZyYW1lXCI7XHJcbmltcG9ydCB7IGNvbXB1dGVGTSB9IGZyb20gXCJAL2NvcmUvZmVhdHVyZXMvc3RyLWF1eC9mcmFtZS9pZGhyXCI7ICAgICAgICAgICAgICAgICAvLyBJREhSICsgZ2ZtICA6Y29udGVudFJlZmVyZW5jZVtvYWljaXRlOjExXXtpbmRleD0xMX1cclxuaW1wb3J0ICogYXMgVGVuZCBmcm9tIFwiQC9jb3JlL2ZlYXR1cmVzL3N0ci1hdXgvY2FsYy90ZW5kZW5jeVwiOyAgICAgICAvLyB2ZWN0b3JzICAgICA6Y29udGVudFJlZmVyZW5jZVtvYWljaXRlOjEyXXtpbmRleD0xMn1cclxuaW1wb3J0ICogYXMgTWV0IGZyb20gXCJAL2NvcmUvZmVhdHVyZXMvc3RyLWF1eC9jYWxjL21ldHJpY3NcIjsgICAgICAgICAgICAgICAgICAgIC8vIGluZXJ0aWEuICAgIDpjb250ZW50UmVmZXJlbmNlW29haWNpdGU6MTNde2luZGV4PTEzfVxyXG5pbXBvcnQge1xyXG4gIGdldE9ySW5pdFN5bWJvbFNlc3Npb24sXHJcbiAgdXBkYXRlU3ltYm9sU2Vzc2lvbixcclxuICB0eXBlIFNuYXBzaG90IGFzIFNlc3NTbmFwXHJcbn0gZnJvbSBcIkAvY29yZS9mZWF0dXJlcy9zdHItYXV4L2ZyYW1lL3Nlc3Npb25cIjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2Vzc2lvbiBBUEkgOmNvbnRlbnRSZWZlcmVuY2Vbb2FpY2l0ZToxNF17aW5kZXg9MTR9XHJcbmltcG9ydCB7XHJcbiAgY29tcHV0ZVN0YXRzLFxyXG4gIHR5cGUgUG9pbnQgYXMgU3RhdFBvaW50LFxyXG4gIHR5cGUgU3RhdHMsXHJcbiAgdHlwZSBTdGF0c09wdGlvbnMsXHJcbn0gZnJvbSBcIkAvY29yZS9mZWF0dXJlcy9zdHItYXV4L2NhbGMvc3RhdHNcIjtcclxuaW1wb3J0IHtcclxuICBnZXRTYW1wbGluZ1N0b3JlLFxyXG4gIHN1bW1hcml6ZVNuYXBzaG90V2luZG93LFxyXG4gIHR5cGUgU2FtcGxpbmdQb2ludCxcclxuICB0eXBlIFNhbXBsaW5nV2luZG93RGlnZXN0LFxyXG4gIHR5cGUgU2FtcGxpbmdXaW5kb3dLZXksXHJcbn0gZnJvbSBcIkAvY29yZS9mZWF0dXJlcy9zdHItYXV4L3NhbXBsaW5nXCI7XHJcbmV4cG9ydCB0eXBlIE1hcmtldFBvaW50ID0geyB0czogbnVtYmVyOyBwcmljZTogbnVtYmVyIH07XHJcbmV4cG9ydCB0eXBlIE9wZW5pbmdFeGFjdCA9IHsgYmVuY2htYXJrOiBudW1iZXIgfCBudWxsIH07XHJcblxyXG5mdW5jdGlvbiB0b1NlcmllcyhwYXlsb2FkOiBTbmFwc2hvdFdpdGhSZWZzKTogUmVjb3JkPHN0cmluZywgTWFya2V0UG9pbnRbXT4ge1xyXG4gIGNvbnN0IHRzID0gcGF5bG9hZC5zbmFwc2hvdC50aWNrLmN5Y2xlVHMgPz8gcGF5bG9hZC5mcmFtZXMuY3ljbGVTdGFydDtcclxuICBjb25zdCBvdXQ6IFJlY29yZDxzdHJpbmcsIE1hcmtldFBvaW50W10+ID0ge307XHJcbiAgZm9yIChjb25zdCBwIG9mIHBheWxvYWQuc25hcHNob3QucG9pbnRzKSB7XHJcbiAgICBjb25zdCBwcmljZSA9IE51bWJlcihwLm1pZCA/PyBOYU4pO1xyXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocHJpY2UpKSBjb250aW51ZTtcclxuICAgIChvdXRbcC5zeW1ib2xdID8/PSBbXSkucHVzaCh7IHRzLCBwcmljZSB9KTtcclxuICB9XHJcbiAgcmV0dXJuIG91dDtcclxufVxyXG5cclxuZnVuY3Rpb24gb3BlbmluZ0Zyb21TZXJpZXMoc2VyaWVzOiBNYXJrZXRQb2ludFtdKTogT3BlbmluZ0V4YWN0IHtcclxuICBjb25zdCBmaXJzdCA9IHNlcmllcy5maW5kKChwKSA9PiBOdW1iZXIuaXNGaW5pdGUocC5wcmljZSkpO1xyXG4gIHJldHVybiB7IGJlbmNobWFyazogZmlyc3QgPyBmaXJzdC5wcmljZSA6IG51bGwgfTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgRXhlY1Jlc3VsdCA9IHtcclxuICBwYWlyOiBzdHJpbmc7XHJcbiAgaWRocjogeyBnZm06IG51bWJlciB8IG51bGw7IHNpZ21hR2xvYmFsOiBudW1iZXIgfCBudWxsOyB6TWVhbkFiczogbnVtYmVyIHwgbnVsbDsgbnVjbGVpOiBhbnlbXSB9O1xyXG4gIHZlY3RvcnM6IHsgdklubmVyPzogbnVtYmVyOyB2T3V0ZXI/OiBudW1iZXI7IHZUZW5kZW5jeT86IG51bWJlciB9O1xyXG4gIG1ldHJpY3M6IHsgaW5lcnRpYT86IHsgc3RhdGljOiBudW1iZXI7IGdyb3d0aDogbnVtYmVyOyB0b3RhbDogbnVtYmVyIH0gfCBudWxsIH07XHJcbiAgc2Vzc2lvbjoge1xyXG4gICAgdWlFcG9jaDogbnVtYmVyOyBnZm1SZWZQcmljZTogbnVtYmVyIHwgbnVsbDsgZ2ZtQ2FsY1ByaWNlOiBudW1iZXIgfCBudWxsOyBnZm1EZWx0YUFic1BjdDogbnVtYmVyO1xyXG4gICAgc25hcHNob3Q6IFNlc3NTbmFwO1xyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZXhlY3V0ZUNhbGNBbmRVcGRhdGVTZXNzaW9uKFxyXG4gIGFwcFNlc3Npb25JZDogc3RyaW5nLFxyXG4gIHBheWxvYWQ6IFNuYXBzaG90V2l0aFJlZnMsXHJcbiAgc2VyaWVzQnVmZmVyczogUmVjb3JkPHN0cmluZywgTWFya2V0UG9pbnRbXT4sICAvLyByaW5nLWJ1ZmZlcnMgcGVyIFwiQkFTRS9RVU9URVwiXHJcbiAgcGN0MjRoTWFwPzogUmVjb3JkPHN0cmluZywgbnVtYmVyPiwgICAgICAgICAgIC8vIG9wdGlvbmFsIDI0aCAlXHJcbik6IEV4ZWNSZXN1bHRbXSB7XHJcbiAgY29uc3QgcmVzOiBFeGVjUmVzdWx0W10gPSBbXTtcclxuICBjb25zdCBzZXJpZXNOb3cgPSB0b1NlcmllcyhwYXlsb2FkKTtcclxuXHJcbiAgZm9yIChjb25zdCBbcGFpciwgcHRzXSBvZiBPYmplY3QuZW50cmllcyhzZXJpZXNOb3cpKSB7XHJcbiAgICAvLyBhcHBlbmQgaW50byBidWZmZXJzXHJcbiAgICBjb25zdCBidWYgPSBzZXJpZXNCdWZmZXJzW3BhaXJdID0gKHNlcmllc0J1ZmZlcnNbcGFpcl0gPz8gW10pLmNvbmNhdChwdHMpLnNsaWNlKC0zNjAwKTtcclxuXHJcbiAgICBjb25zdCBvcGVuaW5nID0gb3BlbmluZ0Zyb21TZXJpZXMoYnVmKTtcclxuICAgIGNvbnN0IGlkaHIgPSBjb21wdXRlRk0oYnVmIGFzIGFueSwgb3BlbmluZyBhcyBhbnkpOyAvLyByZXR1cm5zIHsgZ2ZtLCBzaWdtYUdsb2JhbCwgek1lYW5BYnMsIG51Y2xlaSB9ICA6Y29udGVudFJlZmVyZW5jZVtvYWljaXRlOjE1XXtpbmRleD0xNX1cclxuICAgIGNvbnN0IGdmbUNhbGNQcmljZSA9IE51bWJlci5pc0Zpbml0ZShpZGhyPy5nZm0pID8gaWRoci5nZm0gOiBOYU47XHJcblxyXG4gICAgLy8gc2ltcGxlIHRlbmRlbmN5IGZyb20gbGFzdCBOIHJldHVybnMgKHVzZSB6IGFzIHVuaXRsZXNzKVxyXG4gICAgY29uc3QgcmV0dXJucyA9IGJ1ZlxyXG4gICAgICAuc2xpY2UoLTYwKVxyXG4gICAgICAubWFwKChwLCBpLCBhKSA9PiAoaSA/IDEwMCAqIChwLnByaWNlIC8gYVtpIC0gMV0ucHJpY2UgLSAxKSA6IDApKVxyXG4gICAgICAuc2xpY2UoMSk7XHJcbiAgICBjb25zdCB2aW4gPSByZXR1cm5zLmxlbmd0aCA/IFRlbmQudklubmVyKHsgdmFsdWVzOiByZXR1cm5zIH0sIHsgc2NhbGU6IDEwMCB9KSA6IDA7XHJcbiAgICBjb25zdCB2b3V0ID0gcmV0dXJucy5sZW5ndGggPyBUZW5kLnZPdXRlcihbeyB2YWx1ZXM6IHJldHVybnMgfV0sIHVuZGVmaW5lZCwgeyBzY2FsZTogMTAwIH0pIDogMDtcclxuICAgIGNvbnN0IHZ0ID0gcmV0dXJucy5sZW5ndGggPyBUZW5kLnZUZW5kZW5jeUZyb21TZXJpZXMocmV0dXJucywgeyBzY2FsZTogMTAwIH0pLnNjb3JlIDogMDtcclxuXHJcbiAgICAvLyBpbmVydGlhIGV4YW1wbGU6IGZyb20gcmV0dXJucyBvbmx5ICh3aW5kb3c9cmV0dXJucy5sZW5ndGgpXHJcbiAgICBjb25zdCBpbmVydGlhID0gcmV0dXJucy5sZW5ndGhcclxuICAgICAgPyBNZXQuaW5lcnRpYUZyb21SZXR1cm5zKHJldHVybnMsIHsgd2luZG93OiByZXR1cm5zLmxlbmd0aCB9KVxyXG4gICAgICA6IG51bGw7XHJcblxyXG4gICAgLy8gc2Vzc2lvbiB1cGRhdGVcclxuICAgIGNvbnN0IG5vd1RzID0gcGF5bG9hZC5mcmFtZXMuY3ljbGVFbmQgPz8gcGF5bG9hZC5zbmFwc2hvdC50aWNrLmN5Y2xlVHMgPz8gRGF0ZS5ub3coKTtcclxuICAgIGNvbnN0IHByaWNlTm93ID0gYnVmW2J1Zi5sZW5ndGggLSAxXT8ucHJpY2UgPz8gTmFOO1xyXG4gICAgY29uc3QgcGN0MjRoTm93ID0gTnVtYmVyKHBjdDI0aE1hcD8uW3BhaXJdID8/IDApO1xyXG5cclxuICAgIGNvbnN0IHNzID0gZ2V0T3JJbml0U3ltYm9sU2Vzc2lvbihhcHBTZXNzaW9uSWQsIHBhaXIsIG9wZW5pbmcuYmVuY2htYXJrID8/IHByaWNlTm93ID8/IDAsIG5vd1RzKTtcclxuICAgIGNvbnN0IHVwZCA9IHVwZGF0ZVN5bWJvbFNlc3Npb24oc3MsIHByaWNlTm93LCBub3dUcywgZ2ZtQ2FsY1ByaWNlLCBwY3QyNGhOb3cpOyAgICAgICAgICAgICAgICAgICAgIC8vIDpjb250ZW50UmVmZXJlbmNlW29haWNpdGU6MTdde2luZGV4PTE3fVxyXG5cclxuICAgIHJlcy5wdXNoKHtcclxuICAgICAgcGFpcixcclxuICAgICAgaWRocjoge1xyXG4gICAgICAgIGdmbTogTnVtYmVyLmlzRmluaXRlKGlkaHIuZ2ZtKSA/IGlkaHIuZ2ZtIDogbnVsbCxcclxuICAgICAgICBzaWdtYUdsb2JhbDogTnVtYmVyLmlzRmluaXRlKGlkaHIuc2lnbWFHbG9iYWwpID8gaWRoci5zaWdtYUdsb2JhbCA6IG51bGwsXHJcbiAgICAgICAgek1lYW5BYnM6IE51bWJlci5pc0Zpbml0ZShpZGhyLnpNZWFuQWJzKSA/IGlkaHIuek1lYW5BYnMgOiBudWxsLFxyXG4gICAgICAgIG51Y2xlaTogaWRoci5udWNsZWkgPz8gW10sXHJcbiAgICAgIH0sXHJcbiAgICAgIHZlY3RvcnM6IHsgdklubmVyOiB2aW4sIHZPdXRlcjogdm91dCwgdlRlbmRlbmN5OiB2dCB9LFxyXG4gICAgICBtZXRyaWNzOiB7IGluZXJ0aWEgfSxcclxuICAgICAgc2Vzc2lvbjoge1xyXG4gICAgICAgIHVpRXBvY2g6IHVwZC51aUVwb2NoLFxyXG4gICAgICAgIGdmbVJlZlByaWNlOiB1cGQuZ2ZtUmVmUHJpY2UsXHJcbiAgICAgICAgZ2ZtQ2FsY1ByaWNlOiB1cGQuZ2ZtQ2FsY1ByaWNlLFxyXG4gICAgICAgIGdmbURlbHRhQWJzUGN0OiB1cGQuZ2ZtRGVsdGFBYnNQY3QsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiByZXM7XHJcbn1cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBTYW1wbGluZy1iYWNrZWQgbWV0cmljcyBvcmNoZXN0cmF0aW9uICh1c2VkIGJ5IC9hcGkvc3RyLWF1eC9zdGF0cyAmIGZyaWVuZHMpXHJcblxyXG5leHBvcnQgdHlwZSBTYW1wbGVkU2VyaWVzTWV0YSA9IHtcclxuICBvcGVuaW5nOiBudW1iZXI7XHJcbiAgbGFzdDogbnVtYmVyO1xyXG4gIHByZXY6IG51bWJlcjtcclxuICBsYXN0VXBkYXRlVHM6IG51bWJlcjtcclxuICBuOiBudW1iZXI7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBTYW1wbGVkTWV0cmljc1N1Y2Nlc3MgPSB7XHJcbiAgb2s6IHRydWU7XHJcbiAgc3ltYm9sOiBzdHJpbmc7XHJcbiAgc3RhdHM6IFN0YXRzO1xyXG4gIGhpc3Q6IHtcclxuICAgIGNvdW50czogbnVtYmVyW107XHJcbiAgICBlZGdlczogbnVtYmVyW107XHJcbiAgICBwcm9iczogbnVtYmVyW107XHJcbiAgICBkZW5zZXN0OiBudW1iZXJbXTtcclxuICAgIG11UjogbnVtYmVyO1xyXG4gICAgc2lnbWFSOiBudW1iZXI7XHJcbiAgICB0b3RhbDogbnVtYmVyO1xyXG4gICAgYmluV2lkdGg6IG51bWJlciB8IG51bGw7XHJcbiAgICByTWluOiBudW1iZXIgfCBudWxsO1xyXG4gICAgck1heDogbnVtYmVyIHwgbnVsbDtcclxuICAgIHJldHVybnNQY3Q6IG51bWJlcltdO1xyXG4gIH07XHJcbiAgZXh0cmVtYTogeyBwcmljZU1pbjogbnVtYmVyOyBwcmljZU1heDogbnVtYmVyOyBiZW5jaFBjdE1pbjogbnVtYmVyOyBiZW5jaFBjdE1heDogbnVtYmVyIH07XHJcbiAgbWV0YTogU2FtcGxlZFNlcmllc01ldGE7XHJcbiAgc2FtcGxpbmc6IFNhbXBsaW5nV2luZG93RGlnZXN0O1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgU2FtcGxlZE1ldHJpY3NFcnJvciA9IHtcclxuICBvazogZmFsc2U7XHJcbiAgc3ltYm9sOiBzdHJpbmc7XHJcbiAgZXJyb3I6IHN0cmluZztcclxuICBzYW1wbGluZz86IFNhbXBsaW5nV2luZG93RGlnZXN0O1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgU2FtcGxlZE1ldHJpY3NSZXN1bHQgPSBTYW1wbGVkTWV0cmljc1N1Y2Nlc3MgfCBTYW1wbGVkTWV0cmljc0Vycm9yO1xyXG5cclxuZXhwb3J0IHR5cGUgU2FtcGxlZE1ldHJpY3NPcHRpb25zID0ge1xyXG4gIHdpbmRvdzogU2FtcGxpbmdXaW5kb3dLZXk7XHJcbiAgYmluczogbnVtYmVyO1xyXG4gIGNvbGxlY3Q/OiBib29sZWFuO1xyXG4gIHN0YXRzPzogU3RhdHNPcHRpb25zO1xyXG59O1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVTYW1wbGVkTWV0cmljc0ZvclN5bWJvbChcclxuICBzeW1ib2w6IHN0cmluZyxcclxuICBvcHRzOiBTYW1wbGVkTWV0cmljc09wdGlvbnNcclxuKTogUHJvbWlzZTxTYW1wbGVkTWV0cmljc1Jlc3VsdD4ge1xyXG4gIGNvbnN0IHNhbXBsZXIgPSBnZXRTYW1wbGluZ1N0b3JlKCk7XHJcbiAgbGV0IHNuYXBzaG90O1xyXG5cclxuICBpZiAob3B0cy5jb2xsZWN0ID09PSBmYWxzZSkge1xyXG4gICAgc25hcHNob3QgPSBzYW1wbGVyLnNuYXBzaG90KHN5bWJvbCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNvbGxlY3RlZCA9IGF3YWl0IHNhbXBsZXIuY29sbGVjdChzeW1ib2wpO1xyXG4gICAgICBzbmFwc2hvdCA9IGNvbGxlY3RlZC5zbmFwc2hvdDtcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICBzbmFwc2hvdCA9IHNhbXBsZXIuc25hcHNob3Qoc3ltYm9sKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IHNhbXBsaW5nID0gc3VtbWFyaXplU25hcHNob3RXaW5kb3coc25hcHNob3QsIG9wdHMud2luZG93KTtcclxuICBjb25zdCBwb2ludHMgPSBzYW1wbGVyLmdldFBvaW50cyhzeW1ib2wsIG9wdHMud2luZG93KTtcclxuICBjb25zdCBzZXJpZXMgPSBwb2ludHNUb1N0YXRQb2ludHMocG9pbnRzKTtcclxuXHJcbiAgaWYgKCFzZXJpZXMubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBvazogZmFsc2UsXHJcbiAgICAgIHN5bWJvbCxcclxuICAgICAgZXJyb3I6IFwibm9fcG9pbnRzXCIsXHJcbiAgICAgIHNhbXBsaW5nLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGJpbnMgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKG9wdHMuYmlucyA/PyAxKSk7XHJcbiAgY29uc3Qgb3BlbmluZyA9IHNlcmllc1swXS5wcmljZTtcclxuICBjb25zdCBzdGF0c09wdGlvbnM6IFN0YXRzT3B0aW9ucyA9IHtcclxuICAgIC4uLihvcHRzLnN0YXRzID8/IHt9KSxcclxuICAgIGlkaHI6IHsgLi4uKG9wdHMuc3RhdHM/LmlkaHIgPz8ge30pLCBiaW5zIH0sXHJcbiAgfTtcclxuXHJcbiAgY29uc3Qgc3RhdHMgPSBjb21wdXRlU3RhdHMoc2VyaWVzLCB7IGJlbmNobWFyazogb3BlbmluZyB9LCBzdGF0c09wdGlvbnMpO1xyXG4gIGNvbnN0IHByaWNlVmFsdWVzID0gc2VyaWVzLm1hcCgocCkgPT4gcC5wcmljZSk7XHJcbiAgY29uc3QgcHJpY2VNaW4gPSBNYXRoLm1pbiguLi5wcmljZVZhbHVlcyk7XHJcbiAgY29uc3QgcHJpY2VNYXggPSBNYXRoLm1heCguLi5wcmljZVZhbHVlcyk7XHJcbiAgY29uc3QgYmVuY2hWYWx1ZXMgPSBzZXJpZXMubWFwKChwKSA9PiBiZW5jaFBjdChvcGVuaW5nLCBwLnByaWNlKSk7XHJcbiAgY29uc3QgYmVuY2hQY3RNaW4gPSBNYXRoLm1pbiguLi5iZW5jaFZhbHVlcyk7XHJcbiAgY29uc3QgYmVuY2hQY3RNYXggPSBNYXRoLm1heCguLi5iZW5jaFZhbHVlcyk7XHJcbiAgY29uc3QgaGlzdG9ncmFtID0gc3RhdHMuaGlzdG9ncmFtO1xyXG4gIGNvbnN0IGxhc3RQb2ludCA9IHNlcmllc1tzZXJpZXMubGVuZ3RoIC0gMV07XHJcblxyXG4gIGNvbnN0IGZhbGxiYWNrSGlzdG9ncmFtID0gKCkgPT4ge1xyXG4gICAgY29uc3QgY291bnRzID0gbWFrZUNvdW50cyhzZXJpZXMsIG9wZW5pbmcsIGJpbnMpO1xyXG4gICAgY29uc3QgdG90YWwgPSBjb3VudHMucmVkdWNlKChzLCBjKSA9PiBzICsgYywgMCk7XHJcbiAgICBjb25zdCBwcm9icyA9IHRvdGFsID4gMCA/IGNvdW50cy5tYXAoKGMpID0+IGMgLyB0b3RhbCkgOiBjb3VudHMubWFwKCgpID0+IDApO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY291bnRzLFxyXG4gICAgICBlZGdlczogW10gYXMgbnVtYmVyW10sXHJcbiAgICAgIHByb2JzLFxyXG4gICAgICBkZW5zZXN0OiBbXSBhcyBudW1iZXJbXSxcclxuICAgICAgbXVSOiAwLFxyXG4gICAgICBzaWdtYVI6IDAsXHJcbiAgICAgIHRvdGFsLFxyXG4gICAgICBiaW5XaWR0aDogbnVsbCBhcyBudW1iZXIgfCBudWxsLFxyXG4gICAgICByTWluOiBudWxsIGFzIG51bWJlciB8IG51bGwsXHJcbiAgICAgIHJNYXg6IG51bGwgYXMgbnVtYmVyIHwgbnVsbCxcclxuICAgICAgcmV0dXJuc1BjdDogW10gYXMgbnVtYmVyW10sXHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhpc3RPdXQgPSBoaXN0b2dyYW0gJiYgaGlzdG9ncmFtLmNvdW50cz8ubGVuZ3RoXHJcbiAgICA/IHtcclxuICAgICAgICBjb3VudHM6IGhpc3RvZ3JhbS5jb3VudHMsXHJcbiAgICAgICAgZWRnZXM6IGhpc3RvZ3JhbS5lZGdlcyxcclxuICAgICAgICBwcm9iczogaGlzdG9ncmFtLnByb2JzLFxyXG4gICAgICAgIGRlbnNlc3Q6IGhpc3RvZ3JhbS5kZW5zZXN0LFxyXG4gICAgICAgIG11UjogaGlzdG9ncmFtLm11UixcclxuICAgICAgICBzaWdtYVI6IGhpc3RvZ3JhbS5zaWdtYVIsXHJcbiAgICAgICAgdG90YWw6IGhpc3RvZ3JhbS50b3RhbCxcclxuICAgICAgICBiaW5XaWR0aDogaGlzdG9ncmFtLmVkZ2VzLmxlbmd0aCA+IDEgPyBoaXN0b2dyYW0uZWRnZXNbMV0gLSBoaXN0b2dyYW0uZWRnZXNbMF0gOiBudWxsLFxyXG4gICAgICAgIHJNaW46IGhpc3RvZ3JhbS5lZGdlc1swXSA/PyBudWxsLFxyXG4gICAgICAgIHJNYXg6IGhpc3RvZ3JhbS5lZGdlc1toaXN0b2dyYW0uZWRnZXMubGVuZ3RoIC0gMV0gPz8gbnVsbCxcclxuICAgICAgICByZXR1cm5zUGN0OiBoaXN0b2dyYW0uZWRnZXMubWFwKChyKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBwY3QgPSBNYXRoLmV4cG0xKHIpICogMTAwO1xyXG4gICAgICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShwY3QpID8gcGN0IDogMDtcclxuICAgICAgICB9KSxcclxuICAgICAgfVxyXG4gICAgOiBmYWxsYmFja0hpc3RvZ3JhbSgpO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgb2s6IHRydWUsXHJcbiAgICBzeW1ib2wsXHJcbiAgICBzdGF0cyxcclxuICAgIGhpc3Q6IGhpc3RPdXQsXHJcbiAgICBleHRyZW1hOiB7IHByaWNlTWluLCBwcmljZU1heCwgYmVuY2hQY3RNaW4sIGJlbmNoUGN0TWF4IH0sXHJcbiAgICBtZXRhOiB7XHJcbiAgICAgIG9wZW5pbmc6IHN0YXRzLm9wZW5pbmcsXHJcbiAgICAgIGxhc3Q6IHN0YXRzLmxhc3QsXHJcbiAgICAgIHByZXY6IHN0YXRzLnByZXYsXHJcbiAgICAgIGxhc3RVcGRhdGVUczogbGFzdFBvaW50LnRzLFxyXG4gICAgICBuOiBzZXJpZXMubGVuZ3RoLFxyXG4gICAgfSxcclxuICAgIHNhbXBsaW5nLFxyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb21wdXRlU2FtcGxlZE1ldHJpY3MoXHJcbiAgc3ltYm9sczogc3RyaW5nW10sXHJcbiAgb3B0czogU2FtcGxlZE1ldHJpY3NPcHRpb25zXHJcbik6IFByb21pc2U8UmVjb3JkPHN0cmluZywgU2FtcGxlZE1ldHJpY3NSZXN1bHQ+PiB7XHJcbiAgY29uc3QgcGFpcnMgPSBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgIHN5bWJvbHMubWFwKGFzeW5jIChzeW0pID0+IFtzeW0sIGF3YWl0IGNvbXB1dGVTYW1wbGVkTWV0cmljc0ZvclN5bWJvbChzeW0sIG9wdHMpXSBhcyBjb25zdClcclxuICApO1xyXG4gIGNvbnN0IG91dDogUmVjb3JkPHN0cmluZywgU2FtcGxlZE1ldHJpY3NSZXN1bHQ+ID0ge307XHJcbiAgZm9yIChjb25zdCBbc3ltLCByZXN1bHRdIG9mIHBhaXJzKSBvdXRbc3ltXSA9IHJlc3VsdDtcclxuICByZXR1cm4gb3V0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwb2ludHNUb1N0YXRQb2ludHMocG9pbnRzOiBTYW1wbGluZ1BvaW50W10pOiBTdGF0UG9pbnRbXSB7XHJcbiAgcmV0dXJuIHBvaW50c1xyXG4gICAgLmZpbHRlcigocCkgPT4gTnVtYmVyLmlzRmluaXRlKHAubWlkKSAmJiBwLm1pZCA+IDApXHJcbiAgICAubWFwKChwKSA9PiB7XHJcbiAgICAgIGNvbnN0IGJpZCA9IE51bWJlci5pc0Zpbml0ZShwLmJpZFZvbHVtZSkgPyBwLmJpZFZvbHVtZSA6IDA7XHJcbiAgICAgIGNvbnN0IGFzayA9IE51bWJlci5pc0Zpbml0ZShwLmFza1ZvbHVtZSkgPyBwLmFza1ZvbHVtZSA6IDA7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHM6IHAudHMsXHJcbiAgICAgICAgcHJpY2U6IHAubWlkLFxyXG4gICAgICAgIHZvbHVtZTogTWF0aC5tYXgoMCwgYmlkICsgYXNrKSxcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYWtlQ291bnRzKHBvaW50czogU3RhdFBvaW50W10sIG9wZW5pbmc6IG51bWJlciwgdG90YWxCaW5zOiBudW1iZXIpOiBudW1iZXJbXSB7XHJcbiAgY29uc3QgYmlucyA9IE1hdGgubWF4KDEsIHRvdGFsQmlucyk7XHJcbiAgaWYgKCFwb2ludHMubGVuZ3RoIHx8ICEob3BlbmluZyA+IDApKSByZXR1cm4gQXJyYXkoYmlucykuZmlsbCgwKTtcclxuICBjb25zdCByZXRzID0gcG9pbnRzLm1hcCgocCkgPT4gTWF0aC5sb2cocC5wcmljZSAvIG9wZW5pbmcpKTtcclxuICBjb25zdCBtaW4gPSBNYXRoLm1pbiguLi5yZXRzKTtcclxuICBjb25zdCBtYXggPSBNYXRoLm1heCguLi5yZXRzKTtcclxuICBjb25zdCBsbyA9IG1pbiA9PT0gbWF4ID8gbWluIC0gMWUtNiA6IG1pbjtcclxuICBjb25zdCBoaSA9IG1pbiA9PT0gbWF4ID8gbWF4ICsgMWUtNiA6IG1heDtcclxuICBjb25zdCBjb3VudHMgPSBBcnJheShiaW5zKS5maWxsKDApO1xyXG4gIGZvciAoY29uc3QgciBvZiByZXRzKSB7XHJcbiAgICBjb25zdCB0ID0gKHIgLSBsbykgLyAoaGkgLSBsbyk7XHJcbiAgICBjb25zdCBpZHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihiaW5zIC0gMSwgTWF0aC5mbG9vcih0ICogYmlucykpKTtcclxuICAgIGNvdW50c1tpZHhdICs9IDE7XHJcbiAgfVxyXG4gIHJldHVybiBjb3VudHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJlbmNoUGN0KG9wZW5pbmc6IG51bWJlciwgY3VyOiBudW1iZXIpOiBudW1iZXIge1xyXG4gIHJldHVybiAxMDAgKiAoKGN1ciAvIG9wZW5pbmcpIC0gMSk7XHJcbn1cclxuIl0sIm5hbWVzIjpbImNvbXB1dGVGTSIsIlRlbmQiLCJNZXQiLCJnZXRPckluaXRTeW1ib2xTZXNzaW9uIiwidXBkYXRlU3ltYm9sU2Vzc2lvbiIsImNvbXB1dGVTdGF0cyIsImdldFNhbXBsaW5nU3RvcmUiLCJzdW1tYXJpemVTbmFwc2hvdFdpbmRvdyIsInRvU2VyaWVzIiwicGF5bG9hZCIsInRzIiwic25hcHNob3QiLCJ0aWNrIiwiY3ljbGVUcyIsImZyYW1lcyIsImN5Y2xlU3RhcnQiLCJvdXQiLCJwIiwicG9pbnRzIiwicHJpY2UiLCJOdW1iZXIiLCJtaWQiLCJOYU4iLCJpc0Zpbml0ZSIsInN5bWJvbCIsInB1c2giLCJvcGVuaW5nRnJvbVNlcmllcyIsInNlcmllcyIsImZpcnN0IiwiZmluZCIsImJlbmNobWFyayIsImV4ZWN1dGVDYWxjQW5kVXBkYXRlU2Vzc2lvbiIsImFwcFNlc3Npb25JZCIsInNlcmllc0J1ZmZlcnMiLCJwY3QyNGhNYXAiLCJyZXMiLCJzZXJpZXNOb3ciLCJwYWlyIiwicHRzIiwiT2JqZWN0IiwiZW50cmllcyIsImJ1ZiIsImNvbmNhdCIsInNsaWNlIiwib3BlbmluZyIsImlkaHIiLCJnZm1DYWxjUHJpY2UiLCJnZm0iLCJyZXR1cm5zIiwibWFwIiwiaSIsImEiLCJ2aW4iLCJsZW5ndGgiLCJ2SW5uZXIiLCJ2YWx1ZXMiLCJzY2FsZSIsInZvdXQiLCJ2T3V0ZXIiLCJ1bmRlZmluZWQiLCJ2dCIsInZUZW5kZW5jeUZyb21TZXJpZXMiLCJzY29yZSIsImluZXJ0aWEiLCJpbmVydGlhRnJvbVJldHVybnMiLCJ3aW5kb3ciLCJub3dUcyIsImN5Y2xlRW5kIiwiRGF0ZSIsIm5vdyIsInByaWNlTm93IiwicGN0MjRoTm93Iiwic3MiLCJ1cGQiLCJzaWdtYUdsb2JhbCIsInpNZWFuQWJzIiwibnVjbGVpIiwidmVjdG9ycyIsInZUZW5kZW5jeSIsIm1ldHJpY3MiLCJzZXNzaW9uIiwidWlFcG9jaCIsImdmbVJlZlByaWNlIiwiZ2ZtRGVsdGFBYnNQY3QiLCJjb21wdXRlU2FtcGxlZE1ldHJpY3NGb3JTeW1ib2wiLCJvcHRzIiwic2FtcGxlciIsImNvbGxlY3QiLCJjb2xsZWN0ZWQiLCJzYW1wbGluZyIsImdldFBvaW50cyIsInBvaW50c1RvU3RhdFBvaW50cyIsIm9rIiwiZXJyb3IiLCJiaW5zIiwiTWF0aCIsIm1heCIsImZsb29yIiwic3RhdHNPcHRpb25zIiwic3RhdHMiLCJwcmljZVZhbHVlcyIsInByaWNlTWluIiwibWluIiwicHJpY2VNYXgiLCJiZW5jaFZhbHVlcyIsImJlbmNoUGN0IiwiYmVuY2hQY3RNaW4iLCJiZW5jaFBjdE1heCIsImhpc3RvZ3JhbSIsImxhc3RQb2ludCIsImZhbGxiYWNrSGlzdG9ncmFtIiwiY291bnRzIiwibWFrZUNvdW50cyIsInRvdGFsIiwicmVkdWNlIiwicyIsImMiLCJwcm9icyIsImVkZ2VzIiwiZGVuc2VzdCIsIm11UiIsInNpZ21hUiIsImJpbldpZHRoIiwick1pbiIsInJNYXgiLCJyZXR1cm5zUGN0IiwiaGlzdE91dCIsInIiLCJwY3QiLCJleHBtMSIsImhpc3QiLCJleHRyZW1hIiwibWV0YSIsImxhc3QiLCJwcmV2IiwibGFzdFVwZGF0ZVRzIiwibiIsImNvbXB1dGVTYW1wbGVkTWV0cmljcyIsInN5bWJvbHMiLCJwYWlycyIsIlByb21pc2UiLCJhbGwiLCJzeW0iLCJyZXN1bHQiLCJmaWx0ZXIiLCJiaWQiLCJiaWRWb2x1bWUiLCJhc2siLCJhc2tWb2x1bWUiLCJ2b2x1bWUiLCJ0b3RhbEJpbnMiLCJBcnJheSIsImZpbGwiLCJyZXRzIiwibG9nIiwibG8iLCJoaSIsInQiLCJpZHgiLCJjdXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/calc/executive.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/calc/metrics.ts":
/*!***************************************************!*\
  !*** ./src/core/features/str-aux/calc/metrics.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ampFromSeries: () => (/* binding */ ampFromSeries),\n/* harmony export */   artificialityScore: () => (/* binding */ artificialityScore),\n/* harmony export */   disruptionInstant: () => (/* binding */ disruptionInstant),\n/* harmony export */   disruptionSystemic: () => (/* binding */ disruptionSystemic),\n/* harmony export */   efficiencyScore: () => (/* binding */ efficiencyScore),\n/* harmony export */   inertiaFromReturns: () => (/* binding */ inertiaFromReturns),\n/* harmony export */   inflDefLevel: () => (/* binding */ inflDefLevel),\n/* harmony export */   inflDefRate: () => (/* binding */ inflDefRate),\n/* harmony export */   voltFromDivergence: () => (/* binding */ voltFromDivergence),\n/* harmony export */   voltFromReturns: () => (/* binding */ voltFromReturns),\n/* harmony export */   voltFromSeries: () => (/* binding */ voltFromSeries)\n/* harmony export */ });\n// src/core/maths/metrics.ts\n// Metrics aligned to your definitions (IDHR/ecosystem-aware).\n// Scales: strengths  [0..100], directional  [-100..100].\n/*  basics  */ const clamp = (x, lo, hi)=>Math.max(lo, Math.min(hi, x));\nconst tanh = (x)=>{\n    const e = Math.exp(2 * x);\n    return (e - 1) / (e + 1);\n};\nconst sum = (xs)=>xs.reduce((a, b)=>a + b, 0);\nconst mean = (xs)=>xs.length ? sum(xs) / xs.length : 0;\nconst sign = (x)=>x > 0 ? 1 : x < 0 ? -1 : 0;\nfunction median(xs) {\n    if (!xs.length) return 0;\n    const s = xs.slice().sort((a, b)=>a - b);\n    const m = Math.floor(s.length / 2);\n    return s.length % 2 ? s[m] : (s[m - 1] + s[m]) / 2;\n}\nfunction mad(xs) {\n    if (!xs.length) return 0;\n    const m = median(xs);\n    const dev = xs.map((x)=>Math.abs(x - m));\n    return median(dev);\n}\nfunction iqr(xs) {\n    if (!xs.length) return 0;\n    const s = xs.slice().sort((a, b)=>a - b);\n    const q = (p)=>{\n        const idx = (s.length - 1) * p, lo = Math.floor(idx), hi = Math.ceil(idx);\n        return lo === hi ? s[lo] : s[lo] + (s[hi] - s[lo]) * (idx - lo);\n    };\n    return q(0.75) - q(0.25);\n}\nfunction fracFlips(xs) {\n    let flips = 0, valid = 0, prev = null;\n    for (const v of xs){\n        const s = sign(v);\n        if (s === 0) continue;\n        if (prev === null) {\n            prev = s;\n            continue;\n        }\n        valid++;\n        if (s !== prev) {\n            flips++;\n            prev = s;\n        }\n    }\n    return valid ? flips / valid : 0;\n}\nfunction hhi(shares) {\n    const s = shares.map((x)=>Math.max(0, x));\n    const Z = sum(s);\n    if (!Z) return 0;\n    return s.reduce((a, x)=>a + Math.pow(x / Z, 2), 0); // [1/K..1]\n}\n/*  inputs \r\n   r_t  : coin growth/return series (unitless, can be in S)\r\n   M_t  : ecosystem baseline series (same length as r_t)\r\n   _t  : divergence series (r_t - M_t) if you prefer to pass directly\r\n   W    : window (ticks/steps)\r\n   S    : envelope scale (default 100)\r\n       : epsilon guard for divisions\r\n */ /*  Inertia \r\n   Your meaning:\r\n   - Static inertia: stays put (no growth), low step noise.\r\n   - Growth inertia: keeps the same growth pattern; large steady median vs noise.\r\n   Returns components in [0..100] and a unified \"face\".\r\n */ function inertiaFromReturns(r, opts = {}) {\n    const W = Math.max(5, Math.floor(opts.window ?? Math.min(30, r.length)));\n    if (r.length < 3) return {\n        static: 0,\n        growth: 0,\n        total: 0,\n        face: \"static\"\n    };\n    const y = r.slice(-W);\n    const diffs = [];\n    for(let i = 1; i < y.length; i++)diffs.push(y[i] - y[i - 1]);\n    const mu = median(y), spreadD = mad(diffs);\n    const beta_s = opts.beta_s ?? 1.0;\n    const beta_m = opts.beta_m ?? 1.0;\n    const beta_g = opts.beta_g ?? 1.0;\n    const tau0 = opts.tau0 ?? 0.01; // \"near zero\" target for static\n    // static: small steps + median ~ 0\n    const staticU = tanh(beta_s * (1 / (1 + spreadD))) * tanh(beta_m * (tau0 / (Math.abs(mu) + 1e-9)));\n    // growth: large |median| vs small step noise\n    const growthU = tanh(beta_g * (Math.abs(mu) / (spreadD + 1e-9)));\n    const s = 100 * clamp(staticU, 0, 1);\n    const g = 100 * clamp(growthU, 0, 1);\n    const face = g > s ? \"growth\" : \"static\";\n    return {\n        static: s,\n        growth: g,\n        total: Math.max(s, g),\n        face\n    };\n}\n/*  Disruption \r\n   Your meaning: instant move out of inertia; systemic = proportion of coins.\r\n */ function disruptionInstant(rNow, refWindow// recent returns (window W) for the SAME coin\n, gamma = 1.0) {\n    const mu = median(refWindow);\n    const spreadD = mad(refWindow.length > 1 ? refWindow.map((v, i, a)=>i ? v - a[i - 1] : 0).slice(1) : [\n        0\n    ]);\n    const u = tanh(gamma * (Math.abs(rNow - mu) / (spreadD + 1e-9)));\n    return 100 * clamp(u, 0, 1);\n}\n/** systemic disruption = share of coins whose instant disruption >= threshold */ function disruptionSystemic(disruptions, threshold = 60) {\n    if (!disruptions.length) return 0;\n    const k = disruptions.filter((d)=>d >= threshold).length;\n    return k / disruptions.length * 100; // percent of universe\n}\n/*  Amp (amperage) \r\n   Your meaning: tendency to flip between growth/shrink; swap frequency matters.\r\n   Amp = swing size  flip rate  [0..100].\r\n */ function ampFromSeries(r, opts = {}) {\n    const W = Math.max(5, Math.floor(opts.window ?? Math.min(30, r.length)));\n    if (r.length < 3) return 0;\n    const y = r.slice(-W);\n    const S = opts.S ?? 100;\n    const swing = mad(y); // typical swing size (unitless)\n    const flips = fracFlips(y); // 0..1\n    const u = tanh((opts.etaA ?? 1.0) * (swing / (S || 100))) * tanh((opts.etaF ?? 1.0) * flips);\n    return 100 * clamp(u, 0, 1);\n}\n/*  Volt (voltage) \r\n   Your meaning: persistent imbalance (insulation) vs ecosystem.\r\n   Use divergence _t = r_t - M_t. Volt  [0..100].\r\n */ function voltFromDivergence(delta, opts) {\n    const W = Math.max(5, Math.floor(opts?.window ?? Math.min(30, delta.length)));\n    if (delta.length < 3) return 0;\n    const d = delta.slice(-W);\n    // FIXED: avoid mixing ?? and ||, also guard against 0\n    const spread = Math.max(1e-9, opts?.spread ?? mad(d));\n    const avgAbsZ = mean(d.map((x)=>Math.abs(x) / spread));\n    const u = tanh((opts?.lambda ?? 1.0) * avgAbsZ);\n    return 100 * clamp(u, 0, 1);\n}\n/** helper if you have r_t and M_t instead of _t */ function voltFromReturns(r, M, opts) {\n    const n = Math.min(r.length, M.length);\n    const delta = [];\n    for(let i = 0; i < n; i++)delta.push(r[i] - M[i]);\n    return voltFromDivergence(delta, {\n        window: opts?.window,\n        lambda: opts?.lambda\n    });\n}\nfunction voltFromSeries(y, opts) {\n    const W = Math.max(5, Math.floor(opts?.window ?? Math.min(30, y.length)));\n    if (y.length < 3) return 0;\n    const slice = y.slice(-W);\n    const diffs = [];\n    for(let i = 1; i < slice.length; i++)diffs.push(slice[i] - slice[i - 1]);\n    const S = opts?.S ?? 100;\n    const lambda = opts?.lambda ?? 1.0;\n    return 100 * tanh(lambda * (mad(diffs) / S));\n}\n/*  Inflation / Deflation (systemic) \r\n   Your meaning: position vs the system (ecosystemic analysis).\r\n   Level variant: L_t vs system level M_t^  signed in [-100..100].\r\n */ function inflDefLevel(L_now, M_now, opts = {}) {\n    const S = opts.S ?? 100;\n    const kappa = opts.kappa ?? 1.0;\n    const ratio = M_now > 0 ? L_now / M_now : 1;\n    const R = Math.log(Math.max(1e-9, ratio)); // + inflation (richer), - deflation\n    return clamp(S * tanh(kappa * R), -S, S);\n}\n/** rate variant (change vs previous step) if you want an infl/def rate later */ function inflDefRate(R_now, R_prev, opts = {}) {\n    const S = opts.S ?? 100;\n    const kappa = opts.kappa ?? 1.0;\n    const dR = R_now - R_prev; // already unitless\n    return clamp(S * tanh(kappa * dR), -S, S);\n}\nfunction artificialityScore(inp, weights = {}) {\n    const wM = weights.wMismatch ?? 0.5;\n    const wE = weights.wExec ?? 0.3;\n    const wH = weights.wHHI ?? 0.2;\n    // (1) Impact mismatch (0..1): large if book suggests big move but price barely moves (or vice-versa)\n    const mismatch = Math.abs(inp.expectedImpact) / (Math.abs(inp.observedChange) + 1e-9);\n    const M = clamp(tanh(0.75 * Math.log(1 + mismatch)), 0, 1); // soft-bounded 0..1\n    // (2) Execution ratio (0..1): churny if (placed+cancel)/executed is large\n    let E = 0;\n    if ((inp.executed ?? 0) > 0) {\n        const ratio = ((inp.placed ?? 0) + (inp.canceled ?? 0)) / (inp.executed ?? 1);\n        E = clamp(tanh(0.5 * Math.log(1 + ratio)), 0, 1);\n    }\n    // (3) Concentration via normalized HHI (0..1)\n    let H = 0;\n    if (inp.contribShares && inp.contribShares.length) {\n        const raw = hhi(inp.contribShares);\n        // normalize: minimal ~0 (broad)  0, maximal 1  1 (we skip 1/K floor; unknown K)\n        H = clamp((raw - 0) / (1 - 0), 0, 1);\n    }\n    const A = clamp(wM * M + wE * E + wH * H, 0, 1);\n    return 100 * A; // 0..100 (higher = more artificial)\n}\nfunction efficiencyScore(inp, weights = {}) {\n    const wT = weights.wTrend ?? 0.6;\n    const wV = weights.wVolt ?? 0.2;\n    const wA = weights.wArt ?? 0.2;\n    const alpha = weights.alpha ?? 1.2;\n    const S = weights.S ?? 100;\n    // Organic growth: direction  strength ([-1,1])\n    const trend = clamp(inp.tendencyDirection, -1, 1) * clamp(inp.tendencyStrength, 0, 1);\n    const volt = clamp(inp.volt01 ?? 0, 0, 1); // penalty\n    const art = clamp(inp.artificiality01 ?? 0, 0, 1); // penalty\n    const raw = wT * trend - wV * volt - wA * art;\n    return clamp(S * tanh(alpha * raw), -S, S); // [-S,S]\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L2NhbGMvbWV0cmljcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLDRCQUE0QjtBQUM1Qiw4REFBOEQ7QUFDOUQsMkRBQTJEO0FBRTNELHNFQUFzRSxHQUl0RSxNQUFNQSxRQUFRLENBQUNDLEdBQVdDLElBQVlDLEtBQWVDLEtBQUtDLEdBQUcsQ0FBQ0gsSUFBSUUsS0FBS0UsR0FBRyxDQUFDSCxJQUFJRjtBQUMvRSxNQUFNTSxPQUFPLENBQUNOO0lBQWdCLE1BQU1PLElBQUlKLEtBQUtLLEdBQUcsQ0FBQyxJQUFJUjtJQUFJLE9BQU8sQ0FBQ08sSUFBSSxLQUFNQSxDQUFBQSxJQUFJO0FBQUk7QUFDbkYsTUFBTUUsTUFBTSxDQUFDQyxLQUFpQkEsR0FBR0MsTUFBTSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELElBQUlDLEdBQUc7QUFDekQsTUFBTUMsT0FBTyxDQUFDSixLQUFrQkEsR0FBR0ssTUFBTSxHQUFHTixJQUFJQyxNQUFNQSxHQUFHSyxNQUFNLEdBQUc7QUFDbEUsTUFBTUMsT0FBTyxDQUFDaEIsSUFBZUEsSUFBSSxJQUFJLElBQUlBLElBQUksSUFBSSxDQUFDLElBQUk7QUFFdEQsU0FBU2lCLE9BQU9QLEVBQVk7SUFDMUIsSUFBSSxDQUFDQSxHQUFHSyxNQUFNLEVBQUUsT0FBTztJQUN2QixNQUFNRyxJQUFJUixHQUFHUyxLQUFLLEdBQUdDLElBQUksQ0FBQyxDQUFDUixHQUFHQyxJQUFNRCxJQUFJQztJQUFJLE1BQU1RLElBQUlsQixLQUFLbUIsS0FBSyxDQUFDSixFQUFFSCxNQUFNLEdBQUc7SUFDNUUsT0FBT0csRUFBRUgsTUFBTSxHQUFHLElBQUlHLENBQUMsQ0FBQ0csRUFBRSxHQUFHLENBQUNILENBQUMsQ0FBQ0csSUFBSSxFQUFFLEdBQUdILENBQUMsQ0FBQ0csRUFBRSxJQUFJO0FBQ25EO0FBQ0EsU0FBU0UsSUFBSWIsRUFBWTtJQUN2QixJQUFJLENBQUNBLEdBQUdLLE1BQU0sRUFBRSxPQUFPO0lBQ3ZCLE1BQU1NLElBQUlKLE9BQU9QO0lBQUssTUFBTWMsTUFBTWQsR0FBR2UsR0FBRyxDQUFDekIsQ0FBQUEsSUFBS0csS0FBS3VCLEdBQUcsQ0FBQzFCLElBQUlxQjtJQUMzRCxPQUFPSixPQUFPTztBQUNoQjtBQUNBLFNBQVNHLElBQUlqQixFQUFZO0lBQ3ZCLElBQUksQ0FBQ0EsR0FBR0ssTUFBTSxFQUFFLE9BQU87SUFDdkIsTUFBTUcsSUFBSVIsR0FBR1MsS0FBSyxHQUFHQyxJQUFJLENBQUMsQ0FBQ1IsR0FBR0MsSUFBTUQsSUFBSUM7SUFDeEMsTUFBTWUsSUFBSSxDQUFDQztRQUNULE1BQU1DLE1BQU0sQ0FBQ1osRUFBRUgsTUFBTSxHQUFHLEtBQUtjLEdBQUc1QixLQUFLRSxLQUFLbUIsS0FBSyxDQUFDUSxNQUFNNUIsS0FBS0MsS0FBSzRCLElBQUksQ0FBQ0Q7UUFDckUsT0FBTzdCLE9BQU9DLEtBQUtnQixDQUFDLENBQUNqQixHQUFHLEdBQUdpQixDQUFDLENBQUNqQixHQUFHLEdBQUcsQ0FBQ2lCLENBQUMsQ0FBQ2hCLEdBQUcsR0FBR2dCLENBQUMsQ0FBQ2pCLEdBQUcsSUFBSzZCLENBQUFBLE1BQU03QixFQUFDO0lBQy9EO0lBQ0EsT0FBTzJCLEVBQUUsUUFBUUEsRUFBRTtBQUNyQjtBQUNBLFNBQVNJLFVBQVV0QixFQUFZO0lBQzdCLElBQUl1QixRQUFRLEdBQUdDLFFBQVEsR0FBR0MsT0FBc0I7SUFDaEQsS0FBSyxNQUFNQyxLQUFLMUIsR0FBSTtRQUNsQixNQUFNUSxJQUFJRixLQUFLb0I7UUFBSSxJQUFJbEIsTUFBTSxHQUFHO1FBQ2hDLElBQUlpQixTQUFTLE1BQU07WUFBRUEsT0FBT2pCO1lBQUc7UUFBVTtRQUN6Q2dCO1FBQVMsSUFBSWhCLE1BQU1pQixNQUFNO1lBQUVGO1lBQVNFLE9BQU9qQjtRQUFHO0lBQ2hEO0lBQ0EsT0FBT2dCLFFBQVFELFFBQVFDLFFBQVE7QUFDakM7QUFDQSxTQUFTRyxJQUFJQyxNQUFnQjtJQUMzQixNQUFNcEIsSUFBSW9CLE9BQU9iLEdBQUcsQ0FBQ3pCLENBQUFBLElBQUtHLEtBQUtDLEdBQUcsQ0FBQyxHQUFHSjtJQUFLLE1BQU11QyxJQUFJOUIsSUFBSVM7SUFDekQsSUFBSSxDQUFDcUIsR0FBRyxPQUFPO0lBQ2YsT0FBT3JCLEVBQUVQLE1BQU0sQ0FBQyxDQUFDQyxHQUFHWixJQUFNWSxJQUFJVCxLQUFLcUMsR0FBRyxDQUFDeEMsSUFBSXVDLEdBQUcsSUFBSSxJQUFJLFdBQVc7QUFDbkU7QUFFQTs7Ozs7OzttRUFPbUUsR0FFbkU7Ozs7O21FQUttRSxHQUU1RCxTQUFTRSxtQkFDZEMsQ0FBVyxFQUNYQyxPQUE4RixDQUFDLENBQUM7SUFFaEcsTUFBTUMsSUFBSXpDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLbUIsS0FBSyxDQUFDcUIsS0FBS0UsTUFBTSxJQUFJMUMsS0FBS0UsR0FBRyxDQUFDLElBQUlxQyxFQUFFM0IsTUFBTTtJQUNyRSxJQUFJMkIsRUFBRTNCLE1BQU0sR0FBRyxHQUFHLE9BQU87UUFBRStCLFFBQVE7UUFBR0MsUUFBUTtRQUFHQyxPQUFPO1FBQUdDLE1BQU07SUFBUztJQUMxRSxNQUFNQyxJQUFJUixFQUFFdkIsS0FBSyxDQUFDLENBQUN5QjtJQUNuQixNQUFNTyxRQUFRLEVBQUU7SUFBRSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsRUFBRW5DLE1BQU0sRUFBRXFDLElBQUtELE1BQU1FLElBQUksQ0FBQ0gsQ0FBQyxDQUFDRSxFQUFFLEdBQUdGLENBQUMsQ0FBQ0UsSUFBSSxFQUFFO0lBQy9FLE1BQU1FLEtBQUtyQyxPQUFPaUMsSUFBSUssVUFBVWhDLElBQUk0QjtJQUNwQyxNQUFNSyxTQUFTYixLQUFLYSxNQUFNLElBQUk7SUFDOUIsTUFBTUMsU0FBU2QsS0FBS2MsTUFBTSxJQUFJO0lBQzlCLE1BQU1DLFNBQVNmLEtBQUtlLE1BQU0sSUFBSTtJQUM5QixNQUFNQyxPQUFPaEIsS0FBS2dCLElBQUksSUFBSSxNQUFNLGdDQUFnQztJQUVoRSxtQ0FBbUM7SUFDbkMsTUFBTUMsVUFBVXRELEtBQUtrRCxTQUFVLEtBQUssS0FBSUQsT0FBTSxDQUFDLEtBQU1qRCxLQUFLbUQsU0FBVUUsQ0FBQUEsT0FBUXhELENBQUFBLEtBQUt1QixHQUFHLENBQUM0QixNQUFNLElBQUcsQ0FBQztJQUMvRiw2Q0FBNkM7SUFDN0MsTUFBTU8sVUFBVXZELEtBQUtvRCxTQUFVdkQsQ0FBQUEsS0FBS3VCLEdBQUcsQ0FBQzRCLE1BQU9DLENBQUFBLFVBQVUsSUFBRyxDQUFDO0lBRTdELE1BQU1yQyxJQUFJLE1BQU1uQixNQUFNNkQsU0FBUyxHQUFHO0lBQ2xDLE1BQU1FLElBQUksTUFBTS9ELE1BQU04RCxTQUFTLEdBQUc7SUFDbEMsTUFBTVosT0FBT2EsSUFBSTVDLElBQUksV0FBVztJQUNoQyxPQUFPO1FBQUU0QixRQUFRNUI7UUFBRzZCLFFBQVFlO1FBQUdkLE9BQU83QyxLQUFLQyxHQUFHLENBQUNjLEdBQUc0QztRQUFJYjtJQUFLO0FBQzdEO0FBRUE7O21FQUVtRSxHQUU1RCxTQUFTYyxrQkFDZEMsSUFBWSxFQUNaQyxTQUFtQiw4Q0FBK0M7RUFDbEVDLFFBQVEsR0FBRztJQUNYLE1BQU1aLEtBQUtyQyxPQUFPZ0Q7SUFDbEIsTUFBTVYsVUFBVWhDLElBQUkwQyxVQUFVbEQsTUFBTSxHQUFHLElBQUlrRCxVQUFVeEMsR0FBRyxDQUFDLENBQUNXLEdBQUdnQixHQUFHeEMsSUFBT3dDLElBQUloQixJQUFJeEIsQ0FBQyxDQUFDd0MsSUFBSSxFQUFFLEdBQUcsR0FBSWpDLEtBQUssQ0FBQyxLQUFLO1FBQUM7S0FBRTtJQUM1RyxNQUFNZ0QsSUFBSTdELEtBQUs0RCxRQUFTL0QsQ0FBQUEsS0FBS3VCLEdBQUcsQ0FBQ3NDLE9BQU9WLE1BQU9DLENBQUFBLFVBQVUsSUFBRyxDQUFDO0lBQzdELE9BQU8sTUFBTXhELE1BQU1vRSxHQUFHLEdBQUc7QUFDM0I7QUFFQSwrRUFBK0UsR0FDeEUsU0FBU0MsbUJBQW1CQyxXQUFxQixFQUFFQyxZQUFZLEVBQUU7SUFDdEUsSUFBSSxDQUFDRCxZQUFZdEQsTUFBTSxFQUFFLE9BQU87SUFDaEMsTUFBTXdELElBQUlGLFlBQVlHLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsS0FBS0gsV0FBV3ZELE1BQU07SUFDeEQsT0FBTyxJQUFLc0QsWUFBWXRELE1BQU0sR0FBSSxLQUFLLHNCQUFzQjtBQUMvRDtBQUVBOzs7bUVBR21FLEdBRTVELFNBQVMyRCxjQUNkaEMsQ0FBVyxFQUNYQyxPQUFxRSxDQUFDLENBQUM7SUFFdkUsTUFBTUMsSUFBSXpDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLbUIsS0FBSyxDQUFDcUIsS0FBS0UsTUFBTSxJQUFJMUMsS0FBS0UsR0FBRyxDQUFDLElBQUlxQyxFQUFFM0IsTUFBTTtJQUNyRSxJQUFJMkIsRUFBRTNCLE1BQU0sR0FBRyxHQUFHLE9BQU87SUFDekIsTUFBTW1DLElBQUlSLEVBQUV2QixLQUFLLENBQUMsQ0FBQ3lCO0lBQ25CLE1BQU0rQixJQUFJaEMsS0FBS2dDLENBQUMsSUFBSTtJQUNwQixNQUFNQyxRQUFRckQsSUFBSTJCLElBQXVCLGdDQUFnQztJQUN6RSxNQUFNakIsUUFBUUQsVUFBVWtCLElBQWlCLE9BQU87SUFDaEQsTUFBTWlCLElBQUk3RCxLQUFLLENBQUNxQyxLQUFLa0MsSUFBSSxJQUFJLEdBQUUsSUFBTUQsQ0FBQUEsUUFBU0QsQ0FBQUEsS0FBSyxHQUFFLENBQUMsS0FBTXJFLEtBQUssQ0FBQ3FDLEtBQUttQyxJQUFJLElBQUksR0FBRSxJQUFLN0M7SUFDdEYsT0FBTyxNQUFNbEMsTUFBTW9FLEdBQUcsR0FBRztBQUMzQjtBQUVBOzs7bUVBR21FLEdBRTVELFNBQVNZLG1CQUNkQyxLQUFlLEVBQ2ZyQyxJQUE0RDtJQUU1RCxNQUFNQyxJQUFJekMsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUttQixLQUFLLENBQUNxQixNQUFNRSxVQUFVMUMsS0FBS0UsR0FBRyxDQUFDLElBQUkyRSxNQUFNakUsTUFBTTtJQUMxRSxJQUFJaUUsTUFBTWpFLE1BQU0sR0FBRyxHQUFHLE9BQU87SUFDN0IsTUFBTTBELElBQUlPLE1BQU03RCxLQUFLLENBQUMsQ0FBQ3lCO0lBRXZCLHNEQUFzRDtJQUN0RCxNQUFNcUMsU0FBUzlFLEtBQUtDLEdBQUcsQ0FBQyxNQUFNdUMsTUFBTXNDLFVBQVUxRCxJQUFJa0Q7SUFFbEQsTUFBTVMsVUFBVXBFLEtBQUsyRCxFQUFFaEQsR0FBRyxDQUFDekIsQ0FBQUEsSUFBS0csS0FBS3VCLEdBQUcsQ0FBQzFCLEtBQUtpRjtJQUM5QyxNQUFNZCxJQUFJN0QsS0FBSyxDQUFDcUMsTUFBTXdDLFVBQVUsR0FBRSxJQUFLRDtJQUN2QyxPQUFPLE1BQU1uRixNQUFNb0UsR0FBRyxHQUFHO0FBQzNCO0FBRUEsa0RBQWtELEdBQzNDLFNBQVNpQixnQkFBZ0IxQyxDQUFXLEVBQUUyQyxDQUFXLEVBQUUxQyxJQUEyQztJQUNuRyxNQUFNMkMsSUFBSW5GLEtBQUtFLEdBQUcsQ0FBQ3FDLEVBQUUzQixNQUFNLEVBQUVzRSxFQUFFdEUsTUFBTTtJQUNyQyxNQUFNaUUsUUFBUSxFQUFFO0lBQUUsSUFBSyxJQUFJNUIsSUFBSSxHQUFHQSxJQUFJa0MsR0FBR2xDLElBQUs0QixNQUFNM0IsSUFBSSxDQUFDWCxDQUFDLENBQUNVLEVBQUUsR0FBR2lDLENBQUMsQ0FBQ2pDLEVBQUU7SUFDcEUsT0FBTzJCLG1CQUFtQkMsT0FBTztRQUFFbkMsUUFBUUYsTUFBTUU7UUFBUXNDLFFBQVF4QyxNQUFNd0M7SUFBTztBQUNoRjtBQUVPLFNBQVNJLGVBQWVyQyxDQUFVLEVBQUVQLElBQXNEO0lBQy9GLE1BQU1DLElBQUl6QyxLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS21CLEtBQUssQ0FBQ3FCLE1BQU1FLFVBQVUxQyxLQUFLRSxHQUFHLENBQUMsSUFBSTZDLEVBQUVuQyxNQUFNO0lBQ3RFLElBQUltQyxFQUFFbkMsTUFBTSxHQUFHLEdBQUcsT0FBTztJQUN6QixNQUFNSSxRQUFRK0IsRUFBRS9CLEtBQUssQ0FBQyxDQUFDeUI7SUFDdkIsTUFBTU8sUUFBUSxFQUFFO0lBQUUsSUFBSyxJQUFJQyxJQUFFLEdBQUVBLElBQUVqQyxNQUFNSixNQUFNLEVBQUNxQyxJQUFLRCxNQUFNRSxJQUFJLENBQUNsQyxLQUFLLENBQUNpQyxFQUFFLEdBQUNqQyxLQUFLLENBQUNpQyxJQUFFLEVBQUU7SUFDakYsTUFBTXVCLElBQUloQyxNQUFNZ0MsS0FBSztJQUNyQixNQUFNUSxTQUFTeEMsTUFBTXdDLFVBQVU7SUFDL0IsT0FBTyxNQUFNN0UsS0FBSzZFLFNBQVU1RCxDQUFBQSxJQUFJNEIsU0FBU3dCLENBQUFBO0FBQzNDO0FBRUE7OzttRUFHbUUsR0FFNUQsU0FBU2EsYUFDZEMsS0FBYSxFQUNiQyxLQUFhLEVBQ2IvQyxPQUFzQyxDQUFDLENBQUM7SUFFeEMsTUFBTWdDLElBQUloQyxLQUFLZ0MsQ0FBQyxJQUFJO0lBQUssTUFBTWdCLFFBQVFoRCxLQUFLZ0QsS0FBSyxJQUFJO0lBQ3JELE1BQU1DLFFBQVFGLFFBQVEsSUFBSUQsUUFBUUMsUUFBUTtJQUMxQyxNQUFNRyxJQUFJMUYsS0FBSzJGLEdBQUcsQ0FBQzNGLEtBQUtDLEdBQUcsQ0FBQyxNQUFNd0YsU0FBVyxvQ0FBb0M7SUFDakYsT0FBTzdGLE1BQU00RSxJQUFJckUsS0FBS3FGLFFBQVFFLElBQUksQ0FBQ2xCLEdBQUdBO0FBQ3hDO0FBRUEsZ0ZBQWdGLEdBQ3pFLFNBQVNvQixZQUFZQyxLQUFhLEVBQUVDLE1BQWMsRUFBRXRELE9BQXNDLENBQUMsQ0FBQztJQUNqRyxNQUFNZ0MsSUFBSWhDLEtBQUtnQyxDQUFDLElBQUk7SUFBSyxNQUFNZ0IsUUFBUWhELEtBQUtnRCxLQUFLLElBQUk7SUFDckQsTUFBTU8sS0FBS0YsUUFBUUMsUUFBUSxtQkFBbUI7SUFDOUMsT0FBT2xHLE1BQU00RSxJQUFJckUsS0FBS3FGLFFBQVFPLEtBQUssQ0FBQ3ZCLEdBQUdBO0FBQ3pDO0FBb0JPLFNBQVN3QixtQkFDZEMsR0FBd0IsRUFDeEJDLFVBQWlFLENBQUMsQ0FBQztJQUVuRSxNQUFNQyxLQUFLRCxRQUFRRSxTQUFTLElBQUk7SUFDaEMsTUFBTUMsS0FBS0gsUUFBUUksS0FBSyxJQUFJO0lBQzVCLE1BQU1DLEtBQUtMLFFBQVFNLElBQUksSUFBSTtJQUUzQixxR0FBcUc7SUFDckcsTUFBTUMsV0FBV3pHLEtBQUt1QixHQUFHLENBQUMwRSxJQUFJUyxjQUFjLElBQUsxRyxDQUFBQSxLQUFLdUIsR0FBRyxDQUFDMEUsSUFBSVUsY0FBYyxJQUFJLElBQUc7SUFDbkYsTUFBTXpCLElBQUl0RixNQUFNTyxLQUFLLE9BQU9ILEtBQUsyRixHQUFHLENBQUMsSUFBSWMsWUFBWSxHQUFHLElBQUksb0JBQW9CO0lBRWhGLDBFQUEwRTtJQUMxRSxJQUFJRyxJQUFJO0lBQ1IsSUFBSSxDQUFDWCxJQUFJWSxRQUFRLElBQUksS0FBSyxHQUFHO1FBQzNCLE1BQU1wQixRQUFRLENBQUMsQ0FBQ1EsSUFBSWEsTUFBTSxJQUFJLEtBQU1iLENBQUFBLElBQUljLFFBQVEsSUFBSSxFQUFDLElBQU1kLENBQUFBLElBQUlZLFFBQVEsSUFBSTtRQUMzRUQsSUFBSWhILE1BQU1PLEtBQUssTUFBTUgsS0FBSzJGLEdBQUcsQ0FBQyxJQUFJRixTQUFTLEdBQUc7SUFDaEQ7SUFFQSw4Q0FBOEM7SUFDOUMsSUFBSXVCLElBQUk7SUFDUixJQUFJZixJQUFJZ0IsYUFBYSxJQUFJaEIsSUFBSWdCLGFBQWEsQ0FBQ3JHLE1BQU0sRUFBRTtRQUNqRCxNQUFNc0csTUFBTWhGLElBQUkrRCxJQUFJZ0IsYUFBYTtRQUNqQyxrRkFBa0Y7UUFDbEZELElBQUlwSCxNQUFNLENBQUNzSCxNQUFNLEtBQU0sS0FBSSxJQUFJLEdBQUc7SUFDcEM7SUFFQSxNQUFNQyxJQUFJdkgsTUFBTXVHLEtBQUtqQixJQUFJbUIsS0FBS08sSUFBSUwsS0FBS1MsR0FBRyxHQUFHO0lBQzdDLE9BQU8sTUFBTUcsR0FBRyxvQ0FBb0M7QUFDdEQ7QUFTTyxTQUFTQyxnQkFDZG5CLEdBQXFCLEVBQ3JCQyxVQUF5RixDQUFDLENBQUM7SUFFM0YsTUFBTW1CLEtBQUtuQixRQUFRb0IsTUFBTSxJQUFJO0lBQzdCLE1BQU1DLEtBQUtyQixRQUFRc0IsS0FBSyxJQUFJO0lBQzVCLE1BQU1DLEtBQUt2QixRQUFRd0IsSUFBSSxJQUFJO0lBQzNCLE1BQU1DLFFBQVF6QixRQUFReUIsS0FBSyxJQUFJO0lBQy9CLE1BQU1uRCxJQUFJMEIsUUFBUTFCLENBQUMsSUFBSTtJQUV2QixrREFBa0Q7SUFDbEQsTUFBTW9ELFFBQVFoSSxNQUFNcUcsSUFBSTRCLGlCQUFpQixFQUFFLENBQUMsR0FBRyxLQUFLakksTUFBTXFHLElBQUk2QixnQkFBZ0IsRUFBRSxHQUFHO0lBQ25GLE1BQU1DLE9BQU9uSSxNQUFNcUcsSUFBSStCLE1BQU0sSUFBSSxHQUFHLEdBQUcsSUFBZ0IsVUFBVTtJQUNqRSxNQUFNQyxNQUFPckksTUFBTXFHLElBQUlpQyxlQUFlLElBQUksR0FBRyxHQUFHLElBQU8sVUFBVTtJQUVqRSxNQUFNaEIsTUFBTUcsS0FBS08sUUFBUUwsS0FBS1EsT0FBT04sS0FBS1E7SUFDMUMsT0FBT3JJLE1BQU00RSxJQUFJckUsS0FBS3dILFFBQVFULE1BQU0sQ0FBQzFDLEdBQUdBLElBQWUsU0FBUztBQUNsRSIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGNvcmVcXGZlYXR1cmVzXFxzdHItYXV4XFxjYWxjXFxtZXRyaWNzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb3JlL21hdGhzL21ldHJpY3MudHNcclxuLy8gTWV0cmljcyBhbGlnbmVkIHRvIHlvdXIgZGVmaW5pdGlvbnMgKElESFIvZWNvc3lzdGVtLWF3YXJlKS5cclxuLy8gU2NhbGVzOiBzdHJlbmd0aHMg4oaSIFswLi4xMDBdLCBkaXJlY3Rpb25hbCDihpIgWy0xMDAuLjEwMF0uXHJcblxyXG4vKiDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgYmFzaWNzIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCAqL1xyXG5cclxuZXhwb3J0IHR5cGUgU2NhbGUgPSBudW1iZXI7IC8vIGVudmVsb3BlOyBkZWZhdWx0IFMgPSAxMDBcclxuXHJcbmNvbnN0IGNsYW1wID0gKHg6IG51bWJlciwgbG86IG51bWJlciwgaGk6IG51bWJlcikgPT4gTWF0aC5tYXgobG8sIE1hdGgubWluKGhpLCB4KSk7XHJcbmNvbnN0IHRhbmggPSAoeDogbnVtYmVyKSA9PiB7IGNvbnN0IGUgPSBNYXRoLmV4cCgyICogeCk7IHJldHVybiAoZSAtIDEpIC8gKGUgKyAxKTsgfTtcclxuY29uc3Qgc3VtID0gKHhzOiBudW1iZXJbXSkgPT4geHMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XHJcbmNvbnN0IG1lYW4gPSAoeHM6IG51bWJlcltdKSA9PiAoeHMubGVuZ3RoID8gc3VtKHhzKSAvIHhzLmxlbmd0aCA6IDApO1xyXG5jb25zdCBzaWduID0gKHg6IG51bWJlcikgPT4gKHggPiAwID8gMSA6IHggPCAwID8gLTEgOiAwKTtcclxuXHJcbmZ1bmN0aW9uIG1lZGlhbih4czogbnVtYmVyW10pIHtcclxuICBpZiAoIXhzLmxlbmd0aCkgcmV0dXJuIDA7XHJcbiAgY29uc3QgcyA9IHhzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYSAtIGIpOyBjb25zdCBtID0gTWF0aC5mbG9vcihzLmxlbmd0aCAvIDIpO1xyXG4gIHJldHVybiBzLmxlbmd0aCAlIDIgPyBzW21dIDogKHNbbSAtIDFdICsgc1ttXSkgLyAyO1xyXG59XHJcbmZ1bmN0aW9uIG1hZCh4czogbnVtYmVyW10pIHtcclxuICBpZiAoIXhzLmxlbmd0aCkgcmV0dXJuIDA7XHJcbiAgY29uc3QgbSA9IG1lZGlhbih4cyk7IGNvbnN0IGRldiA9IHhzLm1hcCh4ID0+IE1hdGguYWJzKHggLSBtKSk7XHJcbiAgcmV0dXJuIG1lZGlhbihkZXYpO1xyXG59XHJcbmZ1bmN0aW9uIGlxcih4czogbnVtYmVyW10pIHtcclxuICBpZiAoIXhzLmxlbmd0aCkgcmV0dXJuIDA7XHJcbiAgY29uc3QgcyA9IHhzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG4gIGNvbnN0IHEgPSAocDogbnVtYmVyKSA9PiB7XHJcbiAgICBjb25zdCBpZHggPSAocy5sZW5ndGggLSAxKSAqIHAsIGxvID0gTWF0aC5mbG9vcihpZHgpLCBoaSA9IE1hdGguY2VpbChpZHgpO1xyXG4gICAgcmV0dXJuIGxvID09PSBoaSA/IHNbbG9dIDogc1tsb10gKyAoc1toaV0gLSBzW2xvXSkgKiAoaWR4IC0gbG8pO1xyXG4gIH07XHJcbiAgcmV0dXJuIHEoMC43NSkgLSBxKDAuMjUpO1xyXG59XHJcbmZ1bmN0aW9uIGZyYWNGbGlwcyh4czogbnVtYmVyW10pIHtcclxuICBsZXQgZmxpcHMgPSAwLCB2YWxpZCA9IDAsIHByZXY6IG51bWJlciB8IG51bGwgPSBudWxsO1xyXG4gIGZvciAoY29uc3QgdiBvZiB4cykge1xyXG4gICAgY29uc3QgcyA9IHNpZ24odik7IGlmIChzID09PSAwKSBjb250aW51ZTtcclxuICAgIGlmIChwcmV2ID09PSBudWxsKSB7IHByZXYgPSBzOyBjb250aW51ZTsgfVxyXG4gICAgdmFsaWQrKzsgaWYgKHMgIT09IHByZXYpIHsgZmxpcHMrKzsgcHJldiA9IHM7IH1cclxuICB9XHJcbiAgcmV0dXJuIHZhbGlkID8gZmxpcHMgLyB2YWxpZCA6IDA7XHJcbn1cclxuZnVuY3Rpb24gaGhpKHNoYXJlczogbnVtYmVyW10pIHtcclxuICBjb25zdCBzID0gc2hhcmVzLm1hcCh4ID0+IE1hdGgubWF4KDAsIHgpKTsgY29uc3QgWiA9IHN1bShzKTtcclxuICBpZiAoIVopIHJldHVybiAwO1xyXG4gIHJldHVybiBzLnJlZHVjZSgoYSwgeCkgPT4gYSArIE1hdGgucG93KHggLyBaLCAyKSwgMCk7IC8vIFsxL0suLjFdXHJcbn1cclxuXHJcbi8qIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBpbnB1dHMg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXHJcbiAgIHJfdCAgOiBjb2luIGdyb3d0aC9yZXR1cm4gc2VyaWVzICh1bml0bGVzcywgY2FuIGJlIGluIMKxUylcclxuICAgTV90ICA6IGVjb3N5c3RlbSBiYXNlbGluZSBzZXJpZXMgKHNhbWUgbGVuZ3RoIGFzIHJfdClcclxuICAgzpRfdCAgOiBkaXZlcmdlbmNlIHNlcmllcyAocl90IC0gTV90KSBpZiB5b3UgcHJlZmVyIHRvIHBhc3MgZGlyZWN0bHlcclxuICAgVyAgICA6IHdpbmRvdyAodGlja3Mvc3RlcHMpXHJcbiAgIFMgICAgOiBlbnZlbG9wZSBzY2FsZSAoZGVmYXVsdCAxMDApXHJcbiAgIM61ICAgIDogZXBzaWxvbiBndWFyZCBmb3IgZGl2aXNpb25zXHJcbuKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCAqL1xyXG5cclxuLyog4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIEluZXJ0aWEg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXHJcbiAgIFlvdXIgbWVhbmluZzpcclxuICAgLSBTdGF0aWMgaW5lcnRpYTogc3RheXMgcHV0IChubyBncm93dGgpLCBsb3cgc3RlcCBub2lzZS5cclxuICAgLSBHcm93dGggaW5lcnRpYToga2VlcHMgdGhlIHNhbWUgZ3Jvd3RoIHBhdHRlcm47IGxhcmdlIHN0ZWFkeSBtZWRpYW4gdnMgbm9pc2UuXHJcbiAgIFJldHVybnMgY29tcG9uZW50cyBpbiBbMC4uMTAwXSBhbmQgYSB1bmlmaWVkIFwiZmFjZVwiLlxyXG7ilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbmVydGlhRnJvbVJldHVybnMoXHJcbiAgcjogbnVtYmVyW10sXHJcbiAgb3B0czogeyB3aW5kb3c/OiBudW1iZXI7IGJldGFfcz86IG51bWJlcjsgYmV0YV9tPzogbnVtYmVyOyBiZXRhX2c/OiBudW1iZXI7IHRhdTA/OiBudW1iZXIgfSA9IHt9XHJcbik6IHsgc3RhdGljOiBudW1iZXI7IGdyb3d0aDogbnVtYmVyOyB0b3RhbDogbnVtYmVyOyBmYWNlOiBcInN0YXRpY1wiIHwgXCJncm93dGhcIiB9IHtcclxuICBjb25zdCBXID0gTWF0aC5tYXgoNSwgTWF0aC5mbG9vcihvcHRzLndpbmRvdyA/PyBNYXRoLm1pbigzMCwgci5sZW5ndGgpKSk7XHJcbiAgaWYgKHIubGVuZ3RoIDwgMykgcmV0dXJuIHsgc3RhdGljOiAwLCBncm93dGg6IDAsIHRvdGFsOiAwLCBmYWNlOiBcInN0YXRpY1wiIH07XHJcbiAgY29uc3QgeSA9IHIuc2xpY2UoLVcpO1xyXG4gIGNvbnN0IGRpZmZzID0gW107IGZvciAobGV0IGkgPSAxOyBpIDwgeS5sZW5ndGg7IGkrKykgZGlmZnMucHVzaCh5W2ldIC0geVtpIC0gMV0pO1xyXG4gIGNvbnN0IG11ID0gbWVkaWFuKHkpLCBzcHJlYWREID0gbWFkKGRpZmZzKTtcclxuICBjb25zdCBiZXRhX3MgPSBvcHRzLmJldGFfcyA/PyAxLjA7XHJcbiAgY29uc3QgYmV0YV9tID0gb3B0cy5iZXRhX20gPz8gMS4wO1xyXG4gIGNvbnN0IGJldGFfZyA9IG9wdHMuYmV0YV9nID8/IDEuMDtcclxuICBjb25zdCB0YXUwID0gb3B0cy50YXUwID8/IDAuMDE7IC8vIFwibmVhciB6ZXJvXCIgdGFyZ2V0IGZvciBzdGF0aWNcclxuXHJcbiAgLy8gc3RhdGljOiBzbWFsbCBzdGVwcyArIG1lZGlhbiB+IDBcclxuICBjb25zdCBzdGF0aWNVID0gdGFuaChiZXRhX3MgKiAoMSAvICgxICsgc3ByZWFkRCkpKSAqIHRhbmgoYmV0YV9tICogKHRhdTAgLyAoTWF0aC5hYnMobXUpICsgMWUtOSkpKTtcclxuICAvLyBncm93dGg6IGxhcmdlIHxtZWRpYW58IHZzIHNtYWxsIHN0ZXAgbm9pc2VcclxuICBjb25zdCBncm93dGhVID0gdGFuaChiZXRhX2cgKiAoTWF0aC5hYnMobXUpIC8gKHNwcmVhZEQgKyAxZS05KSkpO1xyXG5cclxuICBjb25zdCBzID0gMTAwICogY2xhbXAoc3RhdGljVSwgMCwgMSk7XHJcbiAgY29uc3QgZyA9IDEwMCAqIGNsYW1wKGdyb3d0aFUsIDAsIDEpO1xyXG4gIGNvbnN0IGZhY2UgPSBnID4gcyA/IFwiZ3Jvd3RoXCIgOiBcInN0YXRpY1wiO1xyXG4gIHJldHVybiB7IHN0YXRpYzogcywgZ3Jvd3RoOiBnLCB0b3RhbDogTWF0aC5tYXgocywgZyksIGZhY2UgfTtcclxufVxyXG5cclxuLyog4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIERpc3J1cHRpb24g4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXHJcbiAgIFlvdXIgbWVhbmluZzogaW5zdGFudCBtb3ZlIG91dCBvZiBpbmVydGlhOyBzeXN0ZW1pYyA9IHByb3BvcnRpb24gb2YgY29pbnMuXHJcbuKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc3J1cHRpb25JbnN0YW50KFxyXG4gIHJOb3c6IG51bWJlcixcclxuICByZWZXaW5kb3c6IG51bWJlcltdIC8vIHJlY2VudCByZXR1cm5zICh3aW5kb3cgVykgZm9yIHRoZSBTQU1FIGNvaW5cclxuLCBnYW1tYSA9IDEuMCk6IG51bWJlciB7XHJcbiAgY29uc3QgbXUgPSBtZWRpYW4ocmVmV2luZG93KTtcclxuICBjb25zdCBzcHJlYWREID0gbWFkKHJlZldpbmRvdy5sZW5ndGggPiAxID8gcmVmV2luZG93Lm1hcCgodiwgaSwgYSkgPT4gKGkgPyB2IC0gYVtpIC0gMV0gOiAwKSkuc2xpY2UoMSkgOiBbMF0pO1xyXG4gIGNvbnN0IHUgPSB0YW5oKGdhbW1hICogKE1hdGguYWJzKHJOb3cgLSBtdSkgLyAoc3ByZWFkRCArIDFlLTkpKSk7XHJcbiAgcmV0dXJuIDEwMCAqIGNsYW1wKHUsIDAsIDEpO1xyXG59XHJcblxyXG4vKiogc3lzdGVtaWMgZGlzcnVwdGlvbiA9IHNoYXJlIG9mIGNvaW5zIHdob3NlIGluc3RhbnQgZGlzcnVwdGlvbiA+PSB0aHJlc2hvbGQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc3J1cHRpb25TeXN0ZW1pYyhkaXNydXB0aW9uczogbnVtYmVyW10sIHRocmVzaG9sZCA9IDYwKTogbnVtYmVyIHtcclxuICBpZiAoIWRpc3J1cHRpb25zLmxlbmd0aCkgcmV0dXJuIDA7XHJcbiAgY29uc3QgayA9IGRpc3J1cHRpb25zLmZpbHRlcihkID0+IGQgPj0gdGhyZXNob2xkKS5sZW5ndGg7XHJcbiAgcmV0dXJuIChrIC8gZGlzcnVwdGlvbnMubGVuZ3RoKSAqIDEwMDsgLy8gcGVyY2VudCBvZiB1bml2ZXJzZVxyXG59XHJcblxyXG4vKiDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgQW1wIChhbXBlcmFnZSkg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXHJcbiAgIFlvdXIgbWVhbmluZzogdGVuZGVuY3kgdG8gZmxpcCBiZXR3ZWVuIGdyb3d0aC9zaHJpbms7IHN3YXAgZnJlcXVlbmN5IG1hdHRlcnMuXHJcbiAgIEFtcCA9IHN3aW5nIHNpemUgw5cgZmxpcCByYXRlIOKGkiBbMC4uMTAwXS5cclxu4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYW1wRnJvbVNlcmllcyhcclxuICByOiBudW1iZXJbXSxcclxuICBvcHRzOiB7IHdpbmRvdz86IG51bWJlcjsgZXRhQT86IG51bWJlcjsgZXRhRj86IG51bWJlcjsgUz86IFNjYWxlIH0gPSB7fVxyXG4pOiBudW1iZXIge1xyXG4gIGNvbnN0IFcgPSBNYXRoLm1heCg1LCBNYXRoLmZsb29yKG9wdHMud2luZG93ID8/IE1hdGgubWluKDMwLCByLmxlbmd0aCkpKTtcclxuICBpZiAoci5sZW5ndGggPCAzKSByZXR1cm4gMDtcclxuICBjb25zdCB5ID0gci5zbGljZSgtVyk7XHJcbiAgY29uc3QgUyA9IG9wdHMuUyA/PyAxMDA7XHJcbiAgY29uc3Qgc3dpbmcgPSBtYWQoeSk7ICAgICAgICAgICAgICAgICAgICAvLyB0eXBpY2FsIHN3aW5nIHNpemUgKHVuaXRsZXNzKVxyXG4gIGNvbnN0IGZsaXBzID0gZnJhY0ZsaXBzKHkpOyAgICAgICAgICAgICAgLy8gMC4uMVxyXG4gIGNvbnN0IHUgPSB0YW5oKChvcHRzLmV0YUEgPz8gMS4wKSAqIChzd2luZyAvIChTIHx8IDEwMCkpKSAqIHRhbmgoKG9wdHMuZXRhRiA/PyAxLjApICogZmxpcHMpO1xyXG4gIHJldHVybiAxMDAgKiBjbGFtcCh1LCAwLCAxKTtcclxufVxyXG5cclxuLyog4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIFZvbHQgKHZvbHRhZ2UpIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgFxyXG4gICBZb3VyIG1lYW5pbmc6IHBlcnNpc3RlbnQgaW1iYWxhbmNlIChpbnN1bGF0aW9uKSB2cyBlY29zeXN0ZW0uXHJcbiAgIFVzZSBkaXZlcmdlbmNlIM6UX3QgPSByX3QgLSBNX3QuIFZvbHQg4oiIIFswLi4xMDBdLlxyXG7ilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2b2x0RnJvbURpdmVyZ2VuY2UoXHJcbiAgZGVsdGE6IG51bWJlcltdLFxyXG4gIG9wdHM/OiB7IHdpbmRvdz86IG51bWJlcjsgbGFtYmRhPzogbnVtYmVyOyBzcHJlYWQ/OiBudW1iZXIgfVxyXG4pOiBudW1iZXIge1xyXG4gIGNvbnN0IFcgPSBNYXRoLm1heCg1LCBNYXRoLmZsb29yKG9wdHM/LndpbmRvdyA/PyBNYXRoLm1pbigzMCwgZGVsdGEubGVuZ3RoKSkpO1xyXG4gIGlmIChkZWx0YS5sZW5ndGggPCAzKSByZXR1cm4gMDtcclxuICBjb25zdCBkID0gZGVsdGEuc2xpY2UoLVcpO1xyXG5cclxuICAvLyBGSVhFRDogYXZvaWQgbWl4aW5nID8/IGFuZCB8fCwgYWxzbyBndWFyZCBhZ2FpbnN0IDBcclxuICBjb25zdCBzcHJlYWQgPSBNYXRoLm1heCgxZS05LCBvcHRzPy5zcHJlYWQgPz8gbWFkKGQpKTtcclxuXHJcbiAgY29uc3QgYXZnQWJzWiA9IG1lYW4oZC5tYXAoeCA9PiBNYXRoLmFicyh4KSAvIHNwcmVhZCkpO1xyXG4gIGNvbnN0IHUgPSB0YW5oKChvcHRzPy5sYW1iZGEgPz8gMS4wKSAqIGF2Z0Fic1opO1xyXG4gIHJldHVybiAxMDAgKiBjbGFtcCh1LCAwLCAxKTtcclxufVxyXG5cclxuLyoqIGhlbHBlciBpZiB5b3UgaGF2ZSByX3QgYW5kIE1fdCBpbnN0ZWFkIG9mIM6UX3QgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZvbHRGcm9tUmV0dXJucyhyOiBudW1iZXJbXSwgTTogbnVtYmVyW10sIG9wdHM/OiB7IHdpbmRvdz86IG51bWJlcjsgbGFtYmRhPzogbnVtYmVyIH0pIHtcclxuICBjb25zdCBuID0gTWF0aC5taW4oci5sZW5ndGgsIE0ubGVuZ3RoKTtcclxuICBjb25zdCBkZWx0YSA9IFtdOyBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykgZGVsdGEucHVzaChyW2ldIC0gTVtpXSk7XHJcbiAgcmV0dXJuIHZvbHRGcm9tRGl2ZXJnZW5jZShkZWx0YSwgeyB3aW5kb3c6IG9wdHM/LndpbmRvdywgbGFtYmRhOiBvcHRzPy5sYW1iZGEgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2b2x0RnJvbVNlcmllcyh5Om51bWJlcltdLCBvcHRzPzogeyB3aW5kb3c/OiBudW1iZXI7IGxhbWJkYT86IG51bWJlcjsgUz86IFNjYWxlIH0pOiBudW1iZXIge1xyXG4gIGNvbnN0IFcgPSBNYXRoLm1heCg1LCBNYXRoLmZsb29yKG9wdHM/LndpbmRvdyA/PyBNYXRoLm1pbigzMCwgeS5sZW5ndGgpKSk7XHJcbiAgaWYgKHkubGVuZ3RoIDwgMykgcmV0dXJuIDA7XHJcbiAgY29uc3Qgc2xpY2UgPSB5LnNsaWNlKC1XKTtcclxuICBjb25zdCBkaWZmcyA9IFtdOyBmb3IgKGxldCBpPTE7aTxzbGljZS5sZW5ndGg7aSsrKSBkaWZmcy5wdXNoKHNsaWNlW2ldLXNsaWNlW2ktMV0pO1xyXG4gIGNvbnN0IFMgPSBvcHRzPy5TID8/IDEwMDtcclxuICBjb25zdCBsYW1iZGEgPSBvcHRzPy5sYW1iZGEgPz8gMS4wO1xyXG4gIHJldHVybiAxMDAgKiB0YW5oKGxhbWJkYSAqIChtYWQoZGlmZnMpIC8gUykpO1xyXG59XHJcblxyXG4vKiDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgSW5mbGF0aW9uIC8gRGVmbGF0aW9uIChzeXN0ZW1pYykg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXHJcbiAgIFlvdXIgbWVhbmluZzogcG9zaXRpb24gdnMgdGhlIHN5c3RlbSAoZWNvc3lzdGVtaWMgYW5hbHlzaXMpLlxyXG4gICBMZXZlbCB2YXJpYW50OiBMX3QgdnMgc3lzdGVtIGxldmVsIE1fdF7ihJMg4oaSIHNpZ25lZCBpbiBbLTEwMC4uMTAwXS5cclxu4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaW5mbERlZkxldmVsKFxyXG4gIExfbm93OiBudW1iZXIsICAgICAgICAvLyBjb2luIGxldmVsIChpbmRleCkgbm93XHJcbiAgTV9ub3c6IG51bWJlciwgICAgICAgIC8vIHN5c3RlbSBsZXZlbCBub3dcclxuICBvcHRzOiB7IGthcHBhPzogbnVtYmVyOyBTPzogU2NhbGUgfSA9IHt9XHJcbik6IG51bWJlciB7XHJcbiAgY29uc3QgUyA9IG9wdHMuUyA/PyAxMDA7IGNvbnN0IGthcHBhID0gb3B0cy5rYXBwYSA/PyAxLjA7XHJcbiAgY29uc3QgcmF0aW8gPSBNX25vdyA+IDAgPyBMX25vdyAvIE1fbm93IDogMTtcclxuICBjb25zdCBSID0gTWF0aC5sb2coTWF0aC5tYXgoMWUtOSwgcmF0aW8pKTsgICAvLyArIGluZmxhdGlvbiAocmljaGVyKSwgLSBkZWZsYXRpb25cclxuICByZXR1cm4gY2xhbXAoUyAqIHRhbmgoa2FwcGEgKiBSKSwgLVMsIFMpO1xyXG59XHJcblxyXG4vKiogcmF0ZSB2YXJpYW50IChjaGFuZ2UgdnMgcHJldmlvdXMgc3RlcCkgaWYgeW91IHdhbnQgYW4g4oCcaW5mbC9kZWYgcmF0ZeKAnSBsYXRlciAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaW5mbERlZlJhdGUoUl9ub3c6IG51bWJlciwgUl9wcmV2OiBudW1iZXIsIG9wdHM6IHsga2FwcGE/OiBudW1iZXI7IFM/OiBTY2FsZSB9ID0ge30pIHtcclxuICBjb25zdCBTID0gb3B0cy5TID8/IDEwMDsgY29uc3Qga2FwcGEgPSBvcHRzLmthcHBhID8/IDEuMDtcclxuICBjb25zdCBkUiA9IFJfbm93IC0gUl9wcmV2OyAvLyBhbHJlYWR5IHVuaXRsZXNzXHJcbiAgcmV0dXJuIGNsYW1wKFMgKiB0YW5oKGthcHBhICogZFIpLCAtUywgUyk7XHJcbn1cclxuXHJcbi8qIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBBcnRpZmljaWFsaXR5ICYgRWZmaWNpZW5jeSDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcclxuICAgWW91ciBtZWFuaW5nOlxyXG4gICAtIEFydGlmaWNpYWxpdHkgPSBtaXNtYXRjaCBiZXR3ZWVuIOKAnGJ1bGsgb3JkZXJz4oCdIGFuZCByZXN1bHRpbmcgYmVuY2htYXJrIG1vdmUsXHJcbiAgICAgcGx1cyBleGVjdXRpb24gY2h1cm4gLyBiaW4gY29uY2VudHJhdGlvbiAoc3BlY3VsYXRpdmUvY29udHJpdmVkKS5cclxuICAgLSBFZmZpY2llbmN5ICA9IGNvbnNvbGlkYXRlZCBvcmdhbmljIGdyb3d0aCAodHJlbmQgw5cgc3RyZW5ndGgpIHBlbmFsaXplZCBieVxyXG4gICAgIHZvbGF0aWxpdHkgYW5kIGFydGlmaWNpYWxpdHkg4oaSIFstMTAwLi4xMDBdLlxyXG7ilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgKi9cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQXJ0aWZpY2lhbGl0eUlucHV0cyB7XHJcbiAgLy8gRXhwZWN0ZWQgdnMgb2JzZXJ2ZWQgaW1wYWN0IChzYW1lIHVuaXRzLCBlLmcuLCByZXR1cm4gb3IgzpRiZW5jaG1hcmsgb3ZlciB0aWNrKVxyXG4gIGV4cGVjdGVkSW1wYWN0OiBudW1iZXI7ICAgLy8gZnJvbSBvcmRlcmJvb2sgbWljcm9zdHJ1Y3R1cmUgbW9kZWxcclxuICBvYnNlcnZlZENoYW5nZTogbnVtYmVyOyAgIC8vIGFjdHVhbCBiZW5jaG1hcmsgY2hhbmdlXHJcbiAgLy8gRXhlY3V0aW9uIHN0YXRzIG92ZXIgd2luZG93IEg6XHJcbiAgcGxhY2VkPzogbnVtYmVyOyBjYW5jZWxlZD86IG51bWJlcjsgZXhlY3V0ZWQ/OiBudW1iZXI7IC8vIGNvdW50cyBvciBub3Rpb25hbFxyXG4gIC8vIENvbmNlbnRyYXRpb246IHBlci1iaW4gY29udHJpYnV0aW9ucyAoYWJzIGlubmVyICogc2hhcmUpIGZvciBjdXJyZW50IHRpY2sgb3IgbWVhbiBvdmVyIHdpbmRvd1xyXG4gIGNvbnRyaWJTaGFyZXM/OiBudW1iZXJbXTsgLy8gZG9lcyBub3QgbmVlZCB0byBzdW0gdG8gMTsgd2Ugbm9ybWFsaXplXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhcnRpZmljaWFsaXR5U2NvcmUoXHJcbiAgaW5wOiBBcnRpZmljaWFsaXR5SW5wdXRzLFxyXG4gIHdlaWdodHM6IHsgd01pc21hdGNoPzogbnVtYmVyOyB3RXhlYz86IG51bWJlcjsgd0hIST86IG51bWJlciB9ID0ge31cclxuKTogbnVtYmVyIHtcclxuICBjb25zdCB3TSA9IHdlaWdodHMud01pc21hdGNoID8/IDAuNTtcclxuICBjb25zdCB3RSA9IHdlaWdodHMud0V4ZWMgPz8gMC4zO1xyXG4gIGNvbnN0IHdIID0gd2VpZ2h0cy53SEhJID8/IDAuMjtcclxuXHJcbiAgLy8gKDEpIEltcGFjdCBtaXNtYXRjaCAoMC4uMSk6IGxhcmdlIGlmIGJvb2sgc3VnZ2VzdHMgYmlnIG1vdmUgYnV0IHByaWNlIGJhcmVseSBtb3ZlcyAob3IgdmljZS12ZXJzYSlcclxuICBjb25zdCBtaXNtYXRjaCA9IE1hdGguYWJzKGlucC5leHBlY3RlZEltcGFjdCkgLyAoTWF0aC5hYnMoaW5wLm9ic2VydmVkQ2hhbmdlKSArIDFlLTkpO1xyXG4gIGNvbnN0IE0gPSBjbGFtcCh0YW5oKDAuNzUgKiBNYXRoLmxvZygxICsgbWlzbWF0Y2gpKSwgMCwgMSk7IC8vIHNvZnQtYm91bmRlZCAwLi4xXHJcblxyXG4gIC8vICgyKSBFeGVjdXRpb24gcmF0aW8gKDAuLjEpOiBjaHVybnkgaWYgKHBsYWNlZCtjYW5jZWwpL2V4ZWN1dGVkIGlzIGxhcmdlXHJcbiAgbGV0IEUgPSAwO1xyXG4gIGlmICgoaW5wLmV4ZWN1dGVkID8/IDApID4gMCkge1xyXG4gICAgY29uc3QgcmF0aW8gPSAoKGlucC5wbGFjZWQgPz8gMCkgKyAoaW5wLmNhbmNlbGVkID8/IDApKSAvIChpbnAuZXhlY3V0ZWQgPz8gMSk7XHJcbiAgICBFID0gY2xhbXAodGFuaCgwLjUgKiBNYXRoLmxvZygxICsgcmF0aW8pKSwgMCwgMSk7XHJcbiAgfVxyXG5cclxuICAvLyAoMykgQ29uY2VudHJhdGlvbiB2aWEgbm9ybWFsaXplZCBISEkgKDAuLjEpXHJcbiAgbGV0IEggPSAwO1xyXG4gIGlmIChpbnAuY29udHJpYlNoYXJlcyAmJiBpbnAuY29udHJpYlNoYXJlcy5sZW5ndGgpIHtcclxuICAgIGNvbnN0IHJhdyA9IGhoaShpbnAuY29udHJpYlNoYXJlcyk7XHJcbiAgICAvLyBub3JtYWxpemU6IG1pbmltYWwgfjAgKGJyb2FkKSDihpIgMCwgbWF4aW1hbCAxIOKGkiAxICh3ZSBza2lwIDEvSyBmbG9vcjsgdW5rbm93biBLKVxyXG4gICAgSCA9IGNsYW1wKChyYXcgLSAwKSAvICgxIC0gMCksIDAsIDEpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgQSA9IGNsYW1wKHdNICogTSArIHdFICogRSArIHdIICogSCwgMCwgMSk7XHJcbiAgcmV0dXJuIDEwMCAqIEE7IC8vIDAuLjEwMCAoaGlnaGVyID0gbW9yZSBhcnRpZmljaWFsKVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEVmZmljaWVuY3lJbnB1dHMge1xyXG4gIHRlbmRlbmN5RGlyZWN0aW9uOiBudW1iZXI7IC8vIGZyb20gdlRlbmRlbmN5LmRpcmVjdGlvbiBpbiBbLTEsMV1cclxuICB0ZW5kZW5jeVN0cmVuZ3RoOiBudW1iZXI7ICAvLyBmcm9tIHZUZW5kZW5jeS5zdHJlbmd0aCBpbiBbMCwxXVxyXG4gIHZvbHQwMT86IG51bWJlcjsgICAgICAgICAgIC8vIHZvbHQgaW4gWzAuLjFdICh1c2Ugdm9sdEZyb23igKYvMTAwKVxyXG4gIGFydGlmaWNpYWxpdHkwMT86IG51bWJlcjsgIC8vIGFydGlmaWNpYWxpdHkgaW4gWzAuLjFdIChhcnRpZmljaWFsaXR5U2NvcmUvMTAwKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZWZmaWNpZW5jeVNjb3JlKFxyXG4gIGlucDogRWZmaWNpZW5jeUlucHV0cyxcclxuICB3ZWlnaHRzOiB7IHdUcmVuZD86IG51bWJlcjsgd1ZvbHQ/OiBudW1iZXI7IHdBcnQ/OiBudW1iZXI7IGFscGhhPzogbnVtYmVyOyBTPzogU2NhbGUgfSA9IHt9XHJcbik6IG51bWJlciB7XHJcbiAgY29uc3Qgd1QgPSB3ZWlnaHRzLndUcmVuZCA/PyAwLjY7XHJcbiAgY29uc3Qgd1YgPSB3ZWlnaHRzLndWb2x0ID8/IDAuMjtcclxuICBjb25zdCB3QSA9IHdlaWdodHMud0FydCA/PyAwLjI7XHJcbiAgY29uc3QgYWxwaGEgPSB3ZWlnaHRzLmFscGhhID8/IDEuMjtcclxuICBjb25zdCBTID0gd2VpZ2h0cy5TID8/IDEwMDtcclxuXHJcbiAgLy8g4oCcT3JnYW5pYyBncm93dGjigJ06IGRpcmVjdGlvbiDDlyBzdHJlbmd0aCAoWy0xLDFdKVxyXG4gIGNvbnN0IHRyZW5kID0gY2xhbXAoaW5wLnRlbmRlbmN5RGlyZWN0aW9uLCAtMSwgMSkgKiBjbGFtcChpbnAudGVuZGVuY3lTdHJlbmd0aCwgMCwgMSk7XHJcbiAgY29uc3Qgdm9sdCA9IGNsYW1wKGlucC52b2x0MDEgPz8gMCwgMCwgMSk7ICAgICAgICAgICAgIC8vIHBlbmFsdHlcclxuICBjb25zdCBhcnQgID0gY2xhbXAoaW5wLmFydGlmaWNpYWxpdHkwMSA/PyAwLCAwLCAxKTsgICAgLy8gcGVuYWx0eVxyXG5cclxuICBjb25zdCByYXcgPSB3VCAqIHRyZW5kIC0gd1YgKiB2b2x0IC0gd0EgKiBhcnQ7XHJcbiAgcmV0dXJuIGNsYW1wKFMgKiB0YW5oKGFscGhhICogcmF3KSwgLVMsIFMpOyAgICAgICAgICAgIC8vIFstUyxTXVxyXG59XHJcbiJdLCJuYW1lcyI6WyJjbGFtcCIsIngiLCJsbyIsImhpIiwiTWF0aCIsIm1heCIsIm1pbiIsInRhbmgiLCJlIiwiZXhwIiwic3VtIiwieHMiLCJyZWR1Y2UiLCJhIiwiYiIsIm1lYW4iLCJsZW5ndGgiLCJzaWduIiwibWVkaWFuIiwicyIsInNsaWNlIiwic29ydCIsIm0iLCJmbG9vciIsIm1hZCIsImRldiIsIm1hcCIsImFicyIsImlxciIsInEiLCJwIiwiaWR4IiwiY2VpbCIsImZyYWNGbGlwcyIsImZsaXBzIiwidmFsaWQiLCJwcmV2IiwidiIsImhoaSIsInNoYXJlcyIsIloiLCJwb3ciLCJpbmVydGlhRnJvbVJldHVybnMiLCJyIiwib3B0cyIsIlciLCJ3aW5kb3ciLCJzdGF0aWMiLCJncm93dGgiLCJ0b3RhbCIsImZhY2UiLCJ5IiwiZGlmZnMiLCJpIiwicHVzaCIsIm11Iiwic3ByZWFkRCIsImJldGFfcyIsImJldGFfbSIsImJldGFfZyIsInRhdTAiLCJzdGF0aWNVIiwiZ3Jvd3RoVSIsImciLCJkaXNydXB0aW9uSW5zdGFudCIsInJOb3ciLCJyZWZXaW5kb3ciLCJnYW1tYSIsInUiLCJkaXNydXB0aW9uU3lzdGVtaWMiLCJkaXNydXB0aW9ucyIsInRocmVzaG9sZCIsImsiLCJmaWx0ZXIiLCJkIiwiYW1wRnJvbVNlcmllcyIsIlMiLCJzd2luZyIsImV0YUEiLCJldGFGIiwidm9sdEZyb21EaXZlcmdlbmNlIiwiZGVsdGEiLCJzcHJlYWQiLCJhdmdBYnNaIiwibGFtYmRhIiwidm9sdEZyb21SZXR1cm5zIiwiTSIsIm4iLCJ2b2x0RnJvbVNlcmllcyIsImluZmxEZWZMZXZlbCIsIkxfbm93IiwiTV9ub3ciLCJrYXBwYSIsInJhdGlvIiwiUiIsImxvZyIsImluZmxEZWZSYXRlIiwiUl9ub3ciLCJSX3ByZXYiLCJkUiIsImFydGlmaWNpYWxpdHlTY29yZSIsImlucCIsIndlaWdodHMiLCJ3TSIsIndNaXNtYXRjaCIsIndFIiwid0V4ZWMiLCJ3SCIsIndISEkiLCJtaXNtYXRjaCIsImV4cGVjdGVkSW1wYWN0Iiwib2JzZXJ2ZWRDaGFuZ2UiLCJFIiwiZXhlY3V0ZWQiLCJwbGFjZWQiLCJjYW5jZWxlZCIsIkgiLCJjb250cmliU2hhcmVzIiwicmF3IiwiQSIsImVmZmljaWVuY3lTY29yZSIsIndUIiwid1RyZW5kIiwid1YiLCJ3Vm9sdCIsIndBIiwid0FydCIsImFscGhhIiwidHJlbmQiLCJ0ZW5kZW5jeURpcmVjdGlvbiIsInRlbmRlbmN5U3RyZW5ndGgiLCJ2b2x0Iiwidm9sdDAxIiwiYXJ0IiwiYXJ0aWZpY2lhbGl0eTAxIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/calc/metrics.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/calc/panel.ts":
/*!*************************************************!*\
  !*** ./src/core/features/str-aux/calc/panel.ts ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildSymbolStatsPanel: () => (/* binding */ buildSymbolStatsPanel),\n/* harmony export */   buildSymbolsStatsPanel: () => (/* binding */ buildSymbolsStatsPanel),\n/* harmony export */   computeSampledMetrics: () => (/* reexport safe */ _core_features_str_aux_calc_executive__WEBPACK_IMPORTED_MODULE_0__.computeSampledMetrics),\n/* harmony export */   computeSampledMetricsForSymbol: () => (/* reexport safe */ _core_features_str_aux_calc_executive__WEBPACK_IMPORTED_MODULE_0__.computeSampledMetricsForSymbol),\n/* harmony export */   toSymbolStatsPanel: () => (/* binding */ toSymbolStatsPanel)\n/* harmony export */ });\n/* harmony import */ var _core_features_str_aux_calc_executive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/features/str-aux/calc/executive */ \"(rsc)/./src/core/features/str-aux/calc/executive.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_features_str_aux_calc_executive__WEBPACK_IMPORTED_MODULE_0__]);\n_core_features_str_aux_calc_executive__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n// src/core/features/str-aux/calc/panel.ts\n// Helpers that transform sampled metrics into the shape consumed by the stats endpoint / UI.\n\nfunction toSymbolStatsPanel(symbol, result, ticker) {\n    if (!result.ok) {\n        return {\n            ok: false,\n            symbol,\n            error: result.error,\n            sampling: result.sampling\n        };\n    }\n    return sampledSuccessToPanel(symbol, result, ticker);\n}\nasync function buildSymbolStatsPanel(symbol, opts, ticker) {\n    const result = await (0,_core_features_str_aux_calc_executive__WEBPACK_IMPORTED_MODULE_0__.computeSampledMetricsForSymbol)(symbol, opts);\n    return toSymbolStatsPanel(symbol, result, ticker);\n}\nasync function buildSymbolsStatsPanel(symbols, opts, tickers) {\n    const entries = await Promise.all(symbols.map(async (symbol)=>{\n        const panel = await buildSymbolStatsPanel(symbol, opts, tickers?.[symbol]);\n        return [\n            symbol,\n            panel\n        ];\n    }));\n    return Object.fromEntries(entries);\n}\n\nfunction sampledSuccessToPanel(symbol, success, ticker) {\n    const pct24h = Number.isFinite(Number(ticker?.pct24h)) ? Number(ticker?.pct24h) : undefined;\n    const cards = buildCards(success.meta, pct24h);\n    const meta = {\n        opening: success.meta.opening,\n        last: success.meta.last,\n        prev: success.meta.prev,\n        lastUpdateTs: success.meta.lastUpdateTs,\n        n: success.meta.n\n    };\n    return {\n        ok: true,\n        symbol,\n        stats: success.stats,\n        hist: success.hist,\n        extrema: success.extrema,\n        sampling: success.sampling,\n        meta,\n        cards\n    };\n}\nfunction buildCards(meta, pct24h) {\n    return {\n        opening: {\n            benchmark: meta.opening,\n            pct24h\n        },\n        live: {\n            benchmark: meta.last,\n            pct_drv: pctDrv(meta.prev, meta.last, meta.n),\n            pct24h\n        }\n    };\n}\nfunction pctDrv(prev, cur, n) {\n    if (!(n > 1) || !Number.isFinite(prev) || !Number.isFinite(cur) || prev === 0) {\n        return 0;\n    }\n    return 100 * (cur / prev - 1);\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L2NhbGMvcGFuZWwudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsMENBQTBDO0FBQzFDLDZGQUE2RjtBQVE3QztBQTBDekMsU0FBU0UsbUJBQ2RDLE1BQWMsRUFDZEMsTUFBNEIsRUFDNUJDLE1BQXVCO0lBRXZCLElBQUksQ0FBQ0QsT0FBT0UsRUFBRSxFQUFFO1FBQ2QsT0FBTztZQUNMQSxJQUFJO1lBQ0pIO1lBQ0FJLE9BQU9ILE9BQU9HLEtBQUs7WUFDbkJDLFVBQVVKLE9BQU9JLFFBQVE7UUFDM0I7SUFDRjtJQUVBLE9BQU9DLHNCQUFzQk4sUUFBUUMsUUFBUUM7QUFDL0M7QUFFTyxlQUFlSyxzQkFDcEJQLE1BQWMsRUFDZFEsSUFBMkIsRUFDM0JOLE1BQXVCO0lBRXZCLE1BQU1ELFNBQVMsTUFBTUoscUdBQThCQSxDQUFDRyxRQUFRUTtJQUM1RCxPQUFPVCxtQkFBbUJDLFFBQVFDLFFBQVFDO0FBQzVDO0FBRU8sZUFBZU8sdUJBQ3BCQyxPQUFpQixFQUNqQkYsSUFBMkIsRUFDM0JHLE9BQXdDO0lBRXhDLE1BQU1DLFVBQVUsTUFBTUMsUUFBUUMsR0FBRyxDQUMvQkosUUFBUUssR0FBRyxDQUFDLE9BQU9mO1FBQ2pCLE1BQU1nQixRQUFRLE1BQU1ULHNCQUFzQlAsUUFBUVEsTUFBTUcsU0FBUyxDQUFDWCxPQUFPO1FBQ3pFLE9BQU87WUFBQ0E7WUFBUWdCO1NBQU07SUFDeEI7SUFFRixPQUFPQyxPQUFPQyxXQUFXLENBQUNOO0FBQzVCO0FBRWlFO0FBR2pFLFNBQVNOLHNCQUNQTixNQUFjLEVBQ2RtQixPQUE4QixFQUM5QmpCLE1BQXVCO0lBRXZCLE1BQU1rQixTQUFTQyxPQUFPQyxRQUFRLENBQUNELE9BQU9uQixRQUFRa0IsV0FDMUNDLE9BQU9uQixRQUFRa0IsVUFDZkc7SUFDSixNQUFNQyxRQUFRQyxXQUFXTixRQUFRTyxJQUFJLEVBQUVOO0lBQ3ZDLE1BQU1NLE9BQXdCO1FBQzVCQyxTQUFTUixRQUFRTyxJQUFJLENBQUNDLE9BQU87UUFDN0JDLE1BQU1ULFFBQVFPLElBQUksQ0FBQ0UsSUFBSTtRQUN2QkMsTUFBTVYsUUFBUU8sSUFBSSxDQUFDRyxJQUFJO1FBQ3ZCQyxjQUFjWCxRQUFRTyxJQUFJLENBQUNJLFlBQVk7UUFDdkNDLEdBQUdaLFFBQVFPLElBQUksQ0FBQ0ssQ0FBQztJQUNuQjtJQUVBLE9BQU87UUFDTDVCLElBQUk7UUFDSkg7UUFDQWdDLE9BQU9iLFFBQVFhLEtBQUs7UUFDcEJDLE1BQU1kLFFBQVFjLElBQUk7UUFDbEJDLFNBQVNmLFFBQVFlLE9BQU87UUFDeEI3QixVQUFVYyxRQUFRZCxRQUFRO1FBQzFCcUI7UUFDQUY7SUFDRjtBQUNGO0FBRUEsU0FBU0MsV0FBV0MsSUFBbUMsRUFBRU4sTUFBZTtJQUN0RSxPQUFPO1FBQ0xPLFNBQVM7WUFBRVEsV0FBV1QsS0FBS0MsT0FBTztZQUFFUDtRQUFPO1FBQzNDZ0IsTUFBTTtZQUNKRCxXQUFXVCxLQUFLRSxJQUFJO1lBQ3BCUyxTQUFTQyxPQUFPWixLQUFLRyxJQUFJLEVBQUVILEtBQUtFLElBQUksRUFBRUYsS0FBS0ssQ0FBQztZQUM1Q1g7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTa0IsT0FBT1QsSUFBWSxFQUFFVSxHQUFXLEVBQUVSLENBQVM7SUFDbEQsSUFBSSxDQUFFQSxDQUFBQSxJQUFJLE1BQU0sQ0FBQ1YsT0FBT0MsUUFBUSxDQUFDTyxTQUFTLENBQUNSLE9BQU9DLFFBQVEsQ0FBQ2lCLFFBQVFWLFNBQVMsR0FBRztRQUM3RSxPQUFPO0lBQ1Q7SUFDQSxPQUFPLE1BQU8sT0FBT0EsT0FBUTtBQUMvQiIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGNvcmVcXGZlYXR1cmVzXFxzdHItYXV4XFxjYWxjXFxwYW5lbC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L2NhbGMvcGFuZWwudHNcbi8vIEhlbHBlcnMgdGhhdCB0cmFuc2Zvcm0gc2FtcGxlZCBtZXRyaWNzIGludG8gdGhlIHNoYXBlIGNvbnN1bWVkIGJ5IHRoZSBzdGF0cyBlbmRwb2ludCAvIFVJLlxuXG5pbXBvcnQge1xuICBjb21wdXRlU2FtcGxlZE1ldHJpY3NGb3JTeW1ib2wsXG4gIGNvbXB1dGVTYW1wbGVkTWV0cmljcyxcbiAgdHlwZSBTYW1wbGVkTWV0cmljc09wdGlvbnMsXG4gIHR5cGUgU2FtcGxlZE1ldHJpY3NSZXN1bHQsXG4gIHR5cGUgU2FtcGxlZE1ldHJpY3NTdWNjZXNzLFxufSBmcm9tIFwiQC9jb3JlL2ZlYXR1cmVzL3N0ci1hdXgvY2FsYy9leGVjdXRpdmVcIjtcbmltcG9ydCB0eXBlIHsgU3RhdHMgfSBmcm9tIFwiQC9jb3JlL2ZlYXR1cmVzL3N0ci1hdXgvY2FsYy9zdGF0c1wiO1xuaW1wb3J0IHR5cGUgeyBTYW1wbGluZ1dpbmRvd0RpZ2VzdCB9IGZyb20gXCJAL2NvcmUvZmVhdHVyZXMvc3RyLWF1eC9zYW1wbGluZ1wiO1xuXG5leHBvcnQgdHlwZSBUaWNrZXJTbmFwc2hvdCA9IHtcbiAgcHJpY2U/OiBudW1iZXIgfCBudWxsO1xuICBwY3QyNGg/OiBudW1iZXIgfCBudWxsO1xufTtcblxuZXhwb3J0IHR5cGUgU3ltYm9sU3RhdHNNZXRhID0ge1xuICBvcGVuaW5nOiBudW1iZXI7XG4gIGxhc3Q6IG51bWJlcjtcbiAgcHJldjogbnVtYmVyO1xuICBsYXN0VXBkYXRlVHM6IG51bWJlcjtcbiAgbjogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgU3ltYm9sU3RhdHNDYXJkcyA9IHtcbiAgb3BlbmluZzogeyBiZW5jaG1hcms6IG51bWJlcjsgcGN0MjRoPzogbnVtYmVyIHwgbnVsbCB9O1xuICBsaXZlOiB7IGJlbmNobWFyazogbnVtYmVyOyBwY3RfZHJ2OiBudW1iZXI7IHBjdDI0aD86IG51bWJlciB8IG51bGwgfTtcbn07XG5cbmV4cG9ydCB0eXBlIFN5bWJvbFN0YXRzUGFuZWxTdWNjZXNzID0ge1xuICBvazogdHJ1ZTtcbiAgc3ltYm9sOiBzdHJpbmc7XG4gIHN0YXRzOiBTdGF0cztcbiAgaGlzdDogU2FtcGxlZE1ldHJpY3NTdWNjZXNzW1wiaGlzdFwiXTtcbiAgZXh0cmVtYTogeyBwcmljZU1pbjogbnVtYmVyOyBwcmljZU1heDogbnVtYmVyOyBiZW5jaFBjdE1pbjogbnVtYmVyOyBiZW5jaFBjdE1heDogbnVtYmVyIH07XG4gIHNhbXBsaW5nOiBTYW1wbGluZ1dpbmRvd0RpZ2VzdDtcbiAgbWV0YTogU3ltYm9sU3RhdHNNZXRhO1xuICBjYXJkczogU3ltYm9sU3RhdHNDYXJkcztcbn07XG5cbmV4cG9ydCB0eXBlIFN5bWJvbFN0YXRzUGFuZWxFcnJvciA9IHtcbiAgb2s6IGZhbHNlO1xuICBzeW1ib2w6IHN0cmluZztcbiAgZXJyb3I6IHN0cmluZztcbiAgc2FtcGxpbmc/OiBTYW1wbGluZ1dpbmRvd0RpZ2VzdDtcbn07XG5cbmV4cG9ydCB0eXBlIFN5bWJvbFN0YXRzUGFuZWwgPSBTeW1ib2xTdGF0c1BhbmVsU3VjY2VzcyB8IFN5bWJvbFN0YXRzUGFuZWxFcnJvcjtcblxuZXhwb3J0IGZ1bmN0aW9uIHRvU3ltYm9sU3RhdHNQYW5lbChcbiAgc3ltYm9sOiBzdHJpbmcsXG4gIHJlc3VsdDogU2FtcGxlZE1ldHJpY3NSZXN1bHQsXG4gIHRpY2tlcj86IFRpY2tlclNuYXBzaG90XG4pOiBTeW1ib2xTdGF0c1BhbmVsIHtcbiAgaWYgKCFyZXN1bHQub2spIHtcbiAgICByZXR1cm4ge1xuICAgICAgb2s6IGZhbHNlLFxuICAgICAgc3ltYm9sLFxuICAgICAgZXJyb3I6IHJlc3VsdC5lcnJvcixcbiAgICAgIHNhbXBsaW5nOiByZXN1bHQuc2FtcGxpbmcsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzYW1wbGVkU3VjY2Vzc1RvUGFuZWwoc3ltYm9sLCByZXN1bHQsIHRpY2tlcik7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBidWlsZFN5bWJvbFN0YXRzUGFuZWwoXG4gIHN5bWJvbDogc3RyaW5nLFxuICBvcHRzOiBTYW1wbGVkTWV0cmljc09wdGlvbnMsXG4gIHRpY2tlcj86IFRpY2tlclNuYXBzaG90XG4pOiBQcm9taXNlPFN5bWJvbFN0YXRzUGFuZWw+IHtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tcHV0ZVNhbXBsZWRNZXRyaWNzRm9yU3ltYm9sKHN5bWJvbCwgb3B0cyk7XG4gIHJldHVybiB0b1N5bWJvbFN0YXRzUGFuZWwoc3ltYm9sLCByZXN1bHQsIHRpY2tlcik7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBidWlsZFN5bWJvbHNTdGF0c1BhbmVsKFxuICBzeW1ib2xzOiBzdHJpbmdbXSxcbiAgb3B0czogU2FtcGxlZE1ldHJpY3NPcHRpb25zLFxuICB0aWNrZXJzPzogUmVjb3JkPHN0cmluZywgVGlja2VyU25hcHNob3Q+XG4pOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIFN5bWJvbFN0YXRzUGFuZWw+PiB7XG4gIGNvbnN0IGVudHJpZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBzeW1ib2xzLm1hcChhc3luYyAoc3ltYm9sKSA9PiB7XG4gICAgICBjb25zdCBwYW5lbCA9IGF3YWl0IGJ1aWxkU3ltYm9sU3RhdHNQYW5lbChzeW1ib2wsIG9wdHMsIHRpY2tlcnM/LltzeW1ib2xdKTtcbiAgICAgIHJldHVybiBbc3ltYm9sLCBwYW5lbF0gYXMgY29uc3Q7XG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhlbnRyaWVzKTtcbn1cblxuZXhwb3J0IHsgY29tcHV0ZVNhbXBsZWRNZXRyaWNzRm9yU3ltYm9sLCBjb21wdXRlU2FtcGxlZE1ldHJpY3MgfTtcbmV4cG9ydCB0eXBlIHsgU2FtcGxlZE1ldHJpY3NPcHRpb25zLCBTYW1wbGVkTWV0cmljc1Jlc3VsdCwgU2FtcGxlZE1ldHJpY3NTdWNjZXNzIH07XG5cbmZ1bmN0aW9uIHNhbXBsZWRTdWNjZXNzVG9QYW5lbChcbiAgc3ltYm9sOiBzdHJpbmcsXG4gIHN1Y2Nlc3M6IFNhbXBsZWRNZXRyaWNzU3VjY2VzcyxcbiAgdGlja2VyPzogVGlja2VyU25hcHNob3Rcbik6IFN5bWJvbFN0YXRzUGFuZWxTdWNjZXNzIHtcbiAgY29uc3QgcGN0MjRoID0gTnVtYmVyLmlzRmluaXRlKE51bWJlcih0aWNrZXI/LnBjdDI0aCkpXG4gICAgPyBOdW1iZXIodGlja2VyPy5wY3QyNGgpXG4gICAgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGNhcmRzID0gYnVpbGRDYXJkcyhzdWNjZXNzLm1ldGEsIHBjdDI0aCk7XG4gIGNvbnN0IG1ldGE6IFN5bWJvbFN0YXRzTWV0YSA9IHtcbiAgICBvcGVuaW5nOiBzdWNjZXNzLm1ldGEub3BlbmluZyxcbiAgICBsYXN0OiBzdWNjZXNzLm1ldGEubGFzdCxcbiAgICBwcmV2OiBzdWNjZXNzLm1ldGEucHJldixcbiAgICBsYXN0VXBkYXRlVHM6IHN1Y2Nlc3MubWV0YS5sYXN0VXBkYXRlVHMsXG4gICAgbjogc3VjY2Vzcy5tZXRhLm4sXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBvazogdHJ1ZSxcbiAgICBzeW1ib2wsXG4gICAgc3RhdHM6IHN1Y2Nlc3Muc3RhdHMsXG4gICAgaGlzdDogc3VjY2Vzcy5oaXN0LFxuICAgIGV4dHJlbWE6IHN1Y2Nlc3MuZXh0cmVtYSxcbiAgICBzYW1wbGluZzogc3VjY2Vzcy5zYW1wbGluZyxcbiAgICBtZXRhLFxuICAgIGNhcmRzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZENhcmRzKG1ldGE6IFNhbXBsZWRNZXRyaWNzU3VjY2Vzc1tcIm1ldGFcIl0sIHBjdDI0aD86IG51bWJlcikge1xuICByZXR1cm4ge1xuICAgIG9wZW5pbmc6IHsgYmVuY2htYXJrOiBtZXRhLm9wZW5pbmcsIHBjdDI0aCB9LFxuICAgIGxpdmU6IHtcbiAgICAgIGJlbmNobWFyazogbWV0YS5sYXN0LFxuICAgICAgcGN0X2RydjogcGN0RHJ2KG1ldGEucHJldiwgbWV0YS5sYXN0LCBtZXRhLm4pLFxuICAgICAgcGN0MjRoLFxuICAgIH0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBjdERydihwcmV2OiBudW1iZXIsIGN1cjogbnVtYmVyLCBuOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoIShuID4gMSkgfHwgIU51bWJlci5pc0Zpbml0ZShwcmV2KSB8fCAhTnVtYmVyLmlzRmluaXRlKGN1cikgfHwgcHJldiA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiAxMDAgKiAoKGN1ciAvIHByZXYpIC0gMSk7XG59XG4iXSwibmFtZXMiOlsiY29tcHV0ZVNhbXBsZWRNZXRyaWNzRm9yU3ltYm9sIiwiY29tcHV0ZVNhbXBsZWRNZXRyaWNzIiwidG9TeW1ib2xTdGF0c1BhbmVsIiwic3ltYm9sIiwicmVzdWx0IiwidGlja2VyIiwib2siLCJlcnJvciIsInNhbXBsaW5nIiwic2FtcGxlZFN1Y2Nlc3NUb1BhbmVsIiwiYnVpbGRTeW1ib2xTdGF0c1BhbmVsIiwib3B0cyIsImJ1aWxkU3ltYm9sc1N0YXRzUGFuZWwiLCJzeW1ib2xzIiwidGlja2VycyIsImVudHJpZXMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwicGFuZWwiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsInN1Y2Nlc3MiLCJwY3QyNGgiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInVuZGVmaW5lZCIsImNhcmRzIiwiYnVpbGRDYXJkcyIsIm1ldGEiLCJvcGVuaW5nIiwibGFzdCIsInByZXYiLCJsYXN0VXBkYXRlVHMiLCJuIiwic3RhdHMiLCJoaXN0IiwiZXh0cmVtYSIsImJlbmNobWFyayIsImxpdmUiLCJwY3RfZHJ2IiwicGN0RHJ2IiwiY3VyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/calc/panel.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/calc/stats.ts":
/*!*************************************************!*\
  !*** ./src/core/features/str-aux/calc/stats.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeStats: () => (/* binding */ computeStats)\n/* harmony export */ });\n/* harmony import */ var _frame_idhr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../frame/idhr */ \"(rsc)/./src/core/features/str-aux/frame/idhr.ts\");\n/* harmony import */ var _frame_idhrRanges__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../frame/idhrRanges */ \"(rsc)/./src/core/features/str-aux/frame/idhrRanges.ts\");\n/* harmony import */ var _vectors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../vectors */ \"(rsc)/./src/core/features/str-aux/vectors.ts\");\n/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./metrics */ \"(rsc)/./src/core/features/str-aux/calc/metrics.ts\");\n// core/features/str-aux/calc/stats.ts\n// STR-AUX descriptive stats + Floating Mode + Vectors + Intrinsic metrics.\n// - FloMo (GFM absolute price) from top-K densest IDHR bins (outlier-robust).\n// - BFloM (BFM 0..1) normalized within current IDHR return window.\n// - Vectors: vInner, vOuter, vTendency, optional vSwap (quartiles).\n// - Intrinsic metrics via metrics toolbox: inertia, amp, volt, efficiency.\n // sampler only (no MarketPoint import)\n\n // vectors\n // toolbox\n//  small utils \nconst EPS = 1e-9;\nconst avg = (a)=>a.length ? a.reduce((x, y)=>x + y, 0) / a.length : 0;\nconst robustSigma = (values)=>{\n    const m = avg(values);\n    const varSum = values.reduce((s, v)=>s + (v - m) * (v - m), 0);\n    return Math.sqrt(varSum / Math.max(1, values.length));\n};\nconst zAbs = (values, sigma)=>{\n    if (!(sigma > 0)) return 0;\n    const m = avg(values);\n    return avg(values.map((v)=>Math.abs((v - m) / sigma)));\n};\n// densest-K (works with idhr exposing edges+counts OR centers+counts)\nfunction takeDensestK(hist, k = 8) {\n    const centers = hist.edges ?? hist.centers ?? [];\n    const counts = hist.counts ?? [];\n    const pairs = centers.map((c, i)=>({\n            idx: i,\n            count: counts[i] ?? 0,\n            centerR: c\n        }));\n    pairs.sort((a, b)=>b.count - a.count);\n    return pairs.slice(0, Math.max(1, Math.min(k, pairs.length)));\n}\nfunction weightedCenterR(_hist, top) {\n    const mass = top.reduce((s, x)=>s + x.count, 0) || 1;\n    return top.reduce((s, x)=>s + x.centerR * (x.count / mass), 0);\n}\n// compute simple log-returns for metrics\nfunction logReturns(prices) {\n    const r = [];\n    for(let i = 1; i < prices.length; i++){\n        const a = prices[i - 1], b = prices[i];\n        if (a > 0 && b > 0) r.push(Math.log(b / a));\n        else r.push(0);\n    }\n    return r;\n}\n//  main \nfunction computeStats(points, opening, opts = {}) {\n    const epsGfmPct = opts.epsGfmPct ?? 0.35;\n    const epsBfmPct = opts.epsBfmPct ?? 0.35;\n    const vScale = opts.vScale ?? 100;\n    const Wm = Math.max(5, Math.floor(opts.metricsWin ?? 30));\n    const topK = Math.max(1, Math.floor(opts.idhr?.topK ?? 8));\n    const rangeInfo = (0,_frame_idhrRanges__WEBPACK_IMPORTED_MODULE_1__.deriveIdhrRanges)(points);\n    const filteredForVectors = (0,_frame_idhrRanges__WEBPACK_IMPORTED_MODULE_1__.filterByIdhrRanges)(points, rangeInfo);\n    // price dispersion\n    const prices = points.map((p)=>Number(p.price)).filter(Number.isFinite);\n    const openingPx = Number(opening?.benchmark ?? NaN);\n    const openingVal = prices[0] ?? openingPx;\n    const last = prices[prices.length - 1] ?? openingPx;\n    const prev = prices.length >= 2 ? prices[prices.length - 2] : last;\n    const sigma = robustSigma(prices);\n    const z = zAbs(prices, sigma);\n    // IDHR histogram (return-space)  map to CompatMarketPoint[] (volume required by sampler)\n    const idhrPoints = points.map((p)=>({\n            ts: Number(p.ts),\n            price: Number(p.price),\n            volume: Number.isFinite(p?.volume) ? Number(p.volume) : 0\n        }));\n    const hist = (0,_frame_idhr__WEBPACK_IMPORTED_MODULE_0__.computeIdhrBins)(idhrPoints, {\n        benchmark: openingPx,\n        pct24h: 0,\n        id_pct: 0,\n        ts: points[0]?.ts ?? 0,\n        layoutHash: '0'\n    }, {\n        bins: opts.idhr?.bins,\n        alpha: opts.idhr?.alpha,\n        sMin: opts.idhr?.sMin,\n        smooth: opts.idhr?.smooth\n    });\n    const binsCount = (hist.edges ?? hist.centers ?? []).length || hist.bins || 0;\n    // densest-K  weighted center in RETURN space\n    const top = takeDensestK(hist, topK);\n    const rCenter = weightedCenterR(hist, top); // ln(px/p0)\n    // FloMo (absolute price)\n    const gfmAbs = Number.isFinite(openingPx) && openingPx > 0 ? openingPx * Math.exp(rCenter) : NaN;\n    const refGfmAbs = Number.isFinite(opts.refGfmAbs) ? opts.refGfmAbs : openingPx;\n    const deltaGfmAbs = Number.isFinite(gfmAbs) && Number.isFinite(refGfmAbs) ? gfmAbs - refGfmAbs : NaN;\n    const deltaGfmPct = Number.isFinite(gfmAbs) && refGfmAbs > 0 ? (gfmAbs / refGfmAbs - 1) * 100 : NaN;\n    const shiftedGfm = Number.isFinite(deltaGfmPct) ? Math.abs(deltaGfmPct) >= epsGfmPct : false;\n    // BFloM (0..1) within current return window\n    const edges = hist.edges ?? hist.centers ?? [];\n    const rMin = edges[0] ?? 0, rMax = edges[edges.length - 1] ?? 1;\n    const bfm01 = (rCenter - rMin) / Math.max(EPS, rMax - rMin);\n    const refBfm01 = Number.isFinite(opts.refBfm01) ? opts.refBfm01 : bfm01;\n    const deltaBfm01 = bfm01 - refBfm01;\n    const deltaBfmPct = deltaBfm01 * 100;\n    const shiftedBfm = Math.abs(deltaBfmPct) >= epsBfmPct;\n    // vectors\n    const vectorSummary = (0,_vectors__WEBPACK_IMPORTED_MODULE_2__.computeVectorSummary)(filteredForVectors, {\n        bins: binsCount,\n        scale: vScale,\n        history: {\n            inner: opts.innerHistScaled,\n            tendency: opts.tendencyHistScaled\n        },\n        tendencyWindow: opts.tendencyWin,\n        tendencyNorm: opts.tendencyNorm,\n        swapAlpha: opts.swapAlpha\n    });\n    const vInnerAgg = vectorSummary.inner.scaled;\n    const vOuterAgg = vectorSummary.outer.scaled;\n    const tendency = vectorSummary.tendency.metrics;\n    const vSwap = vectorSummary.swap;\n    // intrinsic metrics (toolbox) using log-returns\n    const r = logReturns(prices);\n    const rW = r.slice(-Wm);\n    let inertia, amp, volt, efficiency;\n    if (rW.length >= 3) {\n        inertia = (0,_metrics__WEBPACK_IMPORTED_MODULE_3__.inertiaFromReturns)(rW, {\n            window: Wm\n        });\n        amp = (0,_metrics__WEBPACK_IMPORTED_MODULE_3__.ampFromSeries)(rW, {\n            window: Wm,\n            S: 100\n        });\n        volt = (0,_metrics__WEBPACK_IMPORTED_MODULE_3__.voltFromSeries)(rW, {\n            window: Wm,\n            lambda: 1.0,\n            S: 100\n        });\n        efficiency = (0,_metrics__WEBPACK_IMPORTED_MODULE_3__.efficiencyScore)({\n            tendencyDirection: tendency.direction,\n            tendencyStrength: tendency.strength,\n            volt01: (volt ?? 0) / 100,\n            artificiality01: 0\n        }, opts.efficiency);\n    }\n    return {\n        // dispersion\n        sigma,\n        zAbs: z,\n        idhr: rangeInfo.ranges.length ? {\n            ranges: rangeInfo.ranges,\n            selectedPrimaries: rangeInfo.selectedPrimaries,\n            selectedBins: rangeInfo.selectedBins\n        } : undefined,\n        // modes\n        gfmAbs,\n        refGfmAbs,\n        deltaGfmAbs,\n        deltaGfmPct,\n        shiftedGfm,\n        bfm01,\n        refBfm01,\n        deltaBfm01,\n        deltaBfmPct,\n        shiftedBfm,\n        // vectors\n        vInner: vInnerAgg,\n        vOuter: vOuterAgg,\n        tendency,\n        vSwap,\n        vectors: vectorSummary,\n        // metrics\n        inertia,\n        amp,\n        volt,\n        efficiency,\n        // raw\n        opening: Number(openingVal),\n        last: Number(last),\n        prev: Number(prev)\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L2NhbGMvc3RhdHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxzQ0FBc0M7QUFDdEMsMkVBQTJFO0FBQzNFLDhFQUE4RTtBQUM5RSxtRUFBbUU7QUFDbkUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUtwRCxDQUFDLHVDQUF1QztBQUtsQztBQUtULENBQUMsVUFBVTtBQU9aLENBQUMsVUFBVTtBQXdGOUIsa0VBQWtFO0FBQ2xFLE1BQU1RLE1BQU07QUFDWixNQUFNQyxNQUFNLENBQUNDLElBQWlCQSxFQUFFQyxNQUFNLEdBQUdELEVBQUVFLE1BQU0sQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxJQUFJQyxHQUFHLEtBQUtKLEVBQUVDLE1BQU0sR0FBRztBQUNuRixNQUFNSSxjQUFjLENBQUNDO0lBQ25CLE1BQU1DLElBQUlSLElBQUlPO0lBQ2QsTUFBTUUsU0FBU0YsT0FBT0osTUFBTSxDQUFDLENBQUNPLEdBQUdDLElBQU1ELElBQUksQ0FBQ0MsSUFBSUgsQ0FBQUEsSUFBTUcsQ0FBQUEsSUFBSUgsQ0FBQUEsR0FBSTtJQUM5RCxPQUFPSSxLQUFLQyxJQUFJLENBQUNKLFNBQVNHLEtBQUtFLEdBQUcsQ0FBQyxHQUFHUCxPQUFPTCxNQUFNO0FBQ3JEO0FBQ0EsTUFBTWEsT0FBTyxDQUFDUixRQUFrQlM7SUFDOUIsSUFBSSxDQUFFQSxDQUFBQSxRQUFRLElBQUksT0FBTztJQUN6QixNQUFNUixJQUFJUixJQUFJTztJQUNkLE9BQU9QLElBQUlPLE9BQU9VLEdBQUcsQ0FBQyxDQUFDTixJQUFNQyxLQUFLTSxHQUFHLENBQUMsQ0FBQ1AsSUFBSUgsQ0FBQUEsSUFBS1E7QUFDbEQ7QUFFQSxzRUFBc0U7QUFDdEUsU0FBU0csYUFDUEMsSUFBYyxFQUNkQyxJQUFJLENBQUM7SUFFTCxNQUFNQyxVQUFvQixLQUFjQyxLQUFLLElBQUksS0FBY0QsT0FBTyxJQUFJLEVBQUU7SUFDNUUsTUFBTUUsU0FBbUIsS0FBY0Es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Ry9HLE1BQU0sSUFBSSxHQUFHO1FBQ2xCZ0gsVUFBVXZILDREQUFrQkEsQ0FBQ3NILElBQUk7WUFBRUssUUFBUW5FO1FBQUc7UUFDOUNnRSxNQUFNdkgsdURBQWFBLENBQUNxSCxJQUFJO1lBQUVLLFFBQVFuRTtZQUFJb0UsR0FBRztRQUFJO1FBQzdDSCxPQUFPdkgsd0RBQWNBLENBQUNvSCxJQUFJO1lBQUVLLFFBQVFuRTtZQUFJcUUsUUFBUTtZQUFLRCxHQUFHO1FBQUk7UUFDNURGLGFBQWF2SCx5REFBZUEsQ0FDMUI7WUFDRTJILG1CQUFtQnJCLFNBQVNzQixTQUFTO1lBQ3JDQyxrQkFBa0J2QixTQUFTd0IsUUFBUTtZQUNuQ0MsUUFBUSxDQUFDVCxRQUFRLEtBQUs7WUFDdEJVLGlCQUFpQjtRQUNuQixHQUNBL0UsS0FBS3NFLFVBQVU7SUFFbkI7SUFFQSxPQUFPO1FBQ0wsYUFBYTtRQUNickc7UUFDQUQsTUFBTXNEO1FBQ05kLE1BQU1DLFVBQVV1RSxNQUFNLENBQUM3SCxNQUFNLEdBQ3pCO1lBQ0U2SCxRQUFRdkUsVUFBVXVFLE1BQU07WUFDeEJDLG1CQUFtQnhFLFVBQVV3RSxpQkFBaUI7WUFDOUNDLGNBQWN6RSxVQUFVeUUsWUFBWTtRQUN0QyxJQUNBQztRQUVKLFFBQVE7UUFDUmhEO1FBQ0FFO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FHO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBRUEsVUFBVTtRQUNWcUMsUUFBUXpCO1FBQ1IwQixRQUFReEI7UUFDUlI7UUFDQVc7UUFDQXNCLFNBQVN0QztRQUVULFVBQVU7UUFDVm1CO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBRUEsTUFBTTtRQUNOdkUsU0FBU2EsT0FBT087UUFDaEJDLE1BQU1SLE9BQU9RO1FBQ2JDLE1BQU1ULE9BQU9TO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGNvcmVcXGZlYXR1cmVzXFxzdHItYXV4XFxjYWxjXFxzdGF0cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb3JlL2ZlYXR1cmVzL3N0ci1hdXgvY2FsYy9zdGF0cy50c1xuLy8gU1RSLUFVWCBkZXNjcmlwdGl2ZSBzdGF0cyArIEZsb2F0aW5nIE1vZGUgKyBWZWN0b3JzICsgSW50cmluc2ljIG1ldHJpY3MuXG4vLyAtIEZsb01vIChHRk0gYWJzb2x1dGUgcHJpY2UpIGZyb20gdG9wLUsgZGVuc2VzdCBJREhSIGJpbnMgKG91dGxpZXItcm9idXN0KS5cbi8vIC0gQkZsb00gKEJGTSAwLi4xKSBub3JtYWxpemVkIHdpdGhpbiBjdXJyZW50IElESFIgcmV0dXJuIHdpbmRvdy5cbi8vIC0gVmVjdG9yczogdklubmVyLCB2T3V0ZXIsIHZUZW5kZW5jeSwgb3B0aW9uYWwgdlN3YXAgKHF1YXJ0aWxlcykuXG4vLyAtIEludHJpbnNpYyBtZXRyaWNzIHZpYSBtZXRyaWNzIHRvb2xib3g6IGluZXJ0aWEsIGFtcCwgdm9sdCwgZWZmaWNpZW5jeS5cblxuaW1wb3J0IHtcbiAgY29tcHV0ZUlkaHJCaW5zLFxuICB0eXBlIElkaHJCaW5zLFxufSBmcm9tICcuLi9mcmFtZS9pZGhyJzsgLy8gc2FtcGxlciBvbmx5IChubyBNYXJrZXRQb2ludCBpbXBvcnQpXG5pbXBvcnQge1xuICBkZXJpdmVJZGhyUmFuZ2VzLFxuICBmaWx0ZXJCeUlkaHJSYW5nZXMsXG4gIHR5cGUgUmV0dXJuUmFuZ2UsXG59IGZyb20gJy4uL2ZyYW1lL2lkaHJSYW5nZXMnO1xuXG5pbXBvcnQge1xuICBjb21wdXRlVmVjdG9yU3VtbWFyeSxcbiAgdHlwZSBWZWN0b3JTdW1tYXJ5LFxufSBmcm9tICcuLi92ZWN0b3JzJzsgLy8gdmVjdG9yc1xuXG5pbXBvcnQge1xuICBpbmVydGlhRnJvbVJldHVybnMsXG4gIGFtcEZyb21TZXJpZXMsXG4gIHZvbHRGcm9tU2VyaWVzLFxuICBlZmZpY2llbmN5U2NvcmUsXG59IGZyb20gJy4vbWV0cmljcyc7IC8vIHRvb2xib3hcblxuLy8gTG9jYWwgc3RydWN0dXJhbCB0eXBlIGNvbXBhdGlibGUgd2l0aCB0aGUgc2FtcGxlcidzIGV4cGVjdGF0aW9uLlxudHlwZSBDb21wYXRNYXJrZXRQb2ludCA9IHsgdHM6IG51bWJlcjsgcHJpY2U6IG51bWJlcjsgdm9sdW1lOiBudW1iZXIgfTtcblxuZXhwb3J0IHR5cGUgUG9pbnQgPSB7IHRzOiBudW1iZXI7IHByaWNlOiBudW1iZXI7IHc/OiBudW1iZXI7IHZvbHVtZT86IG51bWJlciB9O1xuXG5leHBvcnQgdHlwZSBTdGF0cyA9IHtcbiAgLy8gZGlzcGVyc2lvbiAocHJpY2Ugc2VyaWVzKVxuICBzaWdtYTogbnVtYmVyO1xuICB6QWJzOiBudW1iZXI7XG4gIGlkaHI/OiB7XG4gICAgcmFuZ2VzOiBSZXR1cm5SYW5nZVtdO1xuICAgIHNlbGVjdGVkUHJpbWFyaWVzOiBudW1iZXJbXTtcbiAgICBzZWxlY3RlZEJpbnM6IG51bWJlcltdO1xuICB9O1xuXG4gIC8vIEZsb01vIOKAlCBhYnNvbHV0ZSBHZW5lcmFsIEZsb2F0aW5nIE1vZGUgKHByaWNlIHNwYWNlKVxuICBnZm1BYnM6IG51bWJlcjtcbiAgcmVmR2ZtQWJzOiBudW1iZXI7XG4gIGRlbHRhR2ZtQWJzOiBudW1iZXI7XG4gIGRlbHRhR2ZtUGN0OiBudW1iZXI7XG4gIHNoaWZ0ZWRHZm06IGJvb2xlYW47XG5cbiAgLy8gQkZsb00g4oCUIG5vcm1hbGl6ZWQgKDAuLjEpIHdpdGhpbiBjdXJyZW50IElESFIgcmV0dXJuIHNwYW5cbiAgYmZtMDE6IG51bWJlcjtcbiAgcmVmQmZtMDE6IG51bWJlcjtcbiAgZGVsdGFCZm0wMTogbnVtYmVyO1xuICBkZWx0YUJmbVBjdDogbnVtYmVyO1xuICBzaGlmdGVkQmZtOiBib29sZWFuO1xuXG4gIC8vIHZlY3RvcnNcbiAgdklubmVyOiBudW1iZXI7XG4gIHZPdXRlcjogbnVtYmVyO1xuICB0ZW5kZW5jeTogeyBkaXJlY3Rpb246IG51bWJlcjsgc3RyZW5ndGg6IG51bWJlcjsgc2xvcGU6IG51bWJlcjsgcjogbnVtYmVyOyBzY29yZTogbnVtYmVyIH07XG4gIHZTd2FwPzogeyBROiBudW1iZXI7IHNjb3JlOiBudW1iZXI7IHExOiBudW1iZXI7IHEzOiBudW1iZXIgfTtcbiAgdmVjdG9yczogVmVjdG9yU3VtbWFyeTtcblxuICAvLyBpbnRyaW5zaWMgbWV0cmljcyAodG9vbGJveClcbiAgaW5lcnRpYT86IHsgc3RhdGljOiBudW1iZXI7IGdyb3d0aDogbnVtYmVyOyB0b3RhbDogbnVtYmVyOyBmYWNlOiAnc3RhdGljJyB8ICdncm93dGgnIH07XG4gIGFtcD86IG51bWJlcjtcbiAgdm9sdD86IG51bWJlcjtcbiAgZWZmaWNpZW5jeT86IG51bWJlcjtcblxuICAvLyBvcHRpb25hbCBoaXN0b2dyYW0gc25hcHNob3QgKHByZXNlbnQgd2hlbiBpbnZva2VkIGZyb20gc2FtcGxpbmcgcGlwZWxpbmVzKVxuICBoaXN0b2dyYW0/OiB7XG4gICAgY291bnRzOiBudW1iZXJbXTtcbiAgICBlZGdlczogbnVtYmVyW107XG4gICAgcHJvYnM6IG51bWJlcltdO1xuICAgIGRlbnNlc3Q6IG51bWJlcltdO1xuICAgIG11UjogbnVtYmVyO1xuICAgIHNpZ21hUjogbnVtYmVyO1xuICAgIHRvdGFsOiBudW1iZXI7XG4gIH07XG5cbiAgLy8gcmF3IGhlbHBlcnNcbiAgb3BlbmluZzogbnVtYmVyO1xuICBsYXN0OiBudW1iZXI7XG4gIHByZXY6IG51bWJlcjtcbn07XG5cbnR5cGUgT3B0aW9ucyA9IHtcbiAgLy8gSURIUiBjb250cm9scyAobWVyZ2VkIGluc2lkZSBpZGhyLnRzIGlmIHN1cHBvcnRlZClcbiAgaWRocj86IHsgYmlucz86IG51bWJlcjsgYWxwaGE/OiBudW1iZXI7IHNNaW4/OiBudW1iZXI7IHNtb290aD86IG51bWJlcjsgdG9wSz86IG51bWJlciB9O1xuXG4gIC8vIGFuY2hvcnMgJiB0aHJlc2hvbGRzXG4gIGVwc0dmbVBjdD86IG51bWJlcjsgLy8gZGVmYXVsdCAwLjM1XG4gIGVwc0JmbVBjdD86IG51bWJlcjsgLy8gZGVmYXVsdCAwLjM1XG4gIHJlZkdmbUFicz86IG51bWJlcjsgLy8gZGVmYXVsdCA9IG9wZW5pbmdQeFxuICByZWZCZm0wMT86IG51bWJlcjsgIC8vIGRlZmF1bHQgPSBiZm0wMSBvZiB0aGlzIGNhbGxcblxuICAvLyB2ZWN0b3JzXG4gIHZTY2FsZT86IG51bWJlcjsgLy8gZGVmYXVsdCAxMDBcbiAgdGVuZGVuY3lXaW4/OiBudW1iZXI7IC8vIGRlZmF1bHQgMzBcbiAgdGVuZGVuY3lOb3JtPzogJ21hZCcgfCAnc3RkZXYnOyAvLyBkZWZhdWx0ICdtYWQnXG4gIHN3YXBBbHBoYT86IG51bWJlcjsgLy8gb3B0aW9uYWwgc29mdG5lc3MgZm9yIHZTd2FwIHRhbmhcbiAgaW5uZXJIaXN0U2NhbGVkPzogbnVtYmVyW107XG4gIHRlbmRlbmN5SGlzdFNjYWxlZD86IG51bWJlcltdO1xuXG4gIC8vIG1ldHJpY3Mgd2luZG93c1xuICBtZXRyaWNzV2luPzogbnVtYmVyOyAvLyBkZWZhdWx0IDMwIGZvciBpbmVydGlhL2FtcC92b2x0IGNhbGN1bGF0aW9uc1xuXG4gIC8vIGVmZmljaWVuY3kgd2VpZ2h0cyAob3B0aW9uYWwpXG4gIGVmZmljaWVuY3k/OiB7IHdUcmVuZD86IG51bWJlcjsgd1ZvbHQ/OiBudW1iZXI7IHdBcnQ/OiBudW1iZXI7IGFscGhhPzogbnVtYmVyOyBTPzogbnVtYmVyIH07XG59O1xuXG5leHBvcnQgdHlwZSBTdGF0c09wdGlvbnMgPSBPcHRpb25zO1xuXG4vLyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgc21hbGwgdXRpbHMg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXG5jb25zdCBFUFMgPSAxZS05O1xuY29uc3QgYXZnID0gKGE6IG51bWJlcltdKSA9PiAoYS5sZW5ndGggPyBhLnJlZHVjZSgoeCwgeSkgPT4geCArIHksIDApIC8gYS5sZW5ndGggOiAwKTtcbmNvbnN0IHJvYnVzdFNpZ21hID0gKHZhbHVlczogbnVtYmVyW10pID0+IHtcbiAgY29uc3QgbSA9IGF2Zyh2YWx1ZXMpO1xuICBjb25zdCB2YXJTdW0gPSB2YWx1ZXMucmVkdWNlKChzLCB2KSA9PiBzICsgKHYgLSBtKSAqICh2IC0gbSksIDApO1xuICByZXR1cm4gTWF0aC5zcXJ0KHZhclN1bSAvIE1hdGgubWF4KDEsIHZhbHVlcy5sZW5ndGgpKTtcbn07XG5jb25zdCB6QWJzID0gKHZhbHVlczogbnVtYmVyW10sIHNpZ21hOiBudW1iZXIpID0+IHtcbiAgaWYgKCEoc2lnbWEgPiAwKSkgcmV0dXJuIDA7XG4gIGNvbnN0IG0gPSBhdmcodmFsdWVzKTtcbiAgcmV0dXJuIGF2Zyh2YWx1ZXMubWFwKCh2KSA9PiBNYXRoLmFicygodiAtIG0pIC8gc2lnbWEpKSk7XG59O1xuXG4vLyBkZW5zZXN0LUsgKHdvcmtzIHdpdGggaWRociBleHBvc2luZyBlZGdlcytjb3VudHMgT1IgY2VudGVycytjb3VudHMpXG5mdW5jdGlvbiB0YWtlRGVuc2VzdEsoXG4gIGhpc3Q6IElkaHJCaW5zLFxuICBrID0gOFxuKTogQXJyYXk8eyBpZHg6IG51bWJlcjsgY291bnQ6IG51bWJlcjsgY2VudGVyUjogbnVtYmVyIH0+IHtcbiAgY29uc3QgY2VudGVyczogbnVtYmVyW10gPSAoaGlzdCBhcyBhbnkpLmVkZ2VzID8/IChoaXN0IGFzIGFueSkuY2VudGVycyA/PyBbXTtcbiAgY29uc3QgY291bnRzOiBudW1iZXJbXSA9IChoaXN0IGFzIGFueSkuY291bnRzID8/IFtdO1xuICBjb25zdCBwYWlycyA9IGNlbnRlcnMubWFwKChjLCBpKSA9PiAoeyBpZHg6IGksIGNvdW50OiBjb3VudHNbaV0gPz8gMCwgY2VudGVyUjogYyB9KSk7XG4gIHBhaXJzLnNvcnQoKGEsIGIpID0+IGIuY291bnQgLSBhLmNvdW50KTtcbiAgcmV0dXJuIHBhaXJzLnNsaWNlKDAsIE1hdGgubWF4KDEsIE1hdGgubWluKGssIHBhaXJzLmxlbmd0aCkpKTtcbn1cbmZ1bmN0aW9uIHdlaWdodGVkQ2VudGVyUihcbiAgX2hpc3Q6IElkaHJCaW5zLFxuICB0b3A6IEFycmF5PHsgaWR4OiBudW1iZXI7IGNvdW50OiBudW1iZXI7IGNlbnRlclI6IG51bWJlciB9PlxuKTogbnVtYmVyIHtcbiAgY29uc3QgbWFzcyA9IHRvcC5yZWR1Y2UoKHMsIHgpID0+IHMgKyB4LmNvdW50LCAwKSB8fCAxO1xuICByZXR1cm4gdG9wLnJlZHVjZSgocywgeCkgPT4gcyArIHguY2VudGVyUiAqICh4LmNvdW50IC8gbWFzcyksIDApO1xufVxuXG4vLyBjb21wdXRlIHNpbXBsZSBsb2ctcmV0dXJucyBmb3IgbWV0cmljc1xuZnVuY3Rpb24gbG9nUmV0dXJucyhwcmljZXM6IG51bWJlcltdKTogbnVtYmVyW10ge1xuICBjb25zdCByOiBudW1iZXJbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHByaWNlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGEgPSBwcmljZXNbaSAtIDFdLCBiID0gcHJpY2VzW2ldO1xuICAgIGlmIChhID4gMCAmJiBiID4gMCkgci5wdXNoKE1hdGgubG9nKGIgLyBhKSk7XG4gICAgZWxzZSByLnB1c2goMCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbi8vIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBtYWluIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgFxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVTdGF0cyhcbiAgcG9pbnRzOiBQb2ludFtdLFxuICBvcGVuaW5nOiB7IGJlbmNobWFyazogbnVtYmVyIH0sXG4gIG9wdHM6IE9wdGlvbnMgPSB7fVxuKTogU3RhdHMge1xuICBjb25zdCBlcHNHZm1QY3QgPSBvcHRzLmVwc0dmbVBjdCA/PyAwLjM1O1xuICBjb25zdCBlcHNCZm1QY3QgPSBvcHRzLmVwc0JmbVBjdCA/PyAwLjM1O1xuICBjb25zdCB2U2NhbGUgICAgPSBvcHRzLnZTY2FsZSAgICA/PyAxMDA7XG4gIGNvbnN0IFdtICAgICAgICA9IE1hdGgubWF4KDUsIE1hdGguZmxvb3Iob3B0cy5tZXRyaWNzV2luID8/IDMwKSk7XG4gIGNvbnN0IHRvcEsgICAgICA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3Iob3B0cy5pZGhyPy50b3BLID8/IDgpKTtcblxuICBjb25zdCByYW5nZUluZm8gPSBkZXJpdmVJZGhyUmFuZ2VzKHBvaW50cyBhcyBBcnJheTx7IHByaWNlOiBudW1iZXI7IHRzPzogbnVtYmVyIH0+KTtcbiAgY29uc3QgZmlsdGVyZWRGb3JWZWN0b3JzID0gZmlsdGVyQnlJZGhyUmFuZ2VzKHBvaW50cywgcmFuZ2VJbmZvKTtcblxuICAvLyBwcmljZSBkaXNwZXJzaW9uXG4gIGNvbnN0IHByaWNlcyA9IHBvaW50cy5tYXAoKHApID0+IE51bWJlcihwLnByaWNlKSkuZmlsdGVyKE51bWJlci5pc0Zpbml0ZSk7XG4gIGNvbnN0IG9wZW5pbmdQeCA9IE51bWJlcihvcGVuaW5nPy5iZW5jaG1hcmsgPz8gTmFOKTtcbiAgY29uc3Qgb3BlbmluZ1ZhbCA9IHByaWNlc1swXSA/PyBvcGVuaW5nUHg7XG4gIGNvbnN0IGxhc3QgPSBwcmljZXNbcHJpY2VzLmxlbmd0aCAtIDFdID8/IG9wZW5pbmdQeDtcbiAgY29uc3QgcHJldiA9IHByaWNlcy5sZW5ndGggPj0gMiA/IHByaWNlc1twcmljZXMubGVuZ3RoIC0gMl0gOiBsYXN0O1xuXG4gIGNvbnN0IHNpZ21hID0gcm9idXN0U2lnbWEocHJpY2VzKTtcbiAgY29uc3QgeiA9IHpBYnMocHJpY2VzLCBzaWdtYSk7XG5cbiAgLy8gSURIUiBoaXN0b2dyYW0gKHJldHVybi1zcGFjZSkg4oCUIG1hcCB0byBDb21wYXRNYXJrZXRQb2ludFtdICh2b2x1bWUgcmVxdWlyZWQgYnkgc2FtcGxlcilcbiAgY29uc3QgaWRoclBvaW50czogQ29tcGF0TWFya2V0UG9pbnRbXSA9IHBvaW50cy5tYXAoKHApID0+ICh7XG4gICAgdHM6IE51bWJlcihwLnRzKSxcbiAgICBwcmljZTogTnVtYmVyKHAucHJpY2UpLFxuICAgIHZvbHVtZTogTnVtYmVyLmlzRmluaXRlKChwIGFzIGFueSk/LnZvbHVtZSkgPyBOdW1iZXIoKHAgYXMgYW55KS52b2x1bWUpIDogMCxcbiAgfSkpO1xuXG4gIGNvbnN0IGhpc3QgPSBjb21wdXRlSWRockJpbnMoXG4gICAgaWRoclBvaW50cyxcbiAgICB7XG4gICAgICBiZW5jaG1hcms6IG9wZW5pbmdQeCxcbiAgICAgIHBjdDI0aDogMCxcbiAgICAgIGlkX3BjdDogMCxcbiAgICAgIHRzOiBwb2ludHNbMF0/LnRzID8/IDAsXG4gICAgICBsYXlvdXRIYXNoOiAnMCcsXG4gICAgfSxcbiAgICB7IGJpbnM6IG9wdHMuaWRocj8uYmlucywgYWxwaGE6IG9wdHMuaWRocj8uYWxwaGEsIHNNaW46IG9wdHMuaWRocj8uc01pbiwgc21vb3RoOiBvcHRzLmlkaHI/LnNtb290aCB9IGFzIGFueVxuICApO1xuICBjb25zdCBiaW5zQ291bnQgPVxuICAgICgoaGlzdCBhcyBhbnkpLmVkZ2VzID8/IChoaXN0IGFzIGFueSkuY2VudGVycyA/PyBbXSkubGVuZ3RoIHx8XG4gICAgKGhpc3QgYXMgYW55KS5iaW5zIHx8XG4gICAgMDtcblxuICAvLyBkZW5zZXN0LUsg4oaSIHdlaWdodGVkIGNlbnRlciBpbiBSRVRVUk4gc3BhY2VcbiAgY29uc3QgdG9wID0gdGFrZURlbnNlc3RLKGhpc3QsIHRvcEspO1xuICBjb25zdCByQ2VudGVyID0gd2VpZ2h0ZWRDZW50ZXJSKGhpc3QsIHRvcCk7IC8vIGxuKHB4L3AwKVxuXG4gIC8vIEZsb01vIChhYnNvbHV0ZSBwcmljZSlcbiAgY29uc3QgZ2ZtQWJzID1cbiAgICBOdW1iZXIuaXNGaW5pdGUob3BlbmluZ1B4KSAmJiBvcGVuaW5nUHggPiAwID8gb3BlbmluZ1B4ICogTWF0aC5leHAockNlbnRlcikgOiBOYU47XG4gIGNvbnN0IHJlZkdmbUFicyA9IE51bWJlci5pc0Zpbml0ZShvcHRzLnJlZkdmbUFicyBhcyBudW1iZXIpXG4gICAgPyAob3B0cy5yZWZHZm1BYnMgYXMgbnVtYmVyKVxuICAgIDogb3BlbmluZ1B4O1xuICBjb25zdCBkZWx0YUdmbUFicyA9XG4gICAgTnVtYmVyLmlzRmluaXRlKGdmbUFicykgJiYgTnVtYmVyLmlzRmluaXRlKHJlZkdmbUFicylcbiAgICAgID8gZ2ZtQWJzIC0gcmVmR2ZtQWJzXG4gICAgICA6IE5hTjtcbiAgY29uc3QgZGVsdGFHZm1QY3QgPVxuICAgIE51bWJlci5pc0Zpbml0ZShnZm1BYnMpICYmIHJlZkdmbUFicyA+IDAgPyAoZ2ZtQWJzIC8gcmVmR2ZtQWJzIC0gMSkgKiAxMDAgOiBOYU47XG4gIGNvbnN0IHNoaWZ0ZWRHZm0gPSBOdW1iZXIuaXNGaW5pdGUoZGVsdGFHZm1QY3QpXG4gICAgPyBNYXRoLmFicyhkZWx0YUdmbVBjdCkgPj0gZXBzR2ZtUGN0XG4gICAgOiBmYWxzZTtcblxuICAvLyBCRmxvTSAoMC4uMSkgd2l0aGluIGN1cnJlbnQgcmV0dXJuIHdpbmRvd1xuICBjb25zdCBlZGdlcyA9IChoaXN0IGFzIGFueSkuZWRnZXMgPz8gKGhpc3QgYXMgYW55KS5jZW50ZXJzID8/IFtdO1xuICBjb25zdCByTWluID0gZWRnZXNbMF0gPz8gMCwgck1heCA9IGVkZ2VzW2VkZ2VzLmxlbmd0aCAtIDFdID8/IDE7XG4gIGNvbnN0IGJmbTAxID0gKHJDZW50ZXIgLSByTWluKSAvIE1hdGgubWF4KEVQUywgck1heCAtIHJNaW4pO1xuICBjb25zdCByZWZCZm0wMSA9IE51bWJlci5pc0Zpbml0ZShvcHRzLnJlZkJmbTAxIGFzIG51bWJlcilcbiAgICA/IChvcHRzLnJlZkJmbTAxIGFzIG51bWJlcilcbiAgICA6IGJmbTAxO1xuICBjb25zdCBkZWx0YUJmbTAxID0gYmZtMDEgLSByZWZCZm0wMTtcbiAgY29uc3QgZGVsdGFCZm1QY3QgPSBkZWx0YUJmbTAxICogMTAwO1xuICBjb25zdCBzaGlmdGVkQmZtID0gTWF0aC5hYnMoZGVsdGFCZm1QY3QpID49IGVwc0JmbVBjdDtcblxuICAvLyB2ZWN0b3JzXG4gIGNvbnN0IHZlY3RvclN1bW1hcnkgPSBjb21wdXRlVmVjdG9yU3VtbWFyeShmaWx0ZXJlZEZvclZlY3RvcnMsIHtcbiAgICBiaW5zOiBiaW5zQ291bnQsXG4gICAgc2NhbGU6IHZTY2FsZSxcbiAgICBoaXN0b3J5OiB7XG4gICAgICBpbm5lcjogb3B0cy5pbm5lckhpc3RTY2FsZWQsXG4gICAgICB0ZW5kZW5jeTogb3B0cy50ZW5kZW5jeUhpc3RTY2FsZWQsXG4gICAgfSxcbiAgICB0ZW5kZW5jeVdpbmRvdzogb3B0cy50ZW5kZW5jeVdpbixcbiAgICB0ZW5kZW5jeU5vcm06IG9wdHMudGVuZGVuY3lOb3JtLFxuICAgIHN3YXBBbHBoYTogb3B0cy5zd2FwQWxwaGEsXG4gIH0pO1xuICBjb25zdCB2SW5uZXJBZ2cgPSB2ZWN0b3JTdW1tYXJ5LmlubmVyLnNjYWxlZDtcbiAgY29uc3Qgdk91dGVyQWdnID0gdmVjdG9yU3VtbWFyeS5vdXRlci5zY2FsZWQ7XG4gIGNvbnN0IHRlbmRlbmN5ID0gdmVjdG9yU3VtbWFyeS50ZW5kZW5jeS5tZXRyaWNzO1xuICBjb25zdCB2U3dhcCA9IHZlY3RvclN1bW1hcnkuc3dhcDtcblxuICAvLyBpbnRyaW5zaWMgbWV0cmljcyAodG9vbGJveCkgdXNpbmcgbG9nLXJldHVybnNcbiAgY29uc3QgciA9IGxvZ1JldHVybnMocHJpY2VzKTtcbiAgY29uc3QgclcgPSByLnNsaWNlKC1XbSk7XG4gIGxldCBpbmVydGlhLCBhbXAsIHZvbHQsIGVmZmljaWVuY3k7XG4gIGlmIChyVy5sZW5ndGggPj0gMykge1xuICAgIGluZXJ0aWEgPSBpbmVydGlhRnJvbVJldHVybnMoclcsIHsgd2luZG93OiBXbSB9KTtcbiAgICBhbXAgPSBhbXBGcm9tU2VyaWVzKHJXLCB7IHdpbmRvdzogV20sIFM6IDEwMCB9KTtcbiAgICB2b2x0ID0gdm9sdEZyb21TZXJpZXMoclcsIHsgd2luZG93OiBXbSwgbGFtYmRhOiAxLjAsIFM6IDEwMCB9KTtcbiAgICBlZmZpY2llbmN5ID0gZWZmaWNpZW5jeVNjb3JlKFxuICAgICAge1xuICAgICAgICB0ZW5kZW5jeURpcmVjdGlvbjogdGVuZGVuY3kuZGlyZWN0aW9uLFxuICAgICAgICB0ZW5kZW5jeVN0cmVuZ3RoOiB0ZW5kZW5jeS5zdHJlbmd0aCxcbiAgICAgICAgdm9sdDAxOiAodm9sdCA/PyAwKSAvIDEwMCxcbiAgICAgICAgYXJ0aWZpY2lhbGl0eTAxOiAwLFxuICAgICAgfSxcbiAgICAgIG9wdHMuZWZmaWNpZW5jeVxuICAgICk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIGRpc3BlcnNpb25cbiAgICBzaWdtYSxcbiAgICB6QWJzOiB6LFxuICAgIGlkaHI6IHJhbmdlSW5mby5yYW5nZXMubGVuZ3RoXG4gICAgICA/IHtcbiAgICAgICAgICByYW5nZXM6IHJhbmdlSW5mby5yYW5nZXMsXG4gICAgICAgICAgc2VsZWN0ZWRQcmltYXJpZXM6IHJhbmdlSW5mby5zZWxlY3RlZFByaW1hcmllcyxcbiAgICAgICAgICBzZWxlY3RlZEJpbnM6IHJhbmdlSW5mby5zZWxlY3RlZEJpbnMsXG4gICAgICAgIH1cbiAgICAgIDogdW5kZWZpbmVkLFxuXG4gICAgLy8gbW9kZXNcbiAgICBnZm1BYnMsXG4gICAgcmVmR2ZtQWJzLFxuICAgIGRlbHRhR2ZtQWJzLFxuICAgIGRlbHRhR2ZtUGN0LFxuICAgIHNoaWZ0ZWRHZm0sXG4gICAgYmZtMDEsXG4gICAgcmVmQmZtMDEsXG4gICAgZGVsdGFCZm0wMSxcbiAgICBkZWx0YUJmbVBjdCxcbiAgICBzaGlmdGVkQmZtLFxuXG4gICAgLy8gdmVjdG9yc1xuICAgIHZJbm5lcjogdklubmVyQWdnLFxuICAgIHZPdXRlcjogdk91dGVyQWdnLFxuICAgIHRlbmRlbmN5LFxuICAgIHZTd2FwLFxuICAgIHZlY3RvcnM6IHZlY3RvclN1bW1hcnksXG5cbiAgICAvLyBtZXRyaWNzXG4gICAgaW5lcnRpYSxcbiAgICBhbXAsXG4gICAgdm9sdCxcbiAgICBlZmZpY2llbmN5LFxuXG4gICAgLy8gcmF3XG4gICAgb3BlbmluZzogTnVtYmVyKG9wZW5pbmdWYWwpLFxuICAgIGxhc3Q6IE51bWJlcihsYXN0KSxcbiAgICBwcmV2OiBOdW1iZXIocHJldiksXG4gIH07XG59XG4iXSwibmFtZXMiOlsiY29tcHV0ZUlkaHJCaW5zIiwiZGVyaXZlSWRoclJhbmdlcyIsImZpbHRlckJ5SWRoclJhbmdlcyIsImNvbXB1dGVWZWN0b3JTdW1tYXJ5IiwiaW5lcnRpYUZyb21SZXR1cm5zIiwiYW1wRnJvbVNlcmllcyIsInZvbHRGcm9tU2VyaWVzIiwiZWZmaWNpZW5jeVNjb3JlIiwiRVBTIiwiYXZnIiwiYSIsImxlbmd0aCIsInJlZHVjZSIsIngiLCJ5Iiwicm9idXN0U2lnbWEiLCJ2YWx1ZXMiLCJtIiwidmFyU3VtIiwicyIsInYiLCJNYXRoIiwic3FydCIsIm1heCIsInpBYnMiLCJzaWdtYSIsIm1hcCIsImFicyIsInRha2VEZW5zZXN0SyIsImhpc3QiLCJrIiwiY2VudGVycyIsImVkZ2VzIiwiY291bnRzIiwicGFpcnMiLCJjIiwiaSIsImlkeCIsImNvdW50IiwiY2VudGVyUiIsInNvcnQiLCJiIiwic2xpY2UiLCJtaW4iLCJ3ZWlnaHRlZENlbnRlclIiLCJfaGlzdCIsInRvcCIsIm1hc3MiLCJsb2dSZXR1cm5zIiwicHJpY2VzIiwiciIsInB1c2giLCJsb2ciLCJjb21wdXRlU3RhdHMiLCJwb2ludHMiLCJvcGVuaW5nIiwib3B0cyIsImVwc0dmbVBjdCIsImVwc0JmbVBjdCIsInZTY2FsZSIsIldtIiwiZmxvb3IiLCJtZXRyaWNzV2luIiwidG9wSyIsImlkaHIiLCJyYW5nZUluZm8iLCJmaWx0ZXJlZEZvclZlY3RvcnMiLCJwIiwiTnVtYmVyIiwicHJpY2UiLCJmaWx0ZXIiLCJpc0Zpbml0ZSIsIm9wZW5pbmdQeCIsImJlbmNobWFyayIsIk5hTiIsIm9wZW5pbmdWYWwiLCJsYXN0IiwicHJldiIsInoiLCJpZGhyUG9pbnRzIiwidHMiLCJ2b2x1bWUiLCJwY3QyNGgiLCJpZF9wY3QiLCJsYXlvdXRIYXNoIiwiYmlucyIsImFscGhhIiwic01pbiIsInNtb290aCIsImJpbnNDb3VudCIsInJDZW50ZXIiLCJnZm1BYnMiLCJleHAiLCJyZWZHZm1BYnMiLCJkZWx0YUdmbUFicyIsImRlbHRhR2ZtUGN0Iiwic2hpZnRlZEdmbSIsInJNaW4iLCJyTWF4IiwiYmZtMDEiLCJyZWZCZm0wMSIsImRlbHRhQmZtMDEiLCJkZWx0YUJmbVBjdCIsInNoaWZ0ZWRCZm0iLCJ2ZWN0b3JTdW1tYXJ5Iiwic2NhbGUiLCJoaXN0b3J5IiwiaW5uZXIiLCJpbm5lckhpc3RTY2FsZWQiLCJ0ZW5kZW5jeSIsInRlbmRlbmN5SGlzdFNjYWxlZCIsInRlbmRlbmN5V2luZG93IiwidGVuZGVuY3lXaW4iLCJ0ZW5kZW5jeU5vcm0iLCJzd2FwQWxwaGEiLCJ2SW5uZXJBZ2ciLCJzY2FsZWQiLCJ2T3V0ZXJBZ2ciLCJvdXRlciIsIm1ldHJpY3MiLCJ2U3dhcCIsInN3YXAiLCJyVyIsImluZXJ0aWEiLCJhbXAiLCJ2b2x0IiwiZWZmaWNpZW5jeSIsIndpbmRvdyIsIlMiLCJsYW1iZGEiLCJ0ZW5kZW5jeURpcmVjdGlvbiIsImRpcmVjdGlvbiIsInRlbmRlbmN5U3RyZW5ndGgiLCJzdHJlbmd0aCIsInZvbHQwMSIsImFydGlmaWNpYWxpdHkwMSIsInJhbmdlcyIsInNlbGVjdGVkUHJpbWFyaWVzIiwic2VsZWN0ZWRCaW5zIiwidW5kZWZpbmVkIiwidklubmVyIiwidk91dGVyIiwidmVjdG9ycyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/calc/stats.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/calc/tendency.ts":
/*!****************************************************!*\
  !*** ./src/core/features/str-aux/calc/tendency.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aggregateInnerNow: () => (/* binding */ aggregateInnerNow),\n/* harmony export */   vInner: () => (/* binding */ vInner),\n/* harmony export */   vInnerScaled: () => (/* binding */ vInnerScaled),\n/* harmony export */   vOuter: () => (/* binding */ vOuter),\n/* harmony export */   vOuterScaled: () => (/* binding */ vOuterScaled),\n/* harmony export */   vSwapFromNuclei: () => (/* binding */ vSwapFromNuclei),\n/* harmony export */   vSwapQuartiles: () => (/* binding */ vSwapQuartiles),\n/* harmony export */   vTendencyFromSeries: () => (/* binding */ vTendencyFromSeries)\n/* harmony export */ });\n// tendency.ts\n// IDHR/binning tendency vectors: vInner, vOuter, vTendency, vSwap (quartiles).\n// Scale convention: default S = 100; all public scores in [-S, +S]. No external deps.\n/* ----------------------------- Types & Helpers ---------------------------- */ const clamp = (x, lo, hi)=>Math.max(lo, Math.min(hi, x));\nconst tanh = (x)=>{\n    if (!Number.isFinite(x)) return Math.sign(x) || 0;\n    if (typeof Math.tanh === \"function\") return Math.tanh(x);\n    const e = Math.exp(2 * x);\n    return (e - 1) / (e + 1);\n};\nconst sum = (xs)=>xs.reduce((a, b)=>a + b, 0);\nconst mean = (xs)=>xs.length ? sum(xs) / xs.length : 0;\nfunction sortBy(arr, key) {\n    return arr.slice().sort((a, b)=>key(a) - key(b));\n}\n/** Weighted median of x with weights w (positive). Falls back to plain median if no weights. */ function wMedian(x, w) {\n    const n = x.length;\n    if (!n) return 0;\n    if (!w || w.length !== n) {\n        const xs = x.slice().sort((a, b)=>a - b);\n        const m = Math.floor(n / 2);\n        return n % 2 ? xs[m] : (xs[m - 1] + xs[m]) / 2;\n    }\n    const pairs = sortBy(x.map((xi, i)=>({\n            xi,\n            wi: Math.max(0, Number.isFinite(w[i]) ? w[i] : 0)\n        })), (p)=>p.xi);\n    const total = pairs.reduce((a, p)=>a + p.wi, 0);\n    if (total <= 0) return wMedian(x); // fallback to unweighted\n    let c = 0;\n    for(let i = 0; i < pairs.length; i++){\n        c += pairs[i].wi;\n        if (c >= total / 2) return pairs[i].xi;\n    }\n    return pairs[pairs.length - 1].xi;\n}\n/** Weighted MAD: median of |x - center|, with same weights. */ function wMAD(x, w, center) {\n    if (!x.length) return 0;\n    const c = center ?? wMedian(x, w);\n    const dev = x.map((xi)=>Math.abs(xi - c));\n    return wMedian(dev, w);\n}\nfunction quantile(sorted, p) {\n    if (!sorted.length) return 0;\n    const idx = (sorted.length - 1) * p;\n    const lo = Math.floor(idx);\n    const hi = Math.ceil(idx);\n    if (lo === hi) return sorted[lo];\n    const a = sorted[lo], b = sorted[hi];\n    return a + (b - a) * (idx - lo);\n}\n/**\r\n * vInner_k: per-bin skew of distribution.\r\n * 1) Normalize residuals by robust dispersion (MAD).\r\n * 2) Weighted mean residual -> tanh -> scaled to [-S, S].\r\n */ function vInner(nucleus, opts = {}) {\n    const S = opts.scale ?? 100;\n    const g = opts.gain ?? 1.0;\n    const x = nucleus.values ?? [];\n    const w = nucleus.weights && nucleus.weights.length === x.length ? nucleus.weights : undefined;\n    if (!x.length) return 0;\n    const centerRaw = opts.centerOverride ?? nucleus.center ?? wMedian(x, w);\n    const c = Number.isFinite(centerRaw) ? centerRaw : 0;\n    const sigmaRaw = opts.sigmaOverride ?? wMAD(x, w, c);\n    const sigma = Number.isFinite(sigmaRaw) ? sigmaRaw : 0;\n    const denom = sigma > 0 ? sigma : 1e-9;\n    // weighted mean of standardized residuals\n    let num = 0, den = 0;\n    for(let i = 0; i < x.length; i++){\n        const sampleWeight = w ? Number(w[i]) : 1;\n        const wi = Number.isFinite(sampleWeight) ? Math.max(0, sampleWeight) : 0;\n        if (!wi) continue;\n        const residual = (x[i] - c) / denom;\n        if (!Number.isFinite(residual)) continue;\n        num += wi * residual;\n        den += wi;\n    }\n    if (!(den > 0)) return 0;\n    const rbar = num / den;\n    if (!Number.isFinite(rbar)) return 0;\n    return clamp(S * tanh(g * rbar), -S, S);\n}\n/**\r\n * vOuter: liquidity-weighted aggregation across bins.\r\n * If weights sum to 1 (shares), set normalize=false to respect them.\r\n */ function vOuter(nuclei, weights, opts = {}) {\n    const S = opts.scale ?? 100;\n    const g = opts.gain ?? 1.0;\n    const inners = nuclei.map((nu)=>vInner(nu, {\n            ...opts.inner,\n            scale: S\n        }));\n    const gammas = weights?.map((w)=>Number.isFinite(w?.gamma) ? w.gamma : 1) ?? Array(nuclei.length).fill(1);\n    if (!inners.length) return 0;\n    const sumG = sum(gammas);\n    const denom = opts.normalize === false ? 1 : sumG || inners.length;\n    let agg = 0;\n    for(let i = 0; i < inners.length; i++)agg += gammas[i] * (inners[i] / S);\n    const unitless = denom ? agg / denom : 0; // ~[-1..1]\n    return clamp(S * tanh(g * unitless), -S, S);\n}\n/* ---- optional scaled convenience (maps sign-preserving to ~[-1..1]) ---- */ function vInnerScaled(nucleus, opts = {}) {\n    const S = opts.scale ?? 100;\n    const v = vInner(nucleus, opts);\n    return clamp(v / S, -1, 1);\n}\nfunction vOuterScaled(nuclei, weights, opts = {}) {\n    const S = opts.scale ?? 100;\n    const v = vOuter(nuclei, weights, opts);\n    return clamp(v / S, -1, 1);\n}\n/**\r\n * vTendency over a stable series (typically vOuter_t).\r\n * Regress over last W points; normalize slope by MAD|y|.\r\n * Returns direction/strength/score in your envelope.\r\n */ function vTendencyFromSeries(series, opts = {}) {\n    const W = Math.max(3, Math.floor(opts.window ?? 30));\n    const S = opts.scale ?? 100;\n    const k = opts.k ?? 1.1;\n    const norm = opts.normalizer ?? \"mad\";\n    if (!series?.length || series.length < 2) {\n        return {\n            direction: 0,\n            strength: 0,\n            slope: 0,\n            r: 0,\n            score: 0\n        };\n    }\n    const start = Math.max(0, series.length - W);\n    const y = series.slice(start); // length m\n    // linreg on index 0..m-1\n    const m = y.length;\n    let sx = 0, sy = 0, sxx = 0, sxy = 0, syy = 0;\n    for(let i = 0; i < m; i++){\n        const xi = i, yi = y[i];\n        sx += xi;\n        sy += yi;\n        sxx += xi * xi;\n        sxy += xi * yi;\n        syy += yi * yi;\n    }\n    const num = m * sxy - sx * sy;\n    const den = m * sxx - sx * sx;\n    const slope = den === 0 ? 0 : num / den;\n    const rden = Math.sqrt((m * sxx - sx * sx) * (m * syy - sy * sy));\n    const r = rden === 0 ? 0 : num / rden;\n    // dispersion of first differences\n    const diffs = [];\n    for(let i = 1; i < y.length; i++)diffs.push(y[i] - y[i - 1]);\n    let D = 0;\n    if (norm === \"mad\") {\n        const med = wMedian(diffs);\n        const absdev = diffs.map((d)=>Math.abs(d - med));\n        D = wMedian(absdev);\n    } else {\n        const mu = mean(diffs);\n        const varsum = diffs.reduce((a, d)=>a + (d - mu) * (d - mu), 0);\n        D = diffs.length > 1 ? Math.sqrt(varsum / (diffs.length - 1)) : 0;\n    }\n    const z = D > 0 ? slope / D : 0;\n    const direction = tanh(k * z); // [-1..1]\n    const strength = Math.min(1, Math.max(0, Math.abs(r)));\n    const score = clamp(direction * S, -S, S);\n    return {\n        direction,\n        strength,\n        slope,\n        r,\n        score\n    };\n}\n/* --------------------------------- vSwap ---------------------------------- */ /**\r\n * vSwap (quartile-conditioned, non-parametric):\r\n * Compare average inner in top vs bottom quartile of tendency over a window.\r\n *\r\n * Inputs:\r\n *  - innerHistScaled: history of aggregate inner (scaled in [-S,S]) for last H ticks\r\n *  - tendencyHistScaled: matching history of vTendency (scaled in [-S,S]) for last H ticks\r\n *  - scale S and softness alpha for final tanh\r\n *\r\n * Steps:\r\n *  1) Convert both to unitless [-1..1] by dividing by S.\r\n *  2) Find Q1/Q3 of tendency; compute mean(inner) where T<=Q1 and where T>=Q3.\r\n *  3) Q = (mean_top - mean_bottom)/2 in [-1,1].\r\n *  4) vSwap = S * tanh(alpha * Q).\r\n */ function vSwapQuartiles(innerHistScaled, tendencyHistScaled, opts = {}) {\n    const S = opts.scale ?? 100;\n    const alpha = opts.alpha ?? 1.2;\n    const n = Math.min(innerHistScaled.length, tendencyHistScaled.length);\n    if (n < 2) {\n        const last = innerHistScaled[innerHistScaled.length - 1] ?? 0;\n        const first = innerHistScaled[0] ?? last;\n        const unitless = S ? (last - first) / (2 * S) : (last - first) / 2;\n        const Q = clamp(unitless, -1, 1);\n        const score = clamp(S * tanh(alpha * Q), -S, S);\n        const tail = tendencyHistScaled[tendencyHistScaled.length - 1] ?? 0;\n        return {\n            Q,\n            score,\n            q1: tail,\n            q3: tail\n        };\n    }\n    // unitless series in [-1..1]\n    const I = innerHistScaled.slice(-n).map((v)=>S ? v / S : v);\n    const T = tendencyHistScaled.slice(-n).map((v)=>S ? v / S : v);\n    // compute Q1, Q3 of T\n    const sortedT = T.slice().sort((a, b)=>a - b);\n    const q1 = quantile(sortedT, 0.25);\n    const q3 = quantile(sortedT, 0.75);\n    // means in tails\n    const bot = [];\n    const top = [];\n    for(let i = 0; i < n; i++){\n        if (T[i] <= q1) bot.push(I[i]);\n        else if (T[i] >= q3) top.push(I[i]);\n    }\n    const meanTop = top.length ? mean(top) : 0;\n    const meanBot = bot.length ? mean(bot) : 0;\n    const Q = clamp((meanTop - meanBot) / 2, -1, 1); // [-1,1]\n    const score = clamp(S * tanh(alpha * Q), -S, S);\n    return {\n        Q,\n        score,\n        q1,\n        q3\n    };\n}\n/**\r\n * vSwapFromNuclei (optional side-of-mass view):\r\n * Compare total mass right-vs-left of center across nuclei (bins).\r\n * Returns score in [-S, S].\r\n */ function vSwapFromNuclei(nuclei, bins, opts = {}) {\n    const S = opts.scale ?? 100;\n    const alpha = opts.alpha ?? 1.0;\n    if (!nuclei?.length || bins <= 0) return 0;\n    const mid = (bins - 1) / 2;\n    let left = 0, right = 0;\n    for(let b = 0; b < nuclei.length; b++){\n        const nu = nuclei[b];\n        const w = nu.weights && nu.weights.length === nu.values.length ? nu.weights : undefined;\n        // treat each sample in this nucleus as unit mass (or weighted)\n        for(let i = 0; i < nu.values.length; i++){\n            // map index within the nucleus to its global bin index b\n            // if you keep per-sample bin index, adapt as needed; for now use bin b\n            const wi = w ? Math.max(0, w[i] || 0) : 1;\n            if (b < mid) left += wi;\n            else if (b > mid) right += wi;\n            else {\n                left += wi / 2;\n                right += wi / 2;\n            }\n        }\n    }\n    const s = Math.abs(left) + Math.abs(right);\n    if (!s) return 0;\n    const unitless = (right - left) / s; // [-1,1]\n    return clamp(S * tanh(alpha * unitless), -S, S);\n}\n/* --------------------------- Aggregate inner now -------------------------- */ /**\r\n * Helper to get the aggregate inner (unitless & scaled) at a single tick,\r\n * from the current nuclei & optional bin shares.\r\n */ function aggregateInnerNow(nuclei, weights, innerOpts, scale = 100) {\n    const S = scale;\n    const inners = nuclei.map((nu)=>vInner(nu, {\n            ...innerOpts,\n            scale: S\n        }));\n    const gammas = weights?.map((w)=>Number.isFinite(w?.gamma) ? w.gamma : 1) ?? Array(nuclei.length).fill(1);\n    const sumG = sum(gammas) || inners.length || 1;\n    const u = inners.reduce((a, v, i)=>a + gammas[i] * (v / S), 0) / sumG;\n    return {\n        unitless: u,\n        scaled: clamp(S * u, -S, S)\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L2NhbGMvdGVuZGVuY3kudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxjQUFjO0FBQ2QsK0VBQStFO0FBQy9FLHNGQUFzRjtBQUV0Riw4RUFBOEUsR0FrQjlFLE1BQU1BLFFBQVEsQ0FBQ0MsR0FBV0MsSUFBWUMsS0FBZUMsS0FBS0MsR0FBRyxDQUFDSCxJQUFJRSxLQUFLRSxHQUFHLENBQUNILElBQUlGO0FBRS9FLE1BQU1NLE9BQU8sQ0FBQ047SUFDWixJQUFJLENBQUNPLE9BQU9DLFFBQVEsQ0FBQ1IsSUFBSSxPQUFPRyxLQUFLTSxJQUFJLENBQUNULE1BQU07SUFDaEQsSUFBSSxPQUFPRyxLQUFLRyxJQUFJLEtBQUssWUFBWSxPQUFPSCxLQUFLRyxJQUFJLENBQUNOO0lBQ3RELE1BQU1VLElBQUlQLEtBQUtRLEdBQUcsQ0FBQyxJQUFJWDtJQUN2QixPQUFPLENBQUNVLElBQUksS0FBTUEsQ0FBQUEsSUFBSTtBQUN4QjtBQUVBLE1BQU1FLE1BQU8sQ0FBQ0MsS0FBaUJBLEdBQUdDLE1BQU0sQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxJQUFJQyxHQUFHO0FBQzFELE1BQU1DLE9BQU8sQ0FBQ0osS0FBa0JBLEdBQUdLLE1BQU0sR0FBR04sSUFBSUMsTUFBTUEsR0FBR0ssTUFBTSxHQUFHO0FBRWxFLFNBQVNDLE9BQVVDLEdBQVEsRUFBRUMsR0FBcUI7SUFDaEQsT0FBT0QsSUFBSUUsS0FBSyxHQUFHQyxJQUFJLENBQUMsQ0FBQ1IsR0FBR0MsSUFBTUssSUFBSU4sS0FBS00sSUFBSUw7QUFDakQ7QUFFQSw4RkFBOEYsR0FDOUYsU0FBU1EsUUFBUXhCLENBQVcsRUFBRXlCLENBQVk7SUFDeEMsTUFBTUMsSUFBSTFCLEVBQUVrQixNQUFNO0lBQ2xCLElBQUksQ0FBQ1EsR0FBRyxPQUFPO0lBQ2YsSUFBSSxDQUFDRCxLQUFLQSxFQUFFUCxNQUFNLEtBQUtRLEdBQUc7UUFDeEIsTUFBTWIsS0FBS2Is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Q2RyRSxNQUFpQixFQUNqQmQsT0FBMEIsRUFDMUJvRixTQUFzQixFQUN0QnhGLFFBQWdCLEdBQUc7SUFFbkIsTUFBTUQsSUFBWUM7SUFDbEIsTUFBTW1CLFNBQVNELE9BQU9yQyxHQUFHLENBQUMsQ0FBQ3VDLEtBQU94QixPQUFPd0IsSUFBSTtZQUFFLEdBQUdvRSxTQUFTO1lBQUV4RixPQUFPRDtRQUFFO0lBQ3RFLE1BQU11QixTQUFTbEIsU0FBU3ZCLElBQUksQ0FBQ0wsSUFBT2xCLE9BQU9DLFFBQVEsQ0FBQ2lCLEdBQUcrQyxTQUFvQi9DLEVBQUcrQyxLQUFLLEdBQWMsTUFDNUZDLE1BQU1OLE9BQU9qRCxNQUFNLEVBQUV3RCxJQUFJLENBQUM7SUFDL0IsTUFBTUMsT0FBTy9ELElBQUkyRCxXQUFXSCxPQUFPbEQsTUFBTSxJQUFJO0lBQzdDLE1BQU13SCxJQUFJdEUsT0FBT3RELE1BQU0sQ0FBQyxDQUFDQyxHQUFHaUUsR0FBR2hELElBQU1qQixJQUFLd0QsTUFBTSxDQUFDdkMsRUFBRSxHQUFJZ0QsQ0FBQUEsSUFBSWhDLENBQUFBLEdBQUssS0FBSzJCO0lBQ3JFLE9BQU87UUFBRUcsVUFBVTREO1FBQUdDLFFBQVE1SSxNQUFNaUQsSUFBSTBGLEdBQUcsQ0FBQzFGLEdBQUdBO0lBQUc7QUFDcEQiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxjb3JlXFxmZWF0dXJlc1xcc3RyLWF1eFxcY2FsY1xcdGVuZGVuY3kudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdGVuZGVuY3kudHNcclxuLy8gSURIUi9iaW5uaW5nIHRlbmRlbmN5IHZlY3RvcnM6IHZJbm5lciwgdk91dGVyLCB2VGVuZGVuY3ksIHZTd2FwIChxdWFydGlsZXMpLlxyXG4vLyBTY2FsZSBjb252ZW50aW9uOiBkZWZhdWx0IFMgPSAxMDA7IGFsbCBwdWJsaWMgc2NvcmVzIGluIFstUywgK1NdLiBObyBleHRlcm5hbCBkZXBzLlxyXG5cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gVHlwZXMgJiBIZWxwZXJzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbmV4cG9ydCB0eXBlIFNjYWxlID0gbnVtYmVyOyAvLyBhY2NlcHQgYW55IG51bWVyaWMgc2NhbGU7IGRlZmF1bHQgMTAwXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE51Y2xldXMge1xyXG4gIC8vIEJpbiBzYW1wbGVzIChlLmcuLCBub3JtYWxpemVkIHByaWNlIG9mZnNldHMpLlxyXG4gIHZhbHVlczogbnVtYmVyW107XHJcbiAgLy8gT3B0aW9uYWwgcGVyLXNhbXBsZSB3ZWlnaHRzIChsaXF1aWRpdHkvdm9sdW1lL3RpbWUpLiBNdXN0IG1hdGNoIHZhbHVlcy5sZW5ndGggaWYgcHJvdmlkZWQuXHJcbiAgd2VpZ2h0cz86IG51bWJlcltdO1xyXG4gIC8vIE9wdGlvbmFsIHByZWNvbXB1dGVkIGNlbnRlciBvZiB0aGUgYmluIChlbHNlIGNvbXB1dGVkIGFzIHdlaWdodGVkIG1lZGlhbikuXHJcbiAgY2VudGVyPzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENvbXBvc2VXZWlnaHRzIHtcclxuICAvLyBCaW4tbGV2ZWwgd2VpZ2h0IChlLmcuLCBsaXF1aWRpdHkgc2hhcmUpLiBJZiBub3QgcHJvdmlkZWQsIHRyZWF0ZWQgYXMgMS5cclxuICBnYW1tYT86IG51bWJlcjtcclxufVxyXG5cclxuY29uc3QgY2xhbXAgPSAoeDogbnVtYmVyLCBsbzogbnVtYmVyLCBoaTogbnVtYmVyKSA9PiBNYXRoLm1heChsbywgTWF0aC5taW4oaGksIHgpKTtcclxuXHJcbmNvbnN0IHRhbmggPSAoeDogbnVtYmVyKSA9PiB7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKHgpKSByZXR1cm4gTWF0aC5zaWduKHgpIHx8IDA7XG4gIGlmICh0eXBlb2YgTWF0aC50YW5oID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBNYXRoLnRhbmgoeCk7XG4gIGNvbnN0IGUgPSBNYXRoLmV4cCgyICogeCk7XG4gIHJldHVybiAoZSAtIDEpIC8gKGUgKyAxKTtcbn07XG5cclxuY29uc3Qgc3VtICA9ICh4czogbnVtYmVyW10pID0+IHhzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xyXG5jb25zdCBtZWFuID0gKHhzOiBudW1iZXJbXSkgPT4gKHhzLmxlbmd0aCA/IHN1bSh4cykgLyB4cy5sZW5ndGggOiAwKTtcclxuXHJcbmZ1bmN0aW9uIHNvcnRCeTxUPihhcnI6IFRbXSwga2V5OiAodDogVCkgPT4gbnVtYmVyKTogVFtdIHtcclxuICByZXR1cm4gYXJyLnNsaWNlKCkuc29ydCgoYSwgYikgPT4ga2V5KGEpIC0ga2V5KGIpKTtcclxufVxyXG5cclxuLyoqIFdlaWdodGVkIG1lZGlhbiBvZiB4IHdpdGggd2VpZ2h0cyB3IChwb3NpdGl2ZSkuIEZhbGxzIGJhY2sgdG8gcGxhaW4gbWVkaWFuIGlmIG5vIHdlaWdodHMuICovXHJcbmZ1bmN0aW9uIHdNZWRpYW4oeDogbnVtYmVyW10sIHc/OiBudW1iZXJbXSk6IG51bWJlciB7XHJcbiAgY29uc3QgbiA9IHgubGVuZ3RoO1xyXG4gIGlmICghbikgcmV0dXJuIDA7XHJcbiAgaWYgKCF3IHx8IHcubGVuZ3RoICE9PSBuKSB7XHJcbiAgICBjb25zdCB4cyA9IHguc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcbiAgICBjb25zdCBtID0gTWF0aC5mbG9vcihuIC8gMik7XHJcbiAgICByZXR1cm4gbiAlIDIgPyB4c1ttXSA6ICh4c1ttIC0gMV0gKyB4c1ttXSkgLyAyO1xyXG4gIH1cclxuICBjb25zdCBwYWlycyA9IHNvcnRCeShcclxuICAgIHgubWFwKCh4aSwgaSkgPT4gKHsgeGksIHdpOiBNYXRoLm1heCgwLCBOdW1iZXIuaXNGaW5pdGUod1tpXSEpID8gd1tpXSEgOiAwKSB9KSksXHJcbiAgICAocCkgPT4gcC54aVxyXG4gICk7XHJcbiAgY29uc3QgdG90YWwgPSBwYWlycy5yZWR1Y2UoKGEsIHApID0+IGEgKyBwLndpLCAwKTtcclxuICBpZiAodG90YWwgPD0gMCkgcmV0dXJuIHdNZWRpYW4oeCk7IC8vIGZhbGxiYWNrIHRvIHVud2VpZ2h0ZWRcclxuICBsZXQgYyA9IDA7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgYyArPSBwYWlyc1tpXS53aTtcclxuICAgIGlmIChjID49IHRvdGFsIC8gMikgcmV0dXJuIHBhaXJzW2ldLnhpO1xyXG4gIH1cclxuICByZXR1cm4gcGFpcnNbcGFpcnMubGVuZ3RoIC0gMV0ueGk7XHJcbn1cclxuXHJcbi8qKiBXZWlnaHRlZCBNQUQ6IG1lZGlhbiBvZiB8eCAtIGNlbnRlcnwsIHdpdGggc2FtZSB3ZWlnaHRzLiAqL1xyXG5mdW5jdGlvbiB3TUFEKHg6IG51bWJlcltdLCB3PzogbnVtYmVyW10sIGNlbnRlcj86IG51bWJlcik6IG51bWJlciB7XHJcbiAgaWYgKCF4Lmxlbmd0aCkgcmV0dXJuIDA7XHJcbiAgY29uc3QgYyA9IGNlbnRlciA/PyB3TWVkaWFuKHgsIHcpO1xyXG4gIGNvbnN0IGRldiA9IHgubWFwKCh4aSkgPT4gTWF0aC5hYnMoeGkgLSBjKSk7XHJcbiAgcmV0dXJuIHdNZWRpYW4oZGV2LCB3KTtcclxufVxyXG5cclxuZnVuY3Rpb24gcXVhbnRpbGUoc29ydGVkOiBudW1iZXJbXSwgcDogbnVtYmVyKTogbnVtYmVyIHtcclxuICBpZiAoIXNvcnRlZC5sZW5ndGgpIHJldHVybiAwO1xyXG4gIGNvbnN0IGlkeCA9IChzb3J0ZWQubGVuZ3RoIC0gMSkgKiBwO1xyXG4gIGNvbnN0IGxvID0gTWF0aC5mbG9vcihpZHgpO1xyXG4gIGNvbnN0IGhpID0gTWF0aC5jZWlsKGlkeCk7XHJcbiAgaWYgKGxvID09PSBoaSkgcmV0dXJuIHNvcnRlZFtsb107XHJcbiAgY29uc3QgYSA9IHNvcnRlZFtsb10sIGIgPSBzb3J0ZWRbaGldO1xyXG4gIHJldHVybiBhICsgKGIgLSBhKSAqIChpZHggLSBsbyk7XHJcbn1cclxuXHJcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHZJbm5lciAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFZJbm5lck9wdHMge1xyXG4gIC8vIEdhaW4gYmVmb3JlIHRhbmggKHNlbnNpdGl2aXR5KS5cclxuICBnYWluPzogbnVtYmVyOyAvLyBkZWZhdWx0IDEuMFxyXG4gIC8vIE91dHB1dCBzY2FsZSBlbnZlbG9wZS5cclxuICBzY2FsZT86IG51bWJlcjsgLy8gZGVmYXVsdCAxMDBcclxuICAvLyBJZiBwcm92aWRlZCwgdXNlIHRoaXMgZGlzcGVyc2lvbiBpbnN0ZWFkIG9mIE1BRC5cclxuICBzaWdtYU92ZXJyaWRlPzogbnVtYmVyO1xyXG4gIC8vIElmIHByb3ZpZGVkLCB1c2UgdGhpcyBjZW50ZXIgaW5zdGVhZCBvZiB3ZWlnaHRlZCBtZWRpYW4uXHJcbiAgY2VudGVyT3ZlcnJpZGU/OiBudW1iZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiB2SW5uZXJfazogcGVyLWJpbiBza2V3IG9mIGRpc3RyaWJ1dGlvbi5cclxuICogMSkgTm9ybWFsaXplIHJlc2lkdWFscyBieSByb2J1c3QgZGlzcGVyc2lvbiAoTUFEKS5cclxuICogMikgV2VpZ2h0ZWQgbWVhbiByZXNpZHVhbCAtPiB0YW5oIC0+IHNjYWxlZCB0byBbLVMsIFNdLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZJbm5lcihudWNsZXVzOiBOdWNsZXVzLCBvcHRzOiBWSW5uZXJPcHRzID0ge30pOiBudW1iZXIge1xuICBjb25zdCBTOiBudW1iZXIgPSBvcHRzLnNjYWxlID8/IDEwMDtcbiAgY29uc3QgZzogbnVtYmVyID0gb3B0cy5nYWluID8/IDEuMDtcbiAgY29uc3QgeCA9IG51Y2xldXMudmFsdWVzID8/IFtdO1xuICBjb25zdCB3ID0gbnVjbGV1cy53ZWlnaHRzICYmIG51Y2xldXMud2VpZ2h0cy5sZW5ndGggPT09IHgubGVuZ3RoID8gbnVjbGV1cy53ZWlnaHRzIDogdW5kZWZpbmVkO1xuICBpZiAoIXgubGVuZ3RoKSByZXR1cm4gMDtcblxuICBjb25zdCBjZW50ZXJSYXcgPSBvcHRzLmNlbnRlck92ZXJyaWRlID8/IG51Y2xldXMuY2VudGVyID8/IHdNZWRpYW4oeCwgdyk7XG4gIGNvbnN0IGMgPSBOdW1iZXIuaXNGaW5pdGUoY2VudGVyUmF3KSA/IChjZW50ZXJSYXcgYXMgbnVtYmVyKSA6IDA7XG4gIGNvbnN0IHNpZ21hUmF3ID0gb3B0cy5zaWdtYU92ZXJyaWRlID8/IHdNQUQoeCwgdywgYyk7XG4gIGNvbnN0IHNpZ21hID0gTnVtYmVyLmlzRmluaXRlKHNpZ21hUmF3KSA/IChzaWdtYVJhdyBhcyBudW1iZXIpIDogMDtcbiAgY29uc3QgZGVub20gPSBzaWdtYSA+IDAgPyBzaWdtYSA6IDFlLTk7XG5cbiAgLy8gd2VpZ2h0ZWQgbWVhbiBvZiBzdGFuZGFyZGl6ZWQgcmVzaWR1YWxzXG4gIGxldCBudW0gPSAwLCBkZW4gPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzYW1wbGVXZWlnaHQgPSB3ID8gTnVtYmVyKHdbaV0pIDogMTtcbiAgICBjb25zdCB3aSA9IE51bWJlci5pc0Zpbml0ZShzYW1wbGVXZWlnaHQpID8gTWF0aC5tYXgoMCwgc2FtcGxlV2VpZ2h0KSA6IDA7XG4gICAgaWYgKCF3aSkgY29udGludWU7XG4gICAgY29uc3QgcmVzaWR1YWwgPSAoeFtpXSAtIGMpIC8gZGVub207XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocmVzaWR1YWwpKSBjb250aW51ZTtcbiAgICBudW0gKz0gd2kgKiByZXNpZHVhbDtcbiAgICBkZW4gKz0gd2k7XG4gIH1cbiAgaWYgKCEoZGVuID4gMCkpIHJldHVybiAwO1xuICBjb25zdCByYmFyID0gbnVtIC8gZGVuO1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZShyYmFyKSkgcmV0dXJuIDA7XG4gIHJldHVybiBjbGFtcChTICogdGFuaChnICogcmJhciksIC1TLCBTKTtcbn1cblxyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB2T3V0ZXIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBWT3V0ZXJPcHRzIHtcclxuICAvLyBTY2FsZSBlbnZlbG9wZSBmb3Igb3V0cHV0ICjCsSkuXHJcbiAgc2NhbGU/OiBudW1iZXI7IC8vIGRlZmF1bHQgMTAwXHJcbiAgLy8gTm9ubGluZWFyaXR5IGdhaW4gYmVmb3JlIHRhbmguXHJcbiAgZ2Fpbj86IG51bWJlcjsgLy8gZGVmYXVsdCAxLjBcclxuICAvLyBJZiB0cnVlIChkZWZhdWx0KSwgbm9ybWFsaXplIG91dGVyIGJ5IHN1bSBvZiBnYW1tYXMgb3IgTiBpZiBub25lIHByb3ZpZGVkLlxyXG4gIG5vcm1hbGl6ZT86IGJvb2xlYW47IC8vIGRlZmF1bHQgdHJ1ZVxyXG4gIC8vIFJldXNlIHZJbm5lciBvcHRpb25zIGZvciBlYWNoIGJpbiAoZS5nLiwgc2FtZSBnYWluL3NjYWxlKS5cclxuICBpbm5lcj86IFZJbm5lck9wdHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiB2T3V0ZXI6IGxpcXVpZGl0eS13ZWlnaHRlZCBhZ2dyZWdhdGlvbiBhY3Jvc3MgYmlucy5cclxuICogSWYgd2VpZ2h0cyBzdW0gdG8gMSAoc2hhcmVzKSwgc2V0IG5vcm1hbGl6ZT1mYWxzZSB0byByZXNwZWN0IHRoZW0uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdk91dGVyKG51Y2xlaTogTnVjbGV1c1tdLCB3ZWlnaHRzPzogQ29tcG9zZVdlaWdodHNbXSwgb3B0czogVk91dGVyT3B0cyA9IHt9KTogbnVtYmVyIHtcclxuICBjb25zdCBTOiBudW1iZXIgPSBvcHRzLnNjYWxlID8/IDEwMDtcclxuICBjb25zdCBnOiBudW1iZXIgPSBvcHRzLmdhaW4gPz8gMS4wO1xyXG4gIGNvbnN0IGlubmVycyA9IG51Y2xlaS5tYXAoKG51KSA9PiB2SW5uZXIobnUsIHsgLi4ub3B0cy5pbm5lciwgc2NhbGU6IFMgfSkpO1xyXG4gIGNvbnN0IGdhbW1hcyA9IHdlaWdodHM/Lm1hcCgodykgPT4gKE51bWJlci5pc0Zpbml0ZSh3Py5nYW1tYSBhcyBudW1iZXIpID8gKHchLmdhbW1hIGFzIG51bWJlcikgOiAxKSlcclxuICAgID8/IEFycmF5KG51Y2xlaS5sZW5ndGgpLmZpbGwoMSk7XHJcbiAgaWYgKCFpbm5lcnMubGVuZ3RoKSByZXR1cm4gMDtcclxuXHJcbiAgY29uc3Qgc3VtRyA9IHN1bShnYW1tYXMpO1xyXG4gIGNvbnN0IGRlbm9tID0gb3B0cy5ub3JtYWxpemUgPT09IGZhbHNlID8gMSA6IChzdW1HIHx8IGlubmVycy5sZW5ndGgpO1xyXG4gIGxldCBhZ2cgPSAwO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5uZXJzLmxlbmd0aDsgaSsrKSBhZ2cgKz0gZ2FtbWFzW2ldICogKGlubmVyc1tpXSAvIFMpO1xyXG4gIGNvbnN0IHVuaXRsZXNzID0gZGVub20gPyBhZ2cgLyBkZW5vbSA6IDA7IC8vIH5bLTEuLjFdXHJcbiAgcmV0dXJuIGNsYW1wKFMgKiB0YW5oKGcgKiB1bml0bGVzcyksIC1TLCBTKTtcclxufVxyXG5cclxuLyogLS0tLSBvcHRpb25hbCDigJxzY2FsZWTigJ0gY29udmVuaWVuY2UgKG1hcHMgc2lnbi1wcmVzZXJ2aW5nIHRvIH5bLTEuLjFdKSAtLS0tICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdklubmVyU2NhbGVkKG51Y2xldXM6IE51Y2xldXMsIG9wdHM6IFZJbm5lck9wdHMgPSB7fSk6IG51bWJlciB7XHJcbiAgY29uc3QgUyA9IG9wdHMuc2NhbGUgPz8gMTAwO1xyXG4gIGNvbnN0IHYgPSB2SW5uZXIobnVjbGV1cywgb3B0cyk7XHJcbiAgcmV0dXJuIGNsYW1wKHYgLyBTLCAtMSwgMSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHZPdXRlclNjYWxlZChudWNsZWk6IE51Y2xldXNbXSwgd2VpZ2h0cz86IENvbXBvc2VXZWlnaHRzW10sIG9wdHM6IFZPdXRlck9wdHMgPSB7fSk6IG51bWJlciB7XHJcbiAgY29uc3QgUyA9IG9wdHMuc2NhbGUgPz8gMTAwO1xyXG4gIGNvbnN0IHYgPSB2T3V0ZXIobnVjbGVpLCB3ZWlnaHRzLCBvcHRzKTtcclxuICByZXR1cm4gY2xhbXAodiAvIFMsIC0xLCAxKTtcclxufVxyXG5cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB2VGVuZGVuY3kgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVlRlbmRlbmN5T3B0cyB7XHJcbiAgLy8gV2luZG93IGxlbmd0aCBpbiB0aWNrcy9zdGVwcyAoZS5nLiwgMjDigJM2MCkuXHJcbiAgd2luZG93PzogbnVtYmVyOyAvLyBkZWZhdWx0IDMwXHJcbiAgLy8gU2NhbGUgZW52ZWxvcGUgKMKxKS5cclxuICBzY2FsZT86IG51bWJlcjsgLy8gZGVmYXVsdCAxMDBcclxuICAvLyBTbG9wZSBnYWluIGluc2lkZSB0YW5oLlxyXG4gIGs/OiBudW1iZXI7IC8vIGRlZmF1bHQgMS4xXHJcbiAgLy8gTm9ybWFsaXplciBmb3Igc2xvcGUgZGlzcGVyc2lvbiAoTUFEIG9mIGZpcnN0IGRpZmZlcmVuY2VzIG9yIHN0ZGV2KS5cclxuICBub3JtYWxpemVyPzogXCJtYWRcIiB8IFwic3RkZXZcIjsgLy8gZGVmYXVsdCBcIm1hZFwiXHJcbn1cclxuXHJcbi8qKlxyXG4gKiB2VGVuZGVuY3kgb3ZlciBhIHN0YWJsZSBzZXJpZXMgKHR5cGljYWxseSB2T3V0ZXJfdCkuXHJcbiAqIFJlZ3Jlc3Mgb3ZlciBsYXN0IFcgcG9pbnRzOyBub3JtYWxpemUgc2xvcGUgYnkgTUFEfM6UeXwuXHJcbiAqIFJldHVybnMgZGlyZWN0aW9uL3N0cmVuZ3RoL3Njb3JlIGluIHlvdXIgZW52ZWxvcGUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdlRlbmRlbmN5RnJvbVNlcmllcyhcclxuICBzZXJpZXM6IG51bWJlcltdLFxyXG4gIG9wdHM6IFZUZW5kZW5jeU9wdHMgPSB7fVxyXG4pOiB7IGRpcmVjdGlvbjogbnVtYmVyOyBzdHJlbmd0aDogbnVtYmVyOyBzbG9wZTogbnVtYmVyOyByOiBudW1iZXI7IHNjb3JlOiBudW1iZXIgfSB7XHJcbiAgY29uc3QgVzogbnVtYmVyID0gTWF0aC5tYXgoMywgTWF0aC5mbG9vcihvcHRzLndpbmRvdyA/PyAzMCkpO1xyXG4gIGNvbnN0IFM6IG51bWJlciA9IG9wdHMuc2NhbGUgPz8gMTAwO1xyXG4gIGNvbnN0IGs6IG51bWJlciA9IG9wdHMuayA/PyAxLjE7XHJcbiAgY29uc3Qgbm9ybSA9IG9wdHMubm9ybWFsaXplciA/PyBcIm1hZFwiO1xyXG5cclxuICBpZiAoIXNlcmllcz8ubGVuZ3RoIHx8IHNlcmllcy5sZW5ndGggPCAyKSB7XHJcbiAgICByZXR1cm4geyBkaXJlY3Rpb246IDAsIHN0cmVuZ3RoOiAwLCBzbG9wZTogMCwgcjogMCwgc2NvcmU6IDAgfTtcclxuICB9XHJcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBzZXJpZXMubGVuZ3RoIC0gVyk7XHJcbiAgY29uc3QgeSA9IHNlcmllcy5zbGljZShzdGFydCk7IC8vIGxlbmd0aCBtXHJcblxyXG4gIC8vIGxpbnJlZyBvbiBpbmRleCAwLi5tLTFcclxuICBjb25zdCBtID0geS5sZW5ndGg7XHJcbiAgbGV0IHN4ID0gMCwgc3kgPSAwLCBzeHggPSAwLCBzeHkgPSAwLCBzeXkgPSAwO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbTsgaSsrKSB7XHJcbiAgICBjb25zdCB4aSA9IGksIHlpID0geVtpXTtcclxuICAgIHN4ICs9IHhpOyBzeSArPSB5aTsgc3h4ICs9IHhpICogeGk7IHN4eSArPSB4aSAqIHlpOyBzeXkgKz0geWkgKiB5aTtcclxuICB9XHJcbiAgY29uc3QgbnVtID0gbSAqIHN4eSAtIHN4ICogc3k7XHJcbiAgY29uc3QgZGVuID0gbSAqIHN4eCAtIHN4ICogc3g7XHJcbiAgY29uc3Qgc2xvcGUgPSBkZW4gPT09IDAgPyAwIDogbnVtIC8gZGVuO1xyXG4gIGNvbnN0IHJkZW4gPSBNYXRoLnNxcnQoKG0gKiBzeHggLSBzeCAqIHN4KSAqIChtICogc3l5IC0gc3kgKiBzeSkpO1xyXG4gIGNvbnN0IHIgPSByZGVuID09PSAwID8gMCA6IG51bSAvIHJkZW47XHJcblxyXG4gIC8vIGRpc3BlcnNpb24gb2YgZmlyc3QgZGlmZmVyZW5jZXNcclxuICBjb25zdCBkaWZmczogbnVtYmVyW10gPSBbXTtcclxuICBmb3IgKGxldCBpID0gMTsgaSA8IHkubGVuZ3RoOyBpKyspIGRpZmZzLnB1c2goeVtpXSAtIHlbaSAtIDFdKTtcclxuXHJcbiAgbGV0IEQgPSAwO1xyXG4gIGlmIChub3JtID09PSBcIm1hZFwiKSB7XHJcbiAgICBjb25zdCBtZWQgPSB3TWVkaWFuKGRpZmZzKTtcclxuICAgIGNvbnN0IGFic2RldiA9IGRpZmZzLm1hcCgoZCkgPT4gTWF0aC5hYnMoZCAtIG1lZCkpO1xyXG4gICAgRCA9IHdNZWRpYW4oYWJzZGV2KTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgbXUgPSBtZWFuKGRpZmZzKTtcclxuICAgIGNvbnN0IHZhcnN1bSA9IGRpZmZzLnJlZHVjZSgoYSwgZCkgPT4gYSArIChkIC0gbXUpICogKGQgLSBtdSksIDApO1xyXG4gICAgRCA9IGRpZmZzLmxlbmd0aCA+IDEgPyBNYXRoLnNxcnQodmFyc3VtIC8gKGRpZmZzLmxlbmd0aCAtIDEpKSA6IDA7XHJcbiAgfVxyXG4gIGNvbnN0IHogPSBEID4gMCA/IHNsb3BlIC8gRCA6IDA7XHJcblxyXG4gIGNvbnN0IGRpcmVjdGlvbiA9IHRhbmgoayAqIHopOyAvLyBbLTEuLjFdXHJcbiAgY29uc3Qgc3RyZW5ndGggPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBNYXRoLmFicyhyKSkpO1xyXG4gIGNvbnN0IHNjb3JlID0gY2xhbXAoZGlyZWN0aW9uICogUywgLVMsIFMpO1xyXG4gIHJldHVybiB7IGRpcmVjdGlvbiwgc3RyZW5ndGgsIHNsb3BlLCByLCBzY29yZSB9O1xyXG59XHJcblxyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gdlN3YXAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4vKipcclxuICogdlN3YXAgKHF1YXJ0aWxlLWNvbmRpdGlvbmVkLCBub24tcGFyYW1ldHJpYyk6XHJcbiAqIENvbXBhcmUgYXZlcmFnZSBpbm5lciBpbiB0b3AgdnMgYm90dG9tIHF1YXJ0aWxlIG9mIHRlbmRlbmN5IG92ZXIgYSB3aW5kb3cuXHJcbiAqXHJcbiAqIElucHV0czpcclxuICogIC0gaW5uZXJIaXN0U2NhbGVkOiBoaXN0b3J5IG9mIGFnZ3JlZ2F0ZSBpbm5lciAoc2NhbGVkIGluIFstUyxTXSkgZm9yIGxhc3QgSCB0aWNrc1xyXG4gKiAgLSB0ZW5kZW5jeUhpc3RTY2FsZWQ6IG1hdGNoaW5nIGhpc3Rvcnkgb2YgdlRlbmRlbmN5IChzY2FsZWQgaW4gWy1TLFNdKSBmb3IgbGFzdCBIIHRpY2tzXHJcbiAqICAtIHNjYWxlIFMgYW5kIHNvZnRuZXNzIGFscGhhIGZvciBmaW5hbCB0YW5oXHJcbiAqXHJcbiAqIFN0ZXBzOlxyXG4gKiAgMSkgQ29udmVydCBib3RoIHRvIHVuaXRsZXNzIFstMS4uMV0gYnkgZGl2aWRpbmcgYnkgUy5cclxuICogIDIpIEZpbmQgUTEvUTMgb2YgdGVuZGVuY3k7IGNvbXB1dGUgbWVhbihpbm5lcikgd2hlcmUgVDw9UTEgYW5kIHdoZXJlIFQ+PVEzLlxyXG4gKiAgMykgUSA9IChtZWFuX3RvcCAtIG1lYW5fYm90dG9tKS8yIGluIFstMSwxXS5cclxuICogIDQpIHZTd2FwID0gUyAqIHRhbmgoYWxwaGEgKiBRKS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB2U3dhcFF1YXJ0aWxlcyhcbiAgaW5uZXJIaXN0U2NhbGVkOiBudW1iZXJbXSxcbiAgdGVuZGVuY3lIaXN0U2NhbGVkOiBudW1iZXJbXSxcbiAgb3B0czogeyBzY2FsZT86IG51bWJlcjsgYWxwaGE/OiBudW1iZXIgfSA9IHt9XG4pOiB7IFE6IG51bWJlcjsgc2NvcmU6IG51bWJlcjsgcTE6IG51bWJlcjsgcTM6IG51bWJlciB9IHtcbiAgY29uc3QgUzogbnVtYmVyID0gb3B0cy5zY2FsZSA/PyAxMDA7XG4gIGNvbnN0IGFscGhhOiBudW1iZXIgPSBvcHRzLmFscGhhID8/IDEuMjtcblxuICBjb25zdCBuID0gTWF0aC5taW4oaW5uZXJIaXN0U2NhbGVkLmxlbmd0aCwgdGVuZGVuY3lIaXN0U2NhbGVkLmxlbmd0aCk7XG4gIGlmIChuIDwgMikge1xuICAgIGNvbnN0IGxhc3QgPSBpbm5lckhpc3RTY2FsZWRbaW5uZXJIaXN0U2NhbGVkLmxlbmd0aCAtIDFdID8/IDA7XG4gICAgY29uc3QgZmlyc3QgPSBpbm5lckhpc3RTY2FsZWRbMF0gPz8gbGFzdDtcbiAgICBjb25zdCB1bml0bGVzcyA9IFMgPyAobGFzdCAtIGZpcnN0KSAvICgyICogUykgOiAobGFzdCAtIGZpcnN0KSAvIDI7XG4gICAgY29uc3QgUSA9IGNsYW1wKHVuaXRsZXNzLCAtMSwgMSk7XG4gICAgY29uc3Qgc2NvcmUgPSBjbGFtcChTICogdGFuaChhbHBoYSAqIFEpLCAtUywgUyk7XG4gICAgY29uc3QgdGFpbCA9IHRlbmRlbmN5SGlzdFNjYWxlZFt0ZW5kZW5jeUhpc3RTY2FsZWQubGVuZ3RoIC0gMV0gPz8gMDtcbiAgICByZXR1cm4geyBRLCBzY29yZSwgcTE6IHRhaWwsIHEzOiB0YWlsIH07XG4gIH1cblxuICAvLyB1bml0bGVzcyBzZXJpZXMgaW4gWy0xLi4xXVxuICBjb25zdCBJID0gaW5uZXJIaXN0U2NhbGVkLnNsaWNlKC1uKS5tYXAoKHYpID0+IChTID8gdiAvIFMgOiB2KSk7XG4gIGNvbnN0IFQgPSB0ZW5kZW5jeUhpc3RTY2FsZWQuc2xpY2UoLW4pLm1hcCgodikgPT4gKFMgPyB2IC8gUyA6IHYpKTtcblxyXG4gIC8vIGNvbXB1dGUgUTEsIFEzIG9mIFRcclxuICBjb25zdCBzb3J0ZWRUID0gVC5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcclxuICBjb25zdCBxMSA9IHF1YW50aWxlKHNvcnRlZFQsIDAuMjUpO1xyXG4gIGNvbnN0IHEzID0gcXVhbnRpbGUoc29ydGVkVCwgMC43NSk7XHJcblxyXG4gIC8vIG1lYW5zIGluIHRhaWxzXHJcbiAgY29uc3QgYm90OiBudW1iZXJbXSA9IFtdO1xyXG4gIGNvbnN0IHRvcDogbnVtYmVyW10gPSBbXTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgaWYgKFRbaV0gPD0gcTEpIGJvdC5wdXNoKElbaV0pO1xyXG4gICAgZWxzZSBpZiAoVFtpXSA+PSBxMykgdG9wLnB1c2goSVtpXSk7XHJcbiAgfVxyXG4gIGNvbnN0IG1lYW5Ub3AgPSB0b3AubGVuZ3RoID8gbWVhbih0b3ApIDogMDtcclxuICBjb25zdCBtZWFuQm90ID0gYm90Lmxlbmd0aCA/IG1lYW4oYm90KSA6IDA7XHJcblxyXG4gIGNvbnN0IFEgPSBjbGFtcCgobWVhblRvcCAtIG1lYW5Cb3QpIC8gMiwgLTEsIDEpOyAvLyBbLTEsMV1cclxuICBjb25zdCBzY29yZSA9IGNsYW1wKFMgKiB0YW5oKGFscGhhICogUSksIC1TLCBTKTtcclxuICByZXR1cm4geyBRLCBzY29yZSwgcTEsIHEzIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiB2U3dhcEZyb21OdWNsZWkgKG9wdGlvbmFsIHNpZGUtb2YtbWFzcyB2aWV3KTpcclxuICogQ29tcGFyZSB0b3RhbCBtYXNzIHJpZ2h0LXZzLWxlZnQgb2YgY2VudGVyIGFjcm9zcyBudWNsZWkgKGJpbnMpLlxyXG4gKiBSZXR1cm5zIHNjb3JlIGluIFstUywgU10uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdlN3YXBGcm9tTnVjbGVpKFxyXG4gIG51Y2xlaTogTnVjbGV1c1tdLFxyXG4gIGJpbnM6IG51bWJlcixcclxuICBvcHRzOiB7IHNjYWxlPzogbnVtYmVyOyBhbHBoYT86IG51bWJlciB9ID0ge31cclxuKTogbnVtYmVyIHtcclxuICBjb25zdCBTOiBudW1iZXIgPSBvcHRzLnNjYWxlID8/IDEwMDtcclxuICBjb25zdCBhbHBoYTogbnVtYmVyID0gb3B0cy5hbHBoYSA/PyAxLjA7XHJcbiAgaWYgKCFudWNsZWk/Lmxlbmd0aCB8fCBiaW5zIDw9IDApIHJldHVybiAwO1xyXG5cclxuICBjb25zdCBtaWQgPSAoYmlucyAtIDEpIC8gMjtcclxuICBsZXQgbGVmdCA9IDAsIHJpZ2h0ID0gMDtcclxuXHJcbiAgZm9yIChsZXQgYiA9IDA7IGIgPCBudWNsZWkubGVuZ3RoOyBiKyspIHtcclxuICAgIGNvbnN0IG51ID0gbnVjbGVpW2JdO1xyXG4gICAgY29uc3QgdyA9IG51LndlaWdodHMgJiYgbnUud2VpZ2h0cy5sZW5ndGggPT09IG51LnZhbHVlcy5sZW5ndGggPyBudS53ZWlnaHRzIDogdW5kZWZpbmVkO1xyXG4gICAgLy8gdHJlYXQgZWFjaCBzYW1wbGUgaW4gdGhpcyBudWNsZXVzIGFzIHVuaXQgbWFzcyAob3Igd2VpZ2h0ZWQpXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51LnZhbHVlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAvLyBtYXAgaW5kZXggd2l0aGluIHRoZSBudWNsZXVzIHRvIGl0cyBnbG9iYWwgYmluIGluZGV4IGJcclxuICAgICAgLy8gaWYgeW91IGtlZXAgcGVyLXNhbXBsZSBiaW4gaW5kZXgsIGFkYXB0IGFzIG5lZWRlZDsgZm9yIG5vdyB1c2UgYmluIGJcclxuICAgICAgY29uc3Qgd2kgPSB3ID8gTWF0aC5tYXgoMCwgd1tpXSB8fCAwKSA6IDE7XHJcbiAgICAgIGlmIChiIDwgbWlkKSBsZWZ0ICs9IHdpO1xyXG4gICAgICBlbHNlIGlmIChiID4gbWlkKSByaWdodCArPSB3aTtcclxuICAgICAgZWxzZSB7IGxlZnQgKz0gd2kgLyAyOyByaWdodCArPSB3aSAvIDI7IH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IHMgPSBNYXRoLmFicyhsZWZ0KSArIE1hdGguYWJzKHJpZ2h0KTtcclxuICBpZiAoIXMpIHJldHVybiAwO1xyXG5cclxuICBjb25zdCB1bml0bGVzcyA9IChyaWdodCAtIGxlZnQpIC8gczsgLy8gWy0xLDFdXHJcbiAgcmV0dXJuIGNsYW1wKFMgKiB0YW5oKGFscGhhICogdW5pdGxlc3MpLCAtUywgUyk7XHJcbn1cclxuXHJcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBBZ2dyZWdhdGUgaW5uZXIgbm93IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBhZ2dyZWdhdGUgaW5uZXIgKHVuaXRsZXNzICYgc2NhbGVkKSBhdCBhIHNpbmdsZSB0aWNrLFxyXG4gKiBmcm9tIHRoZSBjdXJyZW50IG51Y2xlaSAmIG9wdGlvbmFsIGJpbiBzaGFyZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWdncmVnYXRlSW5uZXJOb3coXHJcbiAgbnVjbGVpOiBOdWNsZXVzW10sXHJcbiAgd2VpZ2h0cz86IENvbXBvc2VXZWlnaHRzW10sXHJcbiAgaW5uZXJPcHRzPzogVklubmVyT3B0cyxcclxuICBzY2FsZTogbnVtYmVyID0gMTAwXHJcbik6IHsgdW5pdGxlc3M6IG51bWJlcjsgc2NhbGVkOiBudW1iZXIgfSB7XHJcbiAgY29uc3QgUzogbnVtYmVyID0gc2NhbGU7XHJcbiAgY29uc3QgaW5uZXJzID0gbnVjbGVpLm1hcCgobnUpID0+IHZJbm5lcihudSwgeyAuLi5pbm5lck9wdHMsIHNjYWxlOiBTIH0pKTtcclxuICBjb25zdCBnYW1tYXMgPSB3ZWlnaHRzPy5tYXAoKHcpID0+IChOdW1iZXIuaXNGaW5pdGUodz8uZ2FtbWEgYXMgbnVtYmVyKSA/ICh3IS5nYW1tYSBhcyBudW1iZXIpIDogMSkpXHJcbiAgICA/PyBBcnJheShudWNsZWkubGVuZ3RoKS5maWxsKDEpO1xyXG4gIGNvbnN0IHN1bUcgPSBzdW0oZ2FtbWFzKSB8fCBpbm5lcnMubGVuZ3RoIHx8IDE7XHJcbiAgY29uc3QgdSA9IGlubmVycy5yZWR1Y2UoKGEsIHYsIGkpID0+IGEgKyAoZ2FtbWFzW2ldICogKHYgLyBTKSksIDApIC8gc3VtRztcclxuICByZXR1cm4geyB1bml0bGVzczogdSwgc2NhbGVkOiBjbGFtcChTICogdSwgLVMsIFMpIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbImNsYW1wIiwieCIsImxvIiwiaGkiLCJNYXRoIiwibWF4IiwibWluIiwidGFuaCIsIk51bWJlciIsImlzRmluaXRlIiwic2lnbiIsImUiLCJleHAiLCJzdW0iLCJ4cyIsInJlZHVjZSIsImEiLCJiIiwibWVhbiIsImxlbmd0aCIsInNvcnRCeSIsImFyciIsImtleSIsInNsaWNlIiwic29ydCIsIndNZWRpYW4iLCJ3IiwibiIsIm0iLCJmbG9vciIsInBhaXJzIiwibWFwIiwieGkiLCJpIiwid2kiLCJwIiwidG90YWwiLCJjIiwid01BRCIsImNlbnRlciIsImRldiIsImFicyIsInF1YW50aWxlIiwic29ydGVkIiwiaWR4IiwiY2VpbCIsInZJbm5lciIsIm51Y2xldXMiLCJvcHRzIiwiUyIsInNjYWxlIiwiZyIsImdhaW4iLCJ2YWx1ZXMiLCJ3ZWlnaHRzIiwidW5kZWZpbmVkIiwiY2VudGVyUmF3IiwiY2VudGVyT3ZlcnJpZGUiLCJzaWdtYVJhdyIsInNpZ21hT3ZlcnJpZGUiLCJzaWdtYSIsImRlbm9tIiwibnVtIiwiZGVuIiwic2FtcGxlV2VpZ2h0IiwicmVzaWR1YWwiLCJyYmFyIiwidk91dGVyIiwibnVjbGVpIiwiaW5uZXJzIiwibnUiLCJpbm5lciIsImdhbW1hcyIsImdhbW1hIiwiQXJyYXkiLCJmaWxsIiwic3VtRyIsIm5vcm1hbGl6ZSIsImFnZyIsInVuaXRsZXNzIiwidklubmVyU2NhbGVkIiwidiIsInZPdXRlclNjYWxlZCIsInZUZW5kZW5jeUZyb21TZXJpZXMiLCJzZXJpZXMiLCJXIiwid2luZG93IiwiayIsIm5vcm0iLCJub3JtYWxpemVyIiwiZGlyZWN0aW9uIiwic3RyZW5ndGgiLCJzbG9wZSIsInIiLCJzY29yZSIsInN0YXJ0IiwieSIsInN4Iiwic3kiLCJzeHgiLCJzeHkiLCJzeXkiLCJ5aSIsInJkZW4iLCJzcXJ0IiwiZGlmZnMiLCJwdXNoIiwiRCIsIm1lZCIsImFic2RldiIsImQiLCJtdSIsInZhcnN1bSIsInoiLCJ2U3dhcFF1YXJ0aWxlcyIsImlubmVySGlzdFNjYWxlZCIsInRlbmRlbmN5SGlzdFNjYWxlZCIsImFscGhhIiwibGFzdCIsImZpcnN0IiwiUSIsInRhaWwiLCJxMSIsInEzIiwiSSIsIlQiLCJzb3J0ZWRUIiwiYm90IiwidG9wIiwibWVhblRvcCIsIm1lYW5Cb3QiLCJ2U3dhcEZyb21OdWNsZWkiLCJiaW5zIiwibWlkIiwibGVmdCIsInJpZ2h0IiwicyIsImFnZ3JlZ2F0ZUlubmVyTm93IiwiaW5uZXJPcHRzIiwidSIsInNjYWxlZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/calc/tendency.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/frame/idhr.ts":
/*!*************************************************!*\
  !*** ./src/core/features/str-aux/frame/idhr.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_IDHR: () => (/* binding */ DEFAULT_IDHR),\n/* harmony export */   computeFM: () => (/* binding */ computeFM),\n/* harmony export */   computeIdhrBins: () => (/* binding */ computeIdhrBins),\n/* harmony export */   computeIdhrBinsN: () => (/* binding */ computeIdhrBinsN),\n/* harmony export */   extractNuclei: () => (/* binding */ extractNuclei),\n/* harmony export */   idhr: () => (/* binding */ idhr),\n/* harmony export */   serializeIdhr: () => (/* binding */ serializeIdhr)\n/* harmony export */ });\n// src/lab/str-aux/idhr.ts\n// Deterministic IDHR histogram (with exact bin control) + Floating Mode metrics.\n// - Each function merges config locally into `C` (fixes C is not defined).\n// - `totalBins` enables exact-bin sizing (e.g., 128).\n// - Returns Floating Mode (gfm) + basic shape stats.\n// - Nuclei now match your repos Nucleus type: { binIndex, density, firstDegree, secondDegree }.\nconst DEFAULT_IDHR = {\n    alpha: 2.5,\n    sMin: 1e-6,\n    topN: 3,\n    primaryBins: 16,\n    secondaryBins: 16,\n    selectedBins: 16\n};\n// ---------- Utils ----------\nfunction clamp(n, lo, hi) {\n    return n < lo ? lo : n > hi ? hi : n;\n}\nfunction mean(xs) {\n    return xs.length ? xs.reduce((a, b)=>a + b, 0) / xs.length : 0;\n}\nfunction stdev(xs) {\n    if (xs.length < 2) return 0;\n    const m = mean(xs);\n    const v = xs.reduce((acc, x)=>acc + (x - m) ** 2, 0) / (xs.length - 1);\n    return Math.sqrt(Math.max(0, v));\n}\nfunction linspace(min, max, n) {\n    if (n <= 1) return [\n        min\n    ];\n    const step = (max - min) / (n - 1);\n    return Array.from({\n        length: n\n    }, (_, i)=>min + i * step);\n}\nfunction argMax(xs) {\n    let idx = 0, best = -Infinity;\n    for(let i = 0; i < xs.length; i++)if (xs[i] > best) {\n        best = xs[i];\n        idx = i;\n    }\n    return idx;\n}\nfunction smooth1d(xs, k = 3) {\n    const n = xs.length;\n    if (n === 0 || k <= 1) return xs.slice();\n    const half = Math.floor(k / 2);\n    const out = new Array(n).fill(0);\n    for(let i = 0; i < n; i++){\n        let s = 0, c = 0;\n        for(let j = i - half; j <= i + half; j++)if (j >= 0 && j < n) {\n            s += xs[j];\n            c++;\n        }\n        out[i] = s / (c || 1);\n    }\n    return out;\n}\n// ---------- Core: computeIdhrBins ----------\nfunction computeIdhrBins(points, opening, cfg = {}) {\n    const C = {\n        ...DEFAULT_IDHR,\n        ...cfg\n    };\n    const p0 = Number(opening?.benchmark ?? 0);\n    const returns = [];\n    for (const p of points){\n        const px = Number(p?.price ?? 0);\n        if (Number.isFinite(px) && px > 0 && Number.isFinite(p0) && p0 > 0) {\n            returns.push(Math.log(px / p0));\n        }\n    }\n    let primaryBins = Math.max(1, Math.floor(C.primaryBins ?? DEFAULT_IDHR.primaryBins));\n    let secondaryBins = Math.max(1, Math.floor(C.secondaryBins ?? DEFAULT_IDHR.secondaryBins));\n    if (C.totalBins && C.totalBins > 0) {\n        const total = Math.max(1, Math.floor(C.totalBins));\n        primaryBins = Math.max(1, Math.floor(total / secondaryBins));\n        secondaryBins = Math.max(1, Math.floor(total / primaryBins));\n    }\n    const bins = Math.max(1, primaryBins * secondaryBins);\n    const selectedBins = Math.max(1, Math.min(C.selectedBins ?? DEFAULT_IDHR.selectedBins, bins));\n    if (!returns.length) {\n        return {\n            edges: new Array(bins).fill(0),\n            counts: new Array(bins).fill(0),\n            probs: new Array(bins).fill(0),\n            muR: 0,\n            stdR: C.sMin,\n            sigmaGlobal: C.sMin,\n            selectedBins: [],\n            primaryBins,\n            secondaryBins,\n            binWidth: 0,\n            range: {\n                min: 0,\n                max: 0\n            }\n        };\n    }\n    let spanMin = Math.min(...returns);\n    let spanMax = Math.max(...returns);\n    if (!(spanMax > spanMin)) {\n        const mu0 = mean(returns);\n        const sd0 = Math.max(stdev(returns), C.sMin);\n        const span = Math.max(sd0 * C.alpha, 1e-6);\n        spanMin = mu0 - span;\n        spanMax = mu0 + span;\n    }\n    if (!(spanMax > spanMin)) {\n        spanMin -= 1e-6;\n        spanMax += 1e-6;\n    }\n    const totalRange = spanMax - spanMin;\n    const subWidth = totalRange / bins;\n    const edges = new Array(bins).fill(0).map((_, i)=>spanMin + (i + 0.5) * subWidth);\n    const counts = new Array(bins).fill(0);\n    const assignments = new Array(returns.length);\n    const toIndex = (value)=>{\n        if (!Number.isFinite(value)) return 0;\n        if (value <= spanMin) return 0;\n        if (value >= spanMax) return bins - 1;\n        const raw = Math.floor((value - spanMin) / subWidth);\n        return clamp(raw, 0, bins - 1);\n    };\n    for(let i = 0; i < returns.length; i++){\n        const idx = toIndex(returns[i]);\n        counts[idx] += 1;\n        assignments[i] = idx;\n    }\n    const ranked = counts.map((v, i)=>({\n            v,\n            i\n        })).sort((a, b)=>b.v === a.v ? a.i - b.i : b.v - a.v);\n    const topEntries = ranked.slice(0, selectedBins);\n    const selectedSubBins = topEntries.map((entry)=>entry.i);\n    const selectedPrimariesSet = new Set(topEntries.map((entry)=>Math.floor(entry.i / secondaryBins)));\n    const activeSubBins = new Set();\n    for (const primary of selectedPrimariesSet){\n        for(let j = 0; j < secondaryBins; j++){\n            activeSubBins.add(primary * secondaryBins + j);\n        }\n    }\n    const maskedCounts = counts.map((c, idx)=>activeSubBins.has(idx) ? c : 0);\n    const totalSelected = maskedCounts.reduce((a, b)=>a + b, 0);\n    const probs = maskedCounts.map((c)=>totalSelected > 0 ? c / totalSelected : 0);\n    const inlierReturns = [];\n    assignments.forEach((bin, idx)=>{\n        if (activeSubBins.has(bin)) inlierReturns.push(returns[idx]);\n    });\n    const inliers = inlierReturns.length ? inlierReturns : returns;\n    const muR = mean(inliers);\n    const stdR = Math.max(stdev(inliers), C.sMin);\n    return {\n        edges,\n        counts: maskedCounts,\n        probs,\n        muR,\n        stdR,\n        sigmaGlobal: stdR,\n        selectedBins: selectedSubBins,\n        selectedPrimaries: Array.from(selectedPrimariesSet),\n        primaryBins,\n        secondaryBins,\n        binWidth: subWidth,\n        range: {\n            min: spanMin,\n            max: spanMax\n        }\n    };\n}\n// ---------- Nuclei (peak extraction) ----------\nfunction extractNuclei(bins, k) {\n    const sm = smooth1d(bins.counts, 5);\n    const n = sm.length;\n    // central differences for 1st/2nd derivatives\n    const first = new Array(n).fill(0);\n    const second = new Array(n).fill(0);\n    for(let i = 1; i < n - 1; i++){\n        first[i] = (sm[i + 1] - sm[i - 1]) / 2;\n        second[i] = sm[i + 1] - 2 * sm[i] + sm[i - 1];\n    }\n    // simple local maxima\n    const peaks = [];\n    for(let i = 1; i < n - 1; i++){\n        if (sm[i] > sm[i - 1] && sm[i] > sm[i + 1]) peaks.push({\n            i,\n            v: sm[i]\n        });\n    }\n    peaks.sort((a, b)=>b.v - a.v);\n    const top = peaks.slice(0, Math.max(1, k));\n    const total = bins.counts.reduce((a, b)=>a + b, 0) || 1;\n    // match your Nucleus type exactly\n    const nuclei = top.map(({ i, v })=>({\n            binIndex: i,\n            density: v / total,\n            firstDegree: first[i] ?? 0,\n            secondDegree: second[i] ?? 0\n        }));\n    return nuclei;\n}\n// ---------- Floating Mode (metrics) ----------\nfunction computeFM(points, opening, cfg = {}) {\n    const C = {\n        ...DEFAULT_IDHR,\n        ...cfg\n    };\n    const hist = computeIdhrBins(points, opening, C);\n    const modeIdx = argMax(hist.counts);\n    const gfm = hist.edges[modeIdx] ?? 0;\n    const p0 = Number(opening?.benchmark ?? 0);\n    const rets = [];\n    for (const p of points){\n        const px = Number(p?.price ?? 0);\n        if (Number.isFinite(px) && px > 0 && Number.isFinite(p0) && p0 > 0) {\n            rets.push(Math.log(px / p0));\n        }\n    }\n    const sigma = hist.sigmaGlobal;\n    const zAbs = rets.length ? rets.reduce((a, r)=>a + Math.abs((r - hist.muR) / (sigma || 1)), 0) / rets.length : 0;\n    // crude inner/outer mass around the mode\n    const leftCount = hist.counts.slice(0, modeIdx).reduce((a, b)=>a + b, 0);\n    const rightCount = hist.counts.slice(modeIdx + 1).reduce((a, b)=>a + b, 0);\n    const vInner = Math.max(0, Math.min(leftCount, rightCount));\n    const vOuter = Math.max(0, leftCount + rightCount - vInner);\n    // histogram roughness indicators\n    const center = hist.muR;\n    const inertia = rets.reduce((acc, r)=>acc + (r - center) ** 2, 0) / (rets.length || 1);\n    const sm = smooth1d(hist.counts, 3);\n    let disruption = 0;\n    for(let i = 1; i < sm.length; i++)disruption += Math.abs(sm[i] - sm[i - 1]);\n    disruption /= sm.length || 1;\n    const nuclei = extractNuclei(hist, C.topN);\n    return {\n        gfm,\n        confidence: 1 / (1 + zAbs),\n        inertia,\n        disruption,\n        zMeanAbs: zAbs,\n        sigmaGlobal: sigma,\n        vInner,\n        vOuter,\n        nuclei\n    };\n}\n// ---------- Helpers ----------\nfunction computeIdhrBinsN(points, opening, cfg = {}, N = 128) {\n    return computeIdhrBins(points, opening, {\n        ...cfg,\n        totalBins: N\n    });\n}\nfunction serializeIdhr(idhr) {\n    return {\n        edges: idhr.edges,\n        counts: idhr.counts,\n        probs: idhr.probs,\n        muR: idhr.muR,\n        stdR: idhr.stdR,\n        sigmaGlobal: idhr.sigmaGlobal,\n        selectedBins: idhr.selectedBins,\n        selectedPrimaries: idhr.selectedPrimaries,\n        primaryBins: idhr.primaryBins,\n        secondaryBins: idhr.secondaryBins,\n        binWidth: idhr.binWidth,\n        range: idhr.range\n    };\n}\n// Keep buildStrAux compatibility if it imports { idhr }\nfunction idhr(points, opening, cfg = {}) {\n    const bins = computeIdhrBins(points, opening, cfg);\n    const nuclei = extractNuclei(bins, cfg.topN ?? DEFAULT_IDHR.topN);\n    return {\n        nuclei,\n        sampleFirstDegrees: [],\n        outlierCount: 0\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L2ZyYW1lL2lkaHIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLDBCQUEwQjtBQUMxQixpRkFBaUY7QUFDakYsNkVBQTZFO0FBQzdFLHNEQUFzRDtBQUN0RCxxREFBcUQ7QUFDckQsaUdBQWlHO0FBcUIxRixNQUFNQSxlQUEyQjtJQUN0Q0MsT0FBTztJQUNQQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsYUFBYTtJQUNiQyxlQUFlO0lBQ2ZDLGNBQWM7QUFDaEIsRUFBRTtBQWlCRiw4QkFBOEI7QUFFOUIsU0FBU0MsTUFBTUMsQ0FBUyxFQUFFQyxFQUFVLEVBQUVDLEVBQVU7SUFDOUMsT0FBT0YsSUFBSUMsS0FBS0EsS0FBS0QsSUFBSUUsS0FBS0EsS0FBS0Y7QUFDckM7QUFDQSxTQUFTRyxLQUFLQyxFQUFZO0lBQ3hCLE9BQU9BLEdBQUdDLE1BQU0sR0FBR0QsR0FBR0UsTUFBTSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELElBQUlDLEdBQUcsS0FBS0osR0FBR0MsTUFBTSxHQUFHO0FBQ2pFO0FBQ0EsU0FBU0ksTUFBTUwsRUFBWTtJQUN6QixJQUFJQSxHQUFHQyxNQUFNLEdBQUcsR0FBRyxPQUFPO0lBQzFCLE1BQU1LLElBQUlQLEtBQUtDO0lBQ2YsTUFBTU8sSUFBSVAsR0FBR0UsTUFBTSxDQUFDLENBQUNNLEtBQUtDLElBQU1ELE1BQU0sQ0FBQ0MsSUFBSUgsQ0FBQUEsS0FBTSxHQUFHLEtBQU1OLENBQUFBLEdBQUdDLE1BQU0sR0FBRztJQUN0RSxPQUFPUyxLQUFLQyxJQUFJLENBQUNELEtBQUtFLEdBQUcsQ0FBQyxHQUFHTDtBQUMvQjtBQUNBLFNBQVNNLFNBQVNDLEdBQVcsRUFBRUYsR0FBVyxFQUFFaEIsQ0FBUztJQUNuRCxJQUFJQSxLQUFLLEdBQUcsT0FBTztRQUFDa0I7S0FBSTtJQUN4QixNQUFNQyxPQUFPLENBQUNILE1BQU1FLEdBQUUsSUFBTWxCLENBQUFBLElBQUk7SUFDaEMsT0FBT29CLE1BQU1DLElBQUksQ0FBQztRQUFFaEIsUUFBUUw7SUFBRSxHQUFHLENBQUNzQixHQUFHQyxJQUFNTCxNQUFNSyxJQUFJSjtBQUN2RDtBQUNBLFNBQVNLLE9BQU9wQixFQUFZO0lBQzFCLElBQUlxQixNQUFNLEdBQUdDLE9BQU8sQ0FBQ0M7SUFDckIsSUFBSyxJQUFJSixJQUFJLEdBQUdBLElBQUluQixHQUFHQyxNQUFNLEVBQUVrQixJQUFLLElBQUluQixFQUFFLENBQUNtQixFQUFFLEdBQUdHLE1BQU07UUFBRUEsT0FBT3RCLEVBQUUsQ0FBQ21CLEVBQUU7UUFBRUUsTUFBTUY7SUFBRztJQUMvRSxPQUFPRTtBQUNUO0FBQ0EsU0FBU0csU0FBU3hCLEVBQVksRUFBRXlCLElBQUksQ0FBQztJQUNuQyxNQUFNN0IsSUFBSUksR0FBR0MsTUFBTTtJQUNuQixJQUFJTCxNQUFNLEtBQUs2QixLQUFLLEdBQUcsT0FBT3pCLEdBQUcwQixLQUFLO0lBQ3RDLE1BQU1DLE9BQU9qQixLQUFLa0IsS0FBSyxDQUFDSCxJQUFJO0lBQzVCLE1BQU1JLE1BQU0sSUFBSWIsTUFBTXBCLEdBQUdrQyxJQUFJLENBQUM7SUFDOUIsSUFBSyxJQUFJWCxJQUFJLEdBQUdBLElBQUl2QixHQUFHdUIsSUFBSztRQUMxQixJQUFJWSxJQUFJLEdBQUdDLElBQUk7UUFDZixJQUFLLElBQUlDLElBQUlkLElBQUlRLE1BQU1NLEtBQUtkLElBQUlRLE1BQU1NLElBQUssSUFBSUEsS0FBSyxLQUFLQSxJQUFJckMsR0FBRztZQUFFbUMsS0FBSy9CLEVBQUUsQ0FBQ2lDLEVBQUU7WUFBRUQ7UUFBSztRQUNuRkgsR0FBRyxDQUFDVixFQUFFLEdBQUdZLElBQUtDLENBQUFBLEtBQUs7SUFDckI7SUFDQSxPQUFPSDtBQUNUO0FBRUEsOENBQThDO0FBRXZDLFNBQVNLLGdCQUNkQyxNQUFxQixFQUNyQkMsT0FBcUIsRUFDckJDLE1BQTJCLENBQUMsQ0FBQztJQUU3QixNQUFNQyxJQUFnQjtRQUFFLEdBQUdsRCxZQUFZO1FBQUUsR0FBR2lELEdBQUc7SUFBQztJQUNoRCxNQUFNRSxLQUFLQyxPQUFPSixTQUFTSyxhQUFhO0lBQ3hDLE1BQU1DLFVBQW9CLEVBQUU7SUFDNUIsS0FBSyxNQUFNQyxLQUFLUixPQUFRO1FBQ3RCLE1BQU1TLEtBQUtKLE9BQU9HLEdBQUdFLFNBQVM7UUFDOUIsSUFBSUwsT0FBT00sUUFBUSxDQUFDRixPQUFPQSxLQUFLLEtBQUtKLE9BQU9NLFFBQVEsQ0FBQ1AsT0FBT0EsS0FBSyxHQUFHO1lBQ2xFRyxRQUFRSyxJQUFJLENBQUNyQyxLQUFLc0MsR0FBRyxDQUFDSixLQUFLTDtRQUM3QjtJQUNGO0lBRUEsSUFBSS9DLGNBQWNrQixLQUFLRSxHQUFHLENBQUMsR0FBR0YsS0FBS2tCLEtBQUssQ0FBQ1UsRUFBRTlDLFdBQVcsSUFBSUosYUFBYUksV0FBVztJQUNsRixJQUFJQyxnQkFBZ0JpQixLQUFLRSxHQUFHLENBQUMsR0FBR0YsS0FBS2tCLEtBQUssQ0FBQ1UsRUFBRTdDLGFBQWEsSUFBSUwsYUFBYUssYUFBYTtJQUN4RixJQUFJNkMsRUFBRVcsU0FBUyxJQUFJWCxFQUFFVyxTQUFTLEdBQUcsR0FBRztRQUNsQyxNQUFNQyxRQUFReEMsS0FBS0UsR0FBRyxDQUFDLEdBQUdGLEtBQUtrQixLQUFLLENBQUNVLEVBQUVXLFNBQVM7UUFDaER6RCxjQUFja0IsS0FBS0UsR0FBRyxDQUFDLEdBQUdGLEtBQUtrQixLQUFLLENBQUNzQixRQUFRekQ7UUFDN0NBLGdCQUFnQmlCLEtBQUtFLEdBQUcsQ0FBQyxHQUFHRixLQUFLa0IsS0FBSyxDQUFDc0IsUUFBUTFEO0lBQ2pEO0lBQ0EsTUFBTTJELE9BQU96QyxLQUFLRSxHQUFHLENBQUMsR0FBR3BCLGNBQWNDO0lBQ3ZDLE1BQU1DLGVBQWVnQixLQUFLRSxHQUFHLENBQUMsR0FBR0YsS0FBS0ksR0FBRyxDQUFDd0IsRUFBRTVDLFlBQVksSUFBSU4sYUFBYU0sWUFBWSxFQUFFeUQ7SUFFdkYsSUFBSSxDQUFDVCxRQUFRekMsTUFBTSxFQUFFO1FBQ25CLE9BQU87WUFDTG1ELE9BQU8sSUFBSXBDLE1BQU1tQyxNQUFNckIsSUFBSSxDQUFDO1lBQzVCdUIsUUFBUSxJQUFJckMsTUFBTW1DLE1BQU1yQixJQUFJLENBQUM7WUFDN0J3QixPQUFPLElBQUl0QyxNQUFNbUMsTUFBTXJCLElBQUksQ0FBQztZQUM1QnlCLEtBQUs7WUFDTEMsTUFBTWxCLEVBQUVoRCxJQUFJO1lBQ1ptRSxhQUFhbkIsRUFBRWhELElBQUk7WUFDbkJJLGNBQWMsRUFBRTtZQUNoQkY7WUFDQUM7WUFDQWlFLFVBQVU7WUFDVkMsT0FBTztnQkFBRTdDLEtBQUs7Z0JBQUdGLEtBQUs7WUFBRTtRQUMxQjtJQUNGO0lBRUEsSUFBSWdELFVBQVVsRCxLQUFLSSxHQUFHLElBQUk0QjtJQUMxQixJQUFJbUIsVUFBVW5ELEtBQUtFLEdBQUcsSUFBSThCO0lBQzFCLElBQUksQ0FBRW1CLENBQUFBLFVBQVVELE9BQU0sR0FBSTtRQUN4QixNQUFNRSxNQUFNL0QsS0FBSzJDO1FBQ2pCLE1BQU1xQixNQUFNckQsS0FBS0UsR0FBRyxDQUFDUCxNQUFNcUMsVUFBVUosRUFBRWhELElBQUk7UUFDM0MsTUFBTTBFLE9BQU90RCxLQUFLRSxHQUFHLENBQUNtRCxNQUFNekIsRUFBRWpELEtBQUssRUFBRTtRQUNyQ3VFLFVBQVVFLE1BQU1FO1FBQ2hCSCxVQUFVQyxNQUFNRTtJQUNsQjtJQUNBLElBQUksQ0FBRUgsQ0FBQUEsVUFBVUQsT0FBTSxHQUFJO1FBQ3hCQSxXQUFXO1FBQ1hDLFdBQVc7SUFDYjtJQUNBLE1BQU1JLGFBQWFKLFVBQVVEO0lBQzdCLE1BQU1NLFdBQVdELGFBQWFkO0lBQzlCLE1BQU1DLFFBQVEsSUFBSXBDLE1BQU1tQyxNQUFNckIsSUFBSSxDQUFDLEdBQUdxQyxHQUFHLENBQUMsQ0FBQ2pELEdBQUdDLElBQU15QyxVQUFVLENBQUN6QyxJQUFJLEdBQUUsSUFBSytDO0lBQzFFLE1BQU1iLFNBQVMsSUFBSXJDLE1BQU1tQyxNQUFNckIsSUFBSSxDQUFDO0lBQ3BDLE1BQU1zQyxjQUF3QixJQUFJcEQsTUFBTTBCLFFBQVF6QyxNQUFNO0lBRXRELE1BQU1vRSxVQUFVLENBQUNDO1FBQ2YsSUFBSSxDQUFDOUIsT0FBT00sUUFBUSxDQUFDd0IsUUFBUSxPQUFPO1FBQ3BDLElBQUlBLFNBQVNWLFNBQVMsT0FBTztRQUM3QixJQUFJVSxTQUFTVCxTQUFTLE9BQU9WLE9BQU87UUFDcEMsTUFBTW9CLE1BQU03RCxLQUFLa0IsS0FBSyxDQUFDLENBQUMwQyxRQUFRVixPQUFNLElBQUtNO1FBQzNDLE9BQU92RSxNQUFNNEUsS0FBSyxHQUFHcEIsT0FBTztJQUM5QjtJQUVBLElBQUssSUFBSWhDLElBQUksR0FBR0EsSUFBSXVCLFFBQVF6QyxNQUFNLEVBQUVrQixJQUFLO1FBQ3ZDLE1BQU1FLE1BQU1nRCxRQUFRM0IsT0FBTyxDQUFDdkIsRUFBRTtRQUM5QmtDLE1BQU0sQ0FBQ2hDLElBQUksSUFBSTtRQUNmK0MsV0FBVyxDQUFDakQsRUFBRSxHQUFHRTtJQUNuQjtJQUVBLE1BQU1tRCxTQUFTbkIsT0FDWmMsR0FBRyxDQUFDLENBQUM1RCxHQUFHWSxJQUFPO1lBQUVaO1lBQUdZO1FBQUUsSUFDdEJzRCxJQUFJLENBQUMsQ0FBQ3RFLEdBQUdDLElBQU9BLEVBQUVHLENBQUMsS0FBS0osRUFBRUksQ0FBQyxHQUFHSixFQUFFZ0IsQ0FBQyxHQUFHZixFQUFFZSxDQUFDLEdBQUdmLEVBQUVHLENBQUMsR0FBR0osRUFBRUksQ0FBQztJQUN0RCxNQUFNbUUsYUFBYUYsT0FBTzlDLEtBQUssQ0FBQyxHQUFHaEM7SUFDbkMsTUFBTWlGLGtCQUFrQkQsV0FBV1AsR0FBRyxDQUFDLENBQUNTLFFBQVVBLE1BQU16RCxDQUFDO0lBQ3pELE1BQU0wRCx1QkFBdUIsSUFBSUMsSUFDL0JKLFdBQVdQLEdBQUcsQ0FBQyxDQUFDUyxRQUFVbEUsS0FBS2tCLEtBQUssQ0FBQ2dELE1BQU16RCxDQUFDLEdBQUcxQjtJQUVqRCxNQUFNc0YsZ0JBQWdCLElBQUlEO0lBQzFCLEtBQUssTUFBTUUsV0FBV0gscUJBQXNCO1FBQzFDLElBQUssSUFBSTVDLElBQUksR0FBR0EsSUFBSXhDLGVBQWV3QyxJQUFLO1lBQ3RDOEMsY0FBY0UsR0FBRyxDQUFDRCxVQUFVdkYsZ0JBQWdCd0M7UUFDOUM7SUFDRjtJQUNBLE1BQU1pRCxlQUFlN0IsT0FBT2MsR0FBRyxDQUFDLENBQUNuQyxHQUFHWCxNQUFTMEQsY0FBY0ksR0FBRyxDQUFDOUQsT0FBT1csSUFBSTtJQUUxRSxNQUFNb0QsZ0JBQWdCRixhQUFhaEYsTUFBTSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELElBQUlDLEdBQUc7SUFDM0QsTUFBTWtELFFBQVE0QixhQUFhZixHQUFHLENBQUMsQ0FBQ25DLElBQU9vRCxnQkFBZ0IsSUFBSXBELElBQUlvRCxnQkFBZ0I7SUFFL0UsTUFBTUMsZ0JBQTBCLEVBQUU7SUFDbENqQixZQUFZa0IsT0FBTyxDQUFDLENBQUNDLEtBQUtsRTtRQUN4QixJQUFJMEQsY0FBY0ksR0FBRyxDQUFDSSxNQUFNRixjQUFjdEMsSUFBSSxDQUFDTCxPQUFPLENBQUNyQixJQUFJO0lBQzdEO0lBQ0EsTUFBTW1FLFVBQVVILGNBQWNwRixNQUFNLEdBQUdvRixnQkFBZ0IzQztJQUN2RCxNQUFNYSxNQUFNeEQsS0FBS3lGO0lBQ2pCLE1BQU1oQyxPQUFPOUMsS0FBS0UsR0FBRyxDQUFDUCxNQUFNbUYsVUFBVWxELEVBQUVoRCxJQUFJO0lBRTVDLE9BQU87UUFDTDhEO1FBQ0FDLFFBQVE2QjtRQUNSNUI7UUFDQUM7UUFDQUM7UUFDQUMsYUFBYUQ7UUFDYjlELGNBQWNpRjtRQUNkYyxtQkFBbUJ6RSxNQUFNQyxJQUFJLENBQUM0RDtRQUM5QnJGO1FBQ0FDO1FBQ0FpRSxVQUFVUTtRQUNWUCxPQUFPO1lBQUU3QyxLQUFLOEM7WUFBU2hELEtBQUtpRDtRQUFRO0lBQ3RDO0FBQ0Y7QUFFQSxpREFBaUQ7QUFFMUMsU0FBUzZCLGNBQWN2QyxJQUFjLEVBQUUxQixDQUFTO0lBQ3JELE1BQU1rRSxLQUFLbkUsU0FBUzJCLEtBQUtFLE1BQU0sRUFBRTtJQUNqQyxNQUFNekQsSUFBSStGLEdBQUcxRixNQUFNO0lBRW5CLDhDQUE4QztJQUM5QyxNQUFNMkYsUUFBa0IsSUFBSTVFLE1BQU1wQixHQUFHa0MsSUFBSSxDQUFDO0lBQzFDLE1BQU0rRCxTQUFtQixJQUFJN0UsTUFBTXBCLEdBQUdrQyxJQUFJLENBQUM7SUFDM0MsSUFBSyxJQUFJWCxJQUFJLEdBQUdBLElBQUl2QixJQUFJLEdBQUd1QixJQUFLO1FBQzlCeUUsS0FBSyxDQUFDekUsRUFBRSxHQUFHLENBQUN3RSxFQUFFLENBQUN4RSxJQUFJLEVBQUUsR0FBR3dFLEVBQUUsQ0FBQ3hFLElBQUksRUFBRSxJQUFJO1FBQ3JDMEUsTUFBTSxDQUFDMUUsRUFBRSxHQUFHd0UsRUFBRSxDQUFDeEUsSUFBSSxFQUFFLEdBQUcsSUFBSXdFLEVBQUUsQ0FBQ3hFLEVBQUUsR0FBR3dFLEVBQUUsQ0FBQ3hFLElBQUksRUFBRTtJQUMvQztJQUVBLHNCQUFzQjtJQUN0QixNQUFNMkUsUUFBeUMsRUFBRTtJQUNqRCxJQUFLLElBQUkzRSxJQUFJLEdBQUdBLElBQUl2QixJQUFJLEdBQUd1QixJQUFLO1FBQzlCLElBQUl3RSxFQUFFLENBQUN4RSxFQUFFLEdBQUd3RSxFQUFFLENBQUN4RSxJQUFJLEVBQUUsSUFBSXdFLEVBQUUsQ0FBQ3hFLEVBQUUsR0FBR3dFLEVBQUUsQ0FBQ3hFLElBQUksRUFBRSxFQUFFMkUsTUFBTS9DLElBQUksQ0FBQztZQUFFNUI7WUFBR1osR0FBR29GLEVBQUUsQ0FBQ3hFLEVBQUU7UUFBQztJQUN2RTtJQUNBMkUsTUFBTXJCLElBQUksQ0FBQyxDQUFDdEUsR0FBR0MsSUFBTUEsRUFBRUcsQ0FBQyxHQUFHSixFQUFFSSxDQUFDO0lBQzlCLE1BQU13RixNQUFNRCxNQUFNcEUsS0FBSyxDQUFDLEdBQUdoQixLQUFLRSxHQUFHLENBQUMsR0FBR2E7SUFFdkMsTUFBTXlCLFFBQVFDLEtBQUtFLE1BQU0sQ0FBQ25ELE1BQU0sQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxJQUFJQyxHQUFHLE1BQU07SUFFeEQsa0NBQWtDO0lBQ2xDLE1BQU00RixTQUFvQkQsSUFBSTVCLEdBQUcsQ0FBQyxDQUFDLEVBQUVoRCxDQUFDLEVBQUVaLENBQUMsRUFBRSxHQUFNO1lBQy9DMEYsVUFBVTlFO1lBQ1YrRSxTQUFTM0YsSUFBSTJDO1lBQ2JpRCxhQUFhUCxLQUFLLENBQUN6RSxFQUFFLElBQUk7WUFDekJpRixjQUFjUCxNQUFNLENBQUMxRSxFQUFFLElBQUk7UUFDN0I7SUFFQSxPQUFPNkU7QUFDVDtBQUVBLGdEQUFnRDtBQUV6QyxTQUFTSyxVQUNkbEUsTUFBcUIsRUFDckJDLE9BQXFCLEVBQ3JCQyxNQUEyQixDQUFDLENBQUM7SUFFN0IsTUFBTUMsSUFBZ0I7UUFBRSxHQUFHbEQsWUFBWTtRQUFFLEdBQUdpRCxHQUFHO0lBQUM7SUFDaEQsTUFBTWlFLE9BQU9wRSxnQkFBZ0JDLFFBQVFDLFNBQVNFO0lBRTlDLE1BQU1pRSxVQUFVbkYsT0FBT2tGLEtBQUtqRCxNQUFNO0lBQ2xDLE1BQU1tRCxNQUFNRixLQUFLbEQsS0FBSyxDQUFDbUQsUUFBUSxJQUFJO0lBRW5DLE1BQU1oRSxLQUFLQyxPQUFPSixTQUFTSyxhQUFhO0lBQ3hDLE1BQU1nRSxPQUFpQixFQUFFO0lBQ3pCLEtBQUssTUFBTTlELEtBQUtSLE9BQVE7UUFDdEIsTUFBTVMsS0FBS0osT0FBT0csR0FBR0UsU0FBUztRQUM5QixJQUFJTCxPQUFPTSxRQUFRLENBQUNGLE9BQU9BLEtBQUssS0FBS0osT0FBT00sUUFBUSxDQUFDUCxPQUFPQSxLQUFLLEdBQUc7WUFDbEVrRSxLQUFLMUQsSUFBSSxDQUFDckMsS0FBS3NDLEdBQUcsQ0FBQ0osS0FBS0w7UUFDMUI7SUFDRjtJQUVBLE1BQU1tRSxRQUFRSixLQUFLN0MsV0FBVztJQUM5QixNQUFNa0QsT0FBT0YsS0FBS3hHLE1BQU0sR0FDcEJ3RyxLQUFLdkcsTUFBTSxDQUFDLENBQUNDLEdBQUd5RyxJQUFNekcsSUFBSU8sS0FBS21HLEdBQUcsQ0FBQyxDQUFDRCxJQUFJTixLQUFLL0MsR0FBRyxJQUFLbUQsQ0FBQUEsU0FBUyxLQUFLLEtBQUtELEtBQUt4RyxNQUFNLEdBQ25GO0lBRUoseUNBQXlDO0lBQ3pDLE1BQU02RyxZQUFhUixLQUFLakQsTUFBTSxDQUFDM0IsS0FBSyxDQUFDLEdBQUc2RSxTQUFTckcsTUFBTSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELElBQUlDLEdBQUc7SUFDekUsTUFBTTJHLGFBQWFULEtBQUtqRCxNQUFNLENBQUMzQixLQUFLLENBQUM2RSxVQUFVLEdBQUdyRyxNQUFNLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsSUFBSUMsR0FBRztJQUMxRSxNQUFNNEcsU0FBU3RHLEtBQUtFLEdBQUcsQ0FBQyxHQUFHRixLQUFLSSxHQUFHLENBQUNnRyxXQUFXQztJQUMvQyxNQUFNRSxTQUFTdkcsS0FBS0UsR0FBRyxDQUFDLEdBQUdrRyxZQUFZQyxhQUFhQztJQUVwRCxpQ0FBaUM7SUFDakMsTUFBTUUsU0FBU1osS0FBSy9DLEdBQUc7SUFDdkIsTUFBTTRELFVBQVVWLEtBQUt2RyxNQUFNLENBQUMsQ0FBQ00sS0FBS29HLElBQU1wRyxNQUFNLENBQUNvRyxJQUFJTSxNQUFLLEtBQU0sR0FBRyxLQUFNVCxDQUFBQSxLQUFLeEcsTUFBTSxJQUFJO0lBQ3RGLE1BQU0wRixLQUFLbkUsU0FBUzhFLEtBQUtqRCxNQUFNLEVBQUU7SUFDakMsSUFBSStELGFBQWE7SUFDakIsSUFBSyxJQUFJakcsSUFBSSxHQUFHQSxJQUFJd0UsR0FBRzFGLE1BQU0sRUFBRWtCLElBQUtpRyxjQUFjMUcsS0FBS21HLEdBQUcsQ0FBQ2xCLEVBQUUsQ0FBQ3hFLEVBQUUsR0FBR3dFLEVBQUUsQ0FBQ3hFLElBQUksRUFBRTtJQUM1RWlHLGNBQWV6QixHQUFHMUYsTUFBTSxJQUFJO0lBRTVCLE1BQU0rRixTQUFTTixjQUFjWSxNQUFNaEUsRUFBRS9DLElBQUk7SUFFekMsT0FBTztRQUNMaUg7UUFDQWEsWUFBWSxJQUFLLEtBQUlWLElBQUc7UUFDeEJRO1FBQ0FDO1FBQ0FFLFVBQVVYO1FBQ1ZsRCxhQUFhaUQ7UUFDYk07UUFDQUM7UUFDQWpCO0lBQ0Y7QUFDRjtBQUVBLGdDQUFnQztBQUV6QixTQUFTdUIsaUJBQ2RwRixNQUFxQixFQUNyQkMsT0FBcUIsRUFDckJDLE1BQTJCLENBQUMsQ0FBQyxFQUM3Qm1GLElBQUksR0FBRztJQUVQLE9BQU90RixnQkFBZ0JDLFFBQVFDLFNBQVM7UUFBRSxHQUFHQyxHQUFHO1FBQUVZLFdBQVd1RTtJQUFFO0FBQ2pFO0FBRU8sU0FBU0MsY0FBY0MsSUFBYztJQUMxQyxPQUFPO1FBQ0x0RSxPQUFPc0UsS0FBS3RFLEtBQUs7UUFDakJDLFFBQVFxRSxLQUFLckUsTUFBTTtRQUNuQkMsT0FBT29FLEtBQUtwRSxLQUFLO1FBQ2pCQyxLQUFLbUUsS0FBS25FLEdBQUc7UUFDYkMsTUFBTWtFLEtBQUtsRSxJQUFJO1FBQ2ZDLGFBQWFpRSxLQUFLakUsV0FBVztRQUM3Qi9ELGNBQWNnSSxLQUFLaEksWUFBWTtRQUMvQitGLG1CQUFtQmlDLEtBQUtqQyxpQkFBaUI7UUFDekNqRyxhQUFha0ksS0FBS2xJLFdBQVc7UUFDN0JDLGVBQWVpSSxLQUFLakksYUFBYTtRQUNqQ2lFLFVBQVVnRSxLQUFLaEUsUUFBUTtRQUN2QkMsT0FBTytELEtBQUsvRCxLQUFLO0lBQ25CO0FBQ0Y7QUFFQSx3REFBd0Q7QUFDakQsU0FBUytELEtBQ2R2RixNQUFxQixFQUNyQkMsT0FBcUIsRUFDckJDLE1BQTJCLENBQUMsQ0FBQztJQUU3QixNQUFNYyxPQUFPakIsZ0JBQWdCQyxRQUFRQyxTQUFTQztJQUM5QyxNQUFNMkQsU0FBU04sY0FBY3ZDLE1BQU9kLElBQUk5QyxJQUFJLElBQUlILGFBQWFHLElBQUk7SUFDakUsT0FBTztRQUFFeUc7UUFBUTJCLG9CQUFvQixFQUFFO1FBQUVDLGNBQWM7SUFBRTtBQUMzRCIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGNvcmVcXGZlYXR1cmVzXFxzdHItYXV4XFxmcmFtZVxcaWRoci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbGFiL3N0ci1hdXgvaWRoci50c1xyXG4vLyBEZXRlcm1pbmlzdGljIElESFIgaGlzdG9ncmFtICh3aXRoIGV4YWN0IGJpbiBjb250cm9sKSArIEZsb2F0aW5nIE1vZGUgbWV0cmljcy5cclxuLy8gLSBFYWNoIGZ1bmN0aW9uIG1lcmdlcyBjb25maWcgbG9jYWxseSBpbnRvIGBDYCAoZml4ZXMg4oCcQyBpcyBub3QgZGVmaW5lZOKAnSkuXHJcbi8vIC0gYHRvdGFsQmluc2AgZW5hYmxlcyBleGFjdC1iaW4gc2l6aW5nIChlLmcuLCAxMjgpLlxyXG4vLyAtIFJldHVybnMgRmxvYXRpbmcgTW9kZSAoZ2ZtKSArIGJhc2ljIHNoYXBlIHN0YXRzLlxyXG4vLyAtIE51Y2xlaSBub3cgbWF0Y2ggeW91ciByZXBv4oCZcyBOdWNsZXVzIHR5cGU6IHsgYmluSW5kZXgsIGRlbnNpdHksIGZpcnN0RGVncmVlLCBzZWNvbmREZWdyZWUgfS5cclxuXHJcbmltcG9ydCB0eXBlIHtcclxuICBNYXJrZXRQb2ludCxcclxuICBPcGVuaW5nRXhhY3QsXHJcbiAgTnVjbGV1cyxcclxuICBJZGhyUmVzdWx0LFxyXG59IGZyb20gJy4uLy4uLy4uLy4uLy4uL2xhYi9sZWdhY3kvYXV4aWxpYXJ5L3N0ci1hdXgvdHlwZXMnO1xyXG5cclxuLy8gLS0tLS0tLS0tLSBDb25maWcgJiBUeXBlcyAtLS0tLS0tLS0tXHJcblxyXG5leHBvcnQgdHlwZSBJZGhyQ29uZmlnID0ge1xyXG4gIGFscGhhOiBudW1iZXI7ICAgICAgICAgICAgLy8gc3BhbiBtdWx0aXBsaWVyIGFyb3VuZCBtZWFuICjPgyDCtyDOsSlcclxuICBzTWluOiBudW1iZXI7ICAgICAgICAgICAgIC8vIHNpZ21hIGZsb29yIHRvIGF2b2lkIGNvbGxhcHNlXHJcbiAgdG9wTjogbnVtYmVyOyAgICAgICAgICAgICAvLyBudW1iZXIgb2YgbnVjbGVpIHRvIGtlZXBcclxuICBwcmltYXJ5QmluczogbnVtYmVyOyAgICAgIC8vIGNvYXJzZSBiaW5zXHJcbiAgc2Vjb25kYXJ5QmluczogbnVtYmVyOyAgICAvLyBmaW5lIGJpbnMgcGVyIGNvYXJzZSBiaW5cclxuICBzZWxlY3RlZEJpbnM6IG51bWJlcjsgICAgIC8vIG51bWJlciBvZiBmaW5lIGJpbnMgcmV0YWluZWRcclxuICB0b3RhbEJpbnM/OiBudW1iZXI7ICAgICAgIC8vIG9wdGlvbmFsIG92ZXJyaWRlIGZvciB0b3RhbCBiaW5zXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9JREhSOiBJZGhyQ29uZmlnID0ge1xyXG4gIGFscGhhOiAyLjUsXHJcbiAgc01pbjogMWUtNixcclxuICB0b3BOOiAzLFxyXG4gIHByaW1hcnlCaW5zOiAxNixcclxuICBzZWNvbmRhcnlCaW5zOiAxNixcclxuICBzZWxlY3RlZEJpbnM6IDE2LFxyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgSWRockJpbnMgPSB7XG4gIGVkZ2VzOiBudW1iZXJbXTsgICAgLy8gY2VudGVycyBmb3IgZWFjaCBzdWItYmluXG4gIGNvdW50czogbnVtYmVyW107ICAgLy8gY291bnRzIGFmdGVyIG1hc2tpbmcgb3V0bGllcnNcbiAgcHJvYnM6IG51bWJlcltdOyAgICAvLyBwcm9iYWJpbGl0eSBtYXNzIG9mIHNlbGVjdGVkIGJpbnNcbiAgbXVSOiBudW1iZXI7XG4gIHN0ZFI6IG51bWJlcjtcbiAgc2lnbWFHbG9iYWw6IG51bWJlcjsgLy8gYWxpYXMgdG8gc3RkUlxuICBzZWxlY3RlZEJpbnM6IG51bWJlcltdO1xuICBzZWxlY3RlZFByaW1hcmllczogbnVtYmVyW107XG4gIHByaW1hcnlCaW5zOiBudW1iZXI7XG4gIHNlY29uZGFyeUJpbnM6IG51bWJlcjtcbiAgYmluV2lkdGg6IG51bWJlcjtcbiAgcmFuZ2U6IHsgbWluOiBudW1iZXI7IG1heDogbnVtYmVyIH07XG59O1xuXHJcbi8vIC0tLS0tLS0tLS0gVXRpbHMgLS0tLS0tLS0tLVxyXG5cclxuZnVuY3Rpb24gY2xhbXAobjogbnVtYmVyLCBsbzogbnVtYmVyLCBoaTogbnVtYmVyKSB7XHJcbiAgcmV0dXJuIG4gPCBsbyA/IGxvIDogbiA+IGhpID8gaGkgOiBuO1xyXG59XHJcbmZ1bmN0aW9uIG1lYW4oeHM6IG51bWJlcltdKSB7XHJcbiAgcmV0dXJuIHhzLmxlbmd0aCA/IHhzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8geHMubGVuZ3RoIDogMDtcclxufVxyXG5mdW5jdGlvbiBzdGRldih4czogbnVtYmVyW10pIHtcclxuICBpZiAoeHMubGVuZ3RoIDwgMikgcmV0dXJuIDA7XHJcbiAgY29uc3QgbSA9IG1lYW4oeHMpO1xyXG4gIGNvbnN0IHYgPSB4cy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjICsgKHggLSBtKSAqKiAyLCAwKSAvICh4cy5sZW5ndGggLSAxKTtcclxuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIHYpKTtcclxufVxyXG5mdW5jdGlvbiBsaW5zcGFjZShtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIG46IG51bWJlcikge1xyXG4gIGlmIChuIDw9IDEpIHJldHVybiBbbWluXTtcclxuICBjb25zdCBzdGVwID0gKG1heCAtIG1pbikgLyAobiAtIDEpO1xyXG4gIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBuIH0sIChfLCBpKSA9PiBtaW4gKyBpICogc3RlcCk7XHJcbn1cclxuZnVuY3Rpb24gYXJnTWF4KHhzOiBudW1iZXJbXSkge1xyXG4gIGxldCBpZHggPSAwLCBiZXN0ID0gLUluZmluaXR5O1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIGlmICh4c1tpXSA+IGJlc3QpIHsgYmVzdCA9IHhzW2ldOyBpZHggPSBpOyB9XHJcbiAgcmV0dXJuIGlkeDtcclxufVxyXG5mdW5jdGlvbiBzbW9vdGgxZCh4czogbnVtYmVyW10sIGsgPSAzKSB7XHJcbiAgY29uc3QgbiA9IHhzLmxlbmd0aDtcclxuICBpZiAobiA9PT0gMCB8fCBrIDw9IDEpIHJldHVybiB4cy5zbGljZSgpO1xyXG4gIGNvbnN0IGhhbGYgPSBNYXRoLmZsb29yKGsgLyAyKTtcclxuICBjb25zdCBvdXQgPSBuZXcgQXJyYXkobikuZmlsbCgwKTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgbGV0IHMgPSAwLCBjID0gMDtcclxuICAgIGZvciAobGV0IGogPSBpIC0gaGFsZjsgaiA8PSBpICsgaGFsZjsgaisrKSBpZiAoaiA+PSAwICYmIGogPCBuKSB7IHMgKz0geHNbal07IGMrKzsgfVxyXG4gICAgb3V0W2ldID0gcyAvIChjIHx8IDEpO1xyXG4gIH1cclxuICByZXR1cm4gb3V0O1xyXG59XHJcblxyXG4vLyAtLS0tLS0tLS0tIENvcmU6IGNvbXB1dGVJZGhyQmlucyAtLS0tLS0tLS0tXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUlkaHJCaW5zKFxuICBwb2ludHM6IE1hcmtldFBvaW50W10sXG4gIG9wZW5pbmc6IE9wZW5pbmdFeGFjdCxcbiAgY2ZnOiBQYXJ0aWFsPElkaHJDb25maWc+ID0ge30sXG4pOiBJZGhyQmlucyB7XG4gIGNvbnN0IEM6IElkaHJDb25maWcgPSB7IC4uLkRFRkFVTFRfSURIUiwgLi4uY2ZnIH07XG4gIGNvbnN0IHAwID0gTnVtYmVyKG9wZW5pbmc/LmJlbmNobWFyayA/PyAwKTtcbiAgY29uc3QgcmV0dXJuczogbnVtYmVyW10gPSBbXTtcbiAgZm9yIChjb25zdCBwIG9mIHBvaW50cykge1xuICAgIGNvbnN0IHB4ID0gTnVtYmVyKHA/LnByaWNlID8/IDApO1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocHgpICYmIHB4ID4gMCAmJiBOdW1iZXIuaXNGaW5pdGUocDApICYmIHAwID4gMCkge1xuICAgICAgcmV0dXJucy5wdXNoKE1hdGgubG9nKHB4IC8gcDApKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcHJpbWFyeUJpbnMgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKEMucHJpbWFyeUJpbnMgPz8gREVGQVVMVF9JREhSLnByaW1hcnlCaW5zKSk7XG4gIGxldCBzZWNvbmRhcnlCaW5zID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihDLnNlY29uZGFyeUJpbnMgPz8gREVGQVVMVF9JREhSLnNlY29uZGFyeUJpbnMpKTtcbiAgaWYgKEMudG90YWxCaW5zICYmIEMudG90YWxCaW5zID4gMCkge1xuICAgIGNvbnN0IHRvdGFsID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihDLnRvdGFsQmlucykpO1xuICAgIHByaW1hcnlCaW5zID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcih0b3RhbCAvIHNlY29uZGFyeUJpbnMpKTtcbiAgICBzZWNvbmRhcnlCaW5zID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcih0b3RhbCAvIHByaW1hcnlCaW5zKSk7XG4gIH1cbiAgY29uc3QgYmlucyA9IE1hdGgubWF4KDEsIHByaW1hcnlCaW5zICogc2Vjb25kYXJ5Qmlucyk7XG4gIGNvbnN0IHNlbGVjdGVkQmlucyA9IE1hdGgubWF4KDEsIE1hdGgubWluKEMuc2VsZWN0ZWRCaW5zID8/IERFRkFVTFRfSURIUi5zZWxlY3RlZEJpbnMsIGJpbnMpKTtcblxuICBpZiAoIXJldHVybnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVkZ2VzOiBuZXcgQXJyYXkoYmlucykuZmlsbCgwKSxcbiAgICAgIGNvdW50czogbmV3IEFycmF5KGJpbnMpLmZpbGwoMCksXG4gICAgICBwcm9iczogbmV3IEFycmF5KGJpbnMpLmZpbGwoMCksXG4gICAgICBtdVI6IDAsXG4gICAgICBzdGRSOiBDLnNNaW4sXG4gICAgICBzaWdtYUdsb2JhbDogQy5zTWluLFxuICAgICAgc2VsZWN0ZWRCaW5zOiBbXSxcbiAgICAgIHByaW1hcnlCaW5zLFxuICAgICAgc2Vjb25kYXJ5QmlucyxcbiAgICAgIGJpbldpZHRoOiAwLFxuICAgICAgcmFuZ2U6IHsgbWluOiAwLCBtYXg6IDAgfSxcbiAgICB9O1xuICB9XG5cbiAgbGV0IHNwYW5NaW4gPSBNYXRoLm1pbiguLi5yZXR1cm5zKTtcbiAgbGV0IHNwYW5NYXggPSBNYXRoLm1heCguLi5yZXR1cm5zKTtcbiAgaWYgKCEoc3Bhbk1heCA+IHNwYW5NaW4pKSB7XG4gICAgY29uc3QgbXUwID0gbWVhbihyZXR1cm5zKTtcbiAgICBjb25zdCBzZDAgPSBNYXRoLm1heChzdGRldihyZXR1cm5zKSwgQy5zTWluKTtcbiAgICBjb25zdCBzcGFuID0gTWF0aC5tYXgoc2QwICogQy5hbHBoYSwgMWUtNik7XG4gICAgc3Bhbk1pbiA9IG11MCAtIHNwYW47XG4gICAgc3Bhbk1heCA9IG11MCArIHNwYW47XG4gIH1cbiAgaWYgKCEoc3Bhbk1heCA+IHNwYW5NaW4pKSB7XG4gICAgc3Bhbk1pbiAtPSAxZS02O1xuICAgIHNwYW5NYXggKz0gMWUtNjtcbiAgfVxuICBjb25zdCB0b3RhbFJhbmdlID0gc3Bhbk1heCAtIHNwYW5NaW47XG4gIGNvbnN0IHN1YldpZHRoID0gdG90YWxSYW5nZSAvIGJpbnM7XG4gIGNvbnN0IGVkZ2VzID0gbmV3IEFycmF5KGJpbnMpLmZpbGwoMCkubWFwKChfLCBpKSA9PiBzcGFuTWluICsgKGkgKyAwLjUpICogc3ViV2lkdGgpO1xuICBjb25zdCBjb3VudHMgPSBuZXcgQXJyYXkoYmlucykuZmlsbCgwKTtcbiAgY29uc3QgYXNzaWdubWVudHM6IG51bWJlcltdID0gbmV3IEFycmF5KHJldHVybnMubGVuZ3RoKTtcblxuICBjb25zdCB0b0luZGV4ID0gKHZhbHVlOiBudW1iZXIpID0+IHtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHJldHVybiAwO1xuICAgIGlmICh2YWx1ZSA8PSBzcGFuTWluKSByZXR1cm4gMDtcbiAgICBpZiAodmFsdWUgPj0gc3Bhbk1heCkgcmV0dXJuIGJpbnMgLSAxO1xuICAgIGNvbnN0IHJhdyA9IE1hdGguZmxvb3IoKHZhbHVlIC0gc3Bhbk1pbikgLyBzdWJXaWR0aCk7XG4gICAgcmV0dXJuIGNsYW1wKHJhdywgMCwgYmlucyAtIDEpO1xuICB9O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0dXJucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGlkeCA9IHRvSW5kZXgocmV0dXJuc1tpXSk7XG4gICAgY291bnRzW2lkeF0gKz0gMTtcbiAgICBhc3NpZ25tZW50c1tpXSA9IGlkeDtcbiAgfVxuXG4gIGNvbnN0IHJhbmtlZCA9IGNvdW50c1xuICAgIC5tYXAoKHYsIGkpID0+ICh7IHYsIGkgfSkpXG4gICAgLnNvcnQoKGEsIGIpID0+IChiLnYgPT09IGEudiA/IGEuaSAtIGIuaSA6IGIudiAtIGEudikpO1xuICBjb25zdCB0b3BFbnRyaWVzID0gcmFua2VkLnNsaWNlKDAsIHNlbGVjdGVkQmlucyk7XG4gIGNvbnN0IHNlbGVjdGVkU3ViQmlucyA9IHRvcEVudHJpZXMubWFwKChlbnRyeSkgPT4gZW50cnkuaSk7XG4gIGNvbnN0IHNlbGVjdGVkUHJpbWFyaWVzU2V0ID0gbmV3IFNldChcbiAgICB0b3BFbnRyaWVzLm1hcCgoZW50cnkpID0+IE1hdGguZmxvb3IoZW50cnkuaSAvIHNlY29uZGFyeUJpbnMpKVxuICApO1xuICBjb25zdCBhY3RpdmVTdWJCaW5zID0gbmV3IFNldDxudW1iZXI+KCk7XG4gIGZvciAoY29uc3QgcHJpbWFyeSBvZiBzZWxlY3RlZFByaW1hcmllc1NldCkge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2Vjb25kYXJ5QmluczsgaisrKSB7XG4gICAgICBhY3RpdmVTdWJCaW5zLmFkZChwcmltYXJ5ICogc2Vjb25kYXJ5QmlucyArIGopO1xuICAgIH1cbiAgfVxuICBjb25zdCBtYXNrZWRDb3VudHMgPSBjb3VudHMubWFwKChjLCBpZHgpID0+IChhY3RpdmVTdWJCaW5zLmhhcyhpZHgpID8gYyA6IDApKTtcblxuICBjb25zdCB0b3RhbFNlbGVjdGVkID0gbWFza2VkQ291bnRzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICBjb25zdCBwcm9icyA9IG1hc2tlZENvdW50cy5tYXAoKGMpID0+ICh0b3RhbFNlbGVjdGVkID4gMCA/IGMgLyB0b3RhbFNlbGVjdGVkIDogMCkpO1xuXG4gIGNvbnN0IGlubGllclJldHVybnM6IG51bWJlcltdID0gW107XG4gIGFzc2lnbm1lbnRzLmZvckVhY2goKGJpbiwgaWR4KSA9PiB7XG4gICAgaWYgKGFjdGl2ZVN1YkJpbnMuaGFzKGJpbikpIGlubGllclJldHVybnMucHVzaChyZXR1cm5zW2lkeF0pO1xuICB9KTtcbiAgY29uc3QgaW5saWVycyA9IGlubGllclJldHVybnMubGVuZ3RoID8gaW5saWVyUmV0dXJucyA6IHJldHVybnM7XG4gIGNvbnN0IG11UiA9IG1lYW4oaW5saWVycyk7XG4gIGNvbnN0IHN0ZFIgPSBNYXRoLm1heChzdGRldihpbmxpZXJzKSwgQy5zTWluKTtcblxuICByZXR1cm4ge1xuICAgIGVkZ2VzLFxuICAgIGNvdW50czogbWFza2VkQ291bnRzLFxuICAgIHByb2JzLFxuICAgIG11UixcbiAgICBzdGRSLFxuICAgIHNpZ21hR2xvYmFsOiBzdGRSLFxuICAgIHNlbGVjdGVkQmluczogc2VsZWN0ZWRTdWJCaW5zLFxuICAgIHNlbGVjdGVkUHJpbWFyaWVzOiBBcnJheS5mcm9tKHNlbGVjdGVkUHJpbWFyaWVzU2V0KSxcbiAgICBwcmltYXJ5QmlucyxcbiAgICBzZWNvbmRhcnlCaW5zLFxuICAgIGJpbldpZHRoOiBzdWJXaWR0aCxcbiAgICByYW5nZTogeyBtaW46IHNwYW5NaW4sIG1heDogc3Bhbk1heCB9LFxuICB9O1xufVxuXHJcbi8vIC0tLS0tLS0tLS0gTnVjbGVpIChwZWFrIGV4dHJhY3Rpb24pIC0tLS0tLS0tLS1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0TnVjbGVpKGJpbnM6IElkaHJCaW5zLCBrOiBudW1iZXIpOiBOdWNsZXVzW10ge1xyXG4gIGNvbnN0IHNtID0gc21vb3RoMWQoYmlucy5jb3VudHMsIDUpO1xyXG4gIGNvbnN0IG4gPSBzbS5sZW5ndGg7XHJcblxyXG4gIC8vIGNlbnRyYWwgZGlmZmVyZW5jZXMgZm9yIDFzdC8ybmQgZGVyaXZhdGl2ZXNcclxuICBjb25zdCBmaXJzdDogbnVtYmVyW10gPSBuZXcgQXJyYXkobikuZmlsbCgwKTtcclxuICBjb25zdCBzZWNvbmQ6IG51bWJlcltdID0gbmV3IEFycmF5KG4pLmZpbGwoMCk7XHJcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBuIC0gMTsgaSsrKSB7XHJcbiAgICBmaXJzdFtpXSA9IChzbVtpICsgMV0gLSBzbVtpIC0gMV0pIC8gMjtcclxuICAgIHNlY29uZFtpXSA9IHNtW2kgKyAxXSAtIDIgKiBzbVtpXSArIHNtW2kgLSAxXTtcclxuICB9XHJcblxyXG4gIC8vIHNpbXBsZSBsb2NhbCBtYXhpbWFcclxuICBjb25zdCBwZWFrczogQXJyYXk8eyBpOiBudW1iZXI7IHY6IG51bWJlciB9PiA9IFtdO1xyXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbiAtIDE7IGkrKykge1xyXG4gICAgaWYgKHNtW2ldID4gc21baSAtIDFdICYmIHNtW2ldID4gc21baSArIDFdKSBwZWFrcy5wdXNoKHsgaSwgdjogc21baV0gfSk7XHJcbiAgfVxyXG4gIHBlYWtzLnNvcnQoKGEsIGIpID0+IGIudiAtIGEudik7XHJcbiAgY29uc3QgdG9wID0gcGVha3Muc2xpY2UoMCwgTWF0aC5tYXgoMSwgaykpO1xyXG5cclxuICBjb25zdCB0b3RhbCA9IGJpbnMuY291bnRzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIHx8IDE7XHJcblxyXG4gIC8vIG1hdGNoIHlvdXIgTnVjbGV1cyB0eXBlIGV4YWN0bHlcclxuICBjb25zdCBudWNsZWk6IE51Y2xldXNbXSA9IHRvcC5tYXAoKHsgaSwgdiB9KSA9PiAoe1xyXG4gICAgYmluSW5kZXg6IGksXHJcbiAgICBkZW5zaXR5OiB2IC8gdG90YWwsXHJcbiAgICBmaXJzdERlZ3JlZTogZmlyc3RbaV0gPz8gMCxcclxuICAgIHNlY29uZERlZ3JlZTogc2Vjb25kW2ldID8/IDAsXHJcbiAgfSkpO1xyXG5cclxuICByZXR1cm4gbnVjbGVpO1xyXG59XHJcblxyXG4vLyAtLS0tLS0tLS0tIEZsb2F0aW5nIE1vZGUgKG1ldHJpY3MpIC0tLS0tLS0tLS1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlRk0oXHJcbiAgcG9pbnRzOiBNYXJrZXRQb2ludFtdLFxyXG4gIG9wZW5pbmc6IE9wZW5pbmdFeGFjdCxcclxuICBjZmc6IFBhcnRpYWw8SWRockNvbmZpZz4gPSB7fSxcclxuKSB7XHJcbiAgY29uc3QgQzogSWRockNvbmZpZyA9IHsgLi4uREVGQVVMVF9JREhSLCAuLi5jZmcgfTtcclxuICBjb25zdCBoaXN0ID0gY29tcHV0ZUlkaHJCaW5zKHBvaW50cywgb3BlbmluZywgQyk7XHJcblxyXG4gIGNvbnN0IG1vZGVJZHggPSBhcmdNYXgoaGlzdC5jb3VudHMpO1xyXG4gIGNvbnN0IGdmbSA9IGhpc3QuZWRnZXNbbW9kZUlkeF0gPz8gMDtcclxuXHJcbiAgY29uc3QgcDAgPSBOdW1iZXIob3BlbmluZz8uYmVuY2htYXJrID8/IDApO1xyXG4gIGNvbnN0IHJldHM6IG51bWJlcltdID0gW107XHJcbiAgZm9yIChjb25zdCBwIG9mIHBvaW50cykge1xyXG4gICAgY29uc3QgcHggPSBOdW1iZXIocD8ucHJpY2UgPz8gMCk7XHJcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHB4KSAmJiBweCA+IDAgJiYgTnVtYmVyLmlzRmluaXRlKHAwKSAmJiBwMCA+IDApIHtcclxuICAgICAgcmV0cy5wdXNoKE1hdGgubG9nKHB4IC8gcDApKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IHNpZ21hID0gaGlzdC5zaWdtYUdsb2JhbDtcclxuICBjb25zdCB6QWJzID0gcmV0cy5sZW5ndGhcclxuICAgID8gcmV0cy5yZWR1Y2UoKGEsIHIpID0+IGEgKyBNYXRoLmFicygociAtIGhpc3QubXVSKSAvIChzaWdtYSB8fCAxKSksIDApIC8gcmV0cy5sZW5ndGhcclxuICAgIDogMDtcclxuXHJcbiAgLy8gY3J1ZGUgaW5uZXIvb3V0ZXIgbWFzcyBhcm91bmQgdGhlIG1vZGVcclxuICBjb25zdCBsZWZ0Q291bnQgID0gaGlzdC5jb3VudHMuc2xpY2UoMCwgbW9kZUlkeCkucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XHJcbiAgY29uc3QgcmlnaHRDb3VudCA9IGhpc3QuY291bnRzLnNsaWNlKG1vZGVJZHggKyAxKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcclxuICBjb25zdCB2SW5uZXIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsZWZ0Q291bnQsIHJpZ2h0Q291bnQpKTtcclxuICBjb25zdCB2T3V0ZXIgPSBNYXRoLm1heCgwLCBsZWZ0Q291bnQgKyByaWdodENvdW50IC0gdklubmVyKTtcclxuXHJcbiAgLy8gaGlzdG9ncmFtIHJvdWdobmVzcyBpbmRpY2F0b3JzXHJcbiAgY29uc3QgY2VudGVyID0gaGlzdC5tdVI7XHJcbiAgY29uc3QgaW5lcnRpYSA9IHJldHMucmVkdWNlKChhY2MsIHIpID0+IGFjYyArIChyIC0gY2VudGVyKSAqKiAyLCAwKSAvIChyZXRzLmxlbmd0aCB8fCAxKTtcclxuICBjb25zdCBzbSA9IHNtb290aDFkKGhpc3QuY291bnRzLCAzKTtcclxuICBsZXQgZGlzcnVwdGlvbiA9IDA7XHJcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBzbS5sZW5ndGg7IGkrKykgZGlzcnVwdGlvbiArPSBNYXRoLmFicyhzbVtpXSAtIHNtW2kgLSAxXSk7XHJcbiAgZGlzcnVwdGlvbiAvPSAoc20ubGVuZ3RoIHx8IDEpO1xyXG5cclxuICBjb25zdCBudWNsZWkgPSBleHRyYWN0TnVjbGVpKGhpc3QsIEMudG9wTik7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBnZm0sXHJcbiAgICBjb25maWRlbmNlOiAxIC8gKDEgKyB6QWJzKSxcclxuICAgIGluZXJ0aWEsXHJcbiAgICBkaXNydXB0aW9uLFxyXG4gICAgek1lYW5BYnM6IHpBYnMsXHJcbiAgICBzaWdtYUdsb2JhbDogc2lnbWEsXHJcbiAgICB2SW5uZXIsXHJcbiAgICB2T3V0ZXIsXHJcbiAgICBudWNsZWksIC8vIG1hdGNoZXMgTnVjbGV1cyB0eXBlIHVzZWQgaW4geW91ciByZXBvXHJcbiAgfTtcclxufVxyXG5cclxuLy8gLS0tLS0tLS0tLSBIZWxwZXJzIC0tLS0tLS0tLS1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSWRockJpbnNOKFxyXG4gIHBvaW50czogTWFya2V0UG9pbnRbXSxcclxuICBvcGVuaW5nOiBPcGVuaW5nRXhhY3QsXHJcbiAgY2ZnOiBQYXJ0aWFsPElkaHJDb25maWc+ID0ge30sXHJcbiAgTiA9IDEyOFxyXG4pIHtcclxuICByZXR1cm4gY29tcHV0ZUlkaHJCaW5zKHBvaW50cywgb3BlbmluZywgeyAuLi5jZmcsIHRvdGFsQmluczogTiB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUlkaHIoaWRocjogSWRockJpbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBlZGdlczogaWRoci5lZGdlcyxcbiAgICBjb3VudHM6IGlkaHIuY291bnRzLFxuICAgIHByb2JzOiBpZGhyLnByb2JzLFxuICAgIG11UjogaWRoci5tdVIsXG4gICAgc3RkUjogaWRoci5zdGRSLFxuICAgIHNpZ21hR2xvYmFsOiBpZGhyLnNpZ21hR2xvYmFsLFxuICAgIHNlbGVjdGVkQmluczogaWRoci5zZWxlY3RlZEJpbnMsXG4gICAgc2VsZWN0ZWRQcmltYXJpZXM6IGlkaHIuc2VsZWN0ZWRQcmltYXJpZXMsXG4gICAgcHJpbWFyeUJpbnM6IGlkaHIucHJpbWFyeUJpbnMsXG4gICAgc2Vjb25kYXJ5QmluczogaWRoci5zZWNvbmRhcnlCaW5zLFxuICAgIGJpbldpZHRoOiBpZGhyLmJpbldpZHRoLFxuICAgIHJhbmdlOiBpZGhyLnJhbmdlLFxuICB9O1xufVxuXHJcbi8vIEtlZXAgYnVpbGRTdHJBdXggY29tcGF0aWJpbGl0eSBpZiBpdCBpbXBvcnRzIHsgaWRociB9XHJcbmV4cG9ydCBmdW5jdGlvbiBpZGhyKFxyXG4gIHBvaW50czogTWFya2V0UG9pbnRbXSxcclxuICBvcGVuaW5nOiBPcGVuaW5nRXhhY3QsXHJcbiAgY2ZnOiBQYXJ0aWFsPElkaHJDb25maWc+ID0ge31cclxuKTogSWRoclJlc3VsdCB7XHJcbiAgY29uc3QgYmlucyA9IGNvbXB1dGVJZGhyQmlucyhwb2ludHMsIG9wZW5pbmcsIGNmZyk7XHJcbiAgY29uc3QgbnVjbGVpID0gZXh0cmFjdE51Y2xlaShiaW5zLCAoY2ZnLnRvcE4gPz8gREVGQVVMVF9JREhSLnRvcE4pKTtcclxuICByZXR1cm4geyBudWNsZWksIHNhbXBsZUZpcnN0RGVncmVlczogW10sIG91dGxpZXJDb3VudDogMCB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJERUZBVUxUX0lESFIiLCJhbHBoYSIsInNNaW4iLCJ0b3BOIiwicHJpbWFyeUJpbnMiLCJzZWNvbmRhcnlCaW5zIiwic2VsZWN0ZWRCaW5zIiwiY2xhbXAiLCJuIiwibG8iLCJoaSIsIm1lYW4iLCJ4cyIsImxlbmd0aCIsInJlZHVjZSIsImEiLCJiIiwic3RkZXYiLCJtIiwidiIsImFjYyIsIngiLCJNYXRoIiwic3FydCIsIm1heCIsImxpbnNwYWNlIiwibWluIiwic3RlcCIsIkFycmF5IiwiZnJvbSIsIl8iLCJpIiwiYXJnTWF4IiwiaWR4IiwiYmVzdCIsIkluZmluaXR5Iiwic21vb3RoMWQiLCJrIiwic2xpY2UiLCJoYWxmIiwiZmxvb3IiLCJvdXQiLCJmaWxsIiwicyIsImMiLCJqIiwiY29tcHV0ZUlkaHJCaW5zIiwicG9pbnRzIiwib3BlbmluZyIsImNmZyIsIkMiLCJwMCIsIk51bWJlciIsImJlbmNobWFyayIsInJldHVybnMiLCJwIiwicHgiLCJwcmljZSIsImlzRmluaXRlIiwicHVzaCIsImxvZyIsInRvdGFsQmlucyIsInRvdGFsIiwiYmlucyIsImVkZ2VzIiwiY291bnRzIiwicHJvYnMiLCJtdVIiLCJzdGRSIiwic2lnbWFHbG9iYWwiLCJiaW5XaWR0aCIsInJhbmdlIiwic3Bhbk1pbiIsInNwYW5NYXgiLCJtdTAiLCJzZDAiLCJzcGFuIiwidG90YWxSYW5nZSIsInN1YldpZHRoIiwibWFwIiwiYXNzaWdubWVudHMiLCJ0b0luZGV4IiwidmFsdWUiLCJyYXciLCJyYW5rZWQiLCJzb3J0IiwidG9wRW50cmllcyIsInNlbGVjdGVkU3ViQmlucyIsImVudHJ5Iiwic2VsZWN0ZWRQcmltYXJpZXNTZXQiLCJTZXQiLCJhY3RpdmVTdWJCaW5zIiwicHJpbWFyeSIsImFkZCIsIm1hc2tlZENvdW50cyIsImhhcyIsInRvdGFsU2VsZWN0ZWQiLCJpbmxpZXJSZXR1cm5zIiwiZm9yRWFjaCIsImJpbiIsImlubGllcnMiLCJzZWxlY3RlZFByaW1hcmllcyIsImV4dHJhY3ROdWNsZWkiLCJzbSIsImZpcnN0Iiwic2Vjb25kIiwicGVha3MiLCJ0b3AiLCJudWNsZWkiLCJiaW5JbmRleCIsImRlbnNpdHkiLCJmaXJzdERlZ3JlZSIsInNlY29uZERlZ3JlZSIsImNvbXB1dGVGTSIsImhpc3QiLCJtb2RlSWR4IiwiZ2ZtIiwicmV0cyIsInNpZ21hIiwiekFicyIsInIiLCJhYnMiLCJsZWZ0Q291bnQiLCJyaWdodENvdW50IiwidklubmVyIiwidk91dGVyIiwiY2VudGVyIiwiaW5lcnRpYSIsImRpc3J1cHRpb24iLCJjb25maWRlbmNlIiwiek1lYW5BYnMiLCJjb21wdXRlSWRockJpbnNOIiwiTiIsInNlcmlhbGl6ZUlkaHIiLCJpZGhyIiwic2FtcGxlRmlyc3REZWdyZWVzIiwib3V0bGllckNvdW50Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/frame/idhr.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/frame/idhrRanges.ts":
/*!*******************************************************!*\
  !*** ./src/core/features/str-aux/frame/idhrRanges.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deriveIdhrRanges: () => (/* binding */ deriveIdhrRanges),\n/* harmony export */   filterByIdhrRanges: () => (/* binding */ filterByIdhrRanges)\n/* harmony export */ });\n/* harmony import */ var _idhr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./idhr */ \"(rsc)/./src/core/features/str-aux/frame/idhr.ts\");\n\nfunction orderPoints(points) {\n    return points.map((pt, idx)=>{\n        const price = Number(pt.price);\n        if (!(price > 0)) return null;\n        const ts = Number.isFinite(pt.ts) ? Number(pt.ts) : idx;\n        return {\n            price,\n            ts\n        };\n    }).filter((p)=>Boolean(p)).sort((a, b)=>a.ts - b.ts);\n}\nfunction buildRanges(selectedPrimaries, edges, secondaryBins, binWidth) {\n    const ranges = [];\n    for (const primary of selectedPrimaries){\n        const start = primary * secondaryBins;\n        const end = Math.min(edges.length - 1, start + secondaryBins - 1);\n        if (start < 0 || end >= edges.length) continue;\n        const min = edges[start] - binWidth / 2;\n        const max = edges[end] + binWidth / 2;\n        ranges.push({\n            min,\n            max\n        });\n    }\n    return ranges;\n}\nfunction deriveIdhrRanges(points) {\n    const ordered = orderPoints(points);\n    if (ordered.length < 2) {\n        return {\n            ranges: [],\n            selectedPrimaries: [],\n            selectedBins: [],\n            anchor: null\n        };\n    }\n    const anchor = ordered[0]?.price ?? null;\n    if (!(anchor && anchor > 0)) {\n        return {\n            ranges: [],\n            selectedPrimaries: [],\n            selectedBins: [],\n            anchor: null\n        };\n    }\n    const opening = {\n        benchmark: anchor\n    };\n    const bins = (0,_idhr__WEBPACK_IMPORTED_MODULE_0__.computeIdhrBins)(ordered, opening, {\n        primaryBins: 16,\n        secondaryBins: 16,\n        selectedBins: 16\n    });\n    const ranges = buildRanges(bins.selectedPrimaries ?? [], bins.edges ?? [], bins.secondaryBins, bins.binWidth ?? 0);\n    return {\n        ranges,\n        selectedPrimaries: bins.selectedPrimaries ?? [],\n        selectedBins: bins.selectedBins ?? [],\n        anchor\n    };\n}\nfunction filterByIdhrRanges(points, info) {\n    if (!info.anchor || !info.ranges.length) {\n        return points;\n    }\n    const anchor = info.anchor;\n    const filtered = points.filter((pt)=>{\n        const price = Number(pt.price);\n        if (!(price > 0)) return false;\n        const ret = Math.log(price / anchor);\n        return info.ranges.some((range)=>ret >= range.min && ret <= range.max);\n    });\n    return filtered.length ? filtered : points;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L2ZyYW1lL2lkaHJSYW5nZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlDO0FBcUJ6QyxTQUFTQyxZQUFZQyxNQUFvQjtJQUN2QyxPQUFPQSxPQUNKQyxHQUFHLENBQUMsQ0FBQ0MsSUFBSUM7UUFDUixNQUFNQyxRQUFRQyxPQUFPSCxHQUFHRSxLQUFLO1FBQzdCLElBQUksQ0FBRUEsQ0FBQUEsUUFBUSxJQUFJLE9BQU87UUFDekIsTUFBTUUsS0FBS0QsT0FBT0UsUUFBUSxDQUFDTCxHQUFHSSxFQUFFLElBQUlELE9BQU9ILEdBQUdJLEVBQUUsSUFBSUg7UUFDcEQsT0FBTztZQUFFQztZQUFPRTtRQUFHO0lBQ3JCLEdBQ0NFLE1BQU0sQ0FBQyxDQUFDQyxJQUF5QkMsUUFBUUQsSUFDekNFLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFTixFQUFFLEdBQUdPLEVBQUVQLEVBQUU7QUFDL0I7QUFFQSxTQUFTUSxZQUNQQyxpQkFBMkIsRUFDM0JDLEtBQWUsRUFDZkMsYUFBcUIsRUFDckJDLFFBQWdCO0lBRWhCLE1BQU1DLFNBQXdCLEVBQUU7SUFDaEMsS0FBSyxNQUFNQyxXQUFXTCxrQkFBbUI7UUFDdkMsTUFBTU0sUUFBUUQsVUFBVUg7UUFDeEIsTUFBTUssTUFBTUMsS0FBS0MsR0FBRyxDQUFDUixNQUFNUyxNQUFNLEdBQUcsR0FBR0osUUFBUUosZ0JBQWdCO1FBQy9ELElBQUlJLFFBQVEsS0FBS0MsT0FBT04sTUFBTVMsTUFBTSxFQUFFO1FBQ3RDLE1BQU1ELE1BQU1SLEtBQUssQ0FBQ0ssTUFBTSxHQUFHSCxXQUFXO1FBQ3RDLE1BQU1RLE1BQU1WLEtBQUssQ0FBQ00sSUFBSSxHQUFHSixXQUFXO1FBQ3BDQyxPQUFPUSxJQUFJLENBQUM7WUFBRUg7WUFBS0U7UUFBSTtJQUN6QjtJQUNBLE9BQU9QO0FBQ1Q7QUFFTyxTQUFTUyxpQkFBaUI1QixNQUFvQjtJQUNuRCxNQUFNNkIsVUFBVTlCLFlBQVlDO0lBQzVCLElBQUk2QixRQUFRSixNQUFNLEdBQUcsR0FBRztRQUN0QixPQUFPO1lBQUVOLFFBQVEsRUFBRTtZQUFFSixtQkFBbUIsRUFBRTtZQUFFZSxjQUFjLEVBQUU7WUFBRUMsUUFBUTtRQUFLO0lBQzdFO0lBRUEsTUFBTUEsU0FBU0YsT0FBTyxDQUFDLEVBQUUsRUFBRXpCLFNBQVM7SUFDcEMsSUFBSSxDQUFFMkIsQ0FBQUEsVUFBVUEsU0FBUyxJQUFJO1FBQzNCLE9BQU87WUFBRVosUUFBUSxFQUFFO1lBQUVKLG1CQUFtQixFQUFFO1lBQUVlLGNBQWMsRUFBRTtZQUFFQyxRQUFRO1FBQUs7SUFDN0U7SUFFQSxNQUFNQyxVQUFVO1FBQUVDLFdBQVdGO0lBQU87SUFDcEMsTUFBTUcsT0FBT3BDLHNEQUFlQSxDQUFDK0IsU0FBZ0JHLFNBQWdCO1FBQzNERyxhQUFhO1FBQ2JsQixlQUFlO1FBQ2ZhLGNBQWM7SUFDaEI7SUFFQSxNQUFNWCxTQUFTTCxZQUNib0IsS0FBS25CLGlCQUFpQixJQUFJLEVBQUUsRUFDNUJtQixLQUFLbEIsS0FBSyxJQUFJLEVBQUUsRUFDaEJrQixLQUFLakIsYUFBYSxFQUNsQmlCLEtBQUtoQixRQUFRLElBQUk7SUFHbkIsT0FBTztRQUNMQztRQUNBSixtQkFBbUJtQixLQUFLbkIsaUJBQWlCLElBQUksRUFBRTtRQUMvQ2UsY0FBY0ksS0FBS0osWUFBWSxJQUFJLEVBQUU7UUFDckNDO0lBQ0Y7QUFDRjtBQUVPLFNBQVNLLG1CQUNkcEMsTUFBVyxFQUNYcUMsSUFBbUI7SUFFbkIsSUFBSSxDQUFDQSxLQUFLTixNQUFNLElBQUksQ0FBQ00sS0FBS2xCLE1BQU0sQ0FBQ00sTUFBTSxFQUFFO1FBQ3ZDLE9BQU96QjtJQUNUO0lBQ0EsTUFBTStCLFNBQVNNLEtBQUtOLE1BQU07SUFFMUIsTUFBTU8sV0FBV3RDLE9BQU9RLE1BQU0sQ0FBQyxDQUFDTjtRQUM5QixNQUFNRSxRQUFRQyxPQUFPSCxHQUFHRSxLQUFLO1FBQzdCLElBQUksQ0FBRUEsQ0FBQUEsUUFBUSxJQUFJLE9BQU87UUFDekIsTUFBTW1DLE1BQU1oQixLQUFLaUIsR0FBRyxDQUFDcEMsUUFBUTJCO1FBQzdCLE9BQU9NLEtBQUtsQixNQUFNLENBQUNzQixJQUFJLENBQUMsQ0FBQ0MsUUFBVUgsT0FBT0csTUFBTWxCLEdBQUcsSUFBSWUsT0FBT0csTUFBTWhCLEdBQUc7SUFDekU7SUFFQSxPQUFPWSxTQUFTYixNQUFNLEdBQUdhLFdBQVd0QztBQUN0QyIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGNvcmVcXGZlYXR1cmVzXFxzdHItYXV4XFxmcmFtZVxcaWRoclJhbmdlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb21wdXRlSWRockJpbnMgfSBmcm9tIFwiLi9pZGhyXCI7XG5cbmV4cG9ydCB0eXBlIFByaWNlUG9pbnQgPSB7XG4gIHByaWNlOiBudW1iZXI7XG4gIHRzPzogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgUmV0dXJuUmFuZ2UgPSB7XG4gIG1pbjogbnVtYmVyO1xuICBtYXg6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIElkaHJSYW5nZUluZm8gPSB7XG4gIHJhbmdlczogUmV0dXJuUmFuZ2VbXTtcbiAgc2VsZWN0ZWRQcmltYXJpZXM6IG51bWJlcltdO1xuICBzZWxlY3RlZEJpbnM6IG51bWJlcltdO1xuICBhbmNob3I6IG51bWJlciB8IG51bGw7XG59O1xuXG50eXBlIE9yZGVyZWRQb2ludCA9IHsgdHM6IG51bWJlcjsgcHJpY2U6IG51bWJlciB9O1xuXG5mdW5jdGlvbiBvcmRlclBvaW50cyhwb2ludHM6IFByaWNlUG9pbnRbXSk6IE9yZGVyZWRQb2ludFtdIHtcbiAgcmV0dXJuIHBvaW50c1xuICAgIC5tYXAoKHB0LCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IHByaWNlID0gTnVtYmVyKHB0LnByaWNlKTtcbiAgICAgIGlmICghKHByaWNlID4gMCkpIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgdHMgPSBOdW1iZXIuaXNGaW5pdGUocHQudHMpID8gTnVtYmVyKHB0LnRzKSA6IGlkeDtcbiAgICAgIHJldHVybiB7IHByaWNlLCB0cyB9O1xuICAgIH0pXG4gICAgLmZpbHRlcigocCk6IHAgaXMgT3JkZXJlZFBvaW50ID0+IEJvb2xlYW4ocCkpXG4gICAgLnNvcnQoKGEsIGIpID0+IGEudHMgLSBiLnRzKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRSYW5nZXMoXG4gIHNlbGVjdGVkUHJpbWFyaWVzOiBudW1iZXJbXSxcbiAgZWRnZXM6IG51bWJlcltdLFxuICBzZWNvbmRhcnlCaW5zOiBudW1iZXIsXG4gIGJpbldpZHRoOiBudW1iZXJcbik6IFJldHVyblJhbmdlW10ge1xuICBjb25zdCByYW5nZXM6IFJldHVyblJhbmdlW10gPSBbXTtcbiAgZm9yIChjb25zdCBwcmltYXJ5IG9mIHNlbGVjdGVkUHJpbWFyaWVzKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBwcmltYXJ5ICogc2Vjb25kYXJ5QmlucztcbiAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihlZGdlcy5sZW5ndGggLSAxLCBzdGFydCArIHNlY29uZGFyeUJpbnMgLSAxKTtcbiAgICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+PSBlZGdlcy5sZW5ndGgpIGNvbnRpbnVlO1xuICAgIGNvbnN0IG1pbiA9IGVkZ2VzW3N0YXJ0XSAtIGJpbldpZHRoIC8gMjtcbiAgICBjb25zdCBtYXggPSBlZGdlc1tlbmRdICsgYmluV2lkdGggLyAyO1xuICAgIHJhbmdlcy5wdXNoKHsgbWluLCBtYXggfSk7XG4gIH1cbiAgcmV0dXJuIHJhbmdlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZUlkaHJSYW5nZXMocG9pbnRzOiBQcmljZVBvaW50W10pOiBJZGhyUmFuZ2VJbmZvIHtcbiAgY29uc3Qgb3JkZXJlZCA9IG9yZGVyUG9pbnRzKHBvaW50cyk7XG4gIGlmIChvcmRlcmVkLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4geyByYW5nZXM6IFtdLCBzZWxlY3RlZFByaW1hcmllczogW10sIHNlbGVjdGVkQmluczogW10sIGFuY2hvcjogbnVsbCB9O1xuICB9XG5cbiAgY29uc3QgYW5jaG9yID0gb3JkZXJlZFswXT8ucHJpY2UgPz8gbnVsbDtcbiAgaWYgKCEoYW5jaG9yICYmIGFuY2hvciA+IDApKSB7XG4gICAgcmV0dXJuIHsgcmFuZ2VzOiBbXSwgc2VsZWN0ZWRQcmltYXJpZXM6IFtdLCBzZWxlY3RlZEJpbnM6IFtdLCBhbmNob3I6IG51bGwgfTtcbiAgfVxuXG4gIGNvbnN0IG9wZW5pbmcgPSB7IGJlbmNobWFyazogYW5jaG9yIH07XG4gIGNvbnN0IGJpbnMgPSBjb21wdXRlSWRockJpbnMob3JkZXJlZCBhcyBhbnksIG9wZW5pbmcgYXMgYW55LCB7XG4gICAgcHJpbWFyeUJpbnM6IDE2LFxuICAgIHNlY29uZGFyeUJpbnM6IDE2LFxuICAgIHNlbGVjdGVkQmluczogMTYsXG4gIH0pO1xuXG4gIGNvbnN0IHJhbmdlcyA9IGJ1aWxkUmFuZ2VzKFxuICAgIGJpbnMuc2VsZWN0ZWRQcmltYXJpZXMgPz8gW10sXG4gICAgYmlucy5lZGdlcyA/PyBbXSxcbiAgICBiaW5zLnNlY29uZGFyeUJpbnMsXG4gICAgYmlucy5iaW5XaWR0aCA/PyAwXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICByYW5nZXMsXG4gICAgc2VsZWN0ZWRQcmltYXJpZXM6IGJpbnMuc2VsZWN0ZWRQcmltYXJpZXMgPz8gW10sXG4gICAgc2VsZWN0ZWRCaW5zOiBiaW5zLnNlbGVjdGVkQmlucyA/PyBbXSxcbiAgICBhbmNob3IsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJCeUlkaHJSYW5nZXM8VCBleHRlbmRzIFByaWNlUG9pbnQ+KFxuICBwb2ludHM6IFRbXSxcbiAgaW5mbzogSWRoclJhbmdlSW5mb1xuKTogVFtdIHtcbiAgaWYgKCFpbmZvLmFuY2hvciB8fCAhaW5mby5yYW5nZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuICBjb25zdCBhbmNob3IgPSBpbmZvLmFuY2hvcjtcblxuICBjb25zdCBmaWx0ZXJlZCA9IHBvaW50cy5maWx0ZXIoKHB0KSA9PiB7XG4gICAgY29uc3QgcHJpY2UgPSBOdW1iZXIocHQucHJpY2UpO1xuICAgIGlmICghKHByaWNlID4gMCkpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCByZXQgPSBNYXRoLmxvZyhwcmljZSAvIGFuY2hvcik7XG4gICAgcmV0dXJuIGluZm8ucmFuZ2VzLnNvbWUoKHJhbmdlKSA9PiByZXQgPj0gcmFuZ2UubWluICYmIHJldCA8PSByYW5nZS5tYXgpO1xuICB9KTtcblxuICByZXR1cm4gZmlsdGVyZWQubGVuZ3RoID8gZmlsdGVyZWQgOiBwb2ludHM7XG59XG4iXSwibmFtZXMiOlsiY29tcHV0ZUlkaHJCaW5zIiwib3JkZXJQb2ludHMiLCJwb2ludHMiLCJtYXAiLCJwdCIsImlkeCIsInByaWNlIiwiTnVtYmVyIiwidHMiLCJpc0Zpbml0ZSIsImZpbHRlciIsInAiLCJCb29sZWFuIiwic29ydCIsImEiLCJiIiwiYnVpbGRSYW5nZXMiLCJzZWxlY3RlZFByaW1hcmllcyIsImVkZ2VzIiwic2Vjb25kYXJ5QmlucyIsImJpbldpZHRoIiwicmFuZ2VzIiwicHJpbWFyeSIsInN0YXJ0IiwiZW5kIiwiTWF0aCIsIm1pbiIsImxlbmd0aCIsIm1heCIsInB1c2giLCJkZXJpdmVJZGhyUmFuZ2VzIiwib3JkZXJlZCIsInNlbGVjdGVkQmlucyIsImFuY2hvciIsIm9wZW5pbmciLCJiZW5jaG1hcmsiLCJiaW5zIiwicHJpbWFyeUJpbnMiLCJmaWx0ZXJCeUlkaHJSYW5nZXMiLCJpbmZvIiwiZmlsdGVyZWQiLCJyZXQiLCJsb2ciLCJzb21lIiwicmFuZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/frame/idhrRanges.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/frame/session.ts":
/*!****************************************************!*\
  !*** ./src/core/features/str-aux/frame/session.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportStreams: () => (/* binding */ exportStreams),\n/* harmony export */   getOrInitSymbolSession: () => (/* binding */ getOrInitSymbolSession),\n/* harmony export */   updateSymbolSession: () => (/* binding */ updateSymbolSession)\n/* harmony export */ });\n// --- TYPES ---\nconst SESS = globalThis.__STR_AUX_SESS__ ?? new Map();\nglobalThis.__STR_AUX_SESS__ = SESS;\nfunction sgn(x, eps = 0) {\n    if (x > eps) return 1;\n    if (x < -eps) return -1;\n    return 0;\n}\nfunction getOrInitSymbolSession(sessionId, symbol, openingPrice, nowTs, etaPct = 0.05, epsShiftPct = 0.2, K = 5) {\n    const key = `${sessionId}:${symbol}`;\n    const cur = SESS.get(key);\n    if (cur) return cur;\n    const snap0 = {\n        ts: nowTs,\n        price: openingPrice,\n        benchPct: 0,\n        pctDrv: 0,\n        pct24h: 0\n    };\n    const ss = {\n        openingTs: nowTs,\n        openingPrice,\n        priceMin: openingPrice,\n        priceMax: openingPrice,\n        benchPctMin: 0,\n        benchPctMax: 0,\n        swaps: 0,\n        shifts: 0,\n        etaPct,\n        epsShiftPct,\n        K,\n        lastBenchSign: 0,\n        gfmRefPrice: undefined,\n        gfmCalcPrice: undefined,\n        gfmOpeningPrice: undefined,\n        aboveCount: 0,\n        belowCount: 0,\n        uiEpoch: 0,\n        snapPrev: snap0,\n        snapCur: snap0,\n        greatestBenchAbs: 0,\n        greatestDrvAbs: 0,\n        greatestPct24hAbs: 0,\n        gfmDeltaAbsPct: 0,\n        lastPrice: openingPrice\n    };\n    SESS.set(key, ss);\n    return ss;\n}\n/**\n * Update with latest market data + CURRENT calculated GFM (GFMc).\n * - Initializes GFMr once (first valid GFMc).\n * - Builds band around GFMr. Counts consecutive out-of-band hits.\n * - On confirmation (>=K): shift, snapshot prev/cur, re-anchor GFMr = current GFMc, uiEpoch++.\n */ function updateSymbolSession(ss, price, ts, gfmCalcPrice, pct24hNow) {\n    // record current calc GFM\n    if (Number.isFinite(gfmCalcPrice) && gfmCalcPrice > 0) {\n        ss.gfmCalcPrice = gfmCalcPrice;\n    }\n    // initialize anchor GFMr once\n    if (ss.gfmRefPrice === undefined && ss.gfmCalcPrice !== undefined && ss.gfmCalcPrice > 0) {\n        ss.gfmRefPrice = ss.gfmCalcPrice;\n        if (ss.gfmOpeningPrice === undefined) {\n            ss.gfmOpeningPrice = ss.gfmCalcPrice;\n        }\n    }\n    // instantaneous\n    const benchPct = (price / ss.openingPrice - 1) * 100;\n    const prevPrice = ss.lastPrice ?? price;\n    const pctDrv = (price / prevPrice - 1) * 100;\n    ss.lastPrice = price;\n    // stats\n    ss.priceMin = Math.min(ss.priceMin, price);\n    ss.priceMax = Math.max(ss.priceMax, price);\n    ss.benchPctMin = Math.min(ss.benchPctMin, benchPct);\n    ss.benchPctMax = Math.max(ss.benchPctMax, benchPct);\n    // swaps with small hysteresis on benchPct\n    const s = sgn(benchPct, ss.etaPct);\n    if (s !== 0 && ss.lastBenchSign !== 0 && s !== ss.lastBenchSign) ss.swaps += 1;\n    if (s !== 0) ss.lastBenchSign = s;\n    // GFM relative to GFMr\n    const refGfm = ss.gfmRefPrice;\n    const calcGfm = ss.gfmCalcPrice;\n    const deltaPct = refGfm && refGfm > 0 && calcGfm && calcGfm > 0 ? (calcGfm / refGfm - 1) * 100 : 0;\n    ss.gfmDeltaAbsPct = Math.abs(deltaPct);\n    // shift detection: positive delta vs GFMr must persist for K cycles\n    let justShifted = false;\n    if (refGfm && refGfm > 0 && calcGfm && calcGfm > 0) {\n        if (deltaPct >= ss.epsShiftPct) {\n            ss.aboveCount += 1;\n        } else {\n            ss.aboveCount = 0;\n        }\n        ss.belowCount = 0;\n        if (ss.aboveCount >= ss.K) {\n            // snapshot + re-anchor to CURRENT GFMc\n            snapshotOnShift(ss, price, ts, benchPct, pctDrv, pct24hNow);\n            ss.gfmRefPrice = calcGfm; // GFMr  GFMc\n            ss.gfmDeltaAbsPct = 0;\n            ss.aboveCount = 0;\n            ss.belowCount = 0;\n            ss.shifts += 1;\n            ss.uiEpoch += 1; // UI change signal\n            justShifted = true;\n        }\n    } else {\n        ss.aboveCount = 0;\n        ss.belowCount = 0;\n    }\n    // greatest magnitudes\n    ss.greatestBenchAbs = Math.max(ss.greatestBenchAbs, Math.abs(benchPct));\n    ss.greatestDrvAbs = Math.max(ss.greatestDrvAbs, Math.abs(pctDrv));\n    ss.greatestPct24hAbs = Math.max(ss.greatestPct24hAbs, Math.abs(pct24hNow));\n    return {\n        benchPct,\n        pctDrv,\n        pct24h: pct24hNow,\n        isShift: justShifted,\n        gfmDeltaAbsPct: ss.gfmDeltaAbsPct,\n        gfmRefPrice: ss.gfmRefPrice ?? null,\n        gfmCalcPrice: ss.gfmCalcPrice ?? null,\n        uiEpoch: ss.uiEpoch\n    };\n}\nfunction snapshotOnShift(ss, price, ts, benchPct, pctDrv, pct24h) {\n    ss.snapPrev = ss.snapCur;\n    ss.snapCur = {\n        ts,\n        price,\n        benchPct,\n        pctDrv,\n        pct24h\n    };\n}\nfunction exportStreams(ss) {\n    return {\n        benchmark: {\n            prev: ss.snapPrev.price,\n            cur: ss.snapCur.price,\n            greatest: ss.priceMax\n        },\n        pct24h: {\n            prev: ss.snapPrev.pct24h,\n            cur: ss.snapCur.pct24h,\n            greatest: ss.greatestPct24hAbs\n        },\n        pct_drv: {\n            prev: ss.snapPrev.pctDrv,\n            cur: ss.snapCur.pctDrv,\n            greatest: ss.greatestDrvAbs\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L2ZyYW1lL3Nlc3Npb24udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0JBQWdCO0FBcUVoQixNQUFNQSxPQUNKLFdBQW9CRSxnQkFBZ0IsSUFBSSxJQUFJQztBQUM3Q0YsV0FBbUJDLGdCQUFnQixHQUFHRjtBQUV2QyxTQUFTSSxJQUFJQyxDQUFTLEVBQUVDLE1BQU0sQ0FBQztJQUM3QixJQUFJRCxJQUFJQyxLQUFLLE9BQU87SUFDcEIsSUFBSUQsSUFBSSxDQUFDQyxLQUFLLE9BQU8sQ0FBQztJQUN0QixPQUFPO0FBQ1Q7QUFFTyxTQUFTQyx1QkFDZEMsU0FBaUIsRUFDakJDLE1BQWMsRUFDZEMsWUFBb0IsRUFDcEJDLEtBQWEsRUFDYkMsU0FBUyxJQUFJLEVBQ2JDLGNBQWMsR0FBRyxFQUNqQkMsSUFBSSxDQUFDO0lBRUwsTUFBTUMsTUFBTSxHQUFHUCxVQUFVLENBQUMsRUFBRUMsUUFBUTtJQUNwQyxNQUFNTyxNQUFNaEIsS0FBS2lCLEdBQUcsQ0FBQ0Y7SUFDckIsSUFBSUMsS0FBSyxPQUFPQTtJQUVoQixNQUFNRSxRQUFrQjtRQUFFQyxJQUFJUjtRQUFPUyxPQUFPVjtRQUFjVyxVQUFVO1FBQUdDLFFBQVE7UUFBR0MsUUFBUTtJQUFFO0lBQzVGLE1BQU1DLEtBQW9CO1FBQ3hCQyxXQUFXZDtRQUNYRDtRQUVBZ0IsVUFBVWhCO1FBQ1ZpQixVQUFVakI7UUFDVmtCLGFBQWE7UUFDYkMsYUFBYTtRQUViQyxPQUFPO1FBQ1BDLFFBQVE7UUFFUm5CO1FBQ0FDO1FBQ0FDO1FBRUFrQixlQUFlO1FBRWZDLGFBQWFDO1FBQ2JDLGNBQWNEO1FBQ2RFLGlCQUFpQkY7UUFFakJHLFlBQVk7UUFDWkMsWUFBWTtRQUVaQyxTQUFTO1FBRVRDLFVBQVV0QjtRQUNWdUIsU0FBU3ZCO1FBRVR3QixrQkFBa0I7UUFDbEJDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBRW5CQyxnQkFBZ0I7UUFFaEJDLFdBQVdwQztJQUNi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QVEsQ0FBQ2xCLE1BQU07WUFBRU4sS0FBS1EsR0FBR2lCLE9BQU8sQ0FBQ25CLE1BQU07WUFBRTZDLFVBQVUzQyxHQUFHbUIsY0FBYztRQUFDO0lBQzdGO0FBQ0YiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxjb3JlXFxmZWF0dXJlc1xcc3RyLWF1eFxcZnJhbWVcXHNlc3Npb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gLS0tIFRZUEVTIC0tLVxuZXhwb3J0IHR5cGUgU25hcHNob3QgPSB7XG4gIHRzOiBudW1iZXI7XG4gIHByaWNlOiBudW1iZXI7XG4gIGJlbmNoUGN0OiBudW1iZXI7ICAgLy8gMTAwKihwL29wZW4tMSlcbiAgcGN0RHJ2OiBudW1iZXI7ICAgICAvLyAxMDAqKHBfdC9wX3t0LTF9LTEpXG4gIHBjdDI0aDogbnVtYmVyOyAgICAgLy8gZnJvbSBCaW5hbmNlIDI0aFxufTtcblxuZXhwb3J0IHR5cGUgU3RyZWFtcyA9IHtcbiAgYmVuY2htYXJrOiB7IHByZXY6IG51bWJlcjsgY3VyOiBudW1iZXI7IGdyZWF0ZXN0OiBudW1iZXIgfTtcbiAgcGN0MjRoOiAgICB7IHByZXY6IG51bWJlcjsgY3VyOiBudW1iZXI7IGdyZWF0ZXN0OiBudW1iZXIgfTtcbiAgcGN0X2RydjogICB7IHByZXY6IG51bWJlcjsgY3VyOiBudW1iZXI7IGdyZWF0ZXN0OiBudW1iZXIgfTtcbn07XG5cbmV4cG9ydCB0eXBlIFN5bWJvbFNlc3Npb24gPSB7XG4gIG9wZW5pbmdUczogbnVtYmVyO1xuICBvcGVuaW5nUHJpY2U6IG51bWJlcjtcblxuICAvLyBzdGF0c1xuICBwcmljZU1pbjogbnVtYmVyO1xuICBwcmljZU1heDogbnVtYmVyO1xuICBiZW5jaFBjdE1pbjogbnVtYmVyO1xuICBiZW5jaFBjdE1heDogbnVtYmVyO1xuXG4gIC8vIGNvdW50ZXJzXG4gIHN3YXBzOiBudW1iZXI7XG4gIHNoaWZ0czogbnVtYmVyO1xuXG4gIC8vIHRocmVzaG9sZHNcbiAgZXRhUGN0OiBudW1iZXI7ICAgICAgLy8gc3dhcCBoeXN0ZXJlc2lzICUsIHRpbnkgZS5nLiAwLjA1XG4gIGVwc1NoaWZ0UGN0OiBudW1iZXI7IC8vIHNoaWZ0IGJhbmQgJSwgZS5nLiAwLjJcbiAgSzogbnVtYmVyOyAgICAgICAgICAgLy8gY29uc2VjdXRpdmUgY3ljbGVzXG5cbiAgLy8gc2lnbnNcbiAgbGFzdEJlbmNoU2lnbjogbnVtYmVyO1xuXG4gIC8vIEdGTTpcbiAgZ2ZtUmVmUHJpY2U/OiBudW1iZXI7ICAgICAgLy8gR0ZNciAoYW5jaG9yKTogbW92ZXMgT05MWSBvbiBjb25maXJtZWQgc2hpZnRcbiAgZ2ZtQ2FsY1ByaWNlPzogbnVtYmVyOyAgICAgLy8gR0ZNYyAobGF0ZXN0IGNhbGMpOiByZWNhbGN1bGF0ZWQgZXZlcnkgdGlja1xuICBnZm1PcGVuaW5nUHJpY2U/OiBudW1iZXI7ICAvLyBHRk0gYXQgc2Vzc2lvbiBzdGFydCAob0dGTSlcbiAgXG4gIC8vIHNoaWZ0IHN0YWdpbmdcbiAgYWJvdmVDb3VudDogbnVtYmVyO1xuICBiZWxvd0NvdW50OiBudW1iZXI7XG5cbiAgLy8gVUkgZXBvY2ggKGluY3JlbWVudHMgb25seSBvbiBzaGlmdClcbiAgdWlFcG9jaDogbnVtYmVyO1xuXG4gIC8vIHNuYXBzaG90cyAoYWR2YW5jZSBvbmx5IG9uIHNoaWZ0KVxuICBzbmFwUHJldjogU25hcHNob3Q7XG4gIHNuYXBDdXI6IFNuYXBzaG90O1xuXG4gIC8vIGdyZWF0ZXN0IG1hZ25pdHVkZXMgKGFicylcbiAgZ3JlYXRlc3RCZW5jaEFiczogbnVtYmVyO1xuICBncmVhdGVzdERydkFiczogbnVtYmVyO1xuICBncmVhdGVzdFBjdDI0aEFiczogbnVtYmVyO1xuXG4gIC8vIGRpYWdub3N0aWNzXG4gIGdmbURlbHRhQWJzUGN0OiBudW1iZXI7XG5cbiAgbGFzdFByaWNlPzogbnVtYmVyO1xufTtcblxuLy8gSE1SLXNhZmUgc3RvcmVcbmRlY2xhcmUgZ2xvYmFsIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhclxuICB2YXIgX19TVFJfQVVYX1NFU1NfXzogTWFwPHN0cmluZywgU3ltYm9sU2Vzc2lvbj4gfCB1bmRlZmluZWQ7XG59XG5jb25zdCBTRVNTOiBNYXA8c3RyaW5nLCBTeW1ib2xTZXNzaW9uPiA9XG4gIChnbG9iYWxUaGlzIGFzIGFueSkuX19TVFJfQVVYX1NFU1NfXyA/PyBuZXcgTWFwKCk7XG4oZ2xvYmFsVGhpcyBhcyBhbnkpLl9fU1RSX0FVWF9TRVNTX18gPSBTRVNTO1xuXG5mdW5jdGlvbiBzZ24oeDogbnVtYmVyLCBlcHMgPSAwKSB7XG4gIGlmICh4ID4gZXBzKSByZXR1cm4gMTtcbiAgaWYgKHggPCAtZXBzKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3JJbml0U3ltYm9sU2Vzc2lvbihcbiAgc2Vzc2lvbklkOiBzdHJpbmcsXG4gIHN5bWJvbDogc3RyaW5nLFxuICBvcGVuaW5nUHJpY2U6IG51bWJlcixcbiAgbm93VHM6IG51bWJlcixcbiAgZXRhUGN0ID0gMC4wNSxcbiAgZXBzU2hpZnRQY3QgPSAwLjIsXG4gIEsgPSA1XG4pOiBTeW1ib2xTZXNzaW9uIHtcbiAgY29uc3Qga2V5ID0gYCR7c2Vzc2lvbklkfToke3N5bWJvbH1gO1xuICBjb25zdCBjdXIgPSBTRVNTLmdldChrZXkpO1xuICBpZiAoY3VyKSByZXR1cm4gY3VyO1xuXG4gIGNvbnN0IHNuYXAwOiBTbmFwc2hvdCA9IHsgdHM6IG5vd1RzLCBwcmljZTogb3BlbmluZ1ByaWNlLCBiZW5jaFBjdDogMCwgcGN0RHJ2OiAwLCBwY3QyNGg6IDAgfTtcbiAgY29uc3Qgc3M6IFN5bWJvbFNlc3Npb24gPSB7XG4gICAgb3BlbmluZ1RzOiBub3dUcyxcbiAgICBvcGVuaW5nUHJpY2UsXG5cbiAgICBwcmljZU1pbjogb3BlbmluZ1ByaWNlLFxuICAgIHByaWNlTWF4OiBvcGVuaW5nUHJpY2UsXG4gICAgYmVuY2hQY3RNaW46IDAsXG4gICAgYmVuY2hQY3RNYXg6IDAsXG5cbiAgICBzd2FwczogMCxcbiAgICBzaGlmdHM6IDAsXG5cbiAgICBldGFQY3QsXG4gICAgZXBzU2hpZnRQY3QsXG4gICAgSyxcblxuICAgIGxhc3RCZW5jaFNpZ246IDAsXG5cbiAgICBnZm1SZWZQcmljZTogdW5kZWZpbmVkLFxuICAgIGdmbUNhbGNQcmljZTogdW5kZWZpbmVkLFxuICAgIGdmbU9wZW5pbmdQcmljZTogdW5kZWZpbmVkLFxuXG4gICAgYWJvdmVDb3VudDogMCxcbiAgICBiZWxvd0NvdW50OiAwLFxuXG4gICAgdWlFcG9jaDogMCxcblxuICAgIHNuYXBQcmV2OiBzbmFwMCxcbiAgICBzbmFwQ3VyOiBzbmFwMCxcblxuICAgIGdyZWF0ZXN0QmVuY2hBYnM6IDAsXG4gICAgZ3JlYXRlc3REcnZBYnM6IDAsXG4gICAgZ3JlYXRlc3RQY3QyNGhBYnM6IDAsXG5cbiAgICBnZm1EZWx0YUFic1BjdDogMCxcblxuICAgIGxhc3RQcmljZTogb3BlbmluZ1ByaWNlLFxuICB9O1xuICBTRVNTLnNldChrZXksIHNzKTtcbiAgcmV0dXJuIHNzO1xufVxuXG4vKipcbiAqIFVwZGF0ZSB3aXRoIGxhdGVzdCBtYXJrZXQgZGF0YSArIENVUlJFTlQgY2FsY3VsYXRlZCBHRk0gKEdGTWMpLlxuICogLSBJbml0aWFsaXplcyBHRk1yIG9uY2UgKGZpcnN0IHZhbGlkIEdGTWMpLlxuICogLSBCdWlsZHMgYmFuZCBhcm91bmQgR0ZNci4gQ291bnRzIGNvbnNlY3V0aXZlIG91dC1vZi1iYW5kIGhpdHMuXG4gKiAtIE9uIGNvbmZpcm1hdGlvbiAoPj1LKTogc2hpZnQsIHNuYXBzaG90IHByZXYvY3VyLCByZS1hbmNob3IgR0ZNciA9IGN1cnJlbnQgR0ZNYywgdWlFcG9jaCsrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlU3ltYm9sU2Vzc2lvbihcbiAgc3M6IFN5bWJvbFNlc3Npb24sXG4gIHByaWNlOiBudW1iZXIsXG4gIHRzOiBudW1iZXIsXG4gIGdmbUNhbGNQcmljZTogbnVtYmVyLCAvLyBHRk1jXG4gIHBjdDI0aE5vdzogbnVtYmVyXG4pIHtcbiAgLy8gcmVjb3JkIGN1cnJlbnQgY2FsYyBHRk1cbiAgaWYgKE51bWJlci5pc0Zpbml0ZShnZm1DYWxjUHJpY2UpICYmIGdmbUNhbGNQcmljZSA+IDApIHtcbiAgICBzcy5nZm1DYWxjUHJpY2UgPSBnZm1DYWxjUHJpY2U7XG4gIH1cblxuICAvLyBpbml0aWFsaXplIGFuY2hvciBHRk1yIG9uY2VcbiAgaWYgKHNzLmdmbVJlZlByaWNlID09PSB1bmRlZmluZWQgJiYgc3MuZ2ZtQ2FsY1ByaWNlICE9PSB1bmRlZmluZWQgJiYgc3MuZ2ZtQ2FsY1ByaWNlID4gMCkge1xuICAgIHNzLmdmbVJlZlByaWNlID0gc3MuZ2ZtQ2FsY1ByaWNlO1xuICAgIGlmIChzcy5nZm1PcGVuaW5nUHJpY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3MuZ2ZtT3BlbmluZ1ByaWNlID0gc3MuZ2ZtQ2FsY1ByaWNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluc3RhbnRhbmVvdXNcbiAgY29uc3QgYmVuY2hQY3QgPSAoKHByaWNlIC8gc3Mub3BlbmluZ1ByaWNlKSAtIDEpICogMTAwO1xuICBjb25zdCBwcmV2UHJpY2UgPSBzcy5sYXN0UHJpY2UgPz8gcHJpY2U7XG4gIGNvbnN0IHBjdERydiA9ICgocHJpY2UgLyBwcmV2UHJpY2UpIC0gMSkgKiAxMDA7XG4gIHNzLmxhc3RQcmljZSA9IHByaWNlO1xuXG4gIC8vIHN0YXRzXG4gIHNzLnByaWNlTWluID0gTWF0aC5taW4oc3MucHJpY2VNaW4sIHByaWNlKTtcbiAgc3MucHJpY2VNYXggPSBNYXRoLm1heChzcy5wcmljZU1heCwgcHJpY2UpO1xuICBzcy5iZW5jaFBjdE1pbiA9IE1hdGgubWluKHNzLmJlbmNoUGN0TWluLCBiZW5jaFBjdCk7XG4gIHNzLmJlbmNoUGN0TWF4ID0gTWF0aC5tYXgoc3MuYmVuY2hQY3RNYXgsIGJlbmNoUGN0KTtcblxuICAvLyBzd2FwcyB3aXRoIHNtYWxsIGh5c3RlcmVzaXMgb24gYmVuY2hQY3RcbiAgY29uc3QgcyA9IHNnbihiZW5jaFBjdCwgc3MuZXRhUGN0KTtcbiAgaWYgKHMgIT09IDAgJiYgc3MubGFzdEJlbmNoU2lnbiAhPT0gMCAmJiBzICE9PSBzcy5sYXN0QmVuY2hTaWduKSBzcy5zd2FwcyArPSAxO1xuICBpZiAocyAhPT0gMCkgc3MubGFzdEJlbmNoU2lnbiA9IHM7XG5cbiAgLy8gR0ZNzpQgcmVsYXRpdmUgdG8gR0ZNclxuICBjb25zdCByZWZHZm0gPSBzcy5nZm1SZWZQcmljZTtcbiAgY29uc3QgY2FsY0dmbSA9IHNzLmdmbUNhbGNQcmljZTtcbiAgY29uc3QgZGVsdGFQY3QgPVxuICAgIHJlZkdmbSAmJiByZWZHZm0gPiAwICYmIGNhbGNHZm0gJiYgY2FsY0dmbSA+IDBcbiAgICAgID8gKChjYWxjR2ZtIC8gcmVmR2ZtKSAtIDEpICogMTAwXG4gICAgICA6IDA7XG4gIHNzLmdmbURlbHRhQWJzUGN0ID0gTWF0aC5hYnMoZGVsdGFQY3QpO1xuXG4gIC8vIHNoaWZ0IGRldGVjdGlvbjogcG9zaXRpdmUgZGVsdGEgdnMgR0ZNciBtdXN0IHBlcnNpc3QgZm9yIEsgY3ljbGVzXG4gIGxldCBqdXN0U2hpZnRlZCA9IGZhbHNlO1xuICBpZiAocmVmR2ZtICYmIHJlZkdmbSA+IDAgJiYgY2FsY0dmbSAmJiBjYWxjR2ZtID4gMCkge1xuICAgIGlmIChkZWx0YVBjdCA+PSBzcy5lcHNTaGlmdFBjdCkge1xuICAgICAgc3MuYWJvdmVDb3VudCArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzcy5hYm92ZUNvdW50ID0gMDtcbiAgICB9XG4gICAgc3MuYmVsb3dDb3VudCA9IDA7XG5cbiAgICBpZiAoc3MuYWJvdmVDb3VudCA+PSBzcy5LKSB7XG4gICAgICAvLyBzbmFwc2hvdCArIHJlLWFuY2hvciB0byBDVVJSRU5UIEdGTWNcbiAgICAgIHNuYXBzaG90T25TaGlmdChzcywgcHJpY2UsIHRzLCBiZW5jaFBjdCwgcGN0RHJ2LCBwY3QyNGhOb3cpO1xuICAgICAgc3MuZ2ZtUmVmUHJpY2UgPSBjYWxjR2ZtOyAvLyBHRk1yIOKGkCBHRk1jXG4gICAgICBzcy5nZm1EZWx0YUFic1BjdCA9IDA7XG4gICAgICBzcy5hYm92ZUNvdW50ID0gMDtcbiAgICAgIHNzLmJlbG93Q291bnQgPSAwO1xuICAgICAgc3Muc2hpZnRzICs9IDE7XG4gICAgICBzcy51aUVwb2NoICs9IDE7ICAgICAgICAgICAgICAgICAvLyBVSSBjaGFuZ2Ugc2lnbmFsXG4gICAgICBqdXN0U2hpZnRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNzLmFib3ZlQ291bnQgPSAwO1xuICAgIHNzLmJlbG93Q291bnQgPSAwO1xuICB9XG5cbiAgLy8gZ3JlYXRlc3QgbWFnbml0dWRlc1xuICBzcy5ncmVhdGVzdEJlbmNoQWJzICA9IE1hdGgubWF4KHNzLmdyZWF0ZXN0QmVuY2hBYnMsICBNYXRoLmFicyhiZW5jaFBjdCkpO1xuICBzcy5ncmVhdGVzdERydkFicyAgICA9IE1hdGgubWF4KHNzLmdyZWF0ZXN0RHJ2QWJzLCAgICBNYXRoLmFicyhwY3REcnYpKTtcbiAgc3MuZ3JlYXRlc3RQY3QyNGhBYnMgPSBNYXRoLm1heChzcy5ncmVhdGVzdFBjdDI0aEFicywgTWF0aC5hYnMocGN0MjRoTm93KSk7XG5cbiAgcmV0dXJuIHtcbiAgICBiZW5jaFBjdCwgcGN0RHJ2LCBwY3QyNGg6IHBjdDI0aE5vdyxcbiAgICBpc1NoaWZ0OiBqdXN0U2hpZnRlZCxcbiAgICBnZm1EZWx0YUFic1BjdDogc3MuZ2ZtRGVsdGFBYnNQY3QsXG4gICAgZ2ZtUmVmUHJpY2U6IHNzLmdmbVJlZlByaWNlID8/IG51bGwsXG4gICAgZ2ZtQ2FsY1ByaWNlOiBzcy5nZm1DYWxjUHJpY2UgPz8gbnVsbCxcbiAgICB1aUVwb2NoOiBzcy51aUVwb2NoLFxuICB9O1xufVxuXG5mdW5jdGlvbiBzbmFwc2hvdE9uU2hpZnQoXG4gIHNzOiBTeW1ib2xTZXNzaW9uLFxuICBwcmljZTogbnVtYmVyLFxuICB0czogbnVtYmVyLFxuICBiZW5jaFBjdDogbnVtYmVyLFxuICBwY3REcnY6IG51bWJlcixcbiAgcGN0MjRoOiBudW1iZXJcbikge1xuICBzcy5zbmFwUHJldiA9IHNzLnNuYXBDdXI7XG4gIHNzLnNuYXBDdXIgPSB7IHRzLCBwcmljZSwgYmVuY2hQY3QsIHBjdERydiwgcGN0MjRoIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBvcnRTdHJlYW1zKHNzOiBTeW1ib2xTZXNzaW9uKTogU3RyZWFtcyB7XG4gIHJldHVybiB7XG4gICAgYmVuY2htYXJrOiB7IHByZXY6IHNzLnNuYXBQcmV2LnByaWNlLCBjdXI6IHNzLnNuYXBDdXIucHJpY2UsIGdyZWF0ZXN0OiBzcy5wcmljZU1heCB9LFxuICAgIHBjdDI0aDogICAgeyBwcmV2OiBzcy5zbmFwUHJldi5wY3QyNGgsIGN1cjogc3Muc25hcEN1ci5wY3QyNGgsIGdyZWF0ZXN0OiBzcy5ncmVhdGVzdFBjdDI0aEFicyB9LFxuICAgIHBjdF9kcnY6ICAgeyBwcmV2OiBzcy5zbmFwUHJldi5wY3REcnYsIGN1cjogc3Muc25hcEN1ci5wY3REcnYsIGdyZWF0ZXN0OiBzcy5ncmVhdGVzdERydkFicyB9LFxuICB9O1xufVxuIl0sIm5hbWVzIjpbIlNFU1MiLCJnbG9iYWxUaGlzIiwiX19TVFJfQVVYX1NFU1NfXyIsIk1hcCIsInNnbiIsIngiLCJlcHMiLCJnZXRPckluaXRTeW1ib2xTZXNzaW9uIiwic2Vzc2lvbklkIiwic3ltYm9sIiwib3BlbmluZ1ByaWNlIiwibm93VHMiLCJldGFQY3QiLCJlcHNTaGlmdFBjdCIsIksiLCJrZXkiLCJjdXIiLCJnZXQiLCJzbmFwMCIsInRzIiwicHJpY2UiLCJiZW5jaFBjdCIsInBjdERydiIsInBjdDI0aCIsInNzIiwib3BlbmluZ1RzIiwicHJpY2VNaW4iLCJwcmljZU1heCIsImJlbmNoUGN0TWluIiwiYmVuY2hQY3RNYXgiLCJzd2FwcyIsInNoaWZ0cyIsImxhc3RCZW5jaFNpZ24iLCJnZm1SZWZQcmljZSIsInVuZGVmaW5lZCIsImdmbUNhbGNQcmljZSIsImdmbU9wZW5pbmdQcmljZSIsImFib3ZlQ291bnQiLCJiZWxvd0NvdW50IiwidWlFcG9jaCIsInNuYXBQcmV2Iiwic25hcEN1ciIsImdyZWF0ZXN0QmVuY2hBYnMiLCJncmVhdGVzdERydkFicyIsImdyZWF0ZXN0UGN0MjRoQWJzIiwiZ2ZtRGVsdGFBYnNQY3QiLCJsYXN0UHJpY2UiLCJzZXQiLCJ1cGRhdGVTeW1ib2xTZXNzaW9uIiwicGN0MjRoTm93IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJwcmV2UHJpY2UiLCJNYXRoIiwibWluIiwibWF4IiwicyIsInJlZkdmbSIsImNhbGNHZm0iLCJkZWx0YVBjdCIsImFicyIsImp1c3RTaGlmdGVkIiwic25hcHNob3RPblNoaWZ0IiwiaXNTaGlmdCIsImV4cG9ydFN0cmVhbXMiLCJiZW5jaG1hcmsiLCJwcmV2IiwiZ3JlYXRlc3QiLCJwY3RfZHJ2Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/frame/session.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/sampling/buckets.ts":
/*!*******************************************************!*\
  !*** ./src/core/features/str-aux/sampling/buckets.ts ***!
  \*******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ingestOrderBookTick: () => (/* binding */ ingestOrderBookTick)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"(rsc)/./src/core/features/str-aux/sampling/utils.ts\");\n/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./store */ \"(rsc)/./src/core/features/str-aux/sampling/store.ts\");\n/* harmony import */ var _persistence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./persistence */ \"(rsc)/./src/core/features/str-aux/sampling/persistence.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_store__WEBPACK_IMPORTED_MODULE_1__, _persistence__WEBPACK_IMPORTED_MODULE_2__]);\n([_store__WEBPACK_IMPORTED_MODULE_1__, _persistence__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\nconst STEP_MS = _utils__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SAMPLER_CONFIG.pointIntervalMs;\nconst POLL_MS = Number(process.env.STR_SAMPLER_POLL_MS ?? 1000);\nconst GAP_WARN_MS = Number(process.env.STR_SAMPLER_GAP_WARN_MS ?? POLL_MS * 2);\nconst MIN_BUCKET_SNAPSHOTS = Number(process.env.STR_SAMPLER_MIN_BUCKET_SAMPLES ?? 2);\nconst buckets = new Map();\nasync function ingestOrderBookTick(payload) {\n    const symbol = String(payload.symbol ?? \"\").toUpperCase();\n    if (!symbol) return;\n    const ts = Number.isFinite(payload.ts) ? Number(payload.ts) : Date.now();\n    const start = Math.floor(ts / STEP_MS) * STEP_MS;\n    const end = start + STEP_MS;\n    let bucket = buckets.get(symbol);\n    if (!bucket || bucket.end !== end) {\n        if (bucket) await flushBucket(bucket);\n        bucket = {\n            symbol,\n            start,\n            end,\n            snapshots: []\n        };\n        buckets.set(symbol, bucket);\n    }\n    const snapshot = {\n        ts,\n        bids: toLevels(payload.bids, \"bids\"),\n        asks: toLevels(payload.asks, \"asks\"),\n        mid: Number.isFinite(payload.mid) ? Number(payload.mid) : estimateMid(payload),\n        bestBid: Number.isFinite(payload.bestBid) ? Number(payload.bestBid) : maxPrice(payload.bids),\n        bestAsk: Number.isFinite(payload.bestAsk) ? Number(payload.bestAsk) : minPrice(payload.asks)\n    };\n    bucket.snapshots.push(snapshot);\n}\nasync function flushBucket(bucket) {\n    if (!bucket.snapshots.length) return;\n    const point = buildPointFromBucket(bucket);\n    const store = (0,_store__WEBPACK_IMPORTED_MODULE_1__.getSamplingStore)();\n    await store.collect(bucket.symbol, {\n        force: true,\n        point\n    });\n    (0,_persistence__WEBPACK_IMPORTED_MODULE_2__.enqueueBucketPersistence)(point);\n}\nfunction buildPointFromBucket(bucket) {\n    const last = bucket.snapshots[bucket.snapshots.length - 1];\n    const avgMid = bucket.snapshots.reduce((sum, snap)=>sum + snap.mid, 0) / Math.max(1, bucket.snapshots.length);\n    const bids = aggregateLevels(bucket.snapshots, \"bids\");\n    const asks = aggregateLevels(bucket.snapshots, \"asks\");\n    const bidVol = bids.reduce((sum, lvl)=>sum + lvl.qty, 0);\n    const askVol = asks.reduce((sum, lvl)=>sum + lvl.qty, 0);\n    const topVolumes = computeTopVolumes(bids, asks);\n    const spreadStats = computeSpreadStats(bucket.snapshots);\n    const tickStats = computeTickStats(bucket.snapshots);\n    const midStats = computeMidStats(bucket.snapshots);\n    const liquidityImbalance = topVolumes.total > 0 ? (topVolumes.bid - topVolumes.ask) / topVolumes.total : null;\n    const qualityFlags = deriveQualityFlags({\n        bucketCount: bucket.snapshots.length,\n        hasBook: bids.length > 0 && asks.length > 0,\n        tickMsMax: tickStats.max\n    });\n    return {\n        symbol: bucket.symbol,\n        ts: bucket.end,\n        mid: avgMid,\n        bestBid: last.bestBid,\n        bestAsk: last.bestAsk,\n        spread: Math.abs(last.bestAsk - last.bestBid),\n        bidVolume: bidVol,\n        askVolume: askVol,\n        bucketStart: bucket.start,\n        bucketEnd: bucket.end,\n        book: {\n            bids,\n            asks\n        },\n        bucketMeta: {\n            bucketCount: bucket.snapshots.length,\n            tickMsMin: tickStats.min,\n            tickMsMax: tickStats.max,\n            tickMsAvg: tickStats.avg,\n            spreadMin: spreadStats.min,\n            spreadMax: spreadStats.max,\n            spreadAvg: spreadStats.avg,\n            midMin: midStats.min,\n            midMax: midStats.max,\n            topBidVol: topVolumes.bid,\n            topAskVol: topVolumes.ask,\n            liquidityImbalance,\n            qualityFlags\n        }\n    };\n}\nfunction toLevels(rows, side) {\n    if (!Array.isArray(rows)) return [];\n    const levels = [];\n    for (const row of rows){\n        const price = Number(row?.[0]);\n        const qty = Number(row?.[1]);\n        if (!Number.isFinite(price) || !Number.isFinite(qty) || qty <= 0) continue;\n        levels.push({\n            price,\n            qty\n        });\n    }\n    return side === \"bids\" ? levels.sort((a, b)=>b.price - a.price) : levels.sort((a, b)=>a.price - b.price);\n}\nfunction aggregateLevels(snapshots, side) {\n    const map = new Map();\n    for (const snap of snapshots){\n        const levels = side === \"bids\" ? snap.bids : snap.asks;\n        for (const lvl of levels){\n            const key = lvl.price;\n            map.set(key, (map.get(key) ?? 0) + lvl.qty);\n        }\n    }\n    const aggregated = Array.from(map.entries()).map(([price, qty])=>({\n            price,\n            qty\n        }));\n    if (side === \"bids\") {\n        aggregated.sort((a, b)=>b.price - a.price);\n    } else {\n        aggregated.sort((a, b)=>a.price - b.price);\n    }\n    return aggregated;\n}\nfunction computeSpreadStats(snapshots) {\n    if (!snapshots.length) return {\n        min: null,\n        max: null,\n        avg: null\n    };\n    const spreads = snapshots.map((snap)=>Math.max(0, snap.bestAsk - snap.bestBid));\n    if (!spreads.length) return {\n        min: null,\n        max: null,\n        avg: null\n    };\n    return {\n        min: Math.min(...spreads),\n        max: Math.max(...spreads),\n        avg: spreads.reduce((sum, val)=>sum + val, 0) / spreads.length\n    };\n}\nfunction computeMidStats(snapshots) {\n    if (!snapshots.length) return {\n        min: null,\n        max: null\n    };\n    const mids = snapshots.map((snap)=>snap.mid).filter((val)=>Number.isFinite(val));\n    if (!mids.length) return {\n        min: null,\n        max: null\n    };\n    return {\n        min: Math.min(...mids),\n        max: Math.max(...mids)\n    };\n}\nfunction computeTickStats(snapshots) {\n    if (snapshots.length <= 1) return {\n        min: null,\n        max: null,\n        avg: null\n    };\n    const sorted = snapshots.map((snap)=>snap.ts).sort((a, b)=>a - b);\n    const diffs = [];\n    for(let i = 1; i < sorted.length; i++){\n        const diff = sorted[i] - sorted[i - 1];\n        if (diff >= 0) diffs.push(diff);\n    }\n    if (!diffs.length) return {\n        min: null,\n        max: null,\n        avg: null\n    };\n    const min = Math.min(...diffs);\n    const max = Math.max(...diffs);\n    const avg = Math.round(diffs.reduce((sum, val)=>sum + val, 0) / diffs.length);\n    return {\n        min,\n        max,\n        avg\n    };\n}\nfunction computeTopVolumes(bids, asks) {\n    const topBid = bids.slice(0, 5).reduce((sum, lvl)=>sum + lvl.qty, 0);\n    const topAsk = asks.slice(0, 5).reduce((sum, lvl)=>sum + lvl.qty, 0);\n    return {\n        bid: topBid,\n        ask: topAsk,\n        total: topBid + topAsk\n    };\n}\nfunction deriveQualityFlags(input) {\n    const flags = [];\n    if (!input.bucketCount) flags.push(\"empty_bucket\");\n    else if (input.bucketCount < MIN_BUCKET_SNAPSHOTS) flags.push(\"low_samples\");\n    if (!input.hasBook) flags.push(\"empty_book\");\n    if (input.tickMsMax != null && input.tickMsMax > GAP_WARN_MS) flags.push(\"irregular_spacing\");\n    return flags;\n}\nfunction estimateMid(payload) {\n    const bid = maxPrice(payload.bids);\n    const ask = minPrice(payload.asks);\n    if (Number.isFinite(bid) && Number.isFinite(ask)) {\n        return (bid + ask) / 2;\n    }\n    return Number.isFinite(bid) ? bid : Number.isFinite(ask) ? ask : 0;\n}\nfunction maxPrice(rows) {\n    if (!Array.isArray(rows) || !rows.length) return NaN;\n    return rows.reduce((max, row)=>{\n        const price = Number(row?.[0]);\n        return Number.isFinite(price) ? Math.max(max, price) : max;\n    }, -Infinity);\n}\nfunction minPrice(rows) {\n    if (!Array.isArray(rows) || !rows.length) return NaN;\n    return rows.reduce((min, row)=>{\n        const price = Number(row?.[0]);\n        return Number.isFinite(price) ? Math.min(min, price) : min;\n    }, Infinity);\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3NhbXBsaW5nL2J1Y2tldHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFpRDtBQUNOO0FBQ2M7QUFtQnpELE1BQU1HLFVBQVVILDBEQUFzQkEsQ0FBQ0ksZUFBZTtBQUN0RCxNQUFNQyxVQUFVQyxPQUFPQyxRQUFRQyxHQUFHLENBQUNDLG1CQUFtQixJQUFJO0FBQzFELE1BQU1DLGNBQWNKLE9BQU9DLFFBQVFDLEdBQUcsQ0FBQ0csdUJBQXVCLElBQUlOLFVBQVU7QUFDNUUsTUFBTU8sdUJBQXVCTixPQUFPQyxRQUFRQyxHQUFHLENBQUNLLDhCQUE4QixJQUFJO0FBQ2xGLE1BQU1DLFVBQVUsSUFBSUM7QUFZYixlQUFlQyxvQkFBb0JDLE9BQTZCO0lBQ3JFLE1BQU1DLFNBQVNDLE9BQU9GLFFBQVFDLE1BQU0sSUFBSSxJQUFJRSxXQUFXO0lBQ3ZELElBQUksQ0FBQ0YsUUFBUTtJQUNiLE1BQU1HLEtBQUtmLE9BQU9nQixRQUFRLENBQUNMLFFBQVFJLEVBQUUsSUFBSWYsT0FBT1csUUFBUUksRUFBRSxJQUFJRSxLQUFLQyxHQUFHO0lBQ3RFLE1BQU1DLFFBQVFDLEtBQUtDLEtBQUssQ0FBQ04sS0FBS2xCLFdBQVdBO0lBQ3pDLE1BQU15QixNQUFNSCxRQUFRdEI7SUFFcEIsSUFBSTBCLFNBQVNmLFFBQVFnQixHQUFHLENBQUNaO0lBQ3pCLElBQUksQ0FBQ1csVUFBVUEsT0FBT0QsR0FBRyxLQUFLQSxLQUFLO1FBQ2pDLElBQUlDLFFBQVEsTUFBTUUsWUFBWUY7UUFDOUJBLFNBQVM7WUFDUFg7WUFDQU87WUFDQUc7WUFDQUksV0FBVyxFQUFFO1FBQ2Y7UUFDQWxCLFFBQVFtQixHQUFHLENBQUNmLFFBQVFXO0lBQ3RCO0lBRUEsTUFBTUssV0FBMkI7UUFDL0JiO1FBQ0FjLE1BQU1DLFNBQVNuQixRQUFRa0IsSUFBSSxFQUFFO1FBQzdCRSxNQUFNRCxTQUFTbkIsUUFBUW9CLElBQUksRUFBRTtRQUM3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SUFBSS9CLE9BQU9nQixRQUFRLENBQUNrRCxRQUFRbEUsT0FBT2dCLFFBQVEsQ0FBQ21ELE1BQU07UUFDaEQsT0FBTyxDQUFDRCxNQUFNQyxHQUFFLElBQUs7SUFDdkI7SUFDQSxPQUFPbkUsT0FBT2dCLFFBQVEsQ0FBQ2tELE9BQVFBLE1BQWlCbEUsT0FBT2dCLFFBQVEsQ0FBQ21ELE9BQVFBLE1BQWlCO0FBQzNGO0FBRUEsU0FBU2hDLFNBQVN5RCxJQUFnRDtJQUNoRSxJQUFJLENBQUNFLE1BQU1DLE9BQU8sQ0FBQ0gsU0FBUyxDQUFDQSxLQUFLckQsTUFBTSxFQUFFLE9BQU9rRjtJQUNqRCxPQUFPN0IsS0FBSzdDLE1BQU0sQ0FBQyxDQUFDRyxLQUFLK0M7UUFDdkIsTUFBTUMsUUFBUWxHLE9BQU9pRyxLQUFLLENBQUMsRUFBRTtRQUM3QixPQUFPakcsT0FBT2dCLFFBQVEsQ0FBQ2tGLFNBQVM5RSxLQUFLOEIsR0FBRyxDQUFDQSxLQUFLZ0QsU0FBU2hEO0lBQ3pELEdBQUcsQ0FBQ3dFO0FBQ047QUFFQSxTQUFTckYsU0FBU3VELElBQWdEO0lBQ2hFLElBQUksQ0FBQ0UsTUFBTUMsT0FBTyxDQUFDSCxTQUFTLENBQUNBLEtBQUtyRCxNQUFNLEVBQUUsT0FBT2tGO0lBQ2pELE9BQU83QixLQUFLN0MsTUFBTSxDQUFDLENBQUNtQyxLQUFLZTtRQUN2QixNQUFNQyxRQUFRbEcsT0FBT2lHLEtBQUssQ0FBQyxFQUFFO1FBQzdCLE9BQU9qRyxPQUFPZ0IsUUFBUSxDQUFDa0YsU0FBUzlFLEtBQUs4RCxHQUFHLENBQUNBLEtBQUtnQixTQUFTaEI7SUFDekQsR0FBR3dDO0FBQ0wiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxjb3JlXFxmZWF0dXJlc1xcc3RyLWF1eFxcc2FtcGxpbmdcXGJ1Y2tldHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgREVGQVVMVF9TQU1QTEVSX0NPTkZJRyB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXRTYW1wbGluZ1N0b3JlIH0gZnJvbSBcIi4vc3RvcmVcIjtcbmltcG9ydCB7IGVucXVldWVCdWNrZXRQZXJzaXN0ZW5jZSB9IGZyb20gXCIuL3BlcnNpc3RlbmNlXCI7XG5pbXBvcnQgdHlwZSB7IFNhbXBsaW5nUG9pbnQsIE9yZGVyQm9va0xldmVsIH0gZnJvbSBcIi4vdHlwZXNcIjtcblxudHlwZSBCdWNrZXRTbmFwc2hvdCA9IHtcbiAgdHM6IG51bWJlcjtcbiAgYmlkczogT3JkZXJCb29rTGV2ZWxbXTtcbiAgYXNrczogT3JkZXJCb29rTGV2ZWxbXTtcbiAgbWlkOiBudW1iZXI7XG4gIGJlc3RCaWQ6IG51bWJlcjtcbiAgYmVzdEFzazogbnVtYmVyO1xufTtcblxudHlwZSBCdWNrZXQgPSB7XG4gIHN5bWJvbDogc3RyaW5nO1xuICBzdGFydDogbnVtYmVyO1xuICBlbmQ6IG51bWJlcjtcbiAgc25hcHNob3RzOiBCdWNrZXRTbmFwc2hvdFtdO1xufTtcblxuY29uc3QgU1RFUF9NUyA9IERFRkFVTFRfU0FNUExFUl9DT05GSUcucG9pbnRJbnRlcnZhbE1zO1xuY29uc3QgUE9MTF9NUyA9IE51bWJlcihwcm9jZXNzLmVudi5TVFJfU0FNUExFUl9QT0xMX01TID8/IDFfMDAwKTtcbmNvbnN0IEdBUF9XQVJOX01TID0gTnVtYmVyKHByb2Nlc3MuZW52LlNUUl9TQU1QTEVSX0dBUF9XQVJOX01TID8/IFBPTExfTVMgKiAyKTtcbmNvbnN0IE1JTl9CVUNLRVRfU05BUFNIT1RTID0gTnVtYmVyKHByb2Nlc3MuZW52LlNUUl9TQU1QTEVSX01JTl9CVUNLRVRfU0FNUExFUyA/PyAyKTtcbmNvbnN0IGJ1Y2tldHMgPSBuZXcgTWFwPHN0cmluZywgQnVja2V0PigpO1xuXG5leHBvcnQgdHlwZSBPcmRlckJvb2tUaWNrUGF5bG9hZCA9IHtcbiAgc3ltYm9sOiBzdHJpbmc7XG4gIHRzOiBudW1iZXI7XG4gIGJpZHM6IEFycmF5PFtudW1iZXIgfCBzdHJpbmcsIG51bWJlciB8IHN0cmluZ10+O1xuICBhc2tzOiBBcnJheTxbbnVtYmVyIHwgc3RyaW5nLCBudW1iZXIgfCBzdHJpbmddPjtcbiAgbWlkPzogbnVtYmVyO1xuICBiZXN0QmlkPzogbnVtYmVyO1xuICBiZXN0QXNrPzogbnVtYmVyO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluZ2VzdE9yZGVyQm9va1RpY2socGF5bG9hZDogT3JkZXJCb29rVGlja1BheWxvYWQpIHtcbiAgY29uc3Qgc3ltYm9sID0gU3RyaW5nKHBheWxvYWQuc3ltYm9sID8/IFwiXCIpLnRvVXBwZXJDYXNlKCk7XG4gIGlmICghc3ltYm9sKSByZXR1cm47XG4gIGNvbnN0IHRzID0gTnVtYmVyLmlzRmluaXRlKHBheWxvYWQudHMpID8gTnVtYmVyKHBheWxvYWQudHMpIDogRGF0ZS5ub3coKTtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLmZsb29yKHRzIC8gU1RFUF9NUykgKiBTVEVQX01TO1xuICBjb25zdCBlbmQgPSBzdGFydCArIFNURVBfTVM7XG5cbiAgbGV0IGJ1Y2tldCA9IGJ1Y2tldHMuZ2V0KHN5bWJvbCk7XG4gIGlmICghYnVja2V0IHx8IGJ1Y2tldC5lbmQgIT09IGVuZCkge1xuICAgIGlmIChidWNrZXQpIGF3YWl0IGZsdXNoQnVja2V0KGJ1Y2tldCk7XG4gICAgYnVja2V0ID0ge1xuICAgICAgc3ltYm9sLFxuICAgICAgc3RhcnQsXG4gICAgICBlbmQsXG4gICAgICBzbmFwc2hvdHM6IFtdLFxuICAgIH07XG4gICAgYnVja2V0cy5zZXQoc3ltYm9sLCBidWNrZXQpO1xuICB9XG5cbiAgY29uc3Qgc25hcHNob3Q6IEJ1Y2tldFNuYXBzaG90ID0ge1xuICAgIHRzLFxuICAgIGJpZHM6IHRvTGV2ZWxzKHBheWxvYWQuYmlkcywgXCJiaWRzXCIpLFxuICAgIGFza3M6IHRvTGV2ZWxzKHBheWxvYWQuYXNrcywgXCJhc2tzXCIpLFxuICAgIG1pZDogTnVtYmVyLmlzRmluaXRlKHBheWxvYWQubWlkKSA/IE51bWJlcihwYXlsb2FkLm1pZCkgOiBlc3RpbWF0ZU1pZChwYXlsb2FkKSxcbiAgICBiZXN0QmlkOiBOdW1iZXIuaXNGaW5pdGUocGF5bG9hZC5iZXN0QmlkKSA/IE51bWJlcihwYXlsb2FkLmJlc3RCaWQpIDogbWF4UHJpY2UocGF5bG9hZC5iaWRzKSxcbiAgICBiZXN0QXNrOiBOdW1iZXIuaXNGaW5pdGUocGF5bG9hZC5iZXN0QXNrKSA/IE51bWJlcihwYXlsb2FkLmJlc3RBc2spIDogbWluUHJpY2UocGF5bG9hZC5hc2tzKSxcbiAgfTtcbiAgYnVja2V0LnNuYXBzaG90cy5wdXNoKHNuYXBzaG90KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmx1c2hCdWNrZXQoYnVja2V0OiBCdWNrZXQpIHtcbiAgaWYgKCFidWNrZXQuc25hcHNob3RzLmxlbmd0aCkgcmV0dXJuO1xuICBjb25zdCBwb2ludCA9IGJ1aWxkUG9pbnRGcm9tQnVja2V0KGJ1Y2tldCk7XG4gIGNvbnN0IHN0b3JlID0gZ2V0U2FtcGxpbmdTdG9yZSgpO1xuICBhd2FpdCBzdG9yZS5jb2xsZWN0KGJ1Y2tldC5zeW1ib2wsIHsgZm9yY2U6IHRydWUsIHBvaW50IH0pO1xuICBlbnF1ZXVlQnVja2V0UGVyc2lzdGVuY2UocG9pbnQpO1xufVxuXG5mdW5jdGlvbiBidWlsZFBvaW50RnJvbUJ1Y2tldChidWNrZXQ6IEJ1Y2tldCk6IFNhbXBsaW5nUG9pbnQge1xuICBjb25zdCBsYXN0ID0gYnVja2V0LnNuYXBzaG90c1tidWNrZXQuc25hcHNob3RzLmxlbmd0aCAtIDFdITtcbiAgY29uc3QgYXZnTWlkID1cbiAgICBidWNrZXQuc25hcHNob3RzLnJlZHVjZSgoc3VtLCBzbmFwKSA9PiBzdW0gKyBzbmFwLm1pZCwgMCkgL1xuICAgIE1hdGgubWF4KDEsIGJ1Y2tldC5zbmFwc2hvdHMubGVuZ3RoKTtcbiAgY29uc3QgYmlkcyA9IGFnZ3JlZ2F0ZUxldmVscyhidWNrZXQuc25hcHNob3RzLCBcImJpZHNcIik7XG4gIGNvbnN0IGFza3MgPSBhZ2dyZWdhdGVMZXZlbHMoYnVja2V0LnNuYXBzaG90cywgXCJhc2tzXCIpO1xuICBjb25zdCBiaWRWb2wgPSBiaWRzLnJlZHVjZSgoc3VtLCBsdmwpID0+IHN1bSArIGx2bC5xdHksIDApO1xuICBjb25zdCBhc2tWb2wgPSBhc2tzLnJlZHVjZSgoc3VtLCBsdmwpID0+IHN1bSArIGx2bC5xdHksIDApO1xuICBjb25zdCB0b3BWb2x1bWVzID0gY29tcHV0ZVRvcFZvbHVtZXMoYmlkcywgYXNrcyk7XG4gIGNvbnN0IHNwcmVhZFN0YXRzID0gY29tcHV0ZVNwcmVhZFN0YXRzKGJ1Y2tldC5zbmFwc2hvdHMpO1xuICBjb25zdCB0aWNrU3RhdHMgPSBjb21wdXRlVGlja1N0YXRzKGJ1Y2tldC5zbmFwc2hvdHMpO1xuICBjb25zdCBtaWRTdGF0cyA9IGNvbXB1dGVNaWRTdGF0cyhidWNrZXQuc25hcHNob3RzKTtcbiAgY29uc3QgbGlxdWlkaXR5SW1iYWxhbmNlID1cbiAgICB0b3BWb2x1bWVzLnRvdGFsID4gMCA/ICh0b3BWb2x1bWVzLmJpZCAtIHRvcFZvbHVtZXMuYXNrKSAvIHRvcFZvbHVtZXMudG90YWwgOiBudWxsO1xuICBjb25zdCBxdWFsaXR5RmxhZ3MgPSBkZXJpdmVRdWFsaXR5RmxhZ3Moe1xuICAgIGJ1Y2tldENvdW50OiBidWNrZXQuc25hcHNob3RzLmxlbmd0aCxcbiAgICBoYXNCb29rOiBiaWRzLmxlbmd0aCA+IDAgJiYgYXNrcy5sZW5ndGggPiAwLFxuICAgIHRpY2tNc01heDogdGlja1N0YXRzLm1heCxcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBzeW1ib2w6IGJ1Y2tldC5zeW1ib2wsXG4gICAgdHM6IGJ1Y2tldC5lbmQsXG4gICAgbWlkOiBhdmdNaWQsXG4gICAgYmVzdEJpZDogbGFzdC5iZXN0QmlkLFxuICAgIGJlc3RBc2s6IGxhc3QuYmVzdEFzayxcbiAgICBzcHJlYWQ6IE1hdGguYWJzKGxhc3QuYmVzdEFzayAtIGxhc3QuYmVzdEJpZCksXG4gICAgYmlkVm9sdW1lOiBiaWRWb2wsXG4gICAgYXNrVm9sdW1lOiBhc2tWb2wsXG4gICAgYnVja2V0U3RhcnQ6IGJ1Y2tldC5zdGFydCxcbiAgICBidWNrZXRFbmQ6IGJ1Y2tldC5lbmQsXG4gICAgYm9vazoge1xuICAgICAgYmlkcyxcbiAgICAgIGFza3MsXG4gICAgfSxcbiAgICBidWNrZXRNZXRhOiB7XG4gICAgICBidWNrZXRDb3VudDogYnVja2V0LnNuYXBzaG90cy5sZW5ndGgsXG4gICAgICB0aWNrTXNNaW46IHRpY2tTdGF0cy5taW4sXG4gICAgICB0aWNrTXNNYXg6IHRpY2tTdGF0cy5tYXgsXG4gICAgICB0aWNrTXNBdmc6IHRpY2tTdGF0cy5hdmcsXG4gICAgICBzcHJlYWRNaW46IHNwcmVhZFN0YXRzLm1pbixcbiAgICAgIHNwcmVhZE1heDogc3ByZWFkU3RhdHMubWF4LFxuICAgICAgc3ByZWFkQXZnOiBzcHJlYWRTdGF0cy5hdmcsXG4gICAgICBtaWRNaW46IG1pZFN0YXRzLm1pbixcbiAgICAgIG1pZE1heDogbWlkU3RhdHMubWF4LFxuICAgICAgdG9wQmlkVm9sOiB0b3BWb2x1bWVzLmJpZCxcbiAgICAgIHRvcEFza1ZvbDogdG9wVm9sdW1lcy5hc2ssXG4gICAgICBsaXF1aWRpdHlJbWJhbGFuY2UsXG4gICAgICBxdWFsaXR5RmxhZ3MsXG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9MZXZlbHMoXG4gIHJvd3M6IEFycmF5PFtudW1iZXIgfCBzdHJpbmcsIG51bWJlciB8IHN0cmluZ10+IHwgdW5kZWZpbmVkLFxuICBzaWRlOiBcImJpZHNcIiB8IFwiYXNrc1wiXG4pOiBPcmRlckJvb2tMZXZlbFtdIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHJvd3MpKSByZXR1cm4gW107XG4gIGNvbnN0IGxldmVsczogT3JkZXJCb29rTGV2ZWxbXSA9IFtdO1xuICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgY29uc3QgcHJpY2UgPSBOdW1iZXIocm93Py5bMF0pO1xuICAgIGNvbnN0IHF0eSA9IE51bWJlcihyb3c/LlsxXSk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocHJpY2UpIHx8ICFOdW1iZXIuaXNGaW5pdGUocXR5KSB8fCBxdHkgPD0gMCkgY29udGludWU7XG4gICAgbGV2ZWxzLnB1c2goeyBwcmljZSwgcXR5IH0pO1xuICB9XG4gIHJldHVybiBzaWRlID09PSBcImJpZHNcIlxuICAgID8gbGV2ZWxzLnNvcnQoKGEsIGIpID0+IGIucHJpY2UgLSBhLnByaWNlKVxuICAgIDogbGV2ZWxzLnNvcnQoKGEsIGIpID0+IGEucHJpY2UgLSBiLnByaWNlKTtcbn1cblxuZnVuY3Rpb24gYWdncmVnYXRlTGV2ZWxzKFxuICBzbmFwc2hvdHM6IEJ1Y2tldFNuYXBzaG90W10sXG4gIHNpZGU6IFwiYmlkc1wiIHwgXCJhc2tzXCJcbik6IE9yZGVyQm9va0xldmVsW10ge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwPG51bWJlciwgbnVtYmVyPigpO1xuICBmb3IgKGNvbnN0IHNuYXAgb2Ygc25hcHNob3RzKSB7XG4gICAgY29uc3QgbGV2ZWxzID0gc2lkZSA9PT0gXCJiaWRzXCIgPyBzbmFwLmJpZHMgOiBzbmFwLmFza3M7XG4gICAgZm9yIChjb25zdCBsdmwgb2YgbGV2ZWxzKSB7XG4gICAgICBjb25zdCBrZXkgPSBsdmwucHJpY2U7XG4gICAgICBtYXAuc2V0KGtleSwgKG1hcC5nZXQoa2V5KSA/PyAwKSArIGx2bC5xdHkpO1xuICAgIH1cbiAgfVxuICBjb25zdCBhZ2dyZWdhdGVkID0gQXJyYXkuZnJvbShtYXAuZW50cmllcygpKS5tYXAoKFtwcmljZSwgcXR5XSkgPT4gKHtcbiAgICBwcmljZSxcbiAgICBxdHksXG4gIH0pKTtcbiAgaWYgKHNpZGUgPT09IFwiYmlkc1wiKSB7XG4gICAgYWdncmVnYXRlZC5zb3J0KChhLCBiKSA9PiBiLnByaWNlIC0gYS5wcmljZSk7XG4gIH0gZWxzZSB7XG4gICAgYWdncmVnYXRlZC5zb3J0KChhLCBiKSA9PiBhLnByaWNlIC0gYi5wcmljZSk7XG4gIH1cbiAgcmV0dXJuIGFnZ3JlZ2F0ZWQ7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTcHJlYWRTdGF0cyhzbmFwc2hvdHM6IEJ1Y2tldFNuYXBzaG90W10pIHtcbiAgaWYgKCFzbmFwc2hvdHMubGVuZ3RoKSByZXR1cm4geyBtaW46IG51bGwsIG1heDogbnVsbCwgYXZnOiBudWxsIH07XG4gIGNvbnN0IHNwcmVhZHMgPSBzbmFwc2hvdHMubWFwKChzbmFwKSA9PiBNYXRoLm1heCgwLCBzbmFwLmJlc3RBc2sgLSBzbmFwLmJlc3RCaWQpKTtcbiAgaWYgKCFzcHJlYWRzLmxlbmd0aCkgcmV0dXJuIHsgbWluOiBudWxsLCBtYXg6IG51bGwsIGF2ZzogbnVsbCB9O1xuICByZXR1cm4ge1xuICAgIG1pbjogTWF0aC5taW4oLi4uc3ByZWFkcyksXG4gICAgbWF4OiBNYXRoLm1heCguLi5zcHJlYWRzKSxcbiAgICBhdmc6IHNwcmVhZHMucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLCAwKSAvIHNwcmVhZHMubGVuZ3RoLFxuICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlTWlkU3RhdHMoc25hcHNob3RzOiBCdWNrZXRTbmFwc2hvdFtdKSB7XG4gIGlmICghc25hcHNob3RzLmxlbmd0aCkgcmV0dXJuIHsgbWluOiBudWxsLCBtYXg6IG51bGwgfTtcbiAgY29uc3QgbWlkcyA9IHNuYXBzaG90cy5tYXAoKHNuYXApID0+IHNuYXAubWlkKS5maWx0ZXIoKHZhbCkgPT4gTnVtYmVyLmlzRmluaXRlKHZhbCkpO1xuICBpZiAoIW1pZHMubGVuZ3RoKSByZXR1cm4geyBtaW46IG51bGwsIG1heDogbnVsbCB9O1xuICByZXR1cm4geyBtaW46IE1hdGgubWluKC4uLm1pZHMpLCBtYXg6IE1hdGgubWF4KC4uLm1pZHMpIH07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVUaWNrU3RhdHMoc25hcHNob3RzOiBCdWNrZXRTbmFwc2hvdFtdKSB7XG4gIGlmIChzbmFwc2hvdHMubGVuZ3RoIDw9IDEpIHJldHVybiB7IG1pbjogbnVsbCwgbWF4OiBudWxsLCBhdmc6IG51bGwgfTtcbiAgY29uc3Qgc29ydGVkID0gc25hcHNob3RzLm1hcCgoc25hcCkgPT4gc25hcC50cykuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICBjb25zdCBkaWZmczogbnVtYmVyW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBzb3J0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkaWZmID0gc29ydGVkW2ldIC0gc29ydGVkW2kgLSAxXTtcbiAgICBpZiAoZGlmZiA+PSAwKSBkaWZmcy5wdXNoKGRpZmYpO1xuICB9XG4gIGlmICghZGlmZnMubGVuZ3RoKSByZXR1cm4geyBtaW46IG51bGwsIG1heDogbnVsbCwgYXZnOiBudWxsIH07XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKC4uLmRpZmZzKTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgoLi4uZGlmZnMpO1xuICBjb25zdCBhdmcgPSBNYXRoLnJvdW5kKGRpZmZzLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCwgMCkgLyBkaWZmcy5sZW5ndGgpO1xuICByZXR1cm4geyBtaW4sIG1heCwgYXZnIH07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVUb3BWb2x1bWVzKGJpZHM6IE9yZGVyQm9va0xldmVsW10sIGFza3M6IE9yZGVyQm9va0xldmVsW10pIHtcbiAgY29uc3QgdG9wQmlkID0gYmlkcy5zbGljZSgwLCA1KS5yZWR1Y2UoKHN1bSwgbHZsKSA9PiBzdW0gKyBsdmwucXR5LCAwKTtcbiAgY29uc3QgdG9wQXNrID0gYXNrcy5zbGljZSgwLCA1KS5yZWR1Y2UoKHN1bSwgbHZsKSA9PiBzdW0gKyBsdmwucXR5LCAwKTtcbiAgcmV0dXJuIHsgYmlkOiB0b3BCaWQsIGFzazogdG9wQXNrLCB0b3RhbDogdG9wQmlkICsgdG9wQXNrIH07XG59XG5cbmZ1bmN0aW9uIGRlcml2ZVF1YWxpdHlGbGFncyhpbnB1dDogeyBidWNrZXRDb3VudDogbnVtYmVyOyBoYXNCb29rOiBib29sZWFuOyB0aWNrTXNNYXg6IG51bWJlciB8IG51bGwgfSkge1xuICBjb25zdCBmbGFnczogc3RyaW5nW10gPSBbXTtcbiAgaWYgKCFpbnB1dC5idWNrZXRDb3VudCkgZmxhZ3MucHVzaChcImVtcHR5X2J1Y2tldFwiKTtcbiAgZWxzZSBpZiAoaW5wdXQuYnVja2V0Q291bnQgPCBNSU5fQlVDS0VUX1NOQVBTSE9UUykgZmxhZ3MucHVzaChcImxvd19zYW1wbGVzXCIpO1xuICBpZiAoIWlucHV0Lmhhc0Jvb2spIGZsYWdzLnB1c2goXCJlbXB0eV9ib29rXCIpO1xuICBpZiAoaW5wdXQudGlja01zTWF4ICE9IG51bGwgJiYgaW5wdXQudGlja01zTWF4ID4gR0FQX1dBUk5fTVMpIGZsYWdzLnB1c2goXCJpcnJlZ3VsYXJfc3BhY2luZ1wiKTtcbiAgcmV0dXJuIGZsYWdzO1xufVxuXG5mdW5jdGlvbiBlc3RpbWF0ZU1pZChwYXlsb2FkOiBPcmRlckJvb2tUaWNrUGF5bG9hZCk6IG51bWJlciB7XG4gIGNvbnN0IGJpZCA9IG1heFByaWNlKHBheWxvYWQuYmlkcyk7XG4gIGNvbnN0IGFzayA9IG1pblByaWNlKHBheWxvYWQuYXNrcyk7XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoYmlkKSAmJiBOdW1iZXIuaXNGaW5pdGUoYXNrKSkge1xuICAgIHJldHVybiAoYmlkICsgYXNrKSAvIDI7XG4gIH1cbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShiaWQpID8gKGJpZCBhcyBudW1iZXIpIDogTnVtYmVyLmlzRmluaXRlKGFzaykgPyAoYXNrIGFzIG51bWJlcikgOiAwO1xufVxuXG5mdW5jdGlvbiBtYXhQcmljZShyb3dzPzogQXJyYXk8W251bWJlciB8IHN0cmluZywgbnVtYmVyIHwgc3RyaW5nXT4pOiBudW1iZXIge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocm93cykgfHwgIXJvd3MubGVuZ3RoKSByZXR1cm4gTmFOO1xuICByZXR1cm4gcm93cy5yZWR1Y2UoKG1heCwgcm93KSA9PiB7XG4gICAgY29uc3QgcHJpY2UgPSBOdW1iZXIocm93Py5bMF0pO1xuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUocHJpY2UpID8gTWF0aC5tYXgobWF4LCBwcmljZSkgOiBtYXg7XG4gIH0sIC1JbmZpbml0eSk7XG59XG5cbmZ1bmN0aW9uIG1pblByaWNlKHJvd3M/OiBBcnJheTxbbnVtYmVyIHwgc3RyaW5nLCBudW1iZXIgfCBzdHJpbmddPik6IG51bWJlciB7XG4gIGlmICghQXJyYXkuaXNBcnJheShyb3dzKSB8fCAhcm93cy5sZW5ndGgpIHJldHVybiBOYU47XG4gIHJldHVybiByb3dzLnJlZHVjZSgobWluLCByb3cpID0+IHtcbiAgICBjb25zdCBwcmljZSA9IE51bWJlcihyb3c/LlswXSk7XG4gICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShwcmljZSkgPyBNYXRoLm1pbihtaW4sIHByaWNlKSA6IG1pbjtcbiAgfSwgSW5maW5pdHkpO1xufVxuIl0sIm5hbWVzIjpbIkRFRkFVTFRfU0FNUExFUl9DT05GSUciLCJnZXRTYW1wbGluZ1N0b3JlIiwiZW5xdWV1ZUJ1Y2tldFBlcnNpc3RlbmNlIiwiU1RFUF9NUyIsInBvaW50SW50ZXJ2YWxNcyIsIlBPTExfTVMiLCJOdW1iZXIiLCJwcm9jZXNzIiwiZW52IiwiU1RSX1NBTVBMRVJfUE9MTF9NUyIsIkdBUF9XQVJOX01TIiwiU1RSX1NBTVBMRVJfR0FQX1dBUk5fTVMiLCJNSU5fQlVDS0VUX1NOQVBTSE9UUyIsIlNUUl9TQU1QTEVSX01JTl9CVUNLRVRfU0FNUExFUyIsImJ1Y2tldHMiLCJNYXAiLCJpbmdlc3RPcmRlckJvb2tUaWNrIiwicGF5bG9hZCIsInN5bWJvbCIsIlN0cmluZyIsInRvVXBwZXJDYXNlIiwidHMiLCJpc0Zpbml0ZSIsIkRhdGUiLCJub3ciLCJzdGFydCIsIk1hdGgiLCJmbG9vciIsImVuZCIsImJ1Y2tldCIsImdldCIsImZsdXNoQnVja2V0Iiwic25hcHNob3RzIiwic2V0Iiwic25hcHNob3QiLCJiaWRzIiwidG9MZXZlbHMiLCJhc2tzIiwibWlkIiwiZXN0aW1hdGVNaWQiLCJiZXN0QmlkIiwibWF4UHJpY2UiLCJiZXN0QXNrIiwibWluUHJpY2UiLCJwdXNoIiwibGVuZ3RoIiwicG9pbnQiLCJidWlsZFBvaW50RnJvbUJ1Y2tldCIsInN0b3JlIiwiY29sbGVjdCIsImZvcmNlIiwibGFzdCIsImF2Z01pZCIsInJlZHVjZSIsInN1bSIsInNuYXAiLCJtYXgiLCJhZ2dyZWdhdGVMZXZlbHMiLCJiaWRWb2wiLCJsdmwiLCJxdHkiLCJhc2tWb2wiLCJ0b3BWb2x1bWVzIiwiY29tcHV0ZVRvcFZvbHVtZXMiLCJzcHJlYWRTdGF0cyIsImNvbXB1dGVTcHJlYWRTdGF0cyIsInRpY2tTdGF0cyIsImNvbXB1dGVUaWNrU3RhdHMiLCJtaWRTdGF0cyIsImNvbXB1dGVNaWRTdGF0cyIsImxpcXVpZGl0eUltYmFsYW5jZSIsInRvdGFsIiwiYmlkIiwiYXNrIiwicXVhbGl0eUZsYWdzIiwiZGVyaXZlUXVhbGl0eUZsYWdzIiwiYnVja2V0Q291bnQiLCJoYXNCb29rIiwidGlja01zTWF4Iiwic3ByZWFkIiwiYWJzIiwiYmlkVm9sdW1lIiwiYXNrVm9sdW1lIiwiYnVja2V0U3RhcnQiLCJidWNrZXRFbmQiLCJib29rIiwiYnVja2V0TWV0YSIsInRpY2tNc01pbiIsIm1pbiIsInRpY2tNc0F2ZyIsImF2ZyIsInNwcmVhZE1pbiIsInNwcmVhZE1heCIsInNwcmVhZEF2ZyIsIm1pZE1pbiIsIm1pZE1heCIsInRvcEJpZFZvbCIsInRvcEFza1ZvbCIsInJvd3MiLCJzaWRlIiwiQXJyYXkiLCJpc0FycmF5IiwibGV2ZWxzIiwicm93IiwicHJpY2UiLCJzb3J0IiwiYSIsImIiLCJtYXAiLCJrZXkiLCJhZ2dyZWdhdGVkIiwiZnJvbSIsImVudHJpZXMiLCJzcHJlYWRzIiwidmFsIiwibWlkcyIsImZpbHRlciIsInNvcnRlZCIsImRpZmZzIiwiaSIsImRpZmYiLCJyb3VuZCIsInRvcEJpZCIsInNsaWNlIiwidG9wQXNrIiwiaW5wdXQiLCJmbGFncyIsIk5hTiIsIkluZmluaXR5Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/sampling/buckets.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/sampling/index.ts":
/*!*****************************************************!*\
  !*** ./src/core/features/str-aux/sampling/index.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_SAMPLER_CONFIG: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SAMPLER_CONFIG),\n/* harmony export */   SamplingStore: () => (/* reexport safe */ _store__WEBPACK_IMPORTED_MODULE_2__.SamplingStore),\n/* harmony export */   SamplingStoreError: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.SamplingStoreError),\n/* harmony export */   enqueueBucketPersistence: () => (/* reexport safe */ _persistence__WEBPACK_IMPORTED_MODULE_5__.enqueueBucketPersistence),\n/* harmony export */   getSamplingStore: () => (/* reexport safe */ _store__WEBPACK_IMPORTED_MODULE_2__.getSamplingStore),\n/* harmony export */   ingestOrderBookTick: () => (/* reexport safe */ _buckets__WEBPACK_IMPORTED_MODULE_3__.ingestOrderBookTick),\n/* harmony export */   orderedWindowKeys: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.orderedWindowKeys),\n/* harmony export */   reduceStatusCounts: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.reduceStatusCounts),\n/* harmony export */   startPersistenceLoop: () => (/* reexport safe */ _persistence__WEBPACK_IMPORTED_MODULE_5__.startPersistenceLoop),\n/* harmony export */   startSamplingUniverseWatcher: () => (/* reexport safe */ _universeWatcher__WEBPACK_IMPORTED_MODULE_4__.startSamplingUniverseWatcher),\n/* harmony export */   summarizeMark: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.summarizeMark),\n/* harmony export */   summarizeSnapshotWindow: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.summarizeSnapshotWindow),\n/* harmony export */   summarizeWindowMarkers: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.summarizeWindowMarkers)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"(rsc)/./src/core/features/str-aux/sampling/types.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"(rsc)/./src/core/features/str-aux/sampling/utils.ts\");\n/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./store */ \"(rsc)/./src/core/features/str-aux/sampling/store.ts\");\n/* harmony import */ var _buckets__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./buckets */ \"(rsc)/./src/core/features/str-aux/sampling/buckets.ts\");\n/* harmony import */ var _universeWatcher__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./universeWatcher */ \"(rsc)/./src/core/features/str-aux/sampling/universeWatcher.ts\");\n/* harmony import */ var _persistence__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./persistence */ \"(rsc)/./src/core/features/str-aux/sampling/persistence.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_store__WEBPACK_IMPORTED_MODULE_2__, _buckets__WEBPACK_IMPORTED_MODULE_3__, _universeWatcher__WEBPACK_IMPORTED_MODULE_4__, _persistence__WEBPACK_IMPORTED_MODULE_5__]);\n([_store__WEBPACK_IMPORTED_MODULE_2__, _buckets__WEBPACK_IMPORTED_MODULE_3__, _universeWatcher__WEBPACK_IMPORTED_MODULE_4__, _persistence__WEBPACK_IMPORTED_MODULE_5__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n// src/core/features/str-aux/sampling/index.ts\n\n\n\n\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3NhbXBsaW5nL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw4Q0FBOEM7QUFDdEI7QUFDQTtBQUNBO0FBQ0U7QUFDUTtBQUNKIiwic291cmNlcyI6WyJIOlxcVXNlcnNcXEd1c1xcc291cmNlXFxyZXBvXFxkeW5hbWljc1xcZHluYW1pY3MtYlxcY3J5cHRvcGktZHluYW1pY3NcXHNyY1xcY29yZVxcZmVhdHVyZXNcXHN0ci1hdXhcXHNhbXBsaW5nXFxpbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3NhbXBsaW5nL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwiLi90eXBlc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vdXRpbHNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3N0b3JlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9idWNrZXRzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi91bml2ZXJzZVdhdGNoZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3BlcnNpc3RlbmNlXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/sampling/index.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/sampling/persistence.ts":
/*!***********************************************************!*\
  !*** ./src/core/features/str-aux/sampling/persistence.ts ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   enqueueBucketPersistence: () => (/* binding */ enqueueBucketPersistence),\n/* harmony export */   startPersistenceLoop: () => (/* binding */ startPersistenceLoop)\n/* harmony export */ });\n/* harmony import */ var _core_db_pool_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/db/pool_server */ \"(rsc)/./src/core/db/pool_server.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_db_pool_server__WEBPACK_IMPORTED_MODULE_0__]);\n_core_db_pool_server__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\nconst PERSIST_INTERVAL_MS = Number(process.env.STR_SAMPLER_PERSIST_MS ?? 5000);\nconst pendingBuckets = new Map();\nlet dirtySymbols = new Set();\nlet persistTimer = null;\nfunction enqueueBucketPersistence(point) {\n    pendingBuckets.set(`${point.symbol}:${point.bucketEnd}`, point);\n    dirtySymbols.add(point.symbol);\n    if (!persistTimer) {\n        persistTimer = setTimeout(flushPendingBuckets, PERSIST_INTERVAL_MS);\n    }\n}\nasync function flushPendingBuckets() {\n    persistTimer = null;\n    if (!pendingBuckets.size) {\n        dirtySymbols.clear();\n        return;\n    }\n    const toPersist = Array.from(pendingBuckets.values());\n    pendingBuckets.clear();\n    dirtySymbols = new Set();\n    for (const point of toPersist){\n        try {\n            await persistBucket(point);\n        } catch (err) {\n            console.warn(\"[str-aux sampler] failed to persist bucket\", point.symbol, err);\n        }\n    }\n}\nasync function persistBucket(point) {\n    const ts = point.bucketEnd;\n    const density = {\n        mid: point.mid,\n        bestBid: point.bestBid,\n        bestAsk: point.bestAsk,\n        spread: point.spread,\n        bidVolume: point.bidVolume,\n        askVolume: point.askVolume\n    };\n    const meta = point.bucketMeta ?? defaultBucketMeta(point);\n    const stats = {\n        v_inner: null,\n        v_outer: null,\n        v_swap: null,\n        v_tendency: null,\n        disruption: null,\n        amp: null,\n        volt: null,\n        inertia: null,\n        mode_general: null,\n        mode_b: null\n    };\n    await (0,_core_db_pool_server__WEBPACK_IMPORTED_MODULE_0__.query)(`select str_aux.upsert_sample_5s_model($1, to_timestamp($2/1000.0), $3::jsonb)`, [\n        point.symbol,\n        ts,\n        JSON.stringify({\n            bucket_start: point.bucketStart,\n            bucket_end: point.bucketEnd,\n            book: point.book,\n            density,\n            stats: {\n                bucket_count: meta.bucketCount,\n                tick_ms_min: meta.tickMsMin,\n                tick_ms_max: meta.tickMsMax,\n                tick_ms_avg: meta.tickMsAvg,\n                spread_min: meta.spreadMin,\n                spread_max: meta.spreadMax,\n                spread_avg: meta.spreadAvg,\n                mid_min: meta.midMin,\n                mid_max: meta.midMax,\n                top_bid_vol: meta.topBidVol,\n                top_ask_vol: meta.topAskVol,\n                liquidity_imbalance: meta.liquidityImbalance,\n                quality_flags: meta.qualityFlags\n            }\n        })\n    ]);\n    await (0,_core_db_pool_server__WEBPACK_IMPORTED_MODULE_0__.query)(`select str_aux.upsert_sample_5s(\n       $1::text, to_timestamp($2/1000.0),\n       $3::numeric, $4::numeric, $5::numeric, $6::numeric,\n       $7::numeric, $8::numeric, $9::numeric, $10::numeric,\n       $11::smallint, $12::smallint, $13::jsonb,\n       $14::smallint, $15::int, $16::int, $17::int,\n       $18::numeric, $19::numeric, $20::numeric,\n       $21::numeric, $22::numeric,\n       $23::numeric,\n       $24::jsonb\n     )`, [\n        point.symbol,\n        ts,\n        stats.v_inner,\n        stats.v_outer,\n        stats.v_swap,\n        stats.v_tendency,\n        stats.disruption,\n        stats.amp,\n        stats.volt,\n        stats.inertia,\n        stats.mode_general,\n        stats.mode_b,\n        {\n            density,\n            bucket_start: point.bucketStart,\n            bucket_end: point.bucketEnd,\n            top_bid_vol: meta.topBidVol,\n            top_ask_vol: meta.topAskVol\n        },\n        meta.bucketCount || null,\n        meta.tickMsMin,\n        meta.tickMsMax,\n        meta.tickMsAvg,\n        meta.spreadMin,\n        meta.spreadMax,\n        meta.spreadAvg,\n        meta.midMin,\n        meta.midMax,\n        meta.liquidityImbalance,\n        JSON.stringify(meta.qualityFlags ?? [])\n    ]);\n}\nfunction startPersistenceLoop() {\n    if (globalThis.__STR_AUX_PERSIST_LOOPS__?.started) return;\n    globalThis.__STR_AUX_PERSIST_LOOPS__ = {\n        loops: {\n            buckets: new Set()\n        },\n        started: true\n    };\n    if (!persistTimer) {\n        persistTimer = setTimeout(flushPendingBuckets, PERSIST_INTERVAL_MS);\n    }\n}\nfunction defaultBucketMeta(point) {\n    const topBidVol = point.book.bids.slice(0, 5).reduce((sum, lvl)=>sum + lvl.qty, 0);\n    const topAskVol = point.book.asks.slice(0, 5).reduce((sum, lvl)=>sum + lvl.qty, 0);\n    const topTotal = topBidVol + topAskVol;\n    return {\n        bucketCount: 1,\n        tickMsMin: null,\n        tickMsMax: null,\n        tickMsAvg: null,\n        spreadMin: point.spread,\n        spreadMax: point.spread,\n        spreadAvg: point.spread,\n        midMin: point.mid,\n        midMax: point.mid,\n        topBidVol,\n        topAskVol,\n        liquidityImbalance: topTotal > 0 ? (topBidVol - topAskVol) / topTotal : null,\n        qualityFlags: []\n    };\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3NhbXBsaW5nL3BlcnNpc3RlbmNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE4QztBQWM5QyxNQUFNQyxzQkFBc0JDLE9BQU9DLFFBQVFDLEdBQUcsQ0FBQ0Msc0JBQXNCLElBQUk7QUFDekUsTUFBTUMsaUJBQWlCLElBQUlDO0FBQzNCLElBQUlDLGVBQWUsSUFBSUM7QUFDdkIsSUFBSUMsZUFBc0M7QUFFbkMsU0FBU0MseUJBQXlCQyxLQUFvQjtJQUMzRE4sZUFBZU8sR0FBRyxDQUFDLEdBQUdELE1BQU1FLE1BQU0sQ0FBQyxDQUFDLEVBQUVGLE1BQU1HLFNBQVMsRUFBRSxFQUFFSDtJQUN6REosYUFBYVEsR0FBRyxDQUFDSixNQUFNRSxNQUFNO0lBQzdCLElBQUksQ0FBQ0osY0FBYztRQUNqQkEsZUFBZU8sV0FBV0MscUJBQXFCakI7SUFDakQ7QUFDRjtBQUVBLGVBQWVpQjtJQUNiUixlQUFlO0lBQ2YsSUFBSSxDQUFDSixlQUFlYSxJQUFJLEVBQUU7UUFDeEJYLGFBQWFZLEtBQUs7UUFDbEI7SUFDRjtJQUVBLE1BQU1DLFlBQVlDLE1BQU1DLElBQUksQ0FBQ2pCLGVBQWVrQixNQUFNO0lBQ2xEbEIsZUFBZWMsS0FBSztJQUNwQlosZUFBZSxJQUFJQztJQUVuQixLQUFLLE1BQU1HLFNBQVNTLFVBQVc7UUFDN0IsSUFBSTtZQUNGLE1BQU1JLGNBQWNiO1FBQ3RCLEVBQUUsT0FBT2MsS0FBSztZQUNaQyxRQUFRQyxJQUFJLENBQUMsOENBQThDaEIsTUFBTUUsTUFBTSxFQUFFWTtRQUMzRTtJQUNGO0FBQ0Y7QUFFQSxlQUFlRCxjQUFjYixLQUFvQjtJQUMvQyxNQUFNaUIsS0FBS2pCLE1BQU1HLFNBQVM7SUFDMUIsTUFBTWUsVUFBVTtRQUNkQyxLQUFLbkIsTUFBTW1CLEdBQUc7UUFDZEMsU0FBU3BCLE1BQU1vQixPQUFPO1FBQ3RCQyxTQUFTckIsTUFBTXFCLE9BQU87UUFDdEJDLFFBQVF0QixN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QUFDdUMsSUFBSSxDQUFDTCxLQUFLLENBQUMsR0FBRyxHQUFHQyxNQUFNLENBQUMsQ0FBQ0MsS0FBS0MsTUFBUUQsTUFBTUMsSUFBSUMsR0FBRyxFQUFFO0lBQ2xGLE1BQU1FLFdBQVdwQixZQUFZRTtJQUM3QixPQUFPO1FBQ0xwQixhQUFhO1FBQ2JFLFdBQVc7UUFDWEUsV0FBVztRQUNYRSxXQUFXO1FBQ1hFLFdBQVd0RCxNQUFNc0IsTUFBTTtRQUN2QmtDLFdBQVd4RCxNQUFNc0IsTUFBTTtRQUN2Qm9DLFdBQVcxRCxNQUFNc0IsTUFBTTtRQUN2QnNDLFFBQVE1RCxNQUFNbUIsR0FBRztRQUNqQjJDLFFBQVE5RCxNQUFNbUIsR0FBRztRQUNqQjZDO1FBQ0FFO1FBQ0FFLG9CQUFvQmdCLFdBQVcsSUFBSSxDQUFDcEIsWUFBWUUsU0FBUSxJQUFLa0IsV0FBVztRQUN4RWQsY0FBYyxFQUFFO0lBQ2xCO0FBQ0YiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxjb3JlXFxmZWF0dXJlc1xcc3RyLWF1eFxcc2FtcGxpbmdcXHBlcnNpc3RlbmNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHF1ZXJ5IH0gZnJvbSBcIkAvY29yZS9kYi9wb29sX3NlcnZlclwiO1xyXG5pbXBvcnQgdHlwZSB7IFNhbXBsaW5nUG9pbnQgfSBmcm9tIFwiLi90eXBlc1wiO1xyXG5cclxudHlwZSBMb29wc1N0YXRlID0ge1xyXG4gIGJ1Y2tldHM6IFNldDxzdHJpbmc+O1xyXG59O1xyXG5cclxuZGVjbGFyZSBnbG9iYWwge1xyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXJcclxuICB2YXIgX19TVFJfQVVYX1BFUlNJU1RfTE9PUFNfXzpcclxuICAgIHwgeyBsb29wczogTG9vcHNTdGF0ZTsgc3RhcnRlZDogYm9vbGVhbiB9XHJcbiAgICB8IHVuZGVmaW5lZDtcclxufVxyXG5cclxuY29uc3QgUEVSU0lTVF9JTlRFUlZBTF9NUyA9IE51bWJlcihwcm9jZXNzLmVudi5TVFJfU0FNUExFUl9QRVJTSVNUX01TID8/IDVfMDAwKTtcclxuY29uc3QgcGVuZGluZ0J1Y2tldHMgPSBuZXcgTWFwPHN0cmluZywgU2FtcGxpbmdQb2ludD4oKTtcclxubGV0IGRpcnR5U3ltYm9scyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG5sZXQgcGVyc2lzdFRpbWVyOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVucXVldWVCdWNrZXRQZXJzaXN0ZW5jZShwb2ludDogU2FtcGxpbmdQb2ludCkge1xyXG4gIHBlbmRpbmdCdWNrZXRzLnNldChgJHtwb2ludC5zeW1ib2x9OiR7cG9pbnQuYnVja2V0RW5kfWAsIHBvaW50KTtcclxuICBkaXJ0eVN5bWJvbHMuYWRkKHBvaW50LnN5bWJvbCk7XHJcbiAgaWYgKCFwZXJzaXN0VGltZXIpIHtcclxuICAgIHBlcnNpc3RUaW1lciA9IHNldFRpbWVvdXQoZmx1c2hQZW5kaW5nQnVja2V0cywgUEVSU0lTVF9JTlRFUlZBTF9NUyk7XHJcbiAgfVxyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBmbHVzaFBlbmRpbmdCdWNrZXRzKCkge1xyXG4gIHBlcnNpc3RUaW1lciA9IG51bGw7XHJcbiAgaWYgKCFwZW5kaW5nQnVja2V0cy5zaXplKSB7XHJcbiAgICBkaXJ0eVN5bWJvbHMuY2xlYXIoKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGNvbnN0IHRvUGVyc2lzdCA9IEFycmF5LmZyb20ocGVuZGluZ0J1Y2tldHMudmFsdWVzKCkpO1xyXG4gIHBlbmRpbmdCdWNrZXRzLmNsZWFyKCk7XHJcbiAgZGlydHlTeW1ib2xzID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcblxyXG4gIGZvciAoY29uc3QgcG9pbnQgb2YgdG9QZXJzaXN0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCBwZXJzaXN0QnVja2V0KHBvaW50KTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oXCJbc3RyLWF1eCBzYW1wbGVyXSBmYWlsZWQgdG8gcGVyc2lzdCBidWNrZXRcIiwgcG9pbnQuc3ltYm9sLCBlcnIpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gcGVyc2lzdEJ1Y2tldChwb2ludDogU2FtcGxpbmdQb2ludCkge1xyXG4gIGNvbnN0IHRzID0gcG9pbnQuYnVja2V0RW5kO1xyXG4gIGNvbnN0IGRlbnNpdHkgPSB7XHJcbiAgICBtaWQ6IHBvaW50Lm1pZCxcclxuICAgIGJlc3RCaWQ6IHBvaW50LmJlc3RCaWQsXHJcbiAgICBiZXN0QXNrOiBwb2ludC5iZXN0QXNrLFxyXG4gICAgc3ByZWFkOiBwb2ludC5zcHJlYWQsXHJcbiAgICBiaWRWb2x1bWU6IHBvaW50LmJpZFZvbHVtZSxcclxuICAgIGFza1ZvbHVtZTogcG9pbnQuYXNrVm9sdW1lLFxyXG4gIH07XHJcblxyXG4gIGNvbnN0IG1ldGEgPSBwb2ludC5idWNrZXRNZXRhID8/IGRlZmF1bHRCdWNrZXRNZXRhKHBvaW50KTtcclxuXHJcbiAgY29uc3Qgc3RhdHMgPSB7XHJcbiAgICB2X2lubmVyOiBudWxsLFxyXG4gICAgdl9vdXRlcjogbnVsbCxcclxuICAgIHZfc3dhcDogbnVsbCxcclxuICAgIHZfdGVuZGVuY3k6IG51bGwsXHJcbiAgICBkaXNydXB0aW9uOiBudWxsLFxyXG4gICAgYW1wOiBudWxsLFxyXG4gICAgdm9sdDogbnVsbCxcclxuICAgIGluZXJ0aWE6IG51bGwsXHJcbiAgICBtb2RlX2dlbmVyYWw6IG51bGwsXHJcbiAgICBtb2RlX2I6IG51bGwsXHJcbiAgfTtcclxuXHJcbiAgYXdhaXQgcXVlcnkoYHNlbGVjdCBzdHJfYXV4LnVwc2VydF9zYW1wbGVfNXNfbW9kZWwoJDEsIHRvX3RpbWVzdGFtcCgkMi8xMDAwLjApLCAkMzo6anNvbmIpYCwgW1xyXG4gICAgcG9pbnQuc3ltYm9sLFxyXG4gICAgdHMsXHJcbiAgICBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgIGJ1Y2tldF9zdGFydDogcG9pbnQuYnVja2V0U3RhcnQsXHJcbiAgICAgIGJ1Y2tldF9lbmQ6IHBvaW50LmJ1Y2tldEVuZCxcclxuICAgICAgYm9vazogcG9pbnQuYm9vayxcclxuICAgICAgZGVuc2l0eSxcclxuICAgICAgc3RhdHM6IHtcclxuICAgICAgICBidWNrZXRfY291bnQ6IG1ldGEuYnVja2V0Q291bnQsXHJcbiAgICAgICAgdGlja19tc19taW46IG1ldGEudGlja01zTWluLFxyXG4gICAgICAgIHRpY2tfbXNfbWF4OiBtZXRhLnRpY2tNc01heCxcclxuICAgICAgICB0aWNrX21zX2F2ZzogbWV0YS50aWNrTXNBdmcsXHJcbiAgICAgICAgc3ByZWFkX21pbjogbWV0YS5zcHJlYWRNaW4sXHJcbiAgICAgICAgc3ByZWFkX21heDogbWV0YS5zcHJlYWRNYXgsXHJcbiAgICAgICAgc3ByZWFkX2F2ZzogbWV0YS5zcHJlYWRBdmcsXHJcbiAgICAgICAgbWlkX21pbjogbWV0YS5taWRNaW4sXHJcbiAgICAgICAgbWlkX21heDogbWV0YS5taWRNYXgsXHJcbiAgICAgICAgdG9wX2JpZF92b2w6IG1ldGEudG9wQmlkVm9sLFxyXG4gICAgICAgIHRvcF9hc2tfdm9sOiBtZXRhLnRvcEFza1ZvbCxcclxuICAgICAgICBsaXF1aWRpdHlfaW1iYWxhbmNlOiBtZXRhLmxpcXVpZGl0eUltYmFsYW5jZSxcclxuICAgICAgICBxdWFsaXR5X2ZsYWdzOiBtZXRhLnF1YWxpdHlGbGFncyxcclxuICAgICAgfSxcclxuICAgIH0pLFxyXG4gIF0pO1xyXG5cclxuICBhd2FpdCBxdWVyeShcclxuICAgIGBzZWxlY3Qgc3RyX2F1eC51cHNlcnRfc2FtcGxlXzVzKFxyXG4gICAgICAgJDE6OnRleHQsIHRvX3RpbWVzdGFtcCgkMi8xMDAwLjApLFxyXG4gICAgICAgJDM6Om51bWVyaWMsICQ0OjpudW1lcmljLCAkNTo6bnVtZXJpYywgJDY6Om51bWVyaWMsXHJcbiAgICAgICAkNzo6bnVtZXJpYywgJDg6Om51bWVyaWMsICQ5OjpudW1lcmljLCAkMTA6Om51bWVyaWMsXHJcbiAgICAgICAkMTE6OnNtYWxsaW50LCAkMTI6OnNtYWxsaW50LCAkMTM6Ompzb25iLFxyXG4gICAgICAgJDE0OjpzbWFsbGludCwgJDE1OjppbnQsICQxNjo6aW50LCAkMTc6OmludCxcclxuICAgICAgICQxODo6bnVtZXJpYywgJDE5OjpudW1lcmljLCAkMjA6Om51bWVyaWMsXHJcbiAgICAgICAkMjE6Om51bWVyaWMsICQyMjo6bnVtZXJpYyxcclxuICAgICAgICQyMzo6bnVtZXJpYyxcclxuICAgICAgICQyNDo6anNvbmJcclxuICAgICApYCxcclxuICAgIFtcclxuICAgICAgcG9pbnQuc3ltYm9sLFxyXG4gICAgICB0cyxcclxuICAgICAgc3RhdHMudl9pbm5lcixcclxuICAgICAgc3RhdHMudl9vdXRlcixcclxuICAgICAgc3RhdHMudl9zd2FwLFxyXG4gICAgICBzdGF0cy52X3RlbmRlbmN5LFxyXG4gICAgICBzdGF0cy5kaXNydXB0aW9uLFxyXG4gICAgICBzdGF0cy5hbXAsXHJcbiAgICAgIHN0YXRzLnZvbHQsXHJcbiAgICAgIHN0YXRzLmluZXJ0aWEsXHJcbiAgICAgIHN0YXRzLm1vZGVfZ2VuZXJhbCxcclxuICAgICAgc3RhdHMubW9kZV9iLFxyXG4gICAgICB7XHJcbiAgICAgICAgZGVuc2l0eSxcclxuICAgICAgICBidWNrZXRfc3RhcnQ6IHBvaW50LmJ1Y2tldFN0YXJ0LFxyXG4gICAgICAgIGJ1Y2tldF9lbmQ6IHBvaW50LmJ1Y2tldEVuZCxcclxuICAgICAgICB0b3BfYmlkX3ZvbDogbWV0YS50b3BCaWRWb2wsXHJcbiAgICAgICAgdG9wX2Fza192b2w6IG1ldGEudG9wQXNrVm9sLFxyXG4gICAgICB9LFxyXG4gICAgICBtZXRhLmJ1Y2tldENvdW50IHx8IG51bGwsXHJcbiAgICAgIG1ldGEudGlja01zTWluLFxyXG4gICAgICBtZXRhLnRpY2tNc01heCxcclxuICAgICAgbWV0YS50aWNrTXNBdmcsXHJcbiAgICAgIG1ldGEuc3ByZWFkTWluLFxyXG4gICAgICBtZXRhLnNwcmVhZE1heCxcclxuICAgICAgbWV0YS5zcHJlYWRBdmcsXHJcbiAgICAgIG1ldGEubWlkTWluLFxyXG4gICAgICBtZXRhLm1pZE1heCxcclxuICAgICAgbWV0YS5saXF1aWRpdHlJbWJhbGFuY2UsXHJcbiAgICAgIEpTT04uc3RyaW5naWZ5KG1ldGEucXVhbGl0eUZsYWdzID8/IFtdKSxcclxuICAgIF1cclxuICApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRQZXJzaXN0ZW5jZUxvb3AoKSB7XHJcbiAgaWYgKGdsb2JhbFRoaXMuX19TVFJfQVVYX1BFUlNJU1RfTE9PUFNfXz8uc3RhcnRlZCkgcmV0dXJuO1xyXG4gIGdsb2JhbFRoaXMuX19TVFJfQVVYX1BFUlNJU1RfTE9PUFNfXyA9IHtcclxuICAgIGxvb3BzOiB7IGJ1Y2tldHM6IG5ldyBTZXQ8c3RyaW5nPigpIH0sXHJcbiAgICBzdGFydGVkOiB0cnVlLFxyXG4gIH07XHJcbiAgaWYgKCFwZXJzaXN0VGltZXIpIHtcclxuICAgIHBlcnNpc3RUaW1lciA9IHNldFRpbWVvdXQoZmx1c2hQZW5kaW5nQnVja2V0cywgUEVSU0lTVF9JTlRFUlZBTF9NUyk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0QnVja2V0TWV0YShwb2ludDogU2FtcGxpbmdQb2ludCkge1xyXG4gIGNvbnN0IHRvcEJpZFZvbCA9IHBvaW50LmJvb2suYmlkcy5zbGljZSgwLCA1KS5yZWR1Y2UoKHN1bSwgbHZsKSA9PiBzdW0gKyBsdmwucXR5LCAwKTtcclxuICBjb25zdCB0b3BBc2tWb2wgPSBwb2ludC5ib29rLmFza3Muc2xpY2UoMCwgNSkucmVkdWNlKChzdW0sIGx2bCkgPT4gc3VtICsgbHZsLnF0eSwgMCk7XHJcbiAgY29uc3QgdG9wVG90YWwgPSB0b3BCaWRWb2wgKyB0b3BBc2tWb2w7XHJcbiAgcmV0dXJuIHtcclxuICAgIGJ1Y2tldENvdW50OiAxLFxyXG4gICAgdGlja01zTWluOiBudWxsLFxyXG4gICAgdGlja01zTWF4OiBudWxsLFxyXG4gICAgdGlja01zQXZnOiBudWxsLFxyXG4gICAgc3ByZWFkTWluOiBwb2ludC5zcHJlYWQsXHJcbiAgICBzcHJlYWRNYXg6IHBvaW50LnNwcmVhZCxcclxuICAgIHNwcmVhZEF2ZzogcG9pbnQuc3ByZWFkLFxyXG4gICAgbWlkTWluOiBwb2ludC5taWQsXHJcbiAgICBtaWRNYXg6IHBvaW50Lm1pZCxcclxuICAgIHRvcEJpZFZvbCxcclxuICAgIHRvcEFza1ZvbCxcclxuICAgIGxpcXVpZGl0eUltYmFsYW5jZTogdG9wVG90YWwgPiAwID8gKHRvcEJpZFZvbCAtIHRvcEFza1ZvbCkgLyB0b3BUb3RhbCA6IG51bGwsXHJcbiAgICBxdWFsaXR5RmxhZ3M6IFtdLFxyXG4gIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbInF1ZXJ5IiwiUEVSU0lTVF9JTlRFUlZBTF9NUyIsIk51bWJlciIsInByb2Nlc3MiLCJlbnYiLCJTVFJfU0FNUExFUl9QRVJTSVNUX01TIiwicGVuZGluZ0J1Y2tldHMiLCJNYXAiLCJkaXJ0eVN5bWJvbHMiLCJTZXQiLCJwZXJzaXN0VGltZXIiLCJlbnF1ZXVlQnVja2V0UGVyc2lzdGVuY2UiLCJwb2ludCIsInNldCIsInN5bWJvbCIsImJ1Y2tldEVuZCIsImFkZCIsInNldFRpbWVvdXQiLCJmbHVzaFBlbmRpbmdCdWNrZXRzIiwic2l6ZSIsImNsZWFyIiwidG9QZXJzaXN0IiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwicGVyc2lzdEJ1Y2tldCIsImVyciIsImNvbnNvbGUiLCJ3YXJuIiwidHMiLCJkZW5zaXR5IiwibWlkIiwiYmVzdEJpZCIsImJlc3RBc2siLCJzcHJlYWQiLCJiaWRWb2x1bWUiLCJhc2tWb2x1bWUiLCJtZXRhIiwiYnVja2V0TWV0YSIsImRlZmF1bHRCdWNrZXRNZXRhIiwic3RhdHMiLCJ2X2lubmVyIiwidl9vdXRlciIsInZfc3dhcCIsInZfdGVuZGVuY3kiLCJkaXNydXB0aW9uIiwiYW1wIiwidm9sdCIsImluZXJ0aWEiLCJtb2RlX2dlbmVyYWwiLCJtb2RlX2IiLCJKU09OIiwic3RyaW5naWZ5IiwiYnVja2V0X3N0YXJ0IiwiYnVja2V0U3RhcnQiLCJidWNrZXRfZW5kIiwiYm9vayIsImJ1Y2tldF9jb3VudCIsImJ1Y2tldENvdW50IiwidGlja19tc19taW4iLCJ0aWNrTXNNaW4iLCJ0aWNrX21zX21heCIsInRpY2tNc01heCIsInRpY2tfbXNfYXZnIiwidGlja01zQXZnIiwic3ByZWFkX21pbiIsInNwcmVhZE1pbiIsInNwcmVhZF9tYXgiLCJzcHJlYWRNYXgiLCJzcHJlYWRfYXZnIiwic3ByZWFkQXZnIiwibWlkX21pbiIsIm1pZE1pbiIsIm1pZF9tYXgiLCJtaWRNYXgiLCJ0b3BfYmlkX3ZvbCIsInRvcEJpZFZvbCIsInRvcF9hc2tfdm9sIiwidG9wQXNrVm9sIiwibGlxdWlkaXR5X2ltYmFsYW5jZSIsImxpcXVpZGl0eUltYmFsYW5jZSIsInF1YWxpdHlfZmxhZ3MiLCJxdWFsaXR5RmxhZ3MiLCJzdGFydFBlcnNpc3RlbmNlTG9vcCIsImdsb2JhbFRoaXMiLCJfX1NUUl9BVVhfUEVSU0lTVF9MT09QU19fIiwic3RhcnRlZCIsImxvb3BzIiwiYnVja2V0cyIsImJpZHMiLCJzbGljZSIsInJlZHVjZSIsInN1bSIsImx2bCIsInF0eSIsImFza3MiLCJ0b3BUb3RhbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/sampling/persistence.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/sampling/store.ts":
/*!*****************************************************!*\
  !*** ./src/core/features/str-aux/sampling/store.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SamplingStore: () => (/* binding */ SamplingStore),\n/* harmony export */   getSamplingStore: () => (/* binding */ getSamplingStore)\n/* harmony export */ });\n/* harmony import */ var _core_sources_binance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/sources/binance */ \"(rsc)/./src/core/sources/binance.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"(rsc)/./src/core/features/str-aux/sampling/utils.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_sources_binance__WEBPACK_IMPORTED_MODULE_0__]);\n_core_sources_binance__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n// src/core/features/str-aux/sampling/store.ts\n\n\nconst clampStatus = (status, target)=>{\n    if (status === \"error\" || target === \"error\") return \"error\";\n    if (status === \"warn\" || target === \"warn\") return \"warn\";\n    return \"ok\";\n};\nclass SamplingStore {\n    constructor(config = _utils__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SAMPLER_CONFIG){\n        this.states = new Map();\n        this.config = config;\n        this.maxWindowDurationMs = Math.max(...Object.values(config.windows).map((w)=>w.durationMs));\n        this.expectedPointsPerCycle = Math.max(1, Math.round(config.cycleDurationMs / config.pointIntervalMs));\n    }\n    async collect(symbol, opts) {\n        const symbolKey = this.normalizeSymbol(symbol);\n        const state = this.ensureState(symbolKey);\n        const now = Date.now();\n        if (opts?.point) {\n            const mark = this.pushPoint(symbolKey, {\n                ...opts.point,\n                symbol: symbolKey\n            });\n            return {\n                point: opts.point,\n                closedMark: mark,\n                snapshot: this.snapshot(symbolKey, state)\n            };\n        }\n        if (!opts?.force && state.lastPoint && now - state.lastPoint.ts < this.config.pointIntervalMs * 0.75) {\n            return {\n                point: null,\n                closedMark: null,\n                snapshot: this.snapshot(symbolKey, state)\n            };\n        }\n        const point = await this.fetchPoint(symbolKey);\n        if (!point) {\n            return {\n                point: null,\n                closedMark: null,\n                snapshot: this.snapshot(symbolKey, state)\n            };\n        }\n        const mark = this.pushPoint(symbolKey, point);\n        return {\n            point,\n            closedMark: mark,\n            snapshot: this.snapshot(symbolKey, state)\n        };\n    }\n    getPoints(symbol, window) {\n        const symbolKey = this.normalizeSymbol(symbol);\n        const state = this.states.get(symbolKey);\n        if (!state) return [];\n        const durationMs = this.config.windows[window]?.durationMs ?? this.maxWindowDurationMs;\n        const refTs = state.lastPoint?.ts ?? Date.now();\n        const cutoff = refTs - durationMs;\n        const list = state.history;\n        let idx = 0;\n        while(idx < list.length && list[idx].ts < cutoff)idx += 1;\n        return list.slice(idx);\n    }\n    getMarks(symbol, window) {\n        const state = this.states.get(this.normalizeSymbol(symbol));\n        if (!state) return [];\n        return [\n            ...state.windows[window]\n        ];\n    }\n    snapshot(symbol, stateOverride) {\n        const symbolKey = this.normalizeSymbol(symbol);\n        const state = stateOverride ?? this.ensureState(symbolKey);\n        const cycleStatus = this.computeCycleStatus(state, Date.now());\n        const windows = {\n            \"30m\": this.buildWindowSummary(\"30m\", state),\n            \"1h\": this.buildWindowSummary(\"1h\", state),\n            \"3h\": this.buildWindowSummary(\"3h\", state)\n        };\n        return {\n            symbol: symbolKey,\n            cycle: cycleStatus,\n            windows,\n            lastPoint: state.lastPoint,\n            lastClosedMark: state.lastClosedMark,\n            historySize: state.history.length\n        };\n    }\n    get expectedPoints() {\n        return this.expectedPointsPerCycle;\n    }\n    bucketStart(ts) {\n        return Math.floor(ts / this.config.pointIntervalMs) * this.config.pointIntervalMs;\n    }\n    normalizeSymbol(symbol) {\n        return String(symbol ?? \"\").trim().toUpperCase();\n    }\n    ensureState(symbol) {\n        const existing = this.states.get(symbol);\n        if (existing) return existing;\n        const init = {\n            currentStart: null,\n            currentPoints: [],\n            lastPoint: null,\n            lastClosedMark: null,\n            history: [],\n            windows: {\n                \"30m\": [],\n                \"1h\": [],\n                \"3h\": []\n            }\n        };\n        this.states.set(symbol, init);\n        return init;\n    }\n    async fetchPoint(symbol) {\n        try {\n            const ob = await (0,_core_sources_binance__WEBPACK_IMPORTED_MODULE_0__.fetchOrderBook)(symbol, 50);\n            if (!(ob.mid > 0)) return null;\n            const ts = ob.ts ?? Date.now();\n            const bestBid = Number.isFinite(ob.bestBid) ? ob.bestBid : ob.mid;\n            const bestAsk = Number.isFinite(ob.bestAsk) ? ob.bestAsk : ob.mid;\n            const spread = Number.isFinite(bestBid) && Number.isFinite(bestAsk) ? Math.abs(bestAsk - bestBid) : 0;\n            const bucketStart = this.bucketStart(ts);\n            const bucketEnd = bucketStart + this.config.pointIntervalMs;\n            const book = mapDepthSnapshot(ob.depth);\n            return {\n                symbol,\n                ts,\n                mid: ob.mid,\n                bestBid,\n                bestAsk,\n                spread,\n                bidVolume: Number.isFinite(ob.bidVol) ? ob.bidVol : 0,\n                askVolume: Number.isFinite(ob.askVol) ? ob.askVol : 0,\n                bucketStart,\n                bucketEnd,\n                book\n            };\n        } catch (err) {\n            if (err instanceof _utils__WEBPACK_IMPORTED_MODULE_1__.SamplingStoreError) throw err;\n            return null;\n        }\n    }\n    pushPoint(symbol, point) {\n        const state = this.ensureState(symbol);\n        const ts = point.ts;\n        if (state.lastPoint && ts <= state.lastPoint.ts) {\n            point = {\n                ...point,\n                ts: state.lastPoint.ts + 1\n            };\n        }\n        state.lastPoint = point;\n        state.history.push(point);\n        this.pruneHistory(state);\n        if (!state.currentPoints.length) {\n            state.currentPoints = [\n                point\n            ];\n            state.currentStart = point.ts;\n            return null;\n        }\n        const cycleStart = state.currentStart ?? state.currentPoints[0]?.ts ?? point.ts;\n        state.currentStart = cycleStart;\n        const elapsed = ts - cycleStart;\n        if (elapsed < this.config.cycleDurationMs) {\n            state.currentPoints.push(point);\n            return null;\n        }\n        const mark = this.buildMark(symbol, cycleStart, state.currentPoints);\n        this.storeMark(state, mark);\n        state.lastClosedMark = mark;\n        state.currentPoints = [\n            point\n        ];\n        state.currentStart = point.ts;\n        return mark;\n    }\n    pruneHistory(state) {\n        const cutoff = (state.lastPoint?.ts ?? Date.now()) - this.maxWindowDurationMs;\n        let drop = 0;\n        while(drop < state.history.length && state.history[drop].ts < cutoff)drop += 1;\n        if (drop > 0) state.history.splice(0, drop);\n    }\n    buildMark(symbol, startedAt, points) {\n        const list = [\n            ...points\n        ].sort((a, b)=>a.ts - b.ts);\n        const first = list[0];\n        const last = list[list.length - 1] ?? first;\n        const priceValues = list.map((p)=>p.mid).filter((v)=>Number.isFinite(v));\n        const spreadValues = list.map((p)=>p.spread).filter((v)=>Number.isFinite(v));\n        const bidVolumes = list.map((p)=>p.bidVolume).filter((v)=>Number.isFinite(v));\n        const askVolumes = list.map((p)=>p.askVolume).filter((v)=>Number.isFinite(v));\n        const priceMin = priceValues.length ? Math.min(...priceValues) : NaN;\n        const priceMax = priceValues.length ? Math.max(...priceValues) : NaN;\n        const priceAvg = priceValues.length ? priceValues.reduce((s, v)=>s + v, 0) / priceValues.length : NaN;\n        const spreadMin = spreadValues.length ? Math.min(...spreadValues) : NaN;\n        const spreadMax = spreadValues.length ? Math.max(...spreadValues) : NaN;\n        const spreadAvg = spreadValues.length ? spreadValues.reduce((s, v)=>s + v, 0) / spreadValues.length : NaN;\n        const bidVolume = bidVolumes.reduce((s, v)=>s + v, 0);\n        const askVolume = askVolumes.reduce((s, v)=>s + v, 0);\n        const expectedNominal = this.expectedPointsPerCycle;\n        const actualDurationMs = last && startedAt !== null ? Math.max(0, last.ts - startedAt) : this.config.cycleDurationMs;\n        const expectedFromDuration = Math.max(1, Math.round(actualDurationMs / this.config.pointIntervalMs));\n        const expectedPoints = Math.min(expectedNominal, Math.max(1, expectedFromDuration));\n        const warnFloor = Math.max(1, Math.ceil(expectedPoints * 0.5));\n        const tolerance = Math.max(1, Math.ceil(expectedPoints * 0.25));\n        const minOk = Math.max(1, expectedPoints - tolerance);\n        let status = \"ok\";\n        const notes = [];\n        if (!list.length) {\n            status = \"error\";\n            notes.push(\"empty_cycle\");\n        } else {\n            if (priceValues.length === 0) {\n                status = \"error\";\n                notes.push(\"no_prices\");\n            }\n            if (list.length < warnFloor) {\n                status = clampStatus(status, \"warn\");\n                notes.push(\"too_few_points\");\n            } else if (list.length < minOk) {\n                status = clampStatus(status, \"warn\");\n                notes.push(\"partial_cycle\");\n            }\n            if (last && startedAt !== null) {\n                const intended = this.config.cycleDurationMs;\n                const delta = last.ts - startedAt - intended;\n                if (delta > this.config.pointIntervalMs) {\n                    status = clampStatus(status, \"warn\");\n                    notes.push(\"extended_cycle\");\n                }\n            }\n        }\n        const startTs = startedAt ?? first?.ts ?? last?.ts ?? Date.now();\n        const closeTs = last?.ts ?? startTs;\n        return {\n            id: `${symbol}:${startTs}`,\n            symbol,\n            startedAt: startTs,\n            closedAt: closeTs,\n            durationMs: Math.max(0, closeTs - startTs),\n            pointsCount: list.length,\n            price: {\n                open: first?.mid ?? NaN,\n                close: last?.mid ?? NaN,\n                min: priceMin,\n                max: priceMax,\n                avg: priceAvg\n            },\n            spread: {\n                min: spreadMin,\n                max: spreadMax,\n                avg: spreadAvg\n            },\n            volume: {\n                bid: bidVolume,\n                ask: askVolume,\n                total: bidVolume + askVolume\n            },\n            points: list,\n            health: {\n                status,\n                notes,\n                expectedPoints\n            }\n        };\n    }\n    storeMark(state, mark) {\n        for (const key of Object.keys(this.config.windows)){\n            const window = state.windows[key];\n            window.push(mark);\n            const cap = this.config.windows[key]?.capacity ?? window.length;\n            while(window.length > cap)window.shift();\n        }\n    }\n    computeCycleStatus(state, now) {\n        const points = state.currentPoints.length;\n        const expectedNominal = this.expectedPointsPerCycle;\n        const startTs = state.currentStart ?? state.currentPoints[0]?.ts ?? null;\n        const lastPointTs = state.currentPoints[state.currentPoints.length - 1]?.ts ?? state.lastPoint?.ts ?? now;\n        const elapsed = startTs != null ? Math.max(0, (lastPointTs ?? now) - startTs) : 0;\n        const expectedRaw = startTs != null ? Math.max(1, Math.round(elapsed / this.config.pointIntervalMs)) : Math.max(1, Math.min(points || expectedNominal, expectedNominal));\n        const expectedSoFar = Math.min(expectedNominal, expectedRaw);\n        const tolerance = Math.max(1, Math.ceil(expectedSoFar * 0.3));\n        let status = \"ok\";\n        const notes = [];\n        if (!points) {\n            status = \"warn\";\n            notes.push(\"idle_cycle\");\n        } else if (expectedSoFar >= 3 && points + tolerance < expectedSoFar) {\n            status = \"warn\";\n            notes.push(\"low_points\");\n        } else if (points > expectedNominal * 1.5) {\n            status = \"warn\";\n            notes.push(\"extended_cycle\");\n        }\n        const closingAt = startTs ? startTs + this.config.cycleDurationMs : null;\n        return {\n            startedAt: startTs,\n            pointsCollected: points,\n            expectedPoints: expectedSoFar,\n            closingAt,\n            status,\n            notes\n        };\n    }\n    buildWindowSummary(key, state) {\n        const window = state.windows[key];\n        const counts = {\n            ok: 0,\n            warn: 0,\n            error: 0\n        };\n        for (const mark of window){\n            counts[mark.health.status] += 1;\n        }\n        const cfg = this.config.windows[key];\n        return {\n            key,\n            capacity: cfg?.capacity ?? window.length,\n            size: window.length,\n            marks: [\n                ...window\n            ],\n            statusCounts: counts\n        };\n    }\n}\nfunction getSamplingStore(config) {\n    if (!globalThis.__STR_AUX_SAMPLING_STORE__) {\n        globalThis.__STR_AUX_SAMPLING_STORE__ = new SamplingStore(config ?? _utils__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SAMPLER_CONFIG);\n    }\n    return globalThis.__STR_AUX_SAMPLING_STORE__;\n}\nfunction mapDepthSnapshot(depth) {\n    const mapLevels = (levels)=>{\n        if (!Array.isArray(levels)) return [];\n        return levels.map((row)=>{\n            const price = Number(row?.[0]);\n            const qty = Number(row?.[1]);\n            if (!Number.isFinite(price) || !Number.isFinite(qty) || qty <= 0) return null;\n            return {\n                price,\n                qty\n            };\n        }).filter((lvl)=>Boolean(lvl));\n    };\n    return {\n        bids: mapLevels(depth?.bids),\n        asks: mapLevels(depth?.asks)\n    };\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3NhbXBsaW5nL3N0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSw4Q0FBOEM7QUFDVTtBQUl2QztBQXNCakIsTUFBTUcsY0FBYyxDQUFDQyxRQUE4QkM7SUFDakQsSUFBSUQsV0FBVyxXQUFXQyxXQUFXLFNBQVMsT0FBTztJQUNyRCxJQUFJRCxXQUFXLFVBQVVDLFdBQVcsUUFBUSxPQUFPO0lBQ25ELE9BQU87QUFDVDtBQVFPLE1BQU1DO0lBTVgsWUFBWUMsU0FBd0JOLDBEQUFzQixDQUFFO2FBSjNDTyxTQUFTLElBQUlDO1FBSzVCLElBQUksQ0FBQ0YsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0csbUJBQW1CLEdBQUdDLEtBQUtDLEdBQUcsSUFBSUMsT0FBT0MsTUFBTSxDQUFDUCxPQUFPUSxPQUFPLEVBQUVDLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxFQUFFQyxVQUFVO1FBQzVGLElBQUksQ0FBQ0Msc0JBQXNCLEdBQUdSLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLUyxLQUFLLENBQUNiLE9BQU9jLGVBQWUsR0FBR2QsT0FBT2UsZUFBZTtJQUN0RztJQUVBLE1BQU1DLFFBQVFDLE1BQWMsRUFBRUMsSUFBaUQsRUFBMEI7UUFDdkcsTUFBTUMsWUFBWSxJQUFJLENBQUNDLGVBQWUsQ0FBQ0g7UUFDdkMsTUFBTUksUUFBUSxJQUFJLENBQUNDLFdBQVcsQ0FBQ0g7UUFDL0IsTUFBTUksTUFBTUMsS0FBS0QsR0FBRztRQUVwQixJQUFJTCxNQUFNTyxPQUFPO1lBQ2YsTUFBTUMsT0FBTyxJQUFJLENBQUNDLFNBQVMsQ0FBQ1IsV0FBVztnQkFBRSxHQUFHRCxLQUFLTyxLQUFLO2dCQUFFUixRQUFRRTtZQUFVO1lBQzFFLE9BQU87Z0JBQUVNLE9BQU9QLEtBQUtPLEtBQUs7Z0JBQUVHLFlBQVlGO2dCQUFNRyxVQUFVLElBQUksQ0FBQ0EsUUFBUSxDQUFDVixXQUFXRTtZQUFPO1FBQzFGO1FB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Q0FHLFVBQVVXLEtBQUtYLFlBQVl4RyxPQUFPTyxNQUFNO1lBQ3hDNkcsTUFBTXBILE9BQU9PLE1BQU07WUFDbkI4RyxPQUFPO21CQUFJckg7YUFBTztZQUNsQnNILGNBQWNQO1FBQ2hCO0lBQ0Y7QUFDRjtBQU9PLFNBQVNRLGlCQUFpQjFKLE1BQXNCO0lBQ3JELElBQUksQ0FBQyxXQUFvQjRKLDBCQUEwQixFQUFFO1FBQ2xERCxXQUFtQkMsMEJBQTBCLEdBQUcsSUFBSTdKLGNBQWNDLFVBQVVOLDBEQUFzQkE7SUFDckc7SUFDQSxPQUFPLFdBQW9Ca0ssMEJBQTBCO0FBQ3ZEO0FBRUEsU0FBU25GLGlCQUFpQkMsS0FBVTtJQUNsQyxNQUFNbUYsWUFBWSxDQUFDQztRQUNqQixJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0YsU0FBUyxPQUFPLEVBQUU7UUFDckMsT0FBT0EsT0FDSnJKLEdBQUcsQ0FBQyxDQUFDd0o7WUFDSixNQUFNbEMsUUFBUTdELE9BQU8rRixLQUFLLENBQUMsRUFBRTtZQUM3QixNQUFNQyxNQUFNaEcsT0FBTytGLEtBQUssQ0FBQyxFQUFFO1lBQzNCLElBQUksQ0FBQy9GLE9BQU9DLFFBQVEsQ0FBQzRELFVBQVUsQ0FBQzdELE9BQU9DLFFBQVEsQ0FBQytGLFFBQVFBLE9BQU8sR0FBRyxPQUFPO1lBQ3pFLE9BQU87Z0JBQUVuQztnQkFBT21DO1lBQUk7UUFDdEIsR0FDQ2pFLE1BQU0sQ0FBQyxDQUFDa0UsTUFBK0JDLFFBQVFEO0lBQ3BEO0lBRUEsT0FBTztRQUNMRSxNQUFNUixVQUFVbkYsT0FBTzJGO1FBQ3ZCQyxNQUFNVCxVQUFVbkYsT0FBTzRGO0lBQ3pCO0FBQ0YiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxjb3JlXFxmZWF0dXJlc1xcc3RyLWF1eFxcc2FtcGxpbmdcXHN0b3JlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb3JlL2ZlYXR1cmVzL3N0ci1hdXgvc2FtcGxpbmcvc3RvcmUudHNcbmltcG9ydCB7IGZldGNoT3JkZXJCb29rIH0gZnJvbSBcIkAvY29yZS9zb3VyY2VzL2JpbmFuY2VcIjtcbmltcG9ydCB7XG4gIERFRkFVTFRfU0FNUExFUl9DT05GSUcsXG4gIFNhbXBsaW5nU3RvcmVFcnJvcixcbn0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB0eXBlIHtcbiAgU2FtcGxlckNvbmZpZyxcbiAgU2FtcGxpbmdIZWFsdGhTdGF0dXMsXG4gIFNhbXBsaW5nTWFyayxcbiAgU2FtcGxpbmdQb2ludCxcbiAgU2FtcGxpbmdTbmFwc2hvdCxcbiAgU2FtcGxpbmdXaW5kb3dLZXksXG4gIFNhbXBsaW5nV2luZG93U3VtbWFyeSxcbiAgT3JkZXJCb29rU25hcHNob3QsXG4gIE9yZGVyQm9va0xldmVsLFxufSBmcm9tIFwiLi90eXBlc1wiO1xuXG50eXBlIFN5bWJvbFN0YXRlID0ge1xuICBjdXJyZW50U3RhcnQ6IG51bWJlciB8IG51bGw7XG4gIGN1cnJlbnRQb2ludHM6IFNhbXBsaW5nUG9pbnRbXTtcbiAgbGFzdFBvaW50OiBTYW1wbGluZ1BvaW50IHwgbnVsbDtcbiAgbGFzdENsb3NlZE1hcms6IFNhbXBsaW5nTWFyayB8IG51bGw7XG4gIGhpc3Rvcnk6IFNhbXBsaW5nUG9pbnRbXTtcbiAgd2luZG93czogUmVjb3JkPFNhbXBsaW5nV2luZG93S2V5LCBTYW1wbGluZ01hcmtbXT47XG59O1xuXG5jb25zdCBjbGFtcFN0YXR1cyA9IChzdGF0dXM6IFNhbXBsaW5nSGVhbHRoU3RhdHVzLCB0YXJnZXQ6IFNhbXBsaW5nSGVhbHRoU3RhdHVzKTogU2FtcGxpbmdIZWFsdGhTdGF0dXMgPT4ge1xuICBpZiAoc3RhdHVzID09PSBcImVycm9yXCIgfHwgdGFyZ2V0ID09PSBcImVycm9yXCIpIHJldHVybiBcImVycm9yXCI7XG4gIGlmIChzdGF0dXMgPT09IFwid2FyblwiIHx8IHRhcmdldCA9PT0gXCJ3YXJuXCIpIHJldHVybiBcIndhcm5cIjtcbiAgcmV0dXJuIFwib2tcIjtcbn07XG5cbmV4cG9ydCB0eXBlIENvbGxlY3RSZXN1bHQgPSB7XG4gIHBvaW50OiBTYW1wbGluZ1BvaW50IHwgbnVsbDtcbiAgY2xvc2VkTWFyazogU2FtcGxpbmdNYXJrIHwgbnVsbDtcbiAgc25hcHNob3Q6IFNhbXBsaW5nU25hcHNob3Q7XG59O1xuXG5leHBvcnQgY2xhc3MgU2FtcGxpbmdTdG9yZSB7XG4gIHJlYWRvbmx5IGNvbmZpZzogU2FtcGxlckNvbmZpZztcbiAgcHJpdmF0ZSByZWFkb25seSBzdGF0ZXMgPSBuZXcgTWFwPHN0cmluZywgU3ltYm9sU3RhdGU+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgbWF4V2luZG93RHVyYXRpb25NczogbnVtYmVyO1xuICBwcml2YXRlIHJlYWRvbmx5IGV4cGVjdGVkUG9pbnRzUGVyQ3ljbGU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFNhbXBsZXJDb25maWcgPSBERUZBVUxUX1NBTVBMRVJfQ09ORklHKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5tYXhXaW5kb3dEdXJhdGlvbk1zID0gTWF0aC5tYXgoLi4uT2JqZWN0LnZhbHVlcyhjb25maWcud2luZG93cykubWFwKCh3KSA9PiB3LmR1cmF0aW9uTXMpKTtcbiAgICB0aGlzLmV4cGVjdGVkUG9pbnRzUGVyQ3ljbGUgPSBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKGNvbmZpZy5jeWNsZUR1cmF0aW9uTXMgLyBjb25maWcucG9pbnRJbnRlcnZhbE1zKSk7XG4gIH1cblxuICBhc3luYyBjb2xsZWN0KHN5bWJvbDogc3RyaW5nLCBvcHRzPzogeyBmb3JjZT86IGJvb2xlYW47IHBvaW50PzogU2FtcGxpbmdQb2ludCB9KTogUHJvbWlzZTxDb2xsZWN0UmVzdWx0PiB7XG4gICAgY29uc3Qgc3ltYm9sS2V5ID0gdGhpcy5ub3JtYWxpemVTeW1ib2woc3ltYm9sKTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZW5zdXJlU3RhdGUoc3ltYm9sS2V5KTtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgaWYgKG9wdHM/LnBvaW50KSB7XG4gICAgICBjb25zdCBtYXJrID0gdGhpcy5wdXNoUG9pbnQoc3ltYm9sS2V5LCB7IC4uLm9wdHMucG9pbnQsIHN5bWJvbDogc3ltYm9sS2V5IH0pO1xuICAgICAgcmV0dXJuIHsgcG9pbnQ6IG9wdHMucG9pbnQsIGNsb3NlZE1hcms6IG1hcmssIHNuYXBzaG90OiB0aGlzLnNuYXBzaG90KHN5bWJvbEtleSwgc3RhdGUpIH07XG4gICAgfVxuXG4gICAgaWYgKCFvcHRzPy5mb3JjZSAmJiBzdGF0ZS5sYXN0UG9pbnQgJiYgbm93IC0gc3RhdGUubGFzdFBvaW50LnRzIDwgdGhpcy5jb25maWcucG9pbnRJbnRlcnZhbE1zICogMC43NSkge1xuICAgICAgcmV0dXJuIHsgcG9pbnQ6IG51bGwsIGNsb3NlZE1hcms6IG51bGwsIHNuYXBzaG90OiB0aGlzLnNuYXBzaG90KHN5bWJvbEtleSwgc3RhdGUpIH07XG4gICAgfVxuXG4gICAgY29uc3QgcG9pbnQgPSBhd2FpdCB0aGlzLmZldGNoUG9pbnQoc3ltYm9sS2V5KTtcbiAgICBpZiAoIXBvaW50KSB7XG4gICAgICByZXR1cm4geyBwb2ludDogbnVsbCwgY2xvc2VkTWFyazogbnVsbCwgc25hcHNob3Q6IHRoaXMuc25hcHNob3Qoc3ltYm9sS2V5LCBzdGF0ZSkgfTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXJrID0gdGhpcy5wdXNoUG9pbnQoc3ltYm9sS2V5LCBwb2ludCk7XG4gICAgcmV0dXJuIHsgcG9pbnQsIGNsb3NlZE1hcms6IG1hcmssIHNuYXBzaG90OiB0aGlzLnNuYXBzaG90KHN5bWJvbEtleSwgc3RhdGUpIH07XG4gIH1cblxuICBnZXRQb2ludHMoc3ltYm9sOiBzdHJpbmcsIHdpbmRvdzogU2FtcGxpbmdXaW5kb3dLZXkpOiBTYW1wbGluZ1BvaW50W10ge1xuICAgIGNvbnN0IHN5bWJvbEtleSA9IHRoaXMubm9ybWFsaXplU3ltYm9sKHN5bWJvbCk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlcy5nZXQoc3ltYm9sS2V5KTtcbiAgICBpZiAoIXN0YXRlKSByZXR1cm4gW107XG4gICAgY29uc3QgZHVyYXRpb25NcyA9IHRoaXMuY29uZmlnLndpbmRvd3Nbd2luZG93XT8uZHVyYXRpb25NcyA/PyB0aGlzLm1heFdpbmRvd0R1cmF0aW9uTXM7XG4gICAgY29uc3QgcmVmVHMgPSBzdGF0ZS5sYXN0UG9pbnQ/LnRzID8/IERhdGUubm93KCk7XG4gICAgY29uc3QgY3V0b2ZmID0gcmVmVHMgLSBkdXJhdGlvbk1zO1xuICAgIGNvbnN0IGxpc3QgPSBzdGF0ZS5oaXN0b3J5O1xuICAgIGxldCBpZHggPSAwO1xuICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCAmJiBsaXN0W2lkeF0udHMgPCBjdXRvZmYpIGlkeCArPSAxO1xuICAgIHJldHVybiBsaXN0LnNsaWNlKGlkeCk7XG4gIH1cblxuICBnZXRNYXJrcyhzeW1ib2w6IHN0cmluZywgd2luZG93OiBTYW1wbGluZ1dpbmRvd0tleSk6IFNhbXBsaW5nTWFya1tdIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGVzLmdldCh0aGlzLm5vcm1hbGl6ZVN5bWJvbChzeW1ib2wpKTtcbiAgICBpZiAoIXN0YXRlKSByZXR1cm4gW107XG4gICAgcmV0dXJuIFsuLi5zdGF0ZS53aW5kb3dzW3dpbmRvd11dO1xuICB9XG5cbiAgc25hcHNob3Qoc3ltYm9sOiBzdHJpbmcsIHN0YXRlT3ZlcnJpZGU/OiBTeW1ib2xTdGF0ZSk6IFNhbXBsaW5nU25hcHNob3Qge1xuICAgIGNvbnN0IHN5bWJvbEtleSA9IHRoaXMubm9ybWFsaXplU3ltYm9sKHN5bWJvbCk7XG4gICAgY29uc3Qgc3RhdGUgPSBzdGF0ZU92ZXJyaWRlID8/IHRoaXMuZW5zdXJlU3RhdGUoc3ltYm9sS2V5KTtcbiAgICBjb25zdCBjeWNsZVN0YXR1cyA9IHRoaXMuY29tcHV0ZUN5Y2xlU3RhdHVzKHN0YXRlLCBEYXRlLm5vdygpKTtcblxuICAgIGNvbnN0IHdpbmRvd3M6IFJlY29yZDxTYW1wbGluZ1dpbmRvd0tleSwgU2FtcGxpbmdXaW5kb3dTdW1tYXJ5PiA9IHtcbiAgICAgIFwiMzBtXCI6IHRoaXMuYnVpbGRXaW5kb3dTdW1tYXJ5KFwiMzBtXCIsIHN0YXRlKSxcbiAgICAgIFwiMWhcIjogdGhpcy5idWlsZFdpbmRvd1N1bW1hcnkoXCIxaFwiLCBzdGF0ZSksXG4gICAgICBcIjNoXCI6IHRoaXMuYnVpbGRXaW5kb3dTdW1tYXJ5KFwiM2hcIiwgc3RhdGUpLFxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3ltYm9sOiBzeW1ib2xLZXksXG4gICAgICBjeWNsZTogY3ljbGVTdGF0dXMsXG4gICAgICB3aW5kb3dzLFxuICAgICAgbGFzdFBvaW50OiBzdGF0ZS5sYXN0UG9pbnQsXG4gICAgICBsYXN0Q2xvc2VkTWFyazogc3RhdGUubGFzdENsb3NlZE1hcmssXG4gICAgICBoaXN0b3J5U2l6ZTogc3RhdGUuaGlzdG9yeS5sZW5ndGgsXG4gICAgfTtcbiAgfVxuXG4gIGdldCBleHBlY3RlZFBvaW50cygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmV4cGVjdGVkUG9pbnRzUGVyQ3ljbGU7XG4gIH1cblxuICBwcml2YXRlIGJ1Y2tldFN0YXJ0KHRzOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiAoXG4gICAgICBNYXRoLmZsb29yKHRzIC8gdGhpcy5jb25maWcucG9pbnRJbnRlcnZhbE1zKSAqIHRoaXMuY29uZmlnLnBvaW50SW50ZXJ2YWxNc1xuICAgICk7XG4gIH1cblxuICBwcml2YXRlIG5vcm1hbGl6ZVN5bWJvbChzeW1ib2w6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFN0cmluZyhzeW1ib2wgPz8gXCJcIikudHJpbSgpLnRvVXBwZXJDYXNlKCk7XG4gIH1cblxuICBwcml2YXRlIGVuc3VyZVN0YXRlKHN5bWJvbDogc3RyaW5nKTogU3ltYm9sU3RhdGUge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5zdGF0ZXMuZ2V0KHN5bWJvbCk7XG4gICAgaWYgKGV4aXN0aW5nKSByZXR1cm4gZXhpc3Rpbmc7XG4gICAgY29uc3QgaW5pdDogU3ltYm9sU3RhdGUgPSB7XG4gICAgICBjdXJyZW50U3RhcnQ6IG51bGwsXG4gICAgICBjdXJyZW50UG9pbnRzOiBbXSxcbiAgICAgIGxhc3RQb2ludDogbnVsbCxcbiAgICAgIGxhc3RDbG9zZWRNYXJrOiBudWxsLFxuICAgICAgaGlzdG9yeTogW10sXG4gICAgICB3aW5kb3dzOiB7XG4gICAgICAgIFwiMzBtXCI6IFtdLFxuICAgICAgICBcIjFoXCI6IFtdLFxuICAgICAgICBcIjNoXCI6IFtdLFxuICAgICAgfSxcbiAgICB9O1xuICAgIHRoaXMuc3RhdGVzLnNldChzeW1ib2wsIGluaXQpO1xuICAgIHJldHVybiBpbml0O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmZXRjaFBvaW50KHN5bWJvbDogc3RyaW5nKTogUHJvbWlzZTxTYW1wbGluZ1BvaW50IHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvYiA9IGF3YWl0IGZldGNoT3JkZXJCb29rKHN5bWJvbCwgNTApO1xuICAgICAgaWYgKCEob2IubWlkID4gMCkpIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgdHMgPSBvYi50cyA/PyBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgYmVzdEJpZCA9IE51bWJlci5pc0Zpbml0ZShvYi5iZXN0QmlkKSA/IG9iLmJlc3RCaWQgOiBvYi5taWQ7XG4gICAgICBjb25zdCBiZXN0QXNrID0gTnVtYmVyLmlzRmluaXRlKG9iLmJlc3RBc2spID8gb2IuYmVzdEFzayA6IG9iLm1pZDtcbiAgICAgIGNvbnN0IHNwcmVhZCA9IE51bWJlci5pc0Zpbml0ZShiZXN0QmlkKSAmJiBOdW1iZXIuaXNGaW5pdGUoYmVzdEFzaykgPyBNYXRoLmFicyhiZXN0QXNrIC0gYmVzdEJpZCkgOiAwO1xuICAgICAgY29uc3QgYnVja2V0U3RhcnQgPSB0aGlzLmJ1Y2tldFN0YXJ0KHRzKTtcbiAgICAgIGNvbnN0IGJ1Y2tldEVuZCA9IGJ1Y2tldFN0YXJ0ICsgdGhpcy5jb25maWcucG9pbnRJbnRlcnZhbE1zO1xuICAgICAgY29uc3QgYm9vayA9IG1hcERlcHRoU25hcHNob3Qob2IuZGVwdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3ltYm9sLFxuICAgICAgICB0cyxcbiAgICAgICAgbWlkOiBvYi5taWQsXG4gICAgICAgIGJlc3RCaWQsXG4gICAgICAgIGJlc3RBc2ssXG4gICAgICAgIHNwcmVhZCxcbiAgICAgICAgYmlkVm9sdW1lOiBOdW1iZXIuaXNGaW5pdGUob2IuYmlkVm9sKSA/IG9iLmJpZFZvbCA6IDAsXG4gICAgICAgIGFza1ZvbHVtZTogTnVtYmVyLmlzRmluaXRlKG9iLmFza1ZvbCkgPyBvYi5hc2tWb2wgOiAwLFxuICAgICAgICBidWNrZXRTdGFydCxcbiAgICAgICAgYnVja2V0RW5kLFxuICAgICAgICBib29rLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTYW1wbGluZ1N0b3JlRXJyb3IpIHRocm93IGVycjtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcHVzaFBvaW50KHN5bWJvbDogc3RyaW5nLCBwb2ludDogU2FtcGxpbmdQb2ludCk6IFNhbXBsaW5nTWFyayB8IG51bGwge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5lbnN1cmVTdGF0ZShzeW1ib2wpO1xuICAgIGNvbnN0IHRzID0gcG9pbnQudHM7XG4gICAgaWYgKHN0YXRlLmxhc3RQb2ludCAmJiB0cyA8PSBzdGF0ZS5sYXN0UG9pbnQudHMpIHtcbiAgICAgIHBvaW50ID0geyAuLi5wb2ludCwgdHM6IHN0YXRlLmxhc3RQb2ludC50cyArIDEgfTtcbiAgICB9XG5cbiAgICBzdGF0ZS5sYXN0UG9pbnQgPSBwb2ludDtcbiAgICBzdGF0ZS5oaXN0b3J5LnB1c2gocG9pbnQpO1xuICAgIHRoaXMucHJ1bmVIaXN0b3J5KHN0YXRlKTtcblxuICAgIGlmICghc3RhdGUuY3VycmVudFBvaW50cy5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmN1cnJlbnRQb2ludHMgPSBbcG9pbnRdO1xuICAgICAgc3RhdGUuY3VycmVudFN0YXJ0ID0gcG9pbnQudHM7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBjeWNsZVN0YXJ0ID0gc3RhdGUuY3VycmVudFN0YXJ0ID8/IHN0YXRlLmN1cnJlbnRQb2ludHNbMF0/LnRzID8/IHBvaW50LnRzO1xuICAgIHN0YXRlLmN1cnJlbnRTdGFydCA9IGN5Y2xlU3RhcnQ7XG4gICAgY29uc3QgZWxhcHNlZCA9IHRzIC0gY3ljbGVTdGFydDtcbiAgICBpZiAoZWxhcHNlZCA8IHRoaXMuY29uZmlnLmN5Y2xlRHVyYXRpb25Ncykge1xuICAgICAgc3RhdGUuY3VycmVudFBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG1hcmsgPSB0aGlzLmJ1aWxkTWFyayhzeW1ib2wsIGN5Y2xlU3RhcnQsIHN0YXRlLmN1cnJlbnRQb2ludHMpO1xuICAgIHRoaXMuc3RvcmVNYXJrKHN0YXRlLCBtYXJrKTtcbiAgICBzdGF0ZS5sYXN0Q2xvc2VkTWFyayA9IG1hcms7XG4gICAgc3RhdGUuY3VycmVudFBvaW50cyA9IFtwb2ludF07XG4gICAgc3RhdGUuY3VycmVudFN0YXJ0ID0gcG9pbnQudHM7XG4gICAgcmV0dXJuIG1hcms7XG4gIH1cblxuICBwcml2YXRlIHBydW5lSGlzdG9yeShzdGF0ZTogU3ltYm9sU3RhdGUpIHtcbiAgICBjb25zdCBjdXRvZmYgPSAoc3RhdGUubGFzdFBvaW50Py50cyA/PyBEYXRlLm5vdygpKSAtIHRoaXMubWF4V2luZG93RHVyYXRpb25NcztcbiAgICBsZXQgZHJvcCA9IDA7XG4gICAgd2hpbGUgKGRyb3AgPCBzdGF0ZS5oaXN0b3J5Lmxlbmd0aCAmJiBzdGF0ZS5oaXN0b3J5W2Ryb3BdLnRzIDwgY3V0b2ZmKSBkcm9wICs9IDE7XG4gICAgaWYgKGRyb3AgPiAwKSBzdGF0ZS5oaXN0b3J5LnNwbGljZSgwLCBkcm9wKTtcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRNYXJrKHN5bWJvbDogc3RyaW5nLCBzdGFydGVkQXQ6IG51bWJlciB8IG51bGwsIHBvaW50czogU2FtcGxpbmdQb2ludFtdKTogU2FtcGxpbmdNYXJrIHtcbiAgICBjb25zdCBsaXN0ID0gWy4uLnBvaW50c10uc29ydCgoYSwgYikgPT4gYS50cyAtIGIudHMpO1xuICAgIGNvbnN0IGZpcnN0ID0gbGlzdFswXTtcbiAgICBjb25zdCBsYXN0ID0gbGlzdFtsaXN0Lmxlbmd0aCAtIDFdID8/IGZpcnN0O1xuICAgIGNvbnN0IHByaWNlVmFsdWVzID0gbGlzdC5tYXAoKHApID0+IHAubWlkKS5maWx0ZXIoKHYpID0+IE51bWJlci5pc0Zpbml0ZSh2KSk7XG4gICAgY29uc3Qgc3ByZWFkVmFsdWVzID0gbGlzdC5tYXAoKHApID0+IHAuc3ByZWFkKS5maWx0ZXIoKHYpID0+IE51bWJlci5pc0Zpbml0ZSh2KSk7XG4gICAgY29uc3QgYmlkVm9sdW1lcyA9IGxpc3QubWFwKChwKSA9PiBwLmJpZFZvbHVtZSkuZmlsdGVyKCh2KSA9PiBOdW1iZXIuaXNGaW5pdGUodikpO1xuICAgIGNvbnN0IGFza1ZvbHVtZXMgPSBsaXN0Lm1hcCgocCkgPT4gcC5hc2tWb2x1bWUpLmZpbHRlcigodikgPT4gTnVtYmVyLmlzRmluaXRlKHYpKTtcblxuICAgIGNvbnN0IHByaWNlTWluID0gcHJpY2VWYWx1ZXMubGVuZ3RoID8gTWF0aC5taW4oLi4ucHJpY2VWYWx1ZXMpIDogTmFOO1xuICAgIGNvbnN0IHByaWNlTWF4ID0gcHJpY2VWYWx1ZXMubGVuZ3RoID8gTWF0aC5tYXgoLi4ucHJpY2VWYWx1ZXMpIDogTmFOO1xuICAgIGNvbnN0IHByaWNlQXZnID0gcHJpY2VWYWx1ZXMubGVuZ3RoID8gcHJpY2VWYWx1ZXMucmVkdWNlKChzLCB2KSA9PiBzICsgdiwgMCkgLyBwcmljZVZhbHVlcy5sZW5ndGggOiBOYU47XG5cbiAgICBjb25zdCBzcHJlYWRNaW4gPSBzcHJlYWRWYWx1ZXMubGVuZ3RoID8gTWF0aC5taW4oLi4uc3ByZWFkVmFsdWVzKSA6IE5hTjtcbiAgICBjb25zdCBzcHJlYWRNYXggPSBzcHJlYWRWYWx1ZXMubGVuZ3RoID8gTWF0aC5tYXgoLi4uc3ByZWFkVmFsdWVzKSA6IE5hTjtcbiAgICBjb25zdCBzcHJlYWRBdmcgPSBzcHJlYWRWYWx1ZXMubGVuZ3RoID8gc3ByZWFkVmFsdWVzLnJlZHVjZSgocywgdikgPT4gcyArIHYsIDApIC8gc3ByZWFkVmFsdWVzLmxlbmd0aCA6IE5hTjtcblxuICAgIGNvbnN0IGJpZFZvbHVtZSA9IGJpZFZvbHVtZXMucmVkdWNlKChzLCB2KSA9PiBzICsgdiwgMCk7XG4gICAgY29uc3QgYXNrVm9sdW1lID0gYXNrVm9sdW1lcy5yZWR1Y2UoKHMsIHYpID0+IHMgKyB2LCAwKTtcblxuICAgIGNvbnN0IGV4cGVjdGVkTm9taW5hbCA9IHRoaXMuZXhwZWN0ZWRQb2ludHNQZXJDeWNsZTtcbiAgICBjb25zdCBhY3R1YWxEdXJhdGlvbk1zID1cbiAgICAgIGxhc3QgJiYgc3RhcnRlZEF0ICE9PSBudWxsID8gTWF0aC5tYXgoMCwgbGFzdC50cyAtIHN0YXJ0ZWRBdCkgOiB0aGlzLmNvbmZpZy5jeWNsZUR1cmF0aW9uTXM7XG4gICAgY29uc3QgZXhwZWN0ZWRGcm9tRHVyYXRpb24gPSBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKGFjdHVhbER1cmF0aW9uTXMgLyB0aGlzLmNvbmZpZy5wb2ludEludGVydmFsTXMpKTtcbiAgICBjb25zdCBleHBlY3RlZFBvaW50cyA9IE1hdGgubWluKGV4cGVjdGVkTm9taW5hbCwgTWF0aC5tYXgoMSwgZXhwZWN0ZWRGcm9tRHVyYXRpb24pKTtcbiAgICBjb25zdCB3YXJuRmxvb3IgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwoZXhwZWN0ZWRQb2ludHMgKiAwLjUpKTtcbiAgICBjb25zdCB0b2xlcmFuY2UgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwoZXhwZWN0ZWRQb2ludHMgKiAwLjI1KSk7XG4gICAgY29uc3QgbWluT2sgPSBNYXRoLm1heCgxLCBleHBlY3RlZFBvaW50cyAtIHRvbGVyYW5jZSk7XG4gICAgbGV0IHN0YXR1czogU2FtcGxpbmdIZWFsdGhTdGF0dXMgPSBcIm9rXCI7XG4gICAgY29uc3Qgbm90ZXM6IHN0cmluZ1tdID0gW107XG4gICAgaWYgKCFsaXN0Lmxlbmd0aCkge1xuICAgICAgc3RhdHVzID0gXCJlcnJvclwiO1xuICAgICAgbm90ZXMucHVzaChcImVtcHR5X2N5Y2xlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJpY2VWYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0YXR1cyA9IFwiZXJyb3JcIjtcbiAgICAgICAgbm90ZXMucHVzaChcIm5vX3ByaWNlc1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaXN0Lmxlbmd0aCA8IHdhcm5GbG9vcikge1xuICAgICAgICBzdGF0dXMgPSBjbGFtcFN0YXR1cyhzdGF0dXMsIFwid2FyblwiKTtcbiAgICAgICAgbm90ZXMucHVzaChcInRvb19mZXdfcG9pbnRzXCIpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA8IG1pbk9rKSB7XG4gICAgICAgIHN0YXR1cyA9IGNsYW1wU3RhdHVzKHN0YXR1cywgXCJ3YXJuXCIpO1xuICAgICAgICBub3Rlcy5wdXNoKFwicGFydGlhbF9jeWNsZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0ICYmIHN0YXJ0ZWRBdCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBpbnRlbmRlZCA9IHRoaXMuY29uZmlnLmN5Y2xlRHVyYXRpb25NcztcbiAgICAgICAgY29uc3QgZGVsdGEgPSAobGFzdC50cyAtIHN0YXJ0ZWRBdCkgLSBpbnRlbmRlZDtcbiAgICAgICAgaWYgKGRlbHRhID4gdGhpcy5jb25maWcucG9pbnRJbnRlcnZhbE1zKSB7XG4gICAgICAgICAgc3RhdHVzID0gY2xhbXBTdGF0dXMoc3RhdHVzLCBcIndhcm5cIik7XG4gICAgICAgICAgbm90ZXMucHVzaChcImV4dGVuZGVkX2N5Y2xlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRUcyA9IHN0YXJ0ZWRBdCA/PyAoZmlyc3Q/LnRzID8/IGxhc3Q/LnRzID8/IERhdGUubm93KCkpO1xuICAgIGNvbnN0IGNsb3NlVHMgPSBsYXN0Py50cyA/PyBzdGFydFRzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBgJHtzeW1ib2x9OiR7c3RhcnRUc31gLFxuICAgICAgc3ltYm9sLFxuICAgICAgc3RhcnRlZEF0OiBzdGFydFRzLFxuICAgICAgY2xvc2VkQXQ6IGNsb3NlVHMsXG4gICAgICBkdXJhdGlvbk1zOiBNYXRoLm1heCgwLCBjbG9zZVRzIC0gc3RhcnRUcyksXG4gICAgICBwb2ludHNDb3VudDogbGlzdC5sZW5ndGgsXG4gICAgICBwcmljZToge1xuICAgICAgICBvcGVuOiBmaXJzdD8ubWlkID8/IE5hTixcbiAgICAgICAgY2xvc2U6IGxhc3Q/Lm1pZCA/PyBOYU4sXG4gICAgICAgIG1pbjogcHJpY2VNaW4sXG4gICAgICAgIG1heDogcHJpY2VNYXgsXG4gICAgICAgIGF2ZzogcHJpY2VBdmcsXG4gICAgICB9LFxuICAgICAgc3ByZWFkOiB7XG4gICAgICAgIG1pbjogc3ByZWFkTWluLFxuICAgICAgICBtYXg6IHNwcmVhZE1heCxcbiAgICAgICAgYXZnOiBzcHJlYWRBdmcsXG4gICAgICB9LFxuICAgICAgdm9sdW1lOiB7XG4gICAgICAgIGJpZDogYmlkVm9sdW1lLFxuICAgICAgICBhc2s6IGFza1ZvbHVtZSxcbiAgICAgICAgdG90YWw6IGJpZFZvbHVtZSArIGFza1ZvbHVtZSxcbiAgICAgIH0sXG4gICAgICBwb2ludHM6IGxpc3QsXG4gICAgICBoZWFsdGg6IHtcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBub3RlcyxcbiAgICAgICAgZXhwZWN0ZWRQb2ludHMsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIHN0b3JlTWFyayhzdGF0ZTogU3ltYm9sU3RhdGUsIG1hcms6IFNhbXBsaW5nTWFyaykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuY29uZmlnLndpbmRvd3MpIGFzIFNhbXBsaW5nV2luZG93S2V5W10pIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IHN0YXRlLndpbmRvd3Nba2V5XTtcbiAgICAgIHdpbmRvdy5wdXNoKG1hcmspO1xuICAgICAgY29uc3QgY2FwID0gdGhpcy5jb25maWcud2luZG93c1trZXldPy5jYXBhY2l0eSA/PyB3aW5kb3cubGVuZ3RoO1xuICAgICAgd2hpbGUgKHdpbmRvdy5sZW5ndGggPiBjYXApIHdpbmRvdy5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY29tcHV0ZUN5Y2xlU3RhdHVzKHN0YXRlOiBTeW1ib2xTdGF0ZSwgbm93OiBudW1iZXIpIHtcbiAgICBjb25zdCBwb2ludHMgPSBzdGF0ZS5jdXJyZW50UG9pbnRzLmxlbmd0aDtcbiAgICBjb25zdCBleHBlY3RlZE5vbWluYWwgPSB0aGlzLmV4cGVjdGVkUG9pbnRzUGVyQ3ljbGU7XG4gICAgY29uc3Qgc3RhcnRUcyA9IHN0YXRlLmN1cnJlbnRTdGFydCA/PyBzdGF0ZS5jdXJyZW50UG9pbnRzWzBdPy50cyA/PyBudWxsO1xuICAgIGNvbnN0IGxhc3RQb2ludFRzID0gc3RhdGUuY3VycmVudFBvaW50c1tzdGF0ZS5jdXJyZW50UG9pbnRzLmxlbmd0aCAtIDFdPy50c1xuICAgICAgPz8gc3RhdGUubGFzdFBvaW50Py50c1xuICAgICAgPz8gbm93O1xuICAgIGNvbnN0IGVsYXBzZWQgPSBzdGFydFRzICE9IG51bGwgPyBNYXRoLm1heCgwLCAobGFzdFBvaW50VHMgPz8gbm93KSAtIHN0YXJ0VHMpIDogMDtcbiAgICBjb25zdCBleHBlY3RlZFJhdyA9IHN0YXJ0VHMgIT0gbnVsbFxuICAgICAgPyBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKGVsYXBzZWQgLyB0aGlzLmNvbmZpZy5wb2ludEludGVydmFsTXMpKVxuICAgICAgOiBNYXRoLm1heCgxLCBNYXRoLm1pbihwb2ludHMgfHwgZXhwZWN0ZWROb21pbmFsLCBleHBlY3RlZE5vbWluYWwpKTtcbiAgICBjb25zdCBleHBlY3RlZFNvRmFyID0gTWF0aC5taW4oZXhwZWN0ZWROb21pbmFsLCBleHBlY3RlZFJhdyk7XG4gICAgY29uc3QgdG9sZXJhbmNlID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKGV4cGVjdGVkU29GYXIgKiAwLjMpKTtcbiAgICBsZXQgc3RhdHVzOiBTYW1wbGluZ0hlYWx0aFN0YXR1cyA9IFwib2tcIjtcbiAgICBjb25zdCBub3Rlczogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAoIXBvaW50cykge1xuICAgICAgc3RhdHVzID0gXCJ3YXJuXCI7XG4gICAgICBub3Rlcy5wdXNoKFwiaWRsZV9jeWNsZVwiKTtcbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkU29GYXIgPj0gMyAmJiBwb2ludHMgKyB0b2xlcmFuY2UgPCBleHBlY3RlZFNvRmFyKSB7XG4gICAgICBzdGF0dXMgPSBcIndhcm5cIjtcbiAgICAgIG5vdGVzLnB1c2goXCJsb3dfcG9pbnRzXCIpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRzID4gZXhwZWN0ZWROb21pbmFsICogMS41KSB7XG4gICAgICBzdGF0dXMgPSBcIndhcm5cIjtcbiAgICAgIG5vdGVzLnB1c2goXCJleHRlbmRlZF9jeWNsZVwiKTtcbiAgICB9XG4gICAgY29uc3QgY2xvc2luZ0F0ID0gc3RhcnRUcyA/IHN0YXJ0VHMgKyB0aGlzLmNvbmZpZy5jeWNsZUR1cmF0aW9uTXMgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydGVkQXQ6IHN0YXJ0VHMsXG4gICAgICBwb2ludHNDb2xsZWN0ZWQ6IHBvaW50cyxcbiAgICAgIGV4cGVjdGVkUG9pbnRzOiBleHBlY3RlZFNvRmFyLFxuICAgICAgY2xvc2luZ0F0LFxuICAgICAgc3RhdHVzLFxuICAgICAgbm90ZXMsXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRXaW5kb3dTdW1tYXJ5KGtleTogU2FtcGxpbmdXaW5kb3dLZXksIHN0YXRlOiBTeW1ib2xTdGF0ZSk6IFNhbXBsaW5nV2luZG93U3VtbWFyeSB7XG4gICAgY29uc3Qgd2luZG93ID0gc3RhdGUud2luZG93c1trZXldO1xuICAgIGNvbnN0IGNvdW50czogUmVjb3JkPFNhbXBsaW5nSGVhbHRoU3RhdHVzLCBudW1iZXI+ID0geyBvazogMCwgd2FybjogMCwgZXJyb3I6IDAgfTtcbiAgICBmb3IgKGNvbnN0IG1hcmsgb2Ygd2luZG93KSB7XG4gICAgICBjb3VudHNbbWFyay5oZWFsdGguc3RhdHVzXSArPSAxO1xuICAgIH1cbiAgICBjb25zdCBjZmcgPSB0aGlzLmNvbmZpZy53aW5kb3dzW2tleV07XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleSxcbiAgICAgIGNhcGFjaXR5OiBjZmc/LmNhcGFjaXR5ID8/IHdpbmRvdy5sZW5ndGgsXG4gICAgICBzaXplOiB3aW5kb3cubGVuZ3RoLFxuICAgICAgbWFya3M6IFsuLi53aW5kb3ddLFxuICAgICAgc3RhdHVzQ291bnRzOiBjb3VudHMsXG4gICAgfTtcbiAgfVxufVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXJcbiAgdmFyIF9fU1RSX0FVWF9TQU1QTElOR19TVE9SRV9fOiBTYW1wbGluZ1N0b3JlIHwgdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2FtcGxpbmdTdG9yZShjb25maWc/OiBTYW1wbGVyQ29uZmlnKTogU2FtcGxpbmdTdG9yZSB7XG4gIGlmICghKGdsb2JhbFRoaXMgYXMgYW55KS5fX1NUUl9BVVhfU0FNUExJTkdfU1RPUkVfXykge1xuICAgIChnbG9iYWxUaGlzIGFzIGFueSkuX19TVFJfQVVYX1NBTVBMSU5HX1NUT1JFX18gPSBuZXcgU2FtcGxpbmdTdG9yZShjb25maWcgPz8gREVGQVVMVF9TQU1QTEVSX0NPTkZJRyk7XG4gIH1cbiAgcmV0dXJuIChnbG9iYWxUaGlzIGFzIGFueSkuX19TVFJfQVVYX1NBTVBMSU5HX1NUT1JFX18hO1xufVxuXG5mdW5jdGlvbiBtYXBEZXB0aFNuYXBzaG90KGRlcHRoOiBhbnkpOiBPcmRlckJvb2tTbmFwc2hvdCB7XG4gIGNvbnN0IG1hcExldmVscyA9IChsZXZlbHM/OiBhbnlbXSk6IE9yZGVyQm9va0xldmVsW10gPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShsZXZlbHMpKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGxldmVsc1xuICAgICAgLm1hcCgocm93KSA9PiB7XG4gICAgICAgIGNvbnN0IHByaWNlID0gTnVtYmVyKHJvdz8uWzBdKTtcbiAgICAgICAgY29uc3QgcXR5ID0gTnVtYmVyKHJvdz8uWzFdKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocHJpY2UpIHx8ICFOdW1iZXIuaXNGaW5pdGUocXR5KSB8fCBxdHkgPD0gMCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB7IHByaWNlLCBxdHkgfTtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKChsdmwpOiBsdmwgaXMgT3JkZXJCb29rTGV2ZWwgPT4gQm9vbGVhbihsdmwpKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGJpZHM6IG1hcExldmVscyhkZXB0aD8uYmlkcyksXG4gICAgYXNrczogbWFwTGV2ZWxzKGRlcHRoPy5hc2tzKSxcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJmZXRjaE9yZGVyQm9vayIsIkRFRkFVTFRfU0FNUExFUl9DT05GSUciLCJTYW1wbGluZ1N0b3JlRXJyb3IiLCJjbGFtcFN0YXR1cyIsInN0YXR1cyIsInRhcmdldCIsIlNhbXBsaW5nU3RvcmUiLCJjb25maWciLCJzdGF0ZXMiLCJNYXAiLCJtYXhXaW5kb3dEdXJhdGlvbk1zIiwiTWF0aCIsIm1heCIsIk9iamVjdCIsInZhbHVlcyIsIndpbmRvd3MiLCJtYXAiLCJ3IiwiZHVyYXRpb25NcyIsImV4cGVjdGVkUG9pbnRzUGVyQ3ljbGUiLCJyb3VuZCIsImN5Y2xlRHVyYXRpb25NcyIsInBvaW50SW50ZXJ2YWxNcyIsImNvbGxlY3QiLCJzeW1ib2wiLCJvcHRzIiwic3ltYm9sS2V5Iiwibm9ybWFsaXplU3ltYm9sIiwic3RhdGUiLCJlbnN1cmVTdGF0ZSIsIm5vdyIsIkRhdGUiLCJwb2ludCIsIm1hcmsiLCJwdXNoUG9pbnQiLCJjbG9zZWRNYXJrIiwic25hcHNob3QiLCJmb3JjZSIsImxhc3RQb2ludCIsInRzIiwiZmV0Y2hQb2ludCIsImdldFBvaW50cyIsIndpbmRvdyIsImdldCIsInJlZlRzIiwiY3V0b2ZmIiwibGlzdCIsImhpc3RvcnkiLCJpZHgiLCJsZW5ndGgiLCJzbGljZSIsImdldE1hcmtzIiwic3RhdGVPdmVycmlkZSIsImN5Y2xlU3RhdHVzIiwiY29tcHV0ZUN5Y2xlU3RhdHVzIiwiYnVpbGRXaW5kb3dTdW1tYXJ5IiwiY3ljbGUiLCJsYXN0Q2xvc2VkTWFyayIsImhpc3RvcnlTaXplIiwiZXhwZWN0ZWRQb2ludHMiLCJidWNrZXRTdGFydCIsImZsb29yIiwiU3RyaW5nIiwidHJpbSIsInRvVXBwZXJDYXNlIiwiZXhpc3RpbmciLCJpbml0IiwiY3VycmVudFN0YXJ0IiwiY3VycmVudFBvaW50cyIsInNldCIsIm9iIiwibWlkIiwiYmVzdEJpZCIsIk51bWJlciIsImlzRmluaXRlIiwiYmVzdEFzayIsInNwcmVhZCIsImFicyIsImJ1Y2tldEVuZCIsImJvb2siLCJtYXBEZXB0aFNuYXBzaG90IiwiZGVwdGgiLCJiaWRWb2x1bWUiLCJiaWRWb2wiLCJhc2tWb2x1bWUiLCJhc2tWb2wiLCJlcnIiLCJwdXNoIiwicHJ1bmVIaXN0b3J5IiwiY3ljbGVTdGFydCIsImVsYXBzZWQiLCJidWlsZE1hcmsiLCJzdG9yZU1hcmsiLCJkcm9wIiwic3BsaWNlIiwic3RhcnRlZEF0IiwicG9pbnRzIiwic29ydCIsImEiLCJiIiwiZmlyc3QiLCJsYXN0IiwicHJpY2VWYWx1ZXMiLCJwIiwiZmlsdGVyIiwidiIsInNwcmVhZFZhbHVlcyIsImJpZFZvbHVtZXMiLCJhc2tWb2x1bWVzIiwicHJpY2VNaW4iLCJtaW4iLCJOYU4iLCJwcmljZU1heCIsInByaWNlQXZnIiwicmVkdWNlIiwicyIsInNwcmVhZE1pbiIsInNwcmVhZE1heCIsInNwcmVhZEF2ZyIsImV4cGVjdGVkTm9taW5hbCIsImFjdHVhbER1cmF0aW9uTXMiLCJleHBlY3RlZEZyb21EdXJhdGlvbiIsIndhcm5GbG9vciIsImNlaWwiLCJ0b2xlcmFuY2UiLCJtaW5PayIsIm5vdGVzIiwiaW50ZW5kZWQiLCJkZWx0YSIsInN0YXJ0VHMiLCJjbG9zZVRzIiwiaWQiLCJjbG9zZWRBdCIsInBvaW50c0NvdW50IiwicHJpY2UiLCJvcGVuIiwiY2xvc2UiLCJhdmciLCJ2b2x1bWUiLCJiaWQiLCJhc2siLCJ0b3RhbCIsImhlYWx0aCIsImtleSIsImtleXMiLCJjYXAiLCJjYXBhY2l0eSIsInNoaWZ0IiwibGFzdFBvaW50VHMiLCJleHBlY3RlZFJhdyIsImV4cGVjdGVkU29GYXIiLCJjbG9zaW5nQXQiLCJwb2ludHNDb2xsZWN0ZWQiLCJjb3VudHMiLCJvayIsIndhcm4iLCJlcnJvciIsImNmZyIsInNpemUiLCJtYXJrcyIsInN0YXR1c0NvdW50cyIsImdldFNhbXBsaW5nU3RvcmUiLCJnbG9iYWxUaGlzIiwiX19TVFJfQVVYX1NBTVBMSU5HX1NUT1JFX18iLCJtYXBMZXZlbHMiLCJsZXZlbHMiLCJBcnJheSIsImlzQXJyYXkiLCJyb3ciLCJxdHkiLCJsdmwiLCJCb29sZWFuIiwiYmlkcyIsImFza3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/sampling/store.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/sampling/types.ts":
/*!*****************************************************!*\
  !*** ./src/core/features/str-aux/sampling/types.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// src/core/features/str-aux/sampling/types.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3NhbXBsaW5nL3R5cGVzLnRzIiwibWFwcGluZ3MiOiI7QUFBQSw4Q0FBOEM7QUFpSDVDIiwic291cmNlcyI6WyJIOlxcVXNlcnNcXEd1c1xcc291cmNlXFxyZXBvXFxkeW5hbWljc1xcZHluYW1pY3MtYlxcY3J5cHRvcGktZHluYW1pY3NcXHNyY1xcY29yZVxcZmVhdHVyZXNcXHN0ci1hdXhcXHNhbXBsaW5nXFx0eXBlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3NhbXBsaW5nL3R5cGVzLnRzXG5leHBvcnQgdHlwZSBTYW1wbGluZ1dpbmRvd0tleSA9IFwiMzBtXCIgfCBcIjFoXCIgfCBcIjNoXCI7XG5cbmV4cG9ydCB0eXBlIFNhbXBsaW5nSGVhbHRoU3RhdHVzID0gXCJva1wiIHwgXCJ3YXJuXCIgfCBcImVycm9yXCI7XG5cbmV4cG9ydCB0eXBlIE9yZGVyQm9va0xldmVsID0ge1xuICBwcmljZTogbnVtYmVyO1xuICBxdHk6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIE9yZGVyQm9va1NuYXBzaG90ID0ge1xuICBiaWRzOiBPcmRlckJvb2tMZXZlbFtdO1xuICBhc2tzOiBPcmRlckJvb2tMZXZlbFtdO1xufTtcblxuZXhwb3J0IHR5cGUgU2FtcGxpbmdCdWNrZXRNZXRhID0ge1xuICBidWNrZXRDb3VudDogbnVtYmVyO1xuICB0aWNrTXNNaW46IG51bWJlciB8IG51bGw7XG4gIHRpY2tNc01heDogbnVtYmVyIHwgbnVsbDtcbiAgdGlja01zQXZnOiBudW1iZXIgfCBudWxsO1xuICBzcHJlYWRNaW46IG51bWJlciB8IG51bGw7XG4gIHNwcmVhZE1heDogbnVtYmVyIHwgbnVsbDtcbiAgc3ByZWFkQXZnOiBudW1iZXIgfCBudWxsO1xuICBtaWRNaW46IG51bWJlciB8IG51bGw7XG4gIG1pZE1heDogbnVtYmVyIHwgbnVsbDtcbiAgdG9wQmlkVm9sOiBudW1iZXI7XG4gIHRvcEFza1ZvbDogbnVtYmVyO1xuICBsaXF1aWRpdHlJbWJhbGFuY2U6IG51bWJlciB8IG51bGw7XG4gIHF1YWxpdHlGbGFnczogc3RyaW5nW107XG59O1xuXG5leHBvcnQgdHlwZSBTYW1wbGluZ1BvaW50ID0ge1xuICBzeW1ib2w6IHN0cmluZztcbiAgdHM6IG51bWJlcjtcbiAgbWlkOiBudW1iZXI7XG4gIGJlc3RCaWQ6IG51bWJlcjtcbiAgYmVzdEFzazogbnVtYmVyO1xuICBzcHJlYWQ6IG51bWJlcjtcbiAgYmlkVm9sdW1lOiBudW1iZXI7XG4gIGFza1ZvbHVtZTogbnVtYmVyO1xuICBidWNrZXRTdGFydDogbnVtYmVyO1xuICBidWNrZXRFbmQ6IG51bWJlcjtcbiAgYm9vazogT3JkZXJCb29rU25hcHNob3Q7XG4gIGJ1Y2tldE1ldGE/OiBTYW1wbGluZ0J1Y2tldE1ldGE7XG59O1xuXG5leHBvcnQgdHlwZSBTYW1wbGluZ01hcmsgPSB7XG4gIGlkOiBzdHJpbmc7XG4gIHN5bWJvbDogc3RyaW5nO1xuICBzdGFydGVkQXQ6IG51bWJlcjtcbiAgY2xvc2VkQXQ6IG51bWJlcjtcbiAgZHVyYXRpb25NczogbnVtYmVyO1xuICBwb2ludHNDb3VudDogbnVtYmVyO1xuICBwcmljZToge1xuICAgIG9wZW46IG51bWJlcjtcbiAgICBjbG9zZTogbnVtYmVyO1xuICAgIG1pbjogbnVtYmVyO1xuICAgIG1heDogbnVtYmVyO1xuICAgIGF2ZzogbnVtYmVyO1xuICB9O1xuICBzcHJlYWQ6IHtcbiAgICBtaW46IG51bWJlcjtcbiAgICBtYXg6IG51bWJlcjtcbiAgICBhdmc6IG51bWJlcjtcbiAgfTtcbiAgdm9sdW1lOiB7XG4gICAgYmlkOiBudW1iZXI7XG4gICAgYXNrOiBudW1iZXI7XG4gICAgdG90YWw6IG51bWJlcjtcbiAgfTtcbiAgcG9pbnRzOiBTYW1wbGluZ1BvaW50W107XG4gIGhlYWx0aDoge1xuICAgIHN0YXR1czogU2FtcGxpbmdIZWFsdGhTdGF0dXM7XG4gICAgbm90ZXM6IHN0cmluZ1tdO1xuICAgIGV4cGVjdGVkUG9pbnRzOiBudW1iZXI7XG4gIH07XG59O1xuXG5leHBvcnQgdHlwZSBTYW1wbGluZ1dpbmRvd1N1bW1hcnkgPSB7XG4gIGtleTogU2FtcGxpbmdXaW5kb3dLZXk7XG4gIGNhcGFjaXR5OiBudW1iZXI7XG4gIHNpemU6IG51bWJlcjtcbiAgbWFya3M6IFNhbXBsaW5nTWFya1tdO1xuICBzdGF0dXNDb3VudHM6IFJlY29yZDxTYW1wbGluZ0hlYWx0aFN0YXR1cywgbnVtYmVyPjtcbn07XG5cbmV4cG9ydCB0eXBlIFNhbXBsaW5nQ3ljbGVTbmFwc2hvdCA9IHtcbiAgc3RhcnRlZEF0OiBudW1iZXIgfCBudWxsO1xuICBwb2ludHNDb2xsZWN0ZWQ6IG51bWJlcjtcbiAgZXhwZWN0ZWRQb2ludHM6IG51bWJlcjtcbiAgY2xvc2luZ0F0OiBudW1iZXIgfCBudWxsO1xuICBzdGF0dXM6IFNhbXBsaW5nSGVhbHRoU3RhdHVzO1xuICBub3Rlczogc3RyaW5nW107XG59O1xuXG5leHBvcnQgdHlwZSBTYW1wbGluZ1NuYXBzaG90ID0ge1xuICBzeW1ib2w6IHN0cmluZztcbiAgY3ljbGU6IFNhbXBsaW5nQ3ljbGVTbmFwc2hvdDtcbiAgd2luZG93czogUmVjb3JkPFNhbXBsaW5nV2luZG93S2V5LCBTYW1wbGluZ1dpbmRvd1N1bW1hcnk+O1xuICBsYXN0UG9pbnQ6IFNhbXBsaW5nUG9pbnQgfCBudWxsO1xuICBsYXN0Q2xvc2VkTWFyazogU2FtcGxpbmdNYXJrIHwgbnVsbDtcbiAgaGlzdG9yeVNpemU6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIFNhbXBsZXJXaW5kb3dDb25maWcgPSB7XG4gIGR1cmF0aW9uTXM6IG51bWJlcjtcbiAgY2FwYWNpdHk6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIFNhbXBsZXJDb25maWcgPSB7XG4gIHBvaW50SW50ZXJ2YWxNczogbnVtYmVyO1xuICBjeWNsZUR1cmF0aW9uTXM6IG51bWJlcjtcbiAgd2luZG93czogUmVjb3JkPFNhbXBsaW5nV2luZG93S2V5LCBTYW1wbGVyV2luZG93Q29uZmlnPjtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/sampling/types.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/sampling/universeWatcher.ts":
/*!***************************************************************!*\
  !*** ./src/core/features/str-aux/sampling/universeWatcher.ts ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   startSamplingUniverseWatcher: () => (/* binding */ startSamplingUniverseWatcher)\n/* harmony export */ });\n/* harmony import */ var _core_db_pool_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/db/pool_server */ \"(rsc)/./src/core/db/pool_server.ts\");\n/* harmony import */ var _core_sources_binance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/core/sources/binance */ \"(rsc)/./src/core/sources/binance.ts\");\n/* harmony import */ var _buckets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buckets */ \"(rsc)/./src/core/features/str-aux/sampling/buckets.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_db_pool_server__WEBPACK_IMPORTED_MODULE_0__, _core_sources_binance__WEBPACK_IMPORTED_MODULE_1__, _buckets__WEBPACK_IMPORTED_MODULE_2__]);\n([_core_db_pool_server__WEBPACK_IMPORTED_MODULE_0__, _core_sources_binance__WEBPACK_IMPORTED_MODULE_1__, _buckets__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\nconst DEFAULT_REFRESH_MS = Number(process.env.STR_SAMPLER_REFRESH_MS ?? 60000);\nconst DEFAULT_POLL_MS = Number(process.env.STR_SAMPLER_POLL_MS ?? 1000);\nconst DEPTH_OPTIONS = [\n    5,\n    10,\n    20,\n    50,\n    100,\n    500,\n    1000\n];\nfunction resolveDepth(value) {\n    let depth = Number(value ?? 50);\n    if (!Number.isFinite(depth)) depth = 50;\n    let closest = DEPTH_OPTIONS[0];\n    let minDelta = Math.abs(depth - closest);\n    for (const option of DEPTH_OPTIONS){\n        const delta = Math.abs(depth - option);\n        if (delta < minDelta) {\n            minDelta = delta;\n            closest = option;\n        }\n    }\n    return closest;\n}\nconst DEPTH_LIMIT = resolveDepth(Number(process.env.STR_SAMPLER_DEPTH));\nclass SymbolSampler {\n    constructor(symbol, pollMs){\n        this.symbol = symbol;\n        this.pollMs = pollMs;\n        this.stopped = false;\n    }\n    start() {\n        if (this.stopped) return;\n        if (!this.timer) {\n            void this.poll();\n        }\n    }\n    stop() {\n        this.stopped = true;\n        if (this.timer) clearTimeout(this.timer);\n        this.timer = undefined;\n    }\n    async poll() {\n        if (this.stopped) return;\n        try {\n            const snapshot = await (0,_core_sources_binance__WEBPACK_IMPORTED_MODULE_1__.fetchOrderBook)(this.symbol, DEPTH_LIMIT);\n            if (snapshot?.depth) {\n                await (0,_buckets__WEBPACK_IMPORTED_MODULE_2__.ingestOrderBookTick)({\n                    symbol: this.symbol,\n                    bids: snapshot.depth.bids ?? [],\n                    asks: snapshot.depth.asks ?? [],\n                    ts: snapshot.ts ?? Date.now(),\n                    mid: snapshot.mid,\n                    bestBid: snapshot.bestBid,\n                    bestAsk: snapshot.bestAsk\n                });\n            }\n        } catch (err) {\n            console.warn(\"[str-aux sampler] orderbook poll failed\", this.symbol, err);\n        } finally{\n            if (!this.stopped) {\n                this.timer = setTimeout(()=>void this.poll(), this.pollMs);\n            }\n        }\n    }\n}\nclass UniverseSampler {\n    constructor(refreshMs = DEFAULT_REFRESH_MS, pollMs = DEFAULT_POLL_MS){\n        this.refreshMs = refreshMs;\n        this.pollMs = pollMs;\n        this.feeds = new Map();\n        this.running = false;\n    }\n    async start() {\n        if (this.running) return;\n        this.running = true;\n        await this.sync();\n        this.refreshTimer = setInterval(()=>{\n            void this.sync();\n        }, this.refreshMs);\n    }\n    stop() {\n        if (this.refreshTimer) clearInterval(this.refreshTimer);\n        this.refreshTimer = undefined;\n        for (const feed of this.feeds.values()){\n            feed.stop();\n        }\n        this.feeds.clear();\n        this.running = false;\n    }\n    async sync() {\n        try {\n            const symbols = await this.fetchSymbols();\n            const desired = new Set(symbols);\n            for (const symbol of symbols){\n                if (this.feeds.has(symbol)) continue;\n                const sampler = new SymbolSampler(symbol, this.pollMs);\n                this.feeds.set(symbol, sampler);\n                sampler.start();\n            }\n            for (const [symbol, sampler] of this.feeds.entries()){\n                if (!desired.has(symbol)) {\n                    sampler.stop();\n                    this.feeds.delete(symbol);\n                }\n            }\n        } catch (err) {\n            console.warn(\"[str-aux sampler] sync failed\", err);\n        }\n    }\n    async fetchSymbols() {\n        const { rows } = await (0,_core_db_pool_server__WEBPACK_IMPORTED_MODULE_0__.query)(`SELECT symbol::text AS symbol\n         FROM settings.coin_universe\n        WHERE COALESCE(enabled,true) = true\n     ORDER BY sort_order NULLS LAST, symbol`);\n        return rows.map((row)=>row.symbol.trim().toUpperCase()).filter(Boolean);\n    }\n}\nfunction startSamplingUniverseWatcher() {\n    if (process.env.STR_SAMPLER_AUTOSTART === \"false\") return;\n    if (globalThis.__STR_AUX_SAMPLER_WATCHER__?.started) return;\n    const watcher = new UniverseSampler();\n    globalThis.__STR_AUX_SAMPLER_WATCHER__ = {\n        watcher,\n        started: true\n    };\n    watcher.start().catch((err)=>{\n        console.error(\"[str-aux sampler] failed to start\", err);\n    });\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3NhbXBsaW5nL3VuaXZlcnNlV2F0Y2hlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQThDO0FBQ1U7QUFDUjtBQUVoRCxNQUFNRyxxQkFBcUJDLE9BQU9DLFFBQVFDLEdBQUcsQ0FBQ0Msc0JBQXNCLElBQUk7QUFDeEUsTUFBTUMsa0JBQWtCSixPQUFPQyxRQUFRQyxHQUFHLENBQUNHLG1CQUFtQixJQUFJO0FBQ2xFLE1BQU1DLGdCQUFnQjtJQUFDO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBSztJQUFLO0NBQUs7QUFFckQsU0FBU0MsYUFBYUMsS0FBeUI7SUFDN0MsSUFBSUMsUUFBUVQsT0FBT1EsU0FBUztJQUM1QixJQUFJLENBQUNSLE9BQU9VLFFBQVEsQ0FBQ0QsUUFBUUEsUUFBUTtJQUNyQyxJQUFJRSxVQUFVTCxhQUFhLENBQUMsRUFBRTtJQUM5QixJQUFJTSxXQUFXQyxLQUFLQyxHQUFHLENBQUNMLFFBQVFFO0lBQ2hDLEtBQUssTUFBTUksVUFBVVQsY0FBZTtRQUNsQyxNQUFNVSxRQUFRSCxLQUFLQyxHQUFHLENBQUNMLFFBQVFNO1FBQy9CLElBQUlDLFFBQVFKLFVBQVU7WUFDcEJBLFdBQVdJO1lBQ1hMLFVBQVVJO1FBQ1o7SUFDRjtJQUNBLE9BQU9KO0FBQ1Q7QUFFQSxNQUFNTSxjQUFjVixhQUFhUCxPQUFPQyxRQUFRQyxHQUFHLENBQUNnQixpQkFBaUI7QUFFckUsTUFBTUM7SUFJSixZQUFZLE1BQStCLEVBQUUsTUFBK0IsQ0FBRTthQUFqREMsU0FBQUE7YUFBaUNDLFNBQUFBO2FBRnREQyxVQUFVO0lBRTZEO0lBRS9FQyxRQUFRO1FBQ04sSUFBSSxJQUFJLENBQUNELE9BQU8sRUFBRTtRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDRSxLQUFLLEVBQUU7WUFDZixLQUFLLElBQUksQ0FBQ0MsSUFBSTtRQUNoQjtJQUNGO0lBRUFDLE9BQU87UUFDTCxJQUFJLENBQUNKLE9BQU8sR0FB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QUs7WUFDWkMsUUFBUUMsSUFBSSxDQUFDLGlDQUFpQ0Y7UUFDaEQ7SUFDRjtJQUVBLE1BQWNpQixlQUFrQztRQUM5QyxNQUFNLEVBQUVRLElBQUksRUFBRSxHQUFHLE1BQU1uRSwyREFBS0EsQ0FDMUIsQ0FBQzs7OzJDQUdvQyxDQUFDO1FBRXhDLE9BQU9tRSxLQUFLQyxHQUFHLENBQUMsQ0FBQ0MsTUFBUUEsSUFBSTdDLE1BQU0sQ0FBQzhDLElBQUksR0FBR0MsV0FBVyxJQUFJQyxNQUFNLENBQUNDO0lBQ25FO0FBQ0Y7QUFTTyxTQUFTQztJQUNkLElBQUlyRSxRQUFRQyxHQUFHLENBQUNxRSxxQkFBcUIsS0FBSyxTQUFTO0lBQ25ELElBQUlDLFdBQVdDLDJCQUEyQixFQUFFQyxTQUFTO0lBQ3JELE1BQU1DLFVBQVUsSUFBSWpDO0lBQ3BCOEIsV0FBV0MsMkJBQTJCLEdBQUc7UUFBRUU7UUFBU0QsU0FBUztJQUFLO0lBQ2xFQyxRQUFRcEQsS0FBSyxHQUFHcUQsS0FBSyxDQUFDLENBQUN0QztRQUNyQkMsUUFBUXNDLEtBQUssQ0FBQyxxQ0FBcUN2QztJQUNyRDtBQUNGIiwic291cmNlcyI6WyJIOlxcVXNlcnNcXEd1c1xcc291cmNlXFxyZXBvXFxkeW5hbWljc1xcZHluYW1pY3MtYlxcY3J5cHRvcGktZHluYW1pY3NcXHNyY1xcY29yZVxcZmVhdHVyZXNcXHN0ci1hdXhcXHNhbXBsaW5nXFx1bml2ZXJzZVdhdGNoZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcXVlcnkgfSBmcm9tIFwiQC9jb3JlL2RiL3Bvb2xfc2VydmVyXCI7XG5pbXBvcnQgeyBmZXRjaE9yZGVyQm9vayB9IGZyb20gXCJAL2NvcmUvc291cmNlcy9iaW5hbmNlXCI7XG5pbXBvcnQgeyBpbmdlc3RPcmRlckJvb2tUaWNrIH0gZnJvbSBcIi4vYnVja2V0c1wiO1xuXG5jb25zdCBERUZBVUxUX1JFRlJFU0hfTVMgPSBOdW1iZXIocHJvY2Vzcy5lbnYuU1RSX1NBTVBMRVJfUkVGUkVTSF9NUyA/PyA2MF8wMDApO1xuY29uc3QgREVGQVVMVF9QT0xMX01TID0gTnVtYmVyKHByb2Nlc3MuZW52LlNUUl9TQU1QTEVSX1BPTExfTVMgPz8gMV8wMDApO1xuY29uc3QgREVQVEhfT1BUSU9OUyA9IFs1LCAxMCwgMjAsIDUwLCAxMDAsIDUwMCwgMTAwMF0gYXMgY29uc3Q7XG5cbmZ1bmN0aW9uIHJlc29sdmVEZXB0aCh2YWx1ZTogbnVtYmVyIHwgdW5kZWZpbmVkKTogKHR5cGVvZiBERVBUSF9PUFRJT05TKVtudW1iZXJdIHtcbiAgbGV0IGRlcHRoID0gTnVtYmVyKHZhbHVlID8/IDUwKTtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZGVwdGgpKSBkZXB0aCA9IDUwO1xuICBsZXQgY2xvc2VzdCA9IERFUFRIX09QVElPTlNbMF07XG4gIGxldCBtaW5EZWx0YSA9IE1hdGguYWJzKGRlcHRoIC0gY2xvc2VzdCk7XG4gIGZvciAoY29uc3Qgb3B0aW9uIG9mIERFUFRIX09QVElPTlMpIHtcbiAgICBjb25zdCBkZWx0YSA9IE1hdGguYWJzKGRlcHRoIC0gb3B0aW9uKTtcbiAgICBpZiAoZGVsdGEgPCBtaW5EZWx0YSkge1xuICAgICAgbWluRGVsdGEgPSBkZWx0YTtcbiAgICAgIGNsb3Nlc3QgPSBvcHRpb247XG4gICAgfVxuICB9XG4gIHJldHVybiBjbG9zZXN0O1xufVxuXG5jb25zdCBERVBUSF9MSU1JVCA9IHJlc29sdmVEZXB0aChOdW1iZXIocHJvY2Vzcy5lbnYuU1RSX1NBTVBMRVJfREVQVEgpKTtcblxuY2xhc3MgU3ltYm9sU2FtcGxlciB7XG4gIHByaXZhdGUgdGltZXI/OiBOb2RlSlMuVGltZW91dDtcbiAgcHJpdmF0ZSBzdG9wcGVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBzeW1ib2w6IHN0cmluZywgcHJpdmF0ZSByZWFkb25seSBwb2xsTXM6IG51bWJlcikge31cblxuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy5zdG9wcGVkKSByZXR1cm47XG4gICAgaWYgKCF0aGlzLnRpbWVyKSB7XG4gICAgICB2b2lkIHRoaXMucG9sbCgpO1xuICAgIH1cbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy50aW1lcikgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHBvbGwoKSB7XG4gICAgaWYgKHRoaXMuc3RvcHBlZCkgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGZldGNoT3JkZXJCb29rKHRoaXMuc3ltYm9sLCBERVBUSF9MSU1JVCk7XG4gICAgICBpZiAoc25hcHNob3Q/LmRlcHRoKSB7XG4gICAgICAgIGF3YWl0IGluZ2VzdE9yZGVyQm9va1RpY2soe1xuICAgICAgICAgIHN5bWJvbDogdGhpcy5zeW1ib2wsXG4gICAgICAgICAgYmlkczogc25hcHNob3QuZGVwdGguYmlkcyA/PyBbXSxcbiAgICAgICAgICBhc2tzOiBzbmFwc2hvdC5kZXB0aC5hc2tzID8/IFtdLFxuICAgICAgICAgIHRzOiBzbmFwc2hvdC50cyA/PyBEYXRlLm5vdygpLFxuICAgICAgICAgIG1pZDogc25hcHNob3QubWlkLFxuICAgICAgICAgIGJlc3RCaWQ6IHNuYXBzaG90LmJlc3RCaWQsXG4gICAgICAgICAgYmVzdEFzazogc25hcHNob3QuYmVzdEFzayxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbc3RyLWF1eCBzYW1wbGVyXSBvcmRlcmJvb2sgcG9sbCBmYWlsZWRcIiwgdGhpcy5zeW1ib2wsIGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICghdGhpcy5zdG9wcGVkKSB7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHZvaWQgdGhpcy5wb2xsKCksIHRoaXMucG9sbE1zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgVW5pdmVyc2VTYW1wbGVyIHtcbiAgcHJpdmF0ZSBmZWVkcyA9IG5ldyBNYXA8c3RyaW5nLCBTeW1ib2xTYW1wbGVyPigpO1xuICBwcml2YXRlIHJlZnJlc2hUaW1lcj86IE5vZGVKUy5UaW1lb3V0O1xuICBwcml2YXRlIHJ1bm5pbmcgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHJlZnJlc2hNcyA9IERFRkFVTFRfUkVGUkVTSF9NUyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBvbGxNcyA9IERFRkFVTFRfUE9MTF9NU1xuICApIHt9XG5cbiAgYXN5bmMgc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMucnVubmluZykgcmV0dXJuO1xuICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgYXdhaXQgdGhpcy5zeW5jKCk7XG4gICAgdGhpcy5yZWZyZXNoVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB2b2lkIHRoaXMuc3luYygpO1xuICAgIH0sIHRoaXMucmVmcmVzaE1zKTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMucmVmcmVzaFRpbWVyKSBjbGVhckludGVydmFsKHRoaXMucmVmcmVzaFRpbWVyKTtcbiAgICB0aGlzLnJlZnJlc2hUaW1lciA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKGNvbnN0IGZlZWQgb2YgdGhpcy5mZWVkcy52YWx1ZXMoKSkge1xuICAgICAgZmVlZC5zdG9wKCk7XG4gICAgfVxuICAgIHRoaXMuZmVlZHMuY2xlYXIoKTtcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc3luYygpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3ltYm9scyA9IGF3YWl0IHRoaXMuZmV0Y2hTeW1ib2xzKCk7XG4gICAgICBjb25zdCBkZXNpcmVkID0gbmV3IFNldChzeW1ib2xzKTtcblxuICAgICAgZm9yIChjb25zdCBzeW1ib2wgb2Ygc3ltYm9scykge1xuICAgICAgICBpZiAodGhpcy5mZWVkcy5oYXMoc3ltYm9sKSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IHNhbXBsZXIgPSBuZXcgU3ltYm9sU2FtcGxlcihzeW1ib2wsIHRoaXMucG9sbE1zKTtcbiAgICAgICAgdGhpcy5mZWVkcy5zZXQoc3ltYm9sLCBzYW1wbGVyKTtcbiAgICAgICAgc2FtcGxlci5zdGFydCgpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IFtzeW1ib2wsIHNhbXBsZXJdIG9mIHRoaXMuZmVlZHMuZW50cmllcygpKSB7XG4gICAgICAgIGlmICghZGVzaXJlZC5oYXMoc3ltYm9sKSkge1xuICAgICAgICAgIHNhbXBsZXIuc3RvcCgpO1xuICAgICAgICAgIHRoaXMuZmVlZHMuZGVsZXRlKHN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltzdHItYXV4IHNhbXBsZXJdIHN5bmMgZmFpbGVkXCIsIGVycik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmZXRjaFN5bWJvbHMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IHsgcm93cyB9ID0gYXdhaXQgcXVlcnk8eyBzeW1ib2w6IHN0cmluZyB9PihcbiAgICAgIGBTRUxFQ1Qgc3ltYm9sOjp0ZXh0IEFTIHN5bWJvbFxuICAgICAgICAgRlJPTSBzZXR0aW5ncy5jb2luX3VuaXZlcnNlXG4gICAgICAgIFdIRVJFIENPQUxFU0NFKGVuYWJsZWQsdHJ1ZSkgPSB0cnVlXG4gICAgIE9SREVSIEJZIHNvcnRfb3JkZXIgTlVMTFMgTEFTVCwgc3ltYm9sYFxuICAgICk7XG4gICAgcmV0dXJuIHJvd3MubWFwKChyb3cpID0+IHJvdy5zeW1ib2wudHJpbSgpLnRvVXBwZXJDYXNlKCkpLmZpbHRlcihCb29sZWFuKTtcbiAgfVxufVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXJcbiAgdmFyIF9fU1RSX0FVWF9TQU1QTEVSX1dBVENIRVJfXzpcbiAgICB8IHsgd2F0Y2hlcjogVW5pdmVyc2VTYW1wbGVyOyBzdGFydGVkOiBib29sZWFuIH1cbiAgICB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0U2FtcGxpbmdVbml2ZXJzZVdhdGNoZXIoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5TVFJfU0FNUExFUl9BVVRPU1RBUlQgPT09IFwiZmFsc2VcIikgcmV0dXJuO1xuICBpZiAoZ2xvYmFsVGhpcy5fX1NUUl9BVVhfU0FNUExFUl9XQVRDSEVSX18/LnN0YXJ0ZWQpIHJldHVybjtcbiAgY29uc3Qgd2F0Y2hlciA9IG5ldyBVbml2ZXJzZVNhbXBsZXIoKTtcbiAgZ2xvYmFsVGhpcy5fX1NUUl9BVVhfU0FNUExFUl9XQVRDSEVSX18gPSB7IHdhdGNoZXIsIHN0YXJ0ZWQ6IHRydWUgfTtcbiAgd2F0Y2hlci5zdGFydCgpLmNhdGNoKChlcnIpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKFwiW3N0ci1hdXggc2FtcGxlcl0gZmFpbGVkIHRvIHN0YXJ0XCIsIGVycik7XG4gIH0pO1xufVxuIl0sIm5hbWVzIjpbInF1ZXJ5IiwiZmV0Y2hPcmRlckJvb2siLCJpbmdlc3RPcmRlckJvb2tUaWNrIiwiREVGQVVMVF9SRUZSRVNIX01TIiwiTnVtYmVyIiwicHJvY2VzcyIsImVudiIsIlNUUl9TQU1QTEVSX1JFRlJFU0hfTVMiLCJERUZBVUxUX1BPTExfTVMiLCJTVFJfU0FNUExFUl9QT0xMX01TIiwiREVQVEhfT1BUSU9OUyIsInJlc29sdmVEZXB0aCIsInZhbHVlIiwiZGVwdGgiLCJpc0Zpbml0ZSIsImNsb3Nlc3QiLCJtaW5EZWx0YSIsIk1hdGgiLCJhYnMiLCJvcHRpb24iLCJkZWx0YSIsIkRFUFRIX0xJTUlUIiwiU1RSX1NBTVBMRVJfREVQVEgiLCJTeW1ib2xTYW1wbGVyIiwic3ltYm9sIiwicG9sbE1zIiwic3RvcHBlZCIsInN0YXJ0IiwidGltZXIiLCJwb2xsIiwic3RvcCIsImNsZWFyVGltZW91dCIsInVuZGVmaW5lZCIsInNuYXBzaG90IiwiYmlkcyIsImFza3MiLCJ0cyIsIkRhdGUiLCJub3ciLCJtaWQiLCJiZXN0QmlkIiwiYmVzdEFzayIsImVyciIsImNvbnNvbGUiLCJ3YXJuIiwic2V0VGltZW91dCIsIlVuaXZlcnNlU2FtcGxlciIsInJlZnJlc2hNcyIsImZlZWRzIiwiTWFwIiwicnVubmluZyIsInN5bmMiLCJyZWZyZXNoVGltZXIiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJmZWVkIiwidmFsdWVzIiwiY2xlYXIiLCJzeW1ib2xzIiwiZmV0Y2hTeW1ib2xzIiwiZGVzaXJlZCIsIlNldCIsImhhcyIsInNhbXBsZXIiLCJzZXQiLCJlbnRyaWVzIiwiZGVsZXRlIiwicm93cyIsIm1hcCIsInJvdyIsInRyaW0iLCJ0b1VwcGVyQ2FzZSIsImZpbHRlciIsIkJvb2xlYW4iLCJzdGFydFNhbXBsaW5nVW5pdmVyc2VXYXRjaGVyIiwiU1RSX1NBTVBMRVJfQVVUT1NUQVJUIiwiZ2xvYmFsVGhpcyIsIl9fU1RSX0FVWF9TQU1QTEVSX1dBVENIRVJfXyIsInN0YXJ0ZWQiLCJ3YXRjaGVyIiwiY2F0Y2giLCJlcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/sampling/universeWatcher.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/sampling/utils.ts":
/*!*****************************************************!*\
  !*** ./src/core/features/str-aux/sampling/utils.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_SAMPLER_CONFIG: () => (/* binding */ DEFAULT_SAMPLER_CONFIG),\n/* harmony export */   SamplingStoreError: () => (/* binding */ SamplingStoreError),\n/* harmony export */   orderedWindowKeys: () => (/* binding */ orderedWindowKeys),\n/* harmony export */   reduceStatusCounts: () => (/* binding */ reduceStatusCounts),\n/* harmony export */   summarizeMark: () => (/* binding */ summarizeMark),\n/* harmony export */   summarizeSnapshotWindow: () => (/* binding */ summarizeSnapshotWindow),\n/* harmony export */   summarizeWindowMarkers: () => (/* binding */ summarizeWindowMarkers)\n/* harmony export */ });\n// src/core/features/str-aux/sampling/utils.ts\nconst DEFAULT_SAMPLER_CONFIG = {\n    pointIntervalMs: 5000,\n    cycleDurationMs: 40000,\n    windows: {\n        \"30m\": {\n            durationMs: 30 * 60 * 1000,\n            capacity: 45\n        },\n        \"1h\": {\n            durationMs: 60 * 60 * 1000,\n            capacity: 90\n        },\n        \"3h\": {\n            durationMs: 3 * 60 * 60 * 1000,\n            capacity: 270\n        }\n    }\n};\nclass SamplingStoreError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"SamplingStoreError\";\n    }\n}\nfunction summarizeMark(mark) {\n    const points = mark.points ?? [];\n    return {\n        id: mark.id,\n        symbol: mark.symbol,\n        startedAt: mark.startedAt,\n        closedAt: mark.closedAt,\n        durationMs: mark.durationMs,\n        pointsCount: mark.pointsCount,\n        expectedPoints: mark.health.expectedPoints,\n        price: mark.price,\n        spread: mark.spread,\n        volume: mark.volume,\n        health: mark.health,\n        pointRefs: {\n            first: points[0] ?? null,\n            third: points[2] ?? null,\n            last: points[points.length - 1] ?? null\n        }\n    };\n}\nfunction summarizeWindowMarkers(window) {\n    const picks = (indexes)=>indexes.map((i)=>i >= 0 && i < window.marks.length ? window.marks[i] : null).filter((m)=>Boolean(m));\n    const head = picks([\n        0\n    ]).map(summarizeMark)[0] ?? null;\n    const twentieth = picks([\n        19\n    ]).map(summarizeMark)[0] ?? null;\n    const twentyFirst = picks([\n        20\n    ]).map(summarizeMark)[0] ?? null;\n    const tail = picks([\n        window.marks.length - 1\n    ]).map(summarizeMark)[0] ?? null;\n    return {\n        head,\n        twentieth,\n        twentyFirst,\n        tail\n    };\n}\nfunction reduceStatusCounts(marks) {\n    const counts = {\n        ok: 0,\n        warn: 0,\n        error: 0\n    };\n    for (const mark of marks)counts[mark.health.status] += 1;\n    return counts;\n}\nfunction orderedWindowKeys() {\n    return [\n        \"30m\",\n        \"1h\",\n        \"3h\"\n    ];\n}\nfunction summarizeSnapshotWindow(snapshot, key) {\n    const summary = snapshot.windows[key];\n    return {\n        cycle: snapshot.cycle,\n        window: {\n            key,\n            capacity: summary.capacity,\n            size: summary.size,\n            statusCounts: summary.statusCounts,\n            markers: summarizeWindowMarkers(summary)\n        },\n        lastPoint: snapshot.lastPoint,\n        lastClosedMark: snapshot.lastClosedMark ? summarizeMark(snapshot.lastClosedMark) : null\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3NhbXBsaW5nL3V0aWxzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSw4Q0FBOEM7QUFZdkMsTUFBTUEseUJBQXdDO0lBQ25EQyxpQkFBaUI7SUFDakJDLGlCQUFpQjtJQUNqQkMsU0FBUztRQUNQLE9BQU87WUFBRUMsWUFBWSxLQUFLLEtBQUs7WUFBT0MsVUFBVTtRQUFHO1FBQ25ELE1BQU07WUFBRUQsWUFBWSxLQUFLLEtBQUs7WUFBT0MsVUFBVTtRQUFHO1FBQ2xELE1BQU07WUFBRUQsWUFBWSxJQUFJLEtBQUssS0FBSztZQUFPQyxVQUFVO1FBQUk7SUFDekQ7QUFDRixFQUFFO0FBRUssTUFBTUMsMkJBQTJCQztJQUN0QyxZQUFZQyxPQUFlLENBQUU7UUFDM0IsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQXFCTyxTQUFTQyxjQUFjQyxJQUFrQjtJQUM5QyxNQUFNQyxTQUFTRCxLQUFLQyxNQUFNLElBQUksRUFBRTtJQUNoQyxPQUFPO1FBQ0xDLElBQUlGLEtBQUtFLEVBQUU7UUFDWEMsUUFBUUgsS0FBS0csTUFBTTtRQUNuQkMsV0FBV0osS0FBS0ksU0FBUztRQUN6QkMsVUFBVUwsS0FBS0ssUUFBUTtRQUN2QlosWUFBWU8sS0FBS1AsVUFBVTtRQUMzQmEsYUFBYU4sS0FBS00sV0FBVztRQUM3QkMsZ0JBQWdCUCxLQUFLUSxNQUFNLENBQUNELGNBQWM7UUFDMUNFLE9BQU9ULEtBQUtTLEtBQUs7UUFDakJDLFFBQVFWLEtBQUtVLE1BQU07UUFDbkJDLFFBQVFYLEtBQUtXLE1BQU07UUFDbkJILFFBQVFSLEtBQUtRLE1BQU07UUFDbkJJLFdBQVc7WUFDVEMsT0FBT1osTUFBTSxDQUFDLEVBQUUsSUFBSTtZQUNwQmEsT0FBT2IsTUFBTSxDQUFDLEVBQUUsSUFBSTtZQUNwQmMsTUFBTWQsTUFBTSxDQUFDQSxPQUFPZSxNQUFNLEdBQUcsRUFBRSxJQUFJO1FBQ3JDO0lBQ0Y7QUFDRjtBQUVPLFNBQVNDLHVCQUF1QkMsTUFBNkI7SUFDbEUsTUFBTUMsUUFBUSxDQUFDQyxVQUNiQSxRQUNHQyxHQUFHLENBQUMsQ0FBQ0MsSUFBT0EsS0FBSyxLQUFLQSxJQUFJSixPQUFPSyxLQUFLLENBQUNQLE1BQU0sR0FBR0UsT0FBT0ssS0FBSyxDQUFDRCxFQUFFLEdBQUcsTUFDbEVFLE1BQU0sQ0FBQyxDQUFDQyxJQUF5QkMsUUFBUUQ7SUFFOUMsTUFBTUUsT0FBT1IsTUFBTTtRQUFDO0tBQUUsRUFBRUUsR0FBRyxDQUFDdEIsY0FBYyxDQUFDLEVBQUUsSUFBSTtJQUNqRCxNQUFNNkIsWUFBWVQsTUFBTTtRQUFDO0tBQUcsRUFBRUUsR0FBRyxDQUFDdEIsY0FBYyxDQUFDLEVBQUUsSUFBSTtJQUN2RCxNQUFNOEIsY0FBY1YsTUFBTTtRQUFDO0tBQUcsRUFBRUUsR0FBRyxDQUFDdEIsY0FBYyxDQUFDLEVBQUUsSUFBSTtJQUN6RCxNQUFNK0IsT0FBT1gsTUFBTTtRQUFDRCxPQUFPSyxLQUFLLENBQUNQLE1BQU0sR0FBRztLQUFFLEVBQUVLLEdBQUcsQ0FBQ3RCLGNBQWMsQ0FBQyxFQUFFLElBQUk7SUFFdkUsT0FBTztRQUNMNEI7UUFDQUM7UUFDQUM7UUFDQUM7SUFDRjtBQUNGO0FBRU8sU0FBU0MsbUJBQW1CUixLQUFxQjtJQUN0RCxNQUFNUyxTQUErQztRQUFFQyxJQUFJO1FBQUdDLE1BQU07UUFBR0MsT0FBTztJQUFFO0lBQ2hGLEtBQUssTUFBTW5DLFFBQVF1QixNQUFPUyxNQUFNLENBQUNoQyxLQUFLUSxNQUFNLENBQUM0QixNQUFNLENBQUMsSUFBSTtJQUN4RCxPQUFPSjtBQUNUO0FBRU8sU0FBU0s7SUFDZCxPQUFPO1FBQUM7UUFBTztRQUFNO0tBQUs7QUFDNUI7QUFlTyxTQUFTQyx3QkFDZEMsUUFBMEIsRUFDMUJDLEdBQXNCO0lBRXRCLE1BQU1DLFVBQVVGLFNBQVMvQyxPQUFPLENBQUNnRCxJQUFJO0lBQ3JDLE9BQU87UUFDTEUsT0FBT0gsU0FBU0csS0FBSztRQUNyQnhCLFFBQVE7WUFDTnNCO1lBQ0E5QyxVQUFVK0MsUUFBUS9DLFFBQVE7WUFDMUJpRCxNQUFNRixRQUFRRSxJQUFJO1lBQ2xCQyxjQUFjSCxRQUFRRyxZQUFZO1lBQ2xDQyxTQUFTNUIsdUJBQXVCd0I7UUFDbEM7UUFDQUssV0FBV1AsU0FBU08sU0FBUztRQUM3QkMsZ0JBQWdCUixTQUFTUSxjQUFjLEdBQUdoRCxjQUFjd0MsU0FBU1EsY0FBYyxJQUFJO0lBQ3JGO0FBQ0YiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxjb3JlXFxmZWF0dXJlc1xcc3RyLWF1eFxcc2FtcGxpbmdcXHV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb3JlL2ZlYXR1cmVzL3N0ci1hdXgvc2FtcGxpbmcvdXRpbHMudHNcclxuaW1wb3J0IHtcclxuICB0eXBlIFNhbXBsZXJDb25maWcsXHJcbiAgdHlwZSBTYW1wbGluZ0N5Y2xlU25hcHNob3QsXHJcbiAgdHlwZSBTYW1wbGluZ0hlYWx0aFN0YXR1cyxcclxuICB0eXBlIFNhbXBsaW5nTWFyayxcclxuICB0eXBlIFNhbXBsaW5nUG9pbnQsXHJcbiAgdHlwZSBTYW1wbGluZ1NuYXBzaG90LFxyXG4gIHR5cGUgU2FtcGxpbmdXaW5kb3dLZXksXHJcbiAgdHlwZSBTYW1wbGluZ1dpbmRvd1N1bW1hcnksXHJcbn0gZnJvbSBcIi4vdHlwZXNcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1NBTVBMRVJfQ09ORklHOiBTYW1wbGVyQ29uZmlnID0ge1xyXG4gIHBvaW50SW50ZXJ2YWxNczogNV8wMDAsXHJcbiAgY3ljbGVEdXJhdGlvbk1zOiA0MF8wMDAsXHJcbiAgd2luZG93czoge1xyXG4gICAgXCIzMG1cIjogeyBkdXJhdGlvbk1zOiAzMCAqIDYwICogMV8wMDAsIGNhcGFjaXR5OiA0NSB9LFxyXG4gICAgXCIxaFwiOiB7IGR1cmF0aW9uTXM6IDYwICogNjAgKiAxXzAwMCwgY2FwYWNpdHk6IDkwIH0sXHJcbiAgICBcIjNoXCI6IHsgZHVyYXRpb25NczogMyAqIDYwICogNjAgKiAxXzAwMCwgY2FwYWNpdHk6IDI3MCB9LFxyXG4gIH0sXHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgU2FtcGxpbmdTdG9yZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykge1xyXG4gICAgc3VwZXIobWVzc2FnZSk7XHJcbiAgICB0aGlzLm5hbWUgPSBcIlNhbXBsaW5nU3RvcmVFcnJvclwiO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IHR5cGUgTWFya1N1bW1hcnkgPSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBzeW1ib2w6IHN0cmluZztcclxuICBzdGFydGVkQXQ6IG51bWJlcjtcclxuICBjbG9zZWRBdDogbnVtYmVyO1xyXG4gIGR1cmF0aW9uTXM6IG51bWJlcjtcclxuICBwb2ludHNDb3VudDogbnVtYmVyO1xyXG4gIGV4cGVjdGVkUG9pbnRzOiBudW1iZXI7XHJcbiAgcHJpY2U6IFNhbXBsaW5nTWFya1tcInByaWNlXCJdO1xyXG4gIHNwcmVhZDogU2FtcGxpbmdNYXJrW1wic3ByZWFkXCJdO1xyXG4gIHZvbHVtZTogU2FtcGxpbmdNYXJrW1widm9sdW1lXCJdO1xyXG4gIGhlYWx0aDogU2FtcGxpbmdNYXJrW1wiaGVhbHRoXCJdO1xyXG4gIHBvaW50UmVmczoge1xyXG4gICAgZmlyc3Q6IFNhbXBsaW5nUG9pbnQgfCBudWxsO1xyXG4gICAgdGhpcmQ6IFNhbXBsaW5nUG9pbnQgfCBudWxsO1xyXG4gICAgbGFzdDogU2FtcGxpbmdQb2ludCB8IG51bGw7XHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdW1tYXJpemVNYXJrKG1hcms6IFNhbXBsaW5nTWFyayk6IE1hcmtTdW1tYXJ5IHtcclxuICBjb25zdCBwb2ludHMgPSBtYXJrLnBvaW50cyA/PyBbXTtcclxuICByZXR1cm4ge1xyXG4gICAgaWQ6IG1hcmsuaWQsXHJcbiAgICBzeW1ib2w6IG1hcmsuc3ltYm9sLFxyXG4gICAgc3RhcnRlZEF0OiBtYXJrLnN0YXJ0ZWRBdCxcclxuICAgIGNsb3NlZEF0OiBtYXJrLmNsb3NlZEF0LFxyXG4gICAgZHVyYXRpb25NczogbWFyay5kdXJhdGlvbk1zLFxyXG4gICAgcG9pbnRzQ291bnQ6IG1hcmsucG9pbnRzQ291bnQsXHJcbiAgICBleHBlY3RlZFBvaW50czogbWFyay5oZWFsdGguZXhwZWN0ZWRQb2ludHMsXHJcbiAgICBwcmljZTogbWFyay5wcmljZSxcclxuICAgIHNwcmVhZDogbWFyay5zcHJlYWQsXHJcbiAgICB2b2x1bWU6IG1hcmsudm9sdW1lLFxyXG4gICAgaGVhbHRoOiBtYXJrLmhlYWx0aCxcclxuICAgIHBvaW50UmVmczoge1xyXG4gICAgICBmaXJzdDogcG9pbnRzWzBdID8/IG51bGwsXHJcbiAgICAgIHRoaXJkOiBwb2ludHNbMl0gPz8gbnVsbCxcclxuICAgICAgbGFzdDogcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSA/PyBudWxsLFxyXG4gICAgfSxcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc3VtbWFyaXplV2luZG93TWFya2Vycyh3aW5kb3c6IFNhbXBsaW5nV2luZG93U3VtbWFyeSkge1xyXG4gIGNvbnN0IHBpY2tzID0gKGluZGV4ZXM6IG51bWJlcltdKSA9PlxyXG4gICAgaW5kZXhlc1xyXG4gICAgICAubWFwKChpKSA9PiAoaSA+PSAwICYmIGkgPCB3aW5kb3cubWFya3MubGVuZ3RoID8gd2luZG93Lm1hcmtzW2ldIDogbnVsbCkpXHJcbiAgICAgIC5maWx0ZXIoKG0pOiBtIGlzIFNhbXBsaW5nTWFyayA9PiBCb29sZWFuKG0pKTtcclxuXHJcbiAgY29uc3QgaGVhZCA9IHBpY2tzKFswXSkubWFwKHN1bW1hcml6ZU1hcmspWzBdID8/IG51bGw7XHJcbiAgY29uc3QgdHdlbnRpZXRoID0gcGlja3MoWzE5XSkubWFwKHN1bW1hcml6ZU1hcmspWzBdID8/IG51bGw7XHJcbiAgY29uc3QgdHdlbnR5Rmlyc3QgPSBwaWNrcyhbMjBdKS5tYXAoc3VtbWFyaXplTWFyaylbMF0gPz8gbnVsbDtcclxuICBjb25zdCB0YWlsID0gcGlja3MoW3dpbmRvdy5tYXJrcy5sZW5ndGggLSAxXSkubWFwKHN1bW1hcml6ZU1hcmspWzBdID8/IG51bGw7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBoZWFkLFxyXG4gICAgdHdlbnRpZXRoLFxyXG4gICAgdHdlbnR5Rmlyc3QsXHJcbiAgICB0YWlsLFxyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VTdGF0dXNDb3VudHMobWFya3M6IFNhbXBsaW5nTWFya1tdKTogUmVjb3JkPFNhbXBsaW5nSGVhbHRoU3RhdHVzLCBudW1iZXI+IHtcclxuICBjb25zdCBjb3VudHM6IFJlY29yZDxTYW1wbGluZ0hlYWx0aFN0YXR1cywgbnVtYmVyPiA9IHsgb2s6IDAsIHdhcm46IDAsIGVycm9yOiAwIH07XHJcbiAgZm9yIChjb25zdCBtYXJrIG9mIG1hcmtzKSBjb3VudHNbbWFyay5oZWFsdGguc3RhdHVzXSArPSAxO1xyXG4gIHJldHVybiBjb3VudHM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBvcmRlcmVkV2luZG93S2V5cygpOiBTYW1wbGluZ1dpbmRvd0tleVtdIHtcclxuICByZXR1cm4gW1wiMzBtXCIsIFwiMWhcIiwgXCIzaFwiXTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgU2FtcGxpbmdXaW5kb3dEaWdlc3QgPSB7XHJcbiAgY3ljbGU6IFNhbXBsaW5nQ3ljbGVTbmFwc2hvdDtcclxuICB3aW5kb3c6IHtcclxuICAgIGtleTogU2FtcGxpbmdXaW5kb3dLZXk7XHJcbiAgICBjYXBhY2l0eTogbnVtYmVyO1xyXG4gICAgc2l6ZTogbnVtYmVyO1xyXG4gICAgc3RhdHVzQ291bnRzOiBSZWNvcmQ8U2FtcGxpbmdIZWFsdGhTdGF0dXMsIG51bWJlcj47XHJcbiAgICBtYXJrZXJzOiBSZXR1cm5UeXBlPHR5cGVvZiBzdW1tYXJpemVXaW5kb3dNYXJrZXJzPjtcclxuICB9O1xyXG4gIGxhc3RQb2ludDogU2FtcGxpbmdQb2ludCB8IG51bGw7XHJcbiAgbGFzdENsb3NlZE1hcms6IE1hcmtTdW1tYXJ5IHwgbnVsbDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdW1tYXJpemVTbmFwc2hvdFdpbmRvdyhcclxuICBzbmFwc2hvdDogU2FtcGxpbmdTbmFwc2hvdCxcclxuICBrZXk6IFNhbXBsaW5nV2luZG93S2V5XHJcbik6IFNhbXBsaW5nV2luZG93RGlnZXN0IHtcclxuICBjb25zdCBzdW1tYXJ5ID0gc25hcHNob3Qud2luZG93c1trZXldO1xyXG4gIHJldHVybiB7XHJcbiAgICBjeWNsZTogc25hcHNob3QuY3ljbGUsXHJcbiAgICB3aW5kb3c6IHtcclxuICAgICAga2V5LFxyXG4gICAgICBjYXBhY2l0eTogc3VtbWFyeS5jYXBhY2l0eSxcclxuICAgICAgc2l6ZTogc3VtbWFyeS5zaXplLFxyXG4gICAgICBzdGF0dXNDb3VudHM6IHN1bW1hcnkuc3RhdHVzQ291bnRzLFxyXG4gICAgICBtYXJrZXJzOiBzdW1tYXJpemVXaW5kb3dNYXJrZXJzKHN1bW1hcnkpLFxyXG4gICAgfSxcclxuICAgIGxhc3RQb2ludDogc25hcHNob3QubGFzdFBvaW50LFxyXG4gICAgbGFzdENsb3NlZE1hcms6IHNuYXBzaG90Lmxhc3RDbG9zZWRNYXJrID8gc3VtbWFyaXplTWFyayhzbmFwc2hvdC5sYXN0Q2xvc2VkTWFyaykgOiBudWxsLFxyXG4gIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbIkRFRkFVTFRfU0FNUExFUl9DT05GSUciLCJwb2ludEludGVydmFsTXMiLCJjeWNsZUR1cmF0aW9uTXMiLCJ3aW5kb3dzIiwiZHVyYXRpb25NcyIsImNhcGFjaXR5IiwiU2FtcGxpbmdTdG9yZUVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwibmFtZSIsInN1bW1hcml6ZU1hcmsiLCJtYXJrIiwicG9pbnRzIiwiaWQiLCJzeW1ib2wiLCJzdGFydGVkQXQiLCJjbG9zZWRBdCIsInBvaW50c0NvdW50IiwiZXhwZWN0ZWRQb2ludHMiLCJoZWFsdGgiLCJwcmljZSIsInNwcmVhZCIsInZvbHVtZSIsInBvaW50UmVmcyIsImZpcnN0IiwidGhpcmQiLCJsYXN0IiwibGVuZ3RoIiwic3VtbWFyaXplV2luZG93TWFya2VycyIsIndpbmRvdyIsInBpY2tzIiwiaW5kZXhlcyIsIm1hcCIsImkiLCJtYXJrcyIsImZpbHRlciIsIm0iLCJCb29sZWFuIiwiaGVhZCIsInR3ZW50aWV0aCIsInR3ZW50eUZpcnN0IiwidGFpbCIsInJlZHVjZVN0YXR1c0NvdW50cyIsImNvdW50cyIsIm9rIiwid2FybiIsImVycm9yIiwic3RhdHVzIiwib3JkZXJlZFdpbmRvd0tleXMiLCJzdW1tYXJpemVTbmFwc2hvdFdpbmRvdyIsInNuYXBzaG90Iiwia2V5Iiwic3VtbWFyeSIsImN5Y2xlIiwic2l6ZSIsInN0YXR1c0NvdW50cyIsIm1hcmtlcnMiLCJsYXN0UG9pbnQiLCJsYXN0Q2xvc2VkTWFyayJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/sampling/utils.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/vectors.ts":
/*!**********************************************!*\
  !*** ./src/core/features/str-aux/vectors.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildVectorNuclei: () => (/* binding */ buildVectorNuclei),\n/* harmony export */   computeVectorSummary: () => (/* binding */ computeVectorSummary)\n/* harmony export */ });\n/* harmony import */ var _calc_tendency__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calc/tendency */ \"(rsc)/./src/core/features/str-aux/calc/tendency.ts\");\n// src/core/features/str-aux/vectors.ts\n// Shared scaffolding for STR-AUX tendency vectors (vInner, vOuter, vTendency, vSwap).\n// Consolidates the sampling/binning logic so both stats + API layers can reuse the same path.\n\nconst EPS = 1e-9;\nconst clamp01 = (value)=>Math.max(0, Math.min(1, value));\nconst clampScale = (value, scale)=>Math.max(-scale, Math.min(scale, value));\nconst SAFE_SCALE = (scale)=>Number.isFinite(scale) && scale ? Number(scale) : 100;\nconst SAFE_BINS = (bins)=>Math.max(1, Math.floor(Number.isFinite(bins) ? bins : 1));\nfunction sampleWeight(point) {\n    const primary = point.weight ?? point.w;\n    if (Number.isFinite(primary)) {\n        const value = Number(primary);\n        if (value > 0) return value;\n    }\n    if (Number.isFinite(point.volume)) {\n        const volume = Number(point.volume);\n        if (volume > 0) return volume;\n    }\n    return 1;\n}\nfunction nucleusWeight(nucleus) {\n    if (nucleus.weights && nucleus.weights.length) {\n        return nucleus.weights.reduce((sum, w)=>sum + (Number.isFinite(w) && w > 0 ? Number(w) : 0), 0);\n    }\n    return nucleus.values.length;\n}\nfunction buildVectorNuclei(points, binsCount) {\n    const bins = SAFE_BINS(binsCount);\n    if (!points?.length) {\n        return Array.from({\n            length: bins\n        }, ()=>({\n                values: [],\n                weights: []\n            }));\n    }\n    const prices = points.map((p)=>Number(p.price)).filter((price)=>Number.isFinite(price));\n    if (!prices.length) {\n        return Array.from({\n            length: bins\n        }, ()=>({\n                values: [],\n                weights: []\n            }));\n    }\n    const pMin = Math.min(...prices);\n    const pMax = Math.max(...prices);\n    const span = Math.max(EPS, pMax - pMin);\n    const buckets = new Map();\n    for (const point of points){\n        const price = Number(point.price);\n        if (!Number.isFinite(price)) continue;\n        const norm = clamp01((price - pMin) / span);\n        const index = Math.max(0, Math.min(bins - 1, Math.round(norm * (bins - 1))));\n        const weight = sampleWeight(point);\n        const entry = buckets.get(index) ?? {\n            values: [],\n            weights: []\n        };\n        entry.values.push(norm);\n        entry.weights.push(weight);\n        buckets.set(index, entry);\n    }\n    const nuclei = [];\n    for(let idx = 0; idx < bins; idx++){\n        const entry = buckets.get(idx);\n        nuclei.push(entry ? {\n            values: entry.values,\n            weights: entry.weights\n        } : {\n            values: [],\n            weights: []\n        });\n    }\n    return nuclei;\n}\nfunction computeVectorSummary(points, options) {\n    const scale = SAFE_SCALE(options.scale);\n    const bins = SAFE_BINS(options.bins);\n    const safePoints = Array.isArray(points) ? points.map((raw)=>{\n        const price = Number(raw?.price);\n        if (!Number.isFinite(price)) return null;\n        const vectorPoint = {\n            price,\n            ts: Number.isFinite(raw?.ts) ? Number(raw.ts) : undefined,\n            w: Number.isFinite(raw?.w) ? Number(raw.w) : undefined,\n            weight: Number.isFinite(raw?.weight) ? Number(raw.weight) : undefined,\n            volume: Number.isFinite(raw?.volume) ? Number(raw.volume) : undefined\n        };\n        return vectorPoint;\n    }).filter((p)=>Boolean(p)) : [];\n    const samples = safePoints.length;\n    const chronological = safePoints.filter((p)=>Number.isFinite(p.ts)).sort((a, b)=>(Number(a.ts) || 0) - (Number(b.ts) || 0));\n    const orderedPoints = chronological.length ? chronological : safePoints;\n    const priceSeries = orderedPoints.map((p)=>p.price);\n    const scaledPriceHistory = deriveScaledPriceHistory(priceSeries, scale);\n    const { rawReturns, scaledReturns } = deriveReturnSeries(priceSeries, scale);\n    const nuclei = buildVectorNuclei(safePoints, bins);\n    const composeWeights = nuclei.map((nu)=>({\n            gamma: nucleusWeight(nu)\n        }));\n    const weightSum = composeWeights.reduce((sum, w)=>{\n        const gamma = Number.isFinite(w.gamma) ? Math.max(0, w.gamma) : 0;\n        return sum + gamma;\n    }, 0);\n    const aggregateInner = (0,_calc_tendency__WEBPACK_IMPORTED_MODULE_0__.aggregateInnerNow)(nuclei, composeWeights, undefined, scale);\n    const outerScaled = (0,_calc_tendency__WEBPACK_IMPORTED_MODULE_0__.vOuter)(nuclei, composeWeights, {\n        scale\n    });\n    const historyInner = Array.isArray(options.history?.inner) ? options.history.inner.filter((value)=>Number.isFinite(value)).map((value)=>Number(value)) : [];\n    const historyTendency = Array.isArray(options.history?.tendency) ? options.history.tendency.filter((value)=>Number.isFinite(value)).map((value)=>Number(value)) : [];\n    const window = Math.max(3, Math.floor(options.tendencyWindow ?? 30));\n    const normalizer = options.tendencyNorm ?? 'mad';\n    const derivedTendencySeries = rawReturns.length >= 2 ? rawReturns : null;\n    const tendencySeries = derivedTendencySeries ?? historyTendency.concat([\n        outerScaled\n    ]);\n    const tendencyMetrics = (0,_calc_tendency__WEBPACK_IMPORTED_MODULE_0__.vTendencyFromSeries)(tendencySeries, {\n        window,\n        scale,\n        normalizer\n    });\n    const derivedInnerHistory = rawReturns.length >= 2 ? scaledPriceHistory.slice(Math.max(0, scaledPriceHistory.length - rawReturns.length)) : null;\n    const derivedTendencyHistory = scaledReturns.length >= 2 ? scaledReturns : null;\n    const historyInnerWithCurrent = derivedInnerHistory?.length ? derivedInnerHistory : historyInner.concat([\n        aggregateInner.scaled\n    ]);\n    const historyTendencyWithCurrent = derivedTendencyHistory?.length ? derivedTendencyHistory : historyTendency.concat([\n        tendencyMetrics.score\n    ]);\n    let swap;\n    if (historyInnerWithCurrent.length >= 2 && historyTendencyWithCurrent.length >= 2) {\n        swap = (0,_calc_tendency__WEBPACK_IMPORTED_MODULE_0__.vSwapQuartiles)(historyInnerWithCurrent, historyTendencyWithCurrent, {\n            scale,\n            alpha: options.swapAlpha ?? 1.2\n        });\n    }\n    if (!swap) {\n        const fallbackScore = (0,_calc_tendency__WEBPACK_IMPORTED_MODULE_0__.vSwapFromNuclei)(nuclei, bins, {\n            scale,\n            alpha: options.swapAlpha ?? 1.2\n        });\n        const unitless = scale ? fallbackScore / scale : fallbackScore;\n        swap = {\n            Q: unitless,\n            score: fallbackScore,\n            q1: 0,\n            q3: 0\n        };\n    }\n    const innerValues = nuclei.map((nu)=>(0,_calc_tendency__WEBPACK_IMPORTED_MODULE_0__.vInner)(nu, {\n            scale\n        }));\n    const perBin = innerValues.map((scaled, index)=>{\n        const gamma = Number.isFinite(composeWeights[index].gamma) ? Math.max(0, composeWeights[index].gamma) : 0;\n        const share = weightSum > 0 ? gamma / weightSum : innerValues.length ? 1 / innerValues.length : 0;\n        const samplesInBin = nuclei[index].values.length;\n        return {\n            index,\n            scaled,\n            unitless: scale ? scaled / scale : scaled,\n            gamma,\n            share,\n            samples: samplesInBin\n        };\n    });\n    return {\n        scale,\n        bins,\n        samples,\n        inner: {\n            scaled: aggregateInner.scaled,\n            unitless: aggregateInner.unitless,\n            weightSum,\n            perBin\n        },\n        outer: {\n            scaled: outerScaled\n        },\n        tendency: {\n            window,\n            normalizer,\n            series: tendencySeries,\n            metrics: tendencyMetrics\n        },\n        swap,\n        history: {\n            inner: historyInner.length ? historyInner : null,\n            tendency: historyTendency.length ? historyTendency : null\n        }\n    };\n}\nfunction deriveScaledPriceHistory(prices, scale) {\n    if (!prices.length) return [];\n    const mean = prices.reduce((sum, price)=>sum + price, 0) / prices.length;\n    const variance = prices.reduce((sum, price)=>sum + (price - mean) * (price - mean), 0) / Math.max(1, prices.length);\n    const sigma = Math.sqrt(Math.max(variance, EPS));\n    if (!(sigma > 0)) return prices.map(()=>0);\n    return prices.map((price)=>clampScale((price - mean) / sigma * scale, scale));\n}\nfunction deriveReturnSeries(prices, scale) {\n    const rawReturns = [];\n    const scaledReturns = [];\n    for(let i = 1; i < prices.length; i++){\n        const prev = prices[i - 1];\n        const cur = prices[i];\n        if (!(prev > 0 && cur > 0)) continue;\n        const logRet = Math.log(cur / prev);\n        if (!Number.isFinite(logRet)) continue;\n        const raw = logRet * 100;\n        rawReturns.push(raw);\n        scaledReturns.push(clampScale(raw, scale));\n    }\n    return {\n        rawReturns,\n        scaledReturns\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3ZlY3RvcnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsdUNBQXVDO0FBQ3ZDLHNGQUFzRjtBQUN0Riw4RkFBOEY7QUFXckU7QUFFekIsTUFBTU0sTUFBTTtBQUNaLE1BQU1DLFVBQVUsQ0FBQ0MsUUFBa0JDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsR0FBR0g7QUFDM0QsTUFBTUksYUFBYSxDQUFDSixPQUFlSyxRQUNqQ0osS0FBS0MsR0FBRyxDQUFDLENBQUNHLE9BQU9KLEtBQUtFLEdBQUcsQ0FBQ0UsT0FBT0w7QUFzRW5DLE1BQU1NLGFBQWEsQ0FBQ0QsUUFDbEJFLE9BQU9DLFFBQVEsQ0FBQ0gsVUFBVUEsUUFBUUUsT0FBT0YsU0FBUztBQUVwRCxNQUFNSSxZQUFZLENBQUNDLE9BQ2pCVCxLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS1UsS0FBSyxDQUFDSixPQUFPQyxRQUFRLENBQUNFLFFBQVNBLE9BQWtCO0FBRXBFLFNBQVNFLGFBQWFDLEtBQWtCO0lBQ3RDLE1BQU1DLFVBQVVELE1BQU1FLE1BQU0sSUFBSUYsTUFBTUcsQ0FBQztJQUN2QyxJQUFJVCxPQUFPQyxRQUFRLENBQUNNLFVBQW9CO1FBQ3RDLE1BQU1kLFFBQVFPLE9BQU9PO1FBQ3JCLElBQUlkLFFBQVEsR0FBRyxPQUFPQTtJQUN4QjtJQUVBLElBQUlPLE9BQU9DLFFBQVEsQ0FBQ0ssTUFBTUksTUFBTSxHQUFhO1FBQzNDLE1BQU1BLFNBQVNWLE9BQU9NLE1BQU1JLE1BQU07UUFDbEMsSUFBSUEsU0FBUyxHQUFHLE9BQU9BO0lBQ3pCO0lBRUEsT0FBTztBQUNUO0FBRUEsU0FBU0MsY0FBY0MsT0FBb0I7SUFDekMsSUFBSUEsUUFBUUMsT0FBTyxJQUFJRCxRQUFRQyxPQUFPLENBQUNDLE1BQU0sRUFBRTtRQUM3QyxPQUFPRixRQUFRQyxPQUFPLENBQUNFLE1BQU0sQ0FDM0IsQ0FBQ0MsS0FBS1AsSUFB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UWhILEtBQUtpSCxJQUFJLENBQUNqSCxLQUFLQyxHQUFHLENBQUM4RyxVQUFVbEg7SUFDM0MsSUFBSSxDQUFFbUgsQ0FBQUEsUUFBUSxJQUFJLE9BQU9uRixPQUFPQyxHQUFHLENBQUMsSUFBTTtJQUMxQyxPQUFPRCxPQUFPQyxHQUFHLENBQUMsQ0FBQ0UsUUFBVTdCLFdBQVcsQ0FBRTZCLFFBQVE4RSxJQUFHLElBQUtFLFFBQVM1RyxPQUFPQTtBQUM1RTtBQUVBLFNBQVNnRSxtQkFBbUJ2QyxNQUFnQixFQUFFekIsS0FBYTtJQUl6RCxNQUFNOEQsYUFBdUIsRUFBRTtJQUMvQixNQUFNQyxnQkFBMEIsRUFBRTtJQUNsQyxJQUFLLElBQUkrQyxJQUFJLEdBQUdBLElBQUlyRixPQUFPVCxNQUFNLEVBQUU4RixJQUFLO1FBQ3RDLE1BQU1DLE9BQU90RixNQUFNLENBQUNxRixJQUFJLEVBQUU7UUFDMUIsTUFBTUUsTUFBTXZGLE1BQU0sQ0FBQ3FGLEVBQUU7UUFDckIsSUFBSSxDQUFFQyxDQUFBQSxPQUFPLEtBQUtDLE1BQU0sSUFBSTtRQUM1QixNQUFNQyxTQUFTckgsS0FBS3NILEdBQUcsQ0FBQ0YsTUFBTUQ7UUFDOUIsSUFBSSxDQUFDN0csT0FBT0MsUUFBUSxDQUFDOEcsU0FBUztRQUM5QixNQUFNakUsTUFBTWlFLFNBQVM7UUFDckJuRCxXQUFXdEIsSUFBSSxDQUFDUTtRQUNoQmUsY0FBY3ZCLElBQUksQ0FBQ3pDLFdBQVdpRCxLQUFLaEQ7SUFDckM7SUFDQSxPQUFPO1FBQUU4RDtRQUFZQztJQUFjO0FBQ3JDIiwic291cmNlcyI6WyJIOlxcVXNlcnNcXEd1c1xcc291cmNlXFxyZXBvXFxkeW5hbWljc1xcZHluYW1pY3MtYlxcY3J5cHRvcGktZHluYW1pY3NcXHNyY1xcY29yZVxcZmVhdHVyZXNcXHN0ci1hdXhcXHZlY3RvcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvcmUvZmVhdHVyZXMvc3RyLWF1eC92ZWN0b3JzLnRzXG4vLyBTaGFyZWQgc2NhZmZvbGRpbmcgZm9yIFNUUi1BVVggdGVuZGVuY3kgdmVjdG9ycyAodklubmVyLCB2T3V0ZXIsIHZUZW5kZW5jeSwgdlN3YXApLlxuLy8gQ29uc29saWRhdGVzIHRoZSBzYW1wbGluZy9iaW5uaW5nIGxvZ2ljIHNvIGJvdGggc3RhdHMgKyBBUEkgbGF5ZXJzIGNhbiByZXVzZSB0aGUgc2FtZSBwYXRoLlxuXG5pbXBvcnQge1xuICBhZ2dyZWdhdGVJbm5lck5vdyxcbiAgdklubmVyLFxuICB2T3V0ZXIsXG4gIHZUZW5kZW5jeUZyb21TZXJpZXMsXG4gIHZTd2FwUXVhcnRpbGVzLFxuICB2U3dhcEZyb21OdWNsZWksXG4gIHR5cGUgTnVjbGV1cyBhcyBUZW5kTnVjbGV1cyxcbiAgdHlwZSBDb21wb3NlV2VpZ2h0cyxcbn0gZnJvbSAnLi9jYWxjL3RlbmRlbmN5JztcblxuY29uc3QgRVBTID0gMWUtOTtcbmNvbnN0IGNsYW1wMDEgPSAodmFsdWU6IG51bWJlcikgPT4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdmFsdWUpKTtcbmNvbnN0IGNsYW1wU2NhbGUgPSAodmFsdWU6IG51bWJlciwgc2NhbGU6IG51bWJlcikgPT5cbiAgTWF0aC5tYXgoLXNjYWxlLCBNYXRoLm1pbihzY2FsZSwgdmFsdWUpKTtcblxuZXhwb3J0IHR5cGUgVmVjdG9yUG9pbnQgPSB7XG4gIHByaWNlOiBudW1iZXI7XG4gIHRzPzogbnVtYmVyO1xuICB3PzogbnVtYmVyO1xuICB3ZWlnaHQ/OiBudW1iZXI7XG4gIHZvbHVtZT86IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIFZlY3Rvckhpc3RvcnkgPSB7XG4gIGlubmVyPzogbnVtYmVyW107XG4gIHRlbmRlbmN5PzogbnVtYmVyW107XG59O1xuXG5leHBvcnQgdHlwZSBWZWN0b3JPcHRpb25zID0ge1xuICBiaW5zOiBudW1iZXI7XG4gIHNjYWxlPzogbnVtYmVyO1xuICBoaXN0b3J5PzogVmVjdG9ySGlzdG9yeTtcbiAgdGVuZGVuY3lXaW5kb3c/OiBudW1iZXI7XG4gIHRlbmRlbmN5Tm9ybT86ICdtYWQnIHwgJ3N0ZGV2JztcbiAgc3dhcEFscGhhPzogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgVmVjdG9yQmluU25hcHNob3QgPSB7XG4gIGluZGV4OiBudW1iZXI7XG4gIHNjYWxlZDogbnVtYmVyO1xuICB1bml0bGVzczogbnVtYmVyO1xuICBnYW1tYTogbnVtYmVyO1xuICBzaGFyZTogbnVtYmVyO1xuICBzYW1wbGVzOiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBWZWN0b3JTdW1tYXJ5ID0ge1xuICBzY2FsZTogbnVtYmVyO1xuICBiaW5zOiBudW1iZXI7XG4gIHNhbXBsZXM6IG51bWJlcjtcbiAgaW5uZXI6IHtcbiAgICBzY2FsZWQ6IG51bWJlcjtcbiAgICB1bml0bGVzczogbnVtYmVyO1xuICAgIHdlaWdodFN1bTogbnVtYmVyO1xuICAgIHBlckJpbjogVmVjdG9yQmluU25hcHNob3RbXTtcbiAgfTtcbiAgb3V0ZXI6IHtcbiAgICBzY2FsZWQ6IG51bWJlcjtcbiAgfTtcbiAgdGVuZGVuY3k6IHtcbiAgICB3aW5kb3c6IG51bWJlcjtcbiAgICBub3JtYWxpemVyOiAnbWFkJyB8ICdzdGRldic7XG4gICAgc2VyaWVzOiBudW1iZXJbXTtcbiAgICBtZXRyaWNzOiB7XG4gICAgICBkaXJlY3Rpb246IG51bWJlcjtcbiAgICAgIHN0cmVuZ3RoOiBudW1iZXI7XG4gICAgICBzbG9wZTogbnVtYmVyO1xuICAgICAgcjogbnVtYmVyO1xuICAgICAgc2NvcmU6IG51bWJlcjtcbiAgICB9O1xuICB9O1xuICBzd2FwPzoge1xuICAgIFE6IG51bWJlcjtcbiAgICBzY29yZTogbnVtYmVyO1xuICAgIHExOiBudW1iZXI7XG4gICAgcTM6IG51bWJlcjtcbiAgfTtcbiAgaGlzdG9yeToge1xuICAgIGlubmVyOiBudW1iZXJbXSB8IG51bGw7XG4gICAgdGVuZGVuY3k6IG51bWJlcltdIHwgbnVsbDtcbiAgfTtcbn07XG5cbmNvbnN0IFNBRkVfU0NBTEUgPSAoc2NhbGU6IG51bWJlciB8IHVuZGVmaW5lZCkgPT5cbiAgTnVtYmVyLmlzRmluaXRlKHNjYWxlKSAmJiBzY2FsZSA/IE51bWJlcihzY2FsZSkgOiAxMDA7XG5cbmNvbnN0IFNBRkVfQklOUyA9IChiaW5zOiBudW1iZXIgfCB1bmRlZmluZWQpID0+XG4gIE1hdGgubWF4KDEsIE1hdGguZmxvb3IoTnVtYmVyLmlzRmluaXRlKGJpbnMpID8gKGJpbnMgYXMgbnVtYmVyKSA6IDEpKTtcblxuZnVuY3Rpb24gc2FtcGxlV2VpZ2h0KHBvaW50OiBWZWN0b3JQb2ludCk6IG51bWJlciB7XG4gIGNvbnN0IHByaW1hcnkgPSBwb2ludC53ZWlnaHQgPz8gcG9pbnQudztcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShwcmltYXJ5IGFzIG51bWJlcikpIHtcbiAgICBjb25zdCB2YWx1ZSA9IE51bWJlcihwcmltYXJ5KTtcbiAgICBpZiAodmFsdWUgPiAwKSByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoTnVtYmVyLmlzRmluaXRlKHBvaW50LnZvbHVtZSBhcyBudW1iZXIpKSB7XG4gICAgY29uc3Qgdm9sdW1lID0gTnVtYmVyKHBvaW50LnZvbHVtZSk7XG4gICAgaWYgKHZvbHVtZSA+IDApIHJldHVybiB2b2x1bWU7XG4gIH1cblxuICByZXR1cm4gMTtcbn1cblxuZnVuY3Rpb24gbnVjbGV1c1dlaWdodChudWNsZXVzOiBUZW5kTnVjbGV1cyk6IG51bWJlciB7XG4gIGlmIChudWNsZXVzLndlaWdodHMgJiYgbnVjbGV1cy53ZWlnaHRzLmxlbmd0aCkge1xuICAgIHJldHVybiBudWNsZXVzLndlaWdodHMucmVkdWNlKFxuICAgICAgKHN1bSwgdykgPT4gc3VtICsgKE51bWJlci5pc0Zpbml0ZSh3KSAmJiB3ID4gMCA/IE51bWJlcih3KSA6IDApLFxuICAgICAgMFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG51Y2xldXMudmFsdWVzLmxlbmd0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkVmVjdG9yTnVjbGVpKHBvaW50czogVmVjdG9yUG9pbnRbXSwgYmluc0NvdW50OiBudW1iZXIpOiBUZW5kTnVjbGV1c1tdIHtcbiAgY29uc3QgYmlucyA9IFNBRkVfQklOUyhiaW5zQ291bnQpO1xuICBpZiAoIXBvaW50cz8ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGJpbnMgfSwgKCkgPT4gKHsgdmFsdWVzOiBbXSBhcyBudW1iZXJbXSwgd2VpZ2h0czogW10gYXMgbnVtYmVyW10gfSkpO1xuICB9XG5cbiAgY29uc3QgcHJpY2VzID0gcG9pbnRzXG4gICAgLm1hcCgocCkgPT4gTnVtYmVyKHAucHJpY2UpKVxuICAgIC5maWx0ZXIoKHByaWNlKSA9PiBOdW1iZXIuaXNGaW5pdGUocHJpY2UpKTtcbiAgaWYgKCFwcmljZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGJpbnMgfSwgKCkgPT4gKHsgdmFsdWVzOiBbXSBhcyBudW1iZXJbXSwgd2VpZ2h0czogW10gYXMgbnVtYmVyW10gfSkpO1xuICB9XG5cbiAgY29uc3QgcE1pbiA9IE1hdGgubWluKC4uLnByaWNlcyk7XG4gIGNvbnN0IHBNYXggPSBNYXRoLm1heCguLi5wcmljZXMpO1xuICBjb25zdCBzcGFuID0gTWF0aC5tYXgoRVBTLCBwTWF4IC0gcE1pbik7XG5cbiAgY29uc3QgYnVja2V0cyA9IG5ldyBNYXA8bnVtYmVyLCB7IHZhbHVlczogbnVtYmVyW107IHdlaWdodHM6IG51bWJlcltdIH0+KCk7XG4gIGZvciAoY29uc3QgcG9pbnQgb2YgcG9pbnRzKSB7XG4gICAgY29uc3QgcHJpY2UgPSBOdW1iZXIocG9pbnQucHJpY2UpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHByaWNlKSkgY29udGludWU7XG4gICAgY29uc3Qgbm9ybSA9IGNsYW1wMDEoKHByaWNlIC0gcE1pbikgLyBzcGFuKTtcbiAgICBjb25zdCBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGJpbnMgLSAxLCBNYXRoLnJvdW5kKG5vcm0gKiAoYmlucyAtIDEpKSkpO1xuICAgIGNvbnN0IHdlaWdodCA9IHNhbXBsZVdlaWdodChwb2ludCk7XG4gICAgY29uc3QgZW50cnkgPSBidWNrZXRzLmdldChpbmRleCkgPz8geyB2YWx1ZXM6IFtdLCB3ZWlnaHRzOiBbXSB9O1xuICAgIGVudHJ5LnZhbHVlcy5wdXNoKG5vcm0pO1xuICAgIGVudHJ5LndlaWdodHMucHVzaCh3ZWlnaHQpO1xuICAgIGJ1Y2tldHMuc2V0KGluZGV4LCBlbnRyeSk7XG4gIH1cblxuICBjb25zdCBudWNsZWk6IFRlbmROdWNsZXVzW10gPSBbXTtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgYmluczsgaWR4KyspIHtcbiAgICBjb25zdCBlbnRyeSA9IGJ1Y2tldHMuZ2V0KGlkeCk7XG4gICAgbnVjbGVpLnB1c2goXG4gICAgICBlbnRyeVxuICAgICAgICA/IHsgdmFsdWVzOiBlbnRyeS52YWx1ZXMsIHdlaWdodHM6IGVudHJ5LndlaWdodHMgfVxuICAgICAgICA6IHsgdmFsdWVzOiBbXSwgd2VpZ2h0czogW10gfVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG51Y2xlaTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVWZWN0b3JTdW1tYXJ5KFxuICBwb2ludHM6IFZlY3RvclBvaW50W10sXG4gIG9wdGlvbnM6IFZlY3Rvck9wdGlvbnNcbik6IFZlY3RvclN1bW1hcnkge1xuICBjb25zdCBzY2FsZSA9IFNBRkVfU0NBTEUob3B0aW9ucy5zY2FsZSk7XG4gIGNvbnN0IGJpbnMgPSBTQUZFX0JJTlMob3B0aW9ucy5iaW5zKTtcbiAgY29uc3Qgc2FmZVBvaW50cyA9IEFycmF5LmlzQXJyYXkocG9pbnRzKVxuICAgID8gcG9pbnRzXG4gICAgICAgIC5tYXAoKHJhdykgPT4ge1xuICAgICAgICAgIGNvbnN0IHByaWNlID0gTnVtYmVyKChyYXcgYXMgYW55KT8ucHJpY2UpO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHByaWNlKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgY29uc3QgdmVjdG9yUG9pbnQ6IFZlY3RvclBvaW50ID0ge1xuICAgICAgICAgICAgcHJpY2UsXG4gICAgICAgICAgICB0czogTnVtYmVyLmlzRmluaXRlKChyYXcgYXMgYW55KT8udHMpID8gTnVtYmVyKChyYXcgYXMgYW55KS50cykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB3OiBOdW1iZXIuaXNGaW5pdGUoKHJhdyBhcyBhbnkpPy53KSA/IE51bWJlcigocmF3IGFzIGFueSkudykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB3ZWlnaHQ6IE51bWJlci5pc0Zpbml0ZSgocmF3IGFzIGFueSk/LndlaWdodCkgPyBOdW1iZXIoKHJhdyBhcyBhbnkpLndlaWdodCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB2b2x1bWU6IE51bWJlci5pc0Zpbml0ZSgocmF3IGFzIGFueSk/LnZvbHVtZSkgPyBOdW1iZXIoKHJhdyBhcyBhbnkpLnZvbHVtZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gdmVjdG9yUG9pbnQ7XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoKHApOiBwIGlzIFZlY3RvclBvaW50ID0+IEJvb2xlYW4ocCkpXG4gICAgOiBbXTtcbiAgY29uc3Qgc2FtcGxlcyA9IHNhZmVQb2ludHMubGVuZ3RoO1xuXG4gIGNvbnN0IGNocm9ub2xvZ2ljYWwgPSBzYWZlUG9pbnRzXG4gICAgLmZpbHRlcigocCkgPT4gTnVtYmVyLmlzRmluaXRlKHAudHMpKVxuICAgIC5zb3J0KChhLCBiKSA9PiAoTnVtYmVyKGEudHMpIHx8IDApIC0gKE51bWJlcihiLnRzKSB8fCAwKSk7XG4gIGNvbnN0IG9yZGVyZWRQb2ludHMgPSBjaHJvbm9sb2dpY2FsLmxlbmd0aCA/IGNocm9ub2xvZ2ljYWwgOiBzYWZlUG9pbnRzO1xuICBjb25zdCBwcmljZVNlcmllcyA9IG9yZGVyZWRQb2ludHMubWFwKChwKSA9PiBwLnByaWNlKTtcbiAgY29uc3Qgc2NhbGVkUHJpY2VIaXN0b3J5ID0gZGVyaXZlU2NhbGVkUHJpY2VIaXN0b3J5KHByaWNlU2VyaWVzLCBzY2FsZSk7XG4gIGNvbnN0IHsgcmF3UmV0dXJucywgc2NhbGVkUmV0dXJucyB9ID0gZGVyaXZlUmV0dXJuU2VyaWVzKHByaWNlU2VyaWVzLCBzY2FsZSk7XG5cbiAgY29uc3QgbnVjbGVpID0gYnVpbGRWZWN0b3JOdWNsZWkoc2FmZVBvaW50cywgYmlucyk7XG4gIGNvbnN0IGNvbXBvc2VXZWlnaHRzOiBDb21wb3NlV2VpZ2h0c1tdID0gbnVjbGVpLm1hcCgobnUpID0+ICh7IGdhbW1hOiBudWNsZXVzV2VpZ2h0KG51KSB9KSk7XG4gIGNvbnN0IHdlaWdodFN1bSA9IGNvbXBvc2VXZWlnaHRzLnJlZHVjZSgoc3VtLCB3KSA9PiB7XG4gICAgY29uc3QgZ2FtbWEgPSBOdW1iZXIuaXNGaW5pdGUody5nYW1tYSBhcyBudW1iZXIpID8gTWF0aC5tYXgoMCwgdy5nYW1tYSBhcyBudW1iZXIpIDogMDtcbiAgICByZXR1cm4gc3VtICsgZ2FtbWE7XG4gIH0sIDApO1xuXG4gIGNvbnN0IGFnZ3JlZ2F0ZUlubmVyID0gYWdncmVnYXRlSW5uZXJOb3cobnVjbGVpLCBjb21wb3NlV2VpZ2h0cywgdW5kZWZpbmVkLCBzY2FsZSk7XG4gIGNvbnN0IG91dGVyU2NhbGVkID0gdk91dGVyKG51Y2xlaSwgY29tcG9zZVdlaWdodHMsIHsgc2NhbGUgfSk7XG5cbiAgY29uc3QgaGlzdG9yeUlubmVyID0gQXJyYXkuaXNBcnJheShvcHRpb25zLmhpc3Rvcnk/LmlubmVyKVxuICAgID8gb3B0aW9ucy5oaXN0b3J5IS5pbm5lci5maWx0ZXIoKHZhbHVlKSA9PiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpKS5tYXAoKHZhbHVlKSA9PiBOdW1iZXIodmFsdWUpKVxuICAgIDogW107XG4gIGNvbnN0IGhpc3RvcnlUZW5kZW5jeSA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5oaXN0b3J5Py50ZW5kZW5jeSlcbiAgICA/IG9wdGlvbnMuaGlzdG9yeSEudGVuZGVuY3kuZmlsdGVyKCh2YWx1ZSkgPT4gTnVtYmVyLmlzRmluaXRlKHZhbHVlKSkubWFwKCh2YWx1ZSkgPT4gTnVtYmVyKHZhbHVlKSlcbiAgICA6IFtdO1xuICBjb25zdCB3aW5kb3cgPSBNYXRoLm1heCgzLCBNYXRoLmZsb29yKG9wdGlvbnMudGVuZGVuY3lXaW5kb3cgPz8gMzApKTtcbiAgY29uc3Qgbm9ybWFsaXplciA9IG9wdGlvbnMudGVuZGVuY3lOb3JtID8/ICdtYWQnO1xuXG4gIGNvbnN0IGRlcml2ZWRUZW5kZW5jeVNlcmllcyA9IHJhd1JldHVybnMubGVuZ3RoID49IDIgPyByYXdSZXR1cm5zIDogbnVsbDtcbiAgY29uc3QgdGVuZGVuY3lTZXJpZXMgPSBkZXJpdmVkVGVuZGVuY3lTZXJpZXMgPz8gaGlzdG9yeVRlbmRlbmN5LmNvbmNhdChbb3V0ZXJTY2FsZWRdKTtcbiAgY29uc3QgdGVuZGVuY3lNZXRyaWNzID0gdlRlbmRlbmN5RnJvbVNlcmllcyh0ZW5kZW5jeVNlcmllcywge1xuICAgIHdpbmRvdyxcbiAgICBzY2FsZSxcbiAgICBub3JtYWxpemVyLFxuICB9KTtcbiAgY29uc3QgZGVyaXZlZElubmVySGlzdG9yeSA9XG4gICAgcmF3UmV0dXJucy5sZW5ndGggPj0gMlxuICAgICAgPyBzY2FsZWRQcmljZUhpc3Rvcnkuc2xpY2UoTWF0aC5tYXgoMCwgc2NhbGVkUHJpY2VIaXN0b3J5Lmxlbmd0aCAtIHJhd1JldHVybnMubGVuZ3RoKSlcbiAgICAgIDogbnVsbDtcbiAgY29uc3QgZGVyaXZlZFRlbmRlbmN5SGlzdG9yeSA9IHNjYWxlZFJldHVybnMubGVuZ3RoID49IDIgPyBzY2FsZWRSZXR1cm5zIDogbnVsbDtcbiAgY29uc3QgaGlzdG9yeUlubmVyV2l0aEN1cnJlbnQgPSBkZXJpdmVkSW5uZXJIaXN0b3J5Py5sZW5ndGhcbiAgICA/IGRlcml2ZWRJbm5lckhpc3RvcnlcbiAgICA6IGhpc3RvcnlJbm5lci5jb25jYXQoW2FnZ3JlZ2F0ZUlubmVyLnNjYWxlZF0pO1xuICBjb25zdCBoaXN0b3J5VGVuZGVuY3lXaXRoQ3VycmVudCA9IGRlcml2ZWRUZW5kZW5jeUhpc3Rvcnk/Lmxlbmd0aFxuICAgID8gZGVyaXZlZFRlbmRlbmN5SGlzdG9yeVxuICAgIDogaGlzdG9yeVRlbmRlbmN5LmNvbmNhdChbdGVuZGVuY3lNZXRyaWNzLnNjb3JlXSk7XG5cbiAgbGV0IHN3YXA6XG4gICAgfCB7XG4gICAgICAgIFE6IG51bWJlcjtcbiAgICAgICAgc2NvcmU6IG51bWJlcjtcbiAgICAgICAgcTE6IG51bWJlcjtcbiAgICAgICAgcTM6IG51bWJlcjtcbiAgICAgIH1cbiAgICB8IHVuZGVmaW5lZDtcblxuICBpZiAoaGlzdG9yeUlubmVyV2l0aEN1cnJlbnQubGVuZ3RoID49IDIgJiYgaGlzdG9yeVRlbmRlbmN5V2l0aEN1cnJlbnQubGVuZ3RoID49IDIpIHtcbiAgICBzd2FwID0gdlN3YXBRdWFydGlsZXMoaGlzdG9yeUlubmVyV2l0aEN1cnJlbnQsIGhpc3RvcnlUZW5kZW5jeVdpdGhDdXJyZW50LCB7XG4gICAgICBzY2FsZSxcbiAgICAgIGFscGhhOiBvcHRpb25zLnN3YXBBbHBoYSA/PyAxLjIsXG4gICAgfSk7XG4gIH1cbiAgaWYgKCFzd2FwKSB7XG4gICAgY29uc3QgZmFsbGJhY2tTY29yZSA9IHZTd2FwRnJvbU51Y2xlaShudWNsZWksIGJpbnMsIHsgc2NhbGUsIGFscGhhOiBvcHRpb25zLnN3YXBBbHBoYSA/PyAxLjIgfSk7XG4gICAgY29uc3QgdW5pdGxlc3MgPSBzY2FsZSA/IGZhbGxiYWNrU2NvcmUgLyBzY2FsZSA6IGZhbGxiYWNrU2NvcmU7XG4gICAgc3dhcCA9IHsgUTogdW5pdGxlc3MsIHNjb3JlOiBmYWxsYmFja1Njb3JlLCBxMTogMCwgcTM6IDAgfTtcbiAgfVxuXG4gIGNvbnN0IGlubmVyVmFsdWVzID0gbnVjbGVpLm1hcCgobnUpID0+IHZJbm5lcihudSwgeyBzY2FsZSB9KSk7XG4gIGNvbnN0IHBlckJpbjogVmVjdG9yQmluU25hcHNob3RbXSA9IGlubmVyVmFsdWVzLm1hcCgoc2NhbGVkLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGdhbW1hID0gTnVtYmVyLmlzRmluaXRlKGNvbXBvc2VXZWlnaHRzW2luZGV4XS5nYW1tYSBhcyBudW1iZXIpXG4gICAgICA/IE1hdGgubWF4KDAsIGNvbXBvc2VXZWlnaHRzW2luZGV4XS5nYW1tYSBhcyBudW1iZXIpXG4gICAgICA6IDA7XG4gICAgY29uc3Qgc2hhcmUgPSB3ZWlnaHRTdW0gPiAwID8gZ2FtbWEgLyB3ZWlnaHRTdW0gOiBpbm5lclZhbHVlcy5sZW5ndGggPyAxIC8gaW5uZXJWYWx1ZXMubGVuZ3RoIDogMDtcbiAgICBjb25zdCBzYW1wbGVzSW5CaW4gPSBudWNsZWlbaW5kZXhdLnZhbHVlcy5sZW5ndGg7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4LFxuICAgICAgc2NhbGVkLFxuICAgICAgdW5pdGxlc3M6IHNjYWxlID8gc2NhbGVkIC8gc2NhbGUgOiBzY2FsZWQsXG4gICAgICBnYW1tYSxcbiAgICAgIHNoYXJlLFxuICAgICAgc2FtcGxlczogc2FtcGxlc0luQmluLFxuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgc2NhbGUsXG4gICAgYmlucyxcbiAgICBzYW1wbGVzLFxuICAgIGlubmVyOiB7XG4gICAgICBzY2FsZWQ6IGFnZ3JlZ2F0ZUlubmVyLnNjYWxlZCxcbiAgICAgIHVuaXRsZXNzOiBhZ2dyZWdhdGVJbm5lci51bml0bGVzcyxcbiAgICAgIHdlaWdodFN1bSxcbiAgICAgIHBlckJpbixcbiAgICB9LFxuICAgIG91dGVyOiB7XG4gICAgICBzY2FsZWQ6IG91dGVyU2NhbGVkLFxuICAgIH0sXG4gICAgdGVuZGVuY3k6IHtcbiAgICAgIHdpbmRvdyxcbiAgICAgIG5vcm1hbGl6ZXIsXG4gICAgICBzZXJpZXM6IHRlbmRlbmN5U2VyaWVzLFxuICAgICAgbWV0cmljczogdGVuZGVuY3lNZXRyaWNzLFxuICAgIH0sXG4gICAgc3dhcCxcbiAgICBoaXN0b3J5OiB7XG4gICAgICBpbm5lcjogaGlzdG9yeUlubmVyLmxlbmd0aCA/IGhpc3RvcnlJbm5lciA6IG51bGwsXG4gICAgICB0ZW5kZW5jeTogaGlzdG9yeVRlbmRlbmN5Lmxlbmd0aCA/IGhpc3RvcnlUZW5kZW5jeSA6IG51bGwsXG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVyaXZlU2NhbGVkUHJpY2VIaXN0b3J5KHByaWNlczogbnVtYmVyW10sIHNjYWxlOiBudW1iZXIpOiBudW1iZXJbXSB7XG4gIGlmICghcHJpY2VzLmxlbmd0aCkgcmV0dXJuIFtdO1xuICBjb25zdCBtZWFuID0gcHJpY2VzLnJlZHVjZSgoc3VtLCBwcmljZSkgPT4gc3VtICsgcHJpY2UsIDApIC8gcHJpY2VzLmxlbmd0aDtcbiAgY29uc3QgdmFyaWFuY2UgPVxuICAgIHByaWNlcy5yZWR1Y2UoKHN1bSwgcHJpY2UpID0+IHN1bSArIChwcmljZSAtIG1lYW4pICogKHByaWNlIC0gbWVhbiksIDApIC9cbiAgICBNYXRoLm1heCgxLCBwcmljZXMubGVuZ3RoKTtcbiAgY29uc3Qgc2lnbWEgPSBNYXRoLnNxcnQoTWF0aC5tYXgodmFyaWFuY2UsIEVQUykpO1xuICBpZiAoIShzaWdtYSA+IDApKSByZXR1cm4gcHJpY2VzLm1hcCgoKSA9PiAwKTtcbiAgcmV0dXJuIHByaWNlcy5tYXAoKHByaWNlKSA9PiBjbGFtcFNjYWxlKCgocHJpY2UgLSBtZWFuKSAvIHNpZ21hKSAqIHNjYWxlLCBzY2FsZSkpO1xufVxuXG5mdW5jdGlvbiBkZXJpdmVSZXR1cm5TZXJpZXMocHJpY2VzOiBudW1iZXJbXSwgc2NhbGU6IG51bWJlcik6IHtcbiAgcmF3UmV0dXJuczogbnVtYmVyW107XG4gIHNjYWxlZFJldHVybnM6IG51bWJlcltdO1xufSB7XG4gIGNvbnN0IHJhd1JldHVybnM6IG51bWJlcltdID0gW107XG4gIGNvbnN0IHNjYWxlZFJldHVybnM6IG51bWJlcltdID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgcHJpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJldiA9IHByaWNlc1tpIC0gMV07XG4gICAgY29uc3QgY3VyID0gcHJpY2VzW2ldO1xuICAgIGlmICghKHByZXYgPiAwICYmIGN1ciA+IDApKSBjb250aW51ZTtcbiAgICBjb25zdCBsb2dSZXQgPSBNYXRoLmxvZyhjdXIgLyBwcmV2KTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShsb2dSZXQpKSBjb250aW51ZTtcbiAgICBjb25zdCByYXcgPSBsb2dSZXQgKiAxMDA7XG4gICAgcmF3UmV0dXJucy5wdXNoKHJhdyk7XG4gICAgc2NhbGVkUmV0dXJucy5wdXNoKGNsYW1wU2NhbGUocmF3LCBzY2FsZSkpO1xuICB9XG4gIHJldHVybiB7IHJhd1JldHVybnMsIHNjYWxlZFJldHVybnMgfTtcbn1cbiJdLCJuYW1lcyI6WyJhZ2dyZWdhdGVJbm5lck5vdyIsInZJbm5lciIsInZPdXRlciIsInZUZW5kZW5jeUZyb21TZXJpZXMiLCJ2U3dhcFF1YXJ0aWxlcyIsInZTd2FwRnJvbU51Y2xlaSIsIkVQUyIsImNsYW1wMDEiLCJ2YWx1ZSIsIk1hdGgiLCJtYXgiLCJtaW4iLCJjbGFtcFNjYWxlIiwic2NhbGUiLCJTQUZFX1NDQUxFIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJTQUZFX0JJTlMiLCJiaW5zIiwiZmxvb3IiLCJzYW1wbGVXZWlnaHQiLCJwb2ludCIsInByaW1hcnkiLCJ3ZWlnaHQiLCJ3Iiwidm9sdW1lIiwibnVjbGV1c1dlaWdodCIsIm51Y2xldXMiLCJ3ZWlnaHRzIiwibGVuZ3RoIiwicmVkdWNlIiwic3VtIiwidmFsdWVzIiwiYnVpbGRWZWN0b3JOdWNsZWkiLCJwb2ludHMiLCJiaW5zQ291bnQiLCJBcnJheSIsImZyb20iLCJwcmljZXMiLCJtYXAiLCJwIiwicHJpY2UiLCJmaWx0ZXIiLCJwTWluIiwicE1heCIsInNwYW4iLCJidWNrZXRzIiwiTWFwIiwibm9ybSIsImluZGV4Iiwicm91bmQiLCJlbnRyeSIsImdldCIsInB1c2giLCJzZXQiLCJudWNsZWkiLCJpZHgiLCJjb21wdXRlVmVjdG9yU3VtbWFyeSIsIm9wdGlvbnMiLCJzYWZlUG9pbnRzIiwiaXNBcnJheSIsInJhdyIsInZlY3RvclBvaW50IiwidHMiLCJ1bmRlZmluZWQiLCJCb29sZWFuIiwic2FtcGxlcyIsImNocm9ub2xvZ2ljYWwiLCJzb3J0IiwiYSIsImIiLCJvcmRlcmVkUG9pbnRzIiwicHJpY2VTZXJpZXMiLCJzY2FsZWRQcmljZUhpc3RvcnkiLCJkZXJpdmVTY2FsZWRQcmljZUhpc3RvcnkiLCJyYXdSZXR1cm5zIiwic2NhbGVkUmV0dXJucyIsImRlcml2ZVJldHVyblNlcmllcyIsImNvbXBvc2VXZWlnaHRzIiwibnUiLCJnYW1tYSIsIndlaWdodFN1bSIsImFnZ3JlZ2F0ZUlubmVyIiwib3V0ZXJTY2FsZWQiLCJoaXN0b3J5SW5uZXIiLCJoaXN0b3J5IiwiaW5uZXIiLCJoaXN0b3J5VGVuZGVuY3kiLCJ0ZW5kZW5jeSIsIndpbmRvdyIsInRlbmRlbmN5V2luZG93Iiwibm9ybWFsaXplciIsInRlbmRlbmN5Tm9ybSIsImRlcml2ZWRUZW5kZW5jeVNlcmllcyIsInRlbmRlbmN5U2VyaWVzIiwiY29uY2F0IiwidGVuZGVuY3lNZXRyaWNzIiwiZGVyaXZlZElubmVySGlzdG9yeSIsInNsaWNlIiwiZGVyaXZlZFRlbmRlbmN5SGlzdG9yeSIsImhpc3RvcnlJbm5lcldpdGhDdXJyZW50Iiwic2NhbGVkIiwiaGlzdG9yeVRlbmRlbmN5V2l0aEN1cnJlbnQiLCJzY29yZSIsInN3YXAiLCJhbHBoYSIsInN3YXBBbHBoYSIsImZhbGxiYWNrU2NvcmUiLCJ1bml0bGVzcyIsIlEiLCJxMSIsInEzIiwiaW5uZXJWYWx1ZXMiLCJwZXJCaW4iLCJzaGFyZSIsInNhbXBsZXNJbkJpbiIsIm91dGVyIiwic2VyaWVzIiwibWV0cmljcyIsIm1lYW4iLCJ2YXJpYW5jZSIsInNpZ21hIiwic3FydCIsImkiLCJwcmV2IiwiY3VyIiwibG9nUmV0IiwibG9nIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/vectors.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/maths/math.ts":
/*!********************************!*\
  !*** ./src/core/maths/math.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeFromDbAndLive: () => (/* binding */ computeFromDbAndLive),\n/* harmony export */   computeRefBlock: () => (/* binding */ computeRefBlock),\n/* harmony export */   configureBenchmarkProviders: () => (/* binding */ configureBenchmarkProviders),\n/* harmony export */   newGrid: () => (/* binding */ newGrid)\n/* harmony export */ });\n// math.ts - core grid math for Matrices (DB + Live fusion)\n// Uses providers injected by route.ts (incl. opening.ts) to compute:\n//  id_pct, pct_drv, pct_ref, ref, delta\n/** Simple typed newGrid helper. */ function newGrid(n, fill) {\n    return Array.from({\n        length: n\n    }, ()=>Array.from({\n            length: n\n        }, ()=>fill));\n}\nlet PROV = null;\n/** Called by route.ts to inject DB providers (no global imports here). */ function configureBenchmarkProviders(p) {\n    PROV = p;\n}\nconst safeDiv = (num, den)=>{\n    if (num == null || den == null) return null;\n    if (!Number.isFinite(num) || !Number.isFinite(den) || Math.abs(den) < 1e-300) return null;\n    return num / den;\n};\n/** Reference block (pct_ref + ref) */ function computeRefBlock(args) {\n    const { benchmarkNew, id_pct, refValue } = args;\n    // pct_ref = (bm_new - bm_open)/bm_open\n    const pct_ref = refValue == null ? null : safeDiv(benchmarkNew == null ? null : benchmarkNew - refValue, refValue);\n    // ref = (id_pct + 1) * pct_ref\n    const ref = pct_ref == null ? null : (id_pct == null ? 1 : 1 + id_pct) * pct_ref;\n    return {\n        pct_ref,\n        ref\n    };\n}\n/**\r\n * Main derivation using:\r\n *  - live benchmark grid (now)\r\n *  - prev(benchmark) and prev(id_pct) from DB\r\n *  - opening(first-of-day/session) reference grid from DB (via opening.ts)\r\n *\r\n * Formulas:\r\n *  id_pct  = (bm_new - bm_prev)/bm_prev\r\n *  pct_drv = id_pct_new - id_pct_old\r\n *  pct_ref = (bm_new - bm_open)/bm_open\r\n *  ref     = (id_pct + 1) * pct_ref\r\n *  delta   = bm_new - bm_open * (1 + ref)\r\n */ async function computeFromDbAndLive(input) {\n    if (!PROV) throw new Error(\"Providers not configured. Call configureBenchmarkProviders(...) first.\");\n    const { coins, nowTs, liveBenchmark } = input;\n    const n = coins.length;\n    const id_pct = newGrid(n, null);\n    const pct_drv = newGrid(n, null);\n    const pct_ref = newGrid(n, null);\n    const ref = newGrid(n, null);\n    const delta = newGrid(n, null);\n    // 1) Opening grid (persisted opening from v_dyn_matrices via opening.ts)\n    const opening = await PROV.fetchOpeningGrid(coins, nowTs);\n    const openGrid = opening.grid;\n    // 2) prev(benchmark) and prev(id_pct) per pair\n    for(let i = 0; i < n; i++){\n        const bi = coins[i];\n        for(let j = 0; j < n; j++){\n            if (i === j) continue;\n            const qj = coins[j];\n            const bmNow = liveBenchmark[i][j];\n            // id_pct = (bm_new - bm_prev)/bm_prev\n            const bmPrev = await PROV.getPrev(\"benchmark\", bi, qj, nowTs);\n            const idNow = bmPrev == null ? null : safeDiv(bmNow == null ? null : bmNow - bmPrev, bmPrev);\n            id_pct[i][j] = idNow;\n            // pct_drv = id_pct_new - id_pct_old\n            const prevId = await PROV.getPrev(\"id_pct\", bi, qj, nowTs);\n            pct_drv[i][j] = idNow == null || prevId == null || !Number.isFinite(prevId) ? null : idNow - Number(prevId);\n            // pct_ref/ref with persisted opening\n            const openVal = openGrid[i][j];\n            const { pct_ref: pr, ref: r } = computeRefBlock({\n                benchmarkNew: bmNow,\n                id_pct: idNow,\n                refValue: openVal\n            });\n            pct_ref[i][j] = pr;\n            ref[i][j] = r;\n            // delta = bm_new - bm_open * (1 + ref)\n            delta[i][j] = bmNow == null || openVal == null || r == null ? null : bmNow - openVal * (1 + r);\n        }\n    }\n    return {\n        id_pct,\n        pct_drv,\n        pct_ref,\n        ref,\n        delta\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9tYXRocy9tYXRoLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSwyREFBMkQ7QUFDM0QscUVBQXFFO0FBQ3JFLHdDQUF3QztBQUl4QyxpQ0FBaUMsR0FDMUIsU0FBU0EsUUFBV0MsQ0FBUyxFQUFFQyxJQUFPO0lBQzNDLE9BQU9DLE1BQU1DLElBQUksQ0FBQztRQUFFQyxRQUFRSjtJQUFFLEdBQUcsSUFBTUUsTUFBTUMsSUFBSSxDQUFDO1lBQUVDLFFBQVFKO1FBQUUsR0FBRyxJQUFNQztBQUN6RTtBQXVCQSxJQUFJSSxPQUF5QjtBQUU3Qix3RUFBd0UsR0FDakUsU0FBU0MsNEJBQTRCQyxDQUFZO0lBQ3RERixPQUFPRTtBQUNUO0FBRUEsTUFBTUMsVUFBVSxDQUFDQyxLQUFvQkM7SUFDbkMsSUFBSUQsT0FBTyxRQUFRQyxPQUFPLE1BQU0sT0FBTztJQUN2QyxJQUFJLENBQUNDLE9BQU9DLFFBQVEsQ0FBQ0gsUUFBUSxDQUFDRSxPQUFPQyxRQUFRLENBQUNGLFFBQVFHLEtBQUtDLEdBQUcsQ0FBQ0osT0FBTyxRQUFRLE9BQU87SUFDckYsT0FBT0QsTUFBTUM7QUFDZjtBQUVBLG9DQUFvQyxHQUM3QixTQUFTSyxnQkFBZ0JDLElBSS9CO0lBQ0MsTUFBTSxFQUFFQyxZQUFZLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxFQUFFLEdBQUdIO0lBRTNDLHVDQUF1QztJQUN2QyxNQUFNSSxVQUFVLFlBQWEsT0FDekIsT0FDQVosUUFDR1MsZ0JBQWdCLE9BQU8sT0FBT0EsZUFBZUUsVUFDOUNBO0lBR04sK0JBQStCO0lBQy9CLE1BQU1FLE1BQ0osV0FBWSxPQUNSLE9BQ0MsQ0FBQ0gsVUFBVSxPQUFPLElBQUssSUFBSUEsTUFBTSxJQUFLRTtJQUU3QyxPQUFPO1FBQUVBO1FBQVNDO0lBQUk7QUFDeEI7QUFnQkE7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sZUFBZUMscUJBQXFCQyxLQUFtQjtJQUM1RCxJQUFJLENBQUNsQixNQUFNLE1BQU0sSUFBSW1CLE1BQU07SUFFM0IsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsYUFBYSxFQUFFLEdBQUdKO0lBQ3hDLE1BQU12QixJQUFJeUIsTUFBTXJCLE1BQU07SUFFdEIsTUFBTWMsU0FBU25CLFFBQWFDLEdBQUc7SUFDL0IsTUFBTTRCLFVBQVU3QixRQUFhQyxHQUFHO0lBQ2hDLE1BQU1vQixVQUFVckIsUUFBYUMsR0FBRztJQUNoQyxNQUFNcUIsTUFBTXRCLFFBQWFDLEdBQUc7SUFDNUIsTUFBTTZCLFFBQVE5QixRQUFhQyxHQUFHO0lBRTlCLHlFQUF5RTtJQUN6RSxNQUFNOEIsVUFBVSxNQUFNekIsS0FBSzBCLGdCQUFnQixDQUFDTixPQUFPQztJQUNuRCxNQUFNTSxXQUFXRixRQUFRRyxJQUFJO0lBRTdCLCtDQUErQztJQUMvQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSWxDLEdBQUdrQyxJQUFLO1FBQzFCLE1BQU1DLEtBQUtWLEtBQUssQ0FBQ1MsRUFBRTtRQUNuQixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSXBDLEdBQUdvQyxJQUFLO1lBQzFCLElBQUlGLE1BQU1FLEdBQUc7WUFDYixNQUFNQyxLQUFLWixLQUFLLENBQUNXLEVBQUU7WUFFbkIsTUFBTUUsUUFBUVgsYUFBYSxDQUFDTyxFQUFFLENBQUNFLEVBQUU7WUFFakMsc0NBQXNDO1lBQ3RDLE1BQU1HLFNBQVMsTUFBTWxDLEtBQUttQyxPQUFPLENBQUMsYUFBYUwsSUFBSUUsSUFBSVg7WUFDdkQsTUFBTWUsUUFBUSxVQUFXLE9BQ3JCLE9BQ0FqQyxRQUFTOEIsU0FBUyxPQUFPLE9BQU9BLFFBQVFDLFFBQVNBO1lBQ3JEckIsTUFBTSxDQUFDZ0IsRUFBRSxDQUFDRSxFQUFFLEdBQUdLO1lBRWYsb0NBQW9DO1lBQ3BDLE1BQU1DLFNBQVMsTUFBTXJDLEtBQUttQyxPQUFPLENBQUMsVUFBVUwsSUFBSUUsSUFBSVg7WUFDcERFLE9BQU8sQ0FBQ00sRUFBRSxDQUFDRSxFQUFFLEdBQ1gsU0FBVSxRQUFRTSxVQUFVLFFBQVEsQ0FBQy9CLE9BQU9DLFFBQVEsQ0FBQzhCLFVBQ2pELE9BQ0NELFFBQVE5QixPQUFPK0I7WUFFdEIscUNBQXFDO1lBQ3JDLE1BQU1DLFVBQVVYLFFBQVEsQ0FBQ0UsRUFBRSxDQUFDRSxFQUFFO1lBQzlCLE1BQU0sRUFBRWhCLFNBQVN3QixFQUFFLEVBQUV2QixLQUFLd0IsQ0FBQyxFQUFFLEdBQUc5QixnQkFBZ0I7Z0JBQzlDRSxjQUFjcUI7Z0JBQ2RwQixRQUFRdUI7Z0JBQ1J0QixVQUFVd0I7WUFDWjtZQUNBdkIsT0FBTyxDQUFDYyxFQUFFLENBQUNFLEVBQUUsR0FBR1E7WUFDaEJ2QixHQUFHLENBQUNhLEVBQUUsQ0FBQ0UsRUFBRSxHQUFHUztZQUVaLHVDQUF1QztZQUN2Q2hCLEtBQUssQ0FBQ0ssRUFBRSxDQUFDRSxFQUFFLEdBQ1QsU0FBVSxRQUFRTyxXQUFXLFFBQVFFLEtBQUssT0FDdEMsT0FDQ1AsUUFBUUssVUFBVyxLQUFJRSxDQUFBQTtRQUNoQztJQUNGO0lBRUEsT0FBTztRQUFFM0I7UUFBUVU7UUFBU1I7UUFBU0M7UUFBS1E7SUFBTTtBQUNoRCIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGNvcmVcXG1hdGhzXFxtYXRoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIG1hdGgudHMgLSBjb3JlIGdyaWQgbWF0aCBmb3IgTWF0cmljZXMgKERCICsgTGl2ZSBmdXNpb24pXHJcbi8vIFVzZXMgcHJvdmlkZXJzIGluamVjdGVkIGJ5IHJvdXRlLnRzIChpbmNsLiBvcGVuaW5nLnRzKSB0byBjb21wdXRlOlxyXG4vLyAgaWRfcGN0LCBwY3RfZHJ2LCBwY3RfcmVmLCByZWYsIGRlbHRhXHJcblxyXG5leHBvcnQgdHlwZSBOdW0gPSBudW1iZXIgfCBudWxsO1xyXG5cclxuLyoqIFNpbXBsZSB0eXBlZCBuZXdHcmlkIGhlbHBlci4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG5ld0dyaWQ8VD4objogbnVtYmVyLCBmaWxsOiBUKTogVFtdW10ge1xyXG4gIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBuIH0sICgpID0+IEFycmF5LmZyb20oeyBsZW5ndGg6IG4gfSwgKCkgPT4gZmlsbCkpO1xyXG59XHJcblxyXG50eXBlIFByb3ZpZGVyR2V0UHJldiA9IChcclxuICBtYXRyaXhfdHlwZTogXCJiZW5jaG1hcmtcIiB8IFwiaWRfcGN0XCIsXHJcbiAgYmFzZTogc3RyaW5nLFxyXG4gIHF1b3RlOiBzdHJpbmcsXHJcbiAgYmVmb3JlVHM6IG51bWJlclxyXG4pID0+IFByb21pc2U8bnVtYmVyIHwgbnVsbD47XHJcblxyXG4vKipcclxuICogT3BlbmluZyBncmlkIHByb3ZpZGVyICh3aXJlZCB0byBvcGVuaW5nLnRzIGJ5IHRoZSBBUEkgcm91dGUpLlxyXG4gKiBSZXR1cm5zIGFuIE54TiBncmlkIG9mIG9wZW5pbmcgYmVuY2htYXJrIHZhbHVlcyBmb3IgdGhlIHNhbWUgY29pbiB1bml2ZXJzZS5cclxuICovXHJcbnR5cGUgUHJvdmlkZXJPcGVuaW5nR3JpZCA9IChcclxuICBjb2luczogc3RyaW5nW10sXHJcbiAgbm93VHM6IG51bWJlclxyXG4pID0+IFByb21pc2U8eyB0czogbnVtYmVyOyBncmlkOiAobnVtYmVyIHwgbnVsbClbXVtdIH0+O1xyXG5cclxudHlwZSBQcm92aWRlcnMgPSB7XHJcbiAgZ2V0UHJldjogUHJvdmlkZXJHZXRQcmV2O1xyXG4gIGZldGNoT3BlbmluZ0dyaWQ6IFByb3ZpZGVyT3BlbmluZ0dyaWQ7XHJcbn07XHJcblxyXG5sZXQgUFJPVjogUHJvdmlkZXJzIHwgbnVsbCA9IG51bGw7XHJcblxyXG4vKiogQ2FsbGVkIGJ5IHJvdXRlLnRzIHRvIGluamVjdCBEQiBwcm92aWRlcnMgKG5vIGdsb2JhbCBpbXBvcnRzIGhlcmUpLiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29uZmlndXJlQmVuY2htYXJrUHJvdmlkZXJzKHA6IFByb3ZpZGVycykge1xyXG4gIFBST1YgPSBwO1xyXG59XHJcblxyXG5jb25zdCBzYWZlRGl2ID0gKG51bTogbnVtYmVyIHwgbnVsbCwgZGVuOiBudW1iZXIgfCBudWxsKTogbnVtYmVyIHwgbnVsbCA9PiB7XHJcbiAgaWYgKG51bSA9PSBudWxsIHx8IGRlbiA9PSBudWxsKSByZXR1cm4gbnVsbDtcclxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShudW0pIHx8ICFOdW1iZXIuaXNGaW5pdGUoZGVuKSB8fCBNYXRoLmFicyhkZW4pIDwgMWUtMzAwKSByZXR1cm4gbnVsbDtcclxuICByZXR1cm4gbnVtIC8gZGVuO1xyXG59O1xyXG5cclxuLyoqIFJlZmVyZW5jZSBibG9jayAocGN0X3JlZiArIHJlZikgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVSZWZCbG9jayhhcmdzOiB7XHJcbiAgYmVuY2htYXJrTmV3OiBudW1iZXIgfCBudWxsOyAgLy8gYm1fbmV3XHJcbiAgaWRfcGN0OiBudW1iZXIgfCBudWxsOyAgICAgICAgLy8gZGVjaW1hbCwgZS5nLiAwLjAxMjNcclxuICByZWZWYWx1ZTogbnVtYmVyIHwgbnVsbDsgICAgICAvLyBibV9vcGVuXHJcbn0pOiB7IHBjdF9yZWY6IG51bWJlciB8IG51bGw7IHJlZjogbnVtYmVyIHwgbnVsbCB9IHtcclxuICBjb25zdCB7IGJlbmNobWFya05ldywgaWRfcGN0LCByZWZWYWx1ZSB9ID0gYXJncztcclxuXHJcbiAgLy8gcGN0X3JlZiA9IChibV9uZXcgLSBibV9vcGVuKS9ibV9vcGVuXHJcbiAgY29uc3QgcGN0X3JlZiA9IChyZWZWYWx1ZSA9PSBudWxsKVxyXG4gICAgPyBudWxsXHJcbiAgICA6IHNhZmVEaXYoXHJcbiAgICAgICAgKGJlbmNobWFya05ldyA9PSBudWxsID8gbnVsbCA6IGJlbmNobWFya05ldyAtIHJlZlZhbHVlKSxcclxuICAgICAgICByZWZWYWx1ZVxyXG4gICAgICApO1xyXG5cclxuICAvLyByZWYgPSAoaWRfcGN0ICsgMSkgKiBwY3RfcmVmXHJcbiAgY29uc3QgcmVmID1cclxuICAgIChwY3RfcmVmID09IG51bGwpXHJcbiAgICAgID8gbnVsbFxyXG4gICAgICA6ICgoaWRfcGN0ID09IG51bGwgPyAxIDogKDEgKyBpZF9wY3QpKSAqIHBjdF9yZWYpO1xyXG5cclxuICByZXR1cm4geyBwY3RfcmVmLCByZWYgfTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgQ29tcHV0ZUlucHV0ID0ge1xyXG4gIGNvaW5zOiBzdHJpbmdbXTsgICAgICAgICAgICAgICAgICAgIC8vIHVwcGVyY2FzZSB1bml2ZXJzZSAoaW5jbHVkZXMgVVNEVClcclxuICBub3dUczogbnVtYmVyOyAgICAgICAgICAgICAgICAgICAgICAvLyB0aW1lc3RhbXAgZm9yIFwicHJldlwiIGxvb2t1cHNcclxuICBsaXZlQmVuY2htYXJrOiAobnVtYmVyIHwgbnVsbClbXVtdOyAvLyBOeE4gbGl2ZSBibSBncmlkIChmcm9tIGxpdmVGcm9tU291cmNlcy50cylcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIENvbXB1dGVPdXRwdXQgPSB7XHJcbiAgaWRfcGN0OiAobnVtYmVyIHwgbnVsbClbXVtdO1xyXG4gIHBjdF9kcnY6IChudW1iZXIgfCBudWxsKVtdW107XHJcbiAgcGN0X3JlZjogKG51bWJlciB8IG51bGwpW11bXTtcclxuICByZWY6IChudW1iZXIgfCBudWxsKVtdW107XHJcbiAgZGVsdGE6IChudW1iZXIgfCBudWxsKVtdW107XHJcbn07XHJcblxyXG4vKipcclxuICogTWFpbiBkZXJpdmF0aW9uIHVzaW5nOlxyXG4gKiAgLSBsaXZlIGJlbmNobWFyayBncmlkIChub3cpXHJcbiAqICAtIHByZXYoYmVuY2htYXJrKSBhbmQgcHJldihpZF9wY3QpIGZyb20gREJcclxuICogIC0gb3BlbmluZyhmaXJzdC1vZi1kYXkvc2Vzc2lvbikgcmVmZXJlbmNlIGdyaWQgZnJvbSBEQiAodmlhIG9wZW5pbmcudHMpXHJcbiAqXHJcbiAqIEZvcm11bGFzOlxyXG4gKiAgaWRfcGN0ICA9IChibV9uZXcgLSBibV9wcmV2KS9ibV9wcmV2XHJcbiAqICBwY3RfZHJ2ID0gaWRfcGN0X25ldyAtIGlkX3BjdF9vbGRcclxuICogIHBjdF9yZWYgPSAoYm1fbmV3IC0gYm1fb3BlbikvYm1fb3BlblxyXG4gKiAgcmVmICAgICA9IChpZF9wY3QgKyAxKSAqIHBjdF9yZWZcclxuICogIGRlbHRhICAgPSBibV9uZXcgLSBibV9vcGVuICogKDEgKyByZWYpXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZUZyb21EYkFuZExpdmUoaW5wdXQ6IENvbXB1dGVJbnB1dCk6IFByb21pc2U8Q29tcHV0ZU91dHB1dD4ge1xyXG4gIGlmICghUFJPVikgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXJzIG5vdCBjb25maWd1cmVkLiBDYWxsIGNvbmZpZ3VyZUJlbmNobWFya1Byb3ZpZGVycyguLi4pIGZpcnN0LlwiKTtcclxuXHJcbiAgY29uc3QgeyBjb2lucywgbm93VHMsIGxpdmVCZW5jaG1hcmsgfSA9IGlucHV0O1xyXG4gIGNvbnN0IG4gPSBjb2lucy5sZW5ndGg7XHJcblxyXG4gIGNvbnN0IGlkX3BjdCA9IG5ld0dyaWQ8TnVtPihuLCBudWxsKTtcclxuICBjb25zdCBwY3RfZHJ2ID0gbmV3R3JpZDxOdW0+KG4sIG51bGwpO1xyXG4gIGNvbnN0IHBjdF9yZWYgPSBuZXdHcmlkPE51bT4obiwgbnVsbCk7XHJcbiAgY29uc3QgcmVmID0gbmV3R3JpZDxOdW0+KG4sIG51bGwpO1xyXG4gIGNvbnN0IGRlbHRhID0gbmV3R3JpZDxOdW0+KG4sIG51bGwpO1xyXG5cclxuICAvLyAxKSBPcGVuaW5nIGdyaWQgKHBlcnNpc3RlZCBvcGVuaW5nIGZyb20gdl9keW5fbWF0cmljZXMgdmlhIG9wZW5pbmcudHMpXHJcbiAgY29uc3Qgb3BlbmluZyA9IGF3YWl0IFBST1YuZmV0Y2hPcGVuaW5nR3JpZChjb2lucywgbm93VHMpO1xyXG4gIGNvbnN0IG9wZW5HcmlkID0gb3BlbmluZy5ncmlkO1xyXG5cclxuICAvLyAyKSBwcmV2KGJlbmNobWFyaykgYW5kIHByZXYoaWRfcGN0KSBwZXIgcGFpclxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICBjb25zdCBiaSA9IGNvaW5zW2ldITtcclxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbjsgaisrKSB7XHJcbiAgICAgIGlmIChpID09PSBqKSBjb250aW51ZTtcclxuICAgICAgY29uc3QgcWogPSBjb2luc1tqXSE7XHJcblxyXG4gICAgICBjb25zdCBibU5vdyA9IGxpdmVCZW5jaG1hcmtbaV1bal07XHJcblxyXG4gICAgICAvLyBpZF9wY3QgPSAoYm1fbmV3IC0gYm1fcHJldikvYm1fcHJldlxyXG4gICAgICBjb25zdCBibVByZXYgPSBhd2FpdCBQUk9WLmdldFByZXYoXCJiZW5jaG1hcmtcIiwgYmksIHFqLCBub3dUcyk7XHJcbiAgICAgIGNvbnN0IGlkTm93ID0gKGJtUHJldiA9PSBudWxsKVxyXG4gICAgICAgID8gbnVsbFxyXG4gICAgICAgIDogc2FmZURpdigoYm1Ob3cgPT0gbnVsbCA/IG51bGwgOiBibU5vdyAtIGJtUHJldiksIGJtUHJldik7XHJcbiAgICAgIGlkX3BjdFtpXVtqXSA9IGlkTm93O1xyXG5cclxuICAgICAgLy8gcGN0X2RydiA9IGlkX3BjdF9uZXcgLSBpZF9wY3Rfb2xkXHJcbiAgICAgIGNvbnN0IHByZXZJZCA9IGF3YWl0IFBST1YuZ2V0UHJldihcImlkX3BjdFwiLCBiaSwgcWosIG5vd1RzKTtcclxuICAgICAgcGN0X2RydltpXVtqXSA9XHJcbiAgICAgICAgKGlkTm93ID09IG51bGwgfHwgcHJldklkID09IG51bGwgfHwgIU51bWJlci5pc0Zpbml0ZShwcmV2SWQpKVxyXG4gICAgICAgICAgPyBudWxsXHJcbiAgICAgICAgICA6IChpZE5vdyAtIE51bWJlcihwcmV2SWQpKTtcclxuXHJcbiAgICAgIC8vIHBjdF9yZWYvcmVmIHdpdGggcGVyc2lzdGVkIG9wZW5pbmdcclxuICAgICAgY29uc3Qgb3BlblZhbCA9IG9wZW5HcmlkW2ldW2pdO1xyXG4gICAgICBjb25zdCB7IHBjdF9yZWY6IHByLCByZWY6IHIgfSA9IGNvbXB1dGVSZWZCbG9jayh7XHJcbiAgICAgICAgYmVuY2htYXJrTmV3OiBibU5vdyxcclxuICAgICAgICBpZF9wY3Q6IGlkTm93LFxyXG4gICAgICAgIHJlZlZhbHVlOiBvcGVuVmFsXHJcbiAgICAgIH0pO1xyXG4gICAgICBwY3RfcmVmW2ldW2pdID0gcHI7XHJcbiAgICAgIHJlZltpXVtqXSA9IHI7XHJcblxyXG4gICAgICAvLyBkZWx0YSA9IGJtX25ldyAtIGJtX29wZW4gKiAoMSArIHJlZilcclxuICAgICAgZGVsdGFbaV1bal0gPVxyXG4gICAgICAgIChibU5vdyA9PSBudWxsIHx8IG9wZW5WYWwgPT0gbnVsbCB8fCByID09IG51bGwpXHJcbiAgICAgICAgICA/IG51bGxcclxuICAgICAgICAgIDogKGJtTm93IC0gb3BlblZhbCAqICgxICsgcikpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHsgaWRfcGN0LCBwY3RfZHJ2LCBwY3RfcmVmLCByZWYsIGRlbHRhIH07XHJcbn1cclxuXHJcbiJdLCJuYW1lcyI6WyJuZXdHcmlkIiwibiIsImZpbGwiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJQUk9WIiwiY29uZmlndXJlQmVuY2htYXJrUHJvdmlkZXJzIiwicCIsInNhZmVEaXYiLCJudW0iLCJkZW4iLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIk1hdGgiLCJhYnMiLCJjb21wdXRlUmVmQmxvY2siLCJhcmdzIiwiYmVuY2htYXJrTmV3IiwiaWRfcGN0IiwicmVmVmFsdWUiLCJwY3RfcmVmIiwicmVmIiwiY29tcHV0ZUZyb21EYkFuZExpdmUiLCJpbnB1dCIsIkVycm9yIiwiY29pbnMiLCJub3dUcyIsImxpdmVCZW5jaG1hcmsiLCJwY3RfZHJ2IiwiZGVsdGEiLCJvcGVuaW5nIiwiZmV0Y2hPcGVuaW5nR3JpZCIsIm9wZW5HcmlkIiwiZ3JpZCIsImkiLCJiaSIsImoiLCJxaiIsImJtTm93IiwiYm1QcmV2IiwiZ2V0UHJldiIsImlkTm93IiwicHJldklkIiwib3BlblZhbCIsInByIiwiciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/core/maths/math.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/sources/binance.ts":
/*!*************************************!*\
  !*** ./src/core/sources/binance.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fetch24hAll: () => (/* binding */ fetch24hAll),\n/* harmony export */   fetch24hForSymbols: () => (/* binding */ fetch24hForSymbols),\n/* harmony export */   fetchBookTicker: () => (/* binding */ fetchBookTicker),\n/* harmony export */   fetchKlines: () => (/* binding */ fetchKlines),\n/* harmony export */   fetchOrderBook: () => (/* binding */ fetchOrderBook),\n/* harmony export */   fetchOrderBooksForCoins: () => (/* binding */ fetchOrderBooksForCoins),\n/* harmony export */   fetchOrderBooksForSymbols: () => (/* binding */ fetchOrderBooksForSymbols),\n/* harmony export */   fetchTicker24h: () => (/* binding */ fetchTicker24h),\n/* harmony export */   fetchTicker24hNum: () => (/* binding */ fetchTicker24hNum),\n/* harmony export */   fetchTickersForCoins: () => (/* binding */ fetchTickersForCoins),\n/* harmony export */   getSettingsCoins: () => (/* binding */ getSettingsCoins),\n/* harmony export */   listSymbolsByQuote: () => (/* binding */ listSymbolsByQuote),\n/* harmony export */   mapTickerBySymbol: () => (/* binding */ mapTickerBySymbol),\n/* harmony export */   usdtSymbolsFor: () => (/* binding */ usdtSymbolsFor)\n/* harmony export */ });\n/* harmony import */ var _core_sources_binanceClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/sources/binanceClient */ \"(rsc)/./src/core/sources/binanceClient.ts\");\n/* harmony import */ var _lib_settings_server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/settings/server */ \"(rsc)/./src/lib/settings/server.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_settings_server__WEBPACK_IMPORTED_MODULE_1__]);\n_lib_settings_server__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n// src/core/sources/binance.ts\n// Public REST adapter with ticker, klines and orderbook; settings-aware.\n\n\nconst num = (x, d = NaN)=>{\n    const n = Number(x);\n    return Number.isFinite(n) ? n : d;\n};\nasync function fetch24hAll(symbols) {\n    if (!symbols?.length) return [];\n    const qs = new URLSearchParams({\n        symbols: JSON.stringify(symbols)\n    });\n    const arr = await (0,_core_sources_binanceClient__WEBPACK_IMPORTED_MODULE_0__.fetchJson)(`/api/v3/ticker/24hr?${qs.toString()}`);\n    return (Array.isArray(arr) ? arr : []).map((t)=>({\n            symbol: String(t.symbol),\n            weightedAvgPrice: t.weightedAvgPrice,\n            lastPrice: t.lastPrice,\n            priceChangePercent: t.priceChangePercent,\n            priceChange: t.priceChange,\n            openPrice: t.openPrice\n        }));\n}\nfunction mapTickerBySymbol(arr) {\n    const out = {};\n    for (const t of arr)out[t.symbol] = t;\n    return out;\n}\nfunction normCoins(list) {\n    const set = new Set(), out = [];\n    for (const c of list ?? []){\n        const u = String(c || \"\").trim().toUpperCase();\n        if (!u || set.has(u)) continue;\n        set.add(u);\n        out.push(u);\n    }\n    if (!set.has(\"USDT\")) out.push(\"USDT\");\n    return out;\n}\nasync function getSettingsCoins() {\n    const s = await (0,_lib_settings_server__WEBPACK_IMPORTED_MODULE_1__.getAll)();\n    const from = normCoins(s.coinUniverse?.length ? s.coinUniverse : []);\n    return from.length ? from : normCoins([\n        \"BTC\",\n        \"ETH\",\n        \"BNB\",\n        \"SOL\",\n        \"ADA\",\n        \"XRP\",\n        \"PEPE\",\n        \"USDT\"\n    ]);\n}\nfunction usdtSymbolsFor(coins) {\n    return coins.filter((c)=>c !== \"USDT\").map((c)=>`${c}USDT`);\n}\n// Bulk USDT view used for triangulation (kept as-is, but now types are richer).\nasync function fetchTickersForCoins(coins) {\n    const uni = normCoins(coins ?? await getSettingsCoins());\n    const by = mapTickerBySymbol(await fetch24hAll(usdtSymbolsFor(uni)));\n    const out = {\n        USDT: {\n            price: 1,\n            pct24h: 0\n        }\n    };\n    for (const c of uni){\n        if (c === \"USDT\") continue;\n        const t = by[`${c}USDT`];\n        const price = t?.lastPrice != null ? Number(t.lastPrice) : Number(t?.weightedAvgPrice);\n        const pct = t?.priceChangePercent != null ? Number(t.priceChangePercent) : NaN;\n        if (Number.isFinite(price)) out[c] = {\n            price,\n            pct24h: Number.isFinite(pct) ? pct : 0\n        };\n    }\n    return out;\n}\nasync function fetchTicker24h(symbol) {\n    return (0,_core_sources_binanceClient__WEBPACK_IMPORTED_MODULE_0__.fetchJson)(\"/api/v3/ticker/24hr\", {\n        symbol: symbol.toUpperCase()\n    });\n}\n/** Normalized numeric helper: last, pct24h (percent units), delta (absolute) & open */ async function fetchTicker24hNum(symbol) {\n    const t = await fetchTicker24h(symbol);\n    const last = num(t.lastPrice, NaN);\n    const pct = num(t.priceChangePercent, NaN); // percent units\n    let delta = num(t.priceChange, NaN);\n    // robust open and delta if delta missing\n    let open = num(t.openPrice, NaN);\n    if (!Number.isFinite(open) && Number.isFinite(last) && Number.isFinite(pct)) {\n        const r = pct / 100;\n        open = last / (1 + r);\n    }\n    if (!Number.isFinite(delta) && Number.isFinite(last) && Number.isFinite(open)) {\n        delta = last - open;\n    }\n    return {\n        symbol: t.symbol,\n        last: Number.isFinite(last) ? last : null,\n        pct24h: Number.isFinite(pct) ? pct : null,\n        delta: Number.isFinite(delta) ? delta : null,\n        open: Number.isFinite(open) ? open : null\n    };\n}\nasync function fetchKlines(symbol, interval, limit = 128) {\n    return (0,_core_sources_binanceClient__WEBPACK_IMPORTED_MODULE_0__.fetchJson)(\"/api/v3/klines\", {\n        symbol,\n        interval,\n        limit\n    });\n}\nasync function fetchOrderBook(symbol, limit = 100) {\n    const depth = await (0,_core_sources_binanceClient__WEBPACK_IMPORTED_MODULE_0__.fetchJson)(\"/api/v3/depth\", {\n        symbol,\n        limit\n    });\n    const ts = Date.now();\n    const bestBid = num(depth.bids[0]?.[0]);\n    const bestAsk = num(depth.asks[0]?.[0]);\n    const mid = Number.isFinite(bestBid) && Number.isFinite(bestAsk) ? (bestBid + bestAsk) / 2 : NaN;\n    const bidVol = depth.bids.reduce((s, [_, q])=>s + num(q, 0), 0);\n    const askVol = depth.asks.reduce((s, [_, q])=>s + num(q, 0), 0);\n    return {\n        depth,\n        ts,\n        bestBid,\n        bestAsk,\n        mid,\n        bidVol,\n        askVol\n    };\n}\nasync function fetchOrderBooksForSymbols(symbols, limit = 100) {\n    const out = {};\n    await Promise.all((symbols ?? []).map(async (s)=>{\n        const sym = String(s || \"\").toUpperCase();\n        const { mid, bidVol, askVol } = await fetchOrderBook(sym, limit);\n        out[sym] = {\n            mid,\n            bidVol,\n            askVol\n        };\n    }));\n    return out;\n}\nasync function fetchOrderBooksForCoins(coins, limit = 100) {\n    const list = Array.isArray(coins) ? coins.map((c)=>String(c || '').toUpperCase()).filter(Boolean) : [];\n    const symbols = usdtSymbolsFor(list);\n    const books = await fetchOrderBooksForSymbols(symbols, limit);\n    const out = {};\n    for (const coin of list){\n        if (coin === \"USDT\") {\n            out[coin] = {\n                mid: 1,\n                bidVol: 0,\n                askVol: 0\n            };\n            continue;\n        }\n        const entry = books[`${coin}USDT`];\n        out[coin] = entry ?? {\n            mid: NaN,\n            bidVol: 0,\n            askVol: 0\n        };\n    }\n    if (!out.USDT) {\n        out.USDT = {\n            mid: 1,\n            bidVol: 0,\n            askVol: 0\n        };\n    }\n    return out;\n}\nasync function fetchBookTicker(symbol) {\n    const j = await (0,_core_sources_binanceClient__WEBPACK_IMPORTED_MODULE_0__.fetchJson)(\"/api/v3/ticker/bookTicker\", {\n        symbol\n    });\n    const bidPrice = num(j.bidPrice), askPrice = num(j.askPrice);\n    const mid = Number.isFinite(bidPrice) && Number.isFinite(askPrice) ? (bidPrice + askPrice) / 2 : NaN;\n    return {\n        bidPrice,\n        askPrice,\n        mid\n    };\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    fetch24hAll,\n    mapTickerBySymbol,\n    fetchTickersForCoins,\n    getSettingsCoins,\n    usdtSymbolsFor,\n    fetchKlines,\n    fetchOrderBook,\n    fetchOrderBooksForSymbols,\n    fetchOrderBooksForCoins,\n    fetchBookTicker,\n    fetchTicker24h,\n    fetchTicker24hNum\n});\n// src/sources/binance.ts\n// Minimal helpers to list symbols and fetch 24h stats.\n// Adjust base URL or fetch wrapper to your project conventions if needed.\nconst BASE = \"https://api.binance.com\";\nasync function listSymbolsByQuote(quote = \"USDT\") {\n    const r = await fetch(`${BASE}/api/v3/exchangeInfo`, {\n        cache: \"no-store\"\n    });\n    if (!r.ok) throw new Error(`exchangeInfo ${r.status}`);\n    const info = await r.json();\n    const syms = info.symbols.filter((s)=>s.status === \"TRADING\" && s.quoteAsset.toUpperCase() === quote.toUpperCase()).map((s)=>s.symbol).sort();\n    // de-dup\n    const out = [];\n    for (const s of syms)if (!out.length || out[out.length - 1] !== s) out.push(s);\n    return out;\n}\n// If you already have a project-specific fetch24h for one symbol, reuse it inside here.\nasync function fetch24hForSymbols(symbols) {\n    // Batch with Promise.all over /api/v3/ticker/24hr?symbol=XXXX\n    // (Binance also supports /ticker/24hr without symbol returning ALL, but it's heavy;\n    // if you prefer that, you can fetch once and filter.)\n    const qs = symbols.map((s)=>fetch(`${BASE}/api/v3/ticker/24hr?symbol=${s}`, {\n            cache: \"no-store\"\n        }).then((r)=>{\n            if (!r.ok) throw new Error(`24hr ${s} ${r.status}`);\n            return r.json();\n        }).catch((e)=>({\n                symbol: s,\n                _err: String(e)\n            })));\n    return Promise.all(qs);\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ekQsV0FBVyxJQUN0RmxCLEdBQUcsQ0FBQ3VCLENBQUFBLElBQUtBLEVBQUVyQixNQUFNLEVBQ2pCbUYsSUFBSTtJQUNQLFNBQVM7SUFDVCxNQUFNM0UsTUFBZ0IsRUFBRTtJQUN4QixLQUFLLE1BQU1hLEtBQUs0RCxLQUFNLElBQUksQ0FBQ3pFLElBQUluQixNQUFNLElBQUltQixHQUFHLENBQUNBLElBQUluQixNQUFNLEdBQUcsRUFBRSxLQUFLZ0MsR0FBR2IsSUFBSVcsSUFBSSxDQUFDRTtJQUM3RSxPQUFPYjtBQUNUO0FBRUEsd0ZBQXdGO0FBQ2pGLGVBQWU0RSxtQkFBbUJoRyxPQUFpQjtJQUN4RCw4REFBOEQ7SUFDOUQsb0ZBQW9GO0lBQ3BGLHNEQUFzRDtJQUN0RCxNQUFNRSxLQUFLRixRQUFRVSxHQUFHLENBQUN1QixDQUFBQSxJQUFLcUQsTUFBTSxHQUFHSCxLQUFLLDJCQUEyQixFQUFFbEQsR0FBRyxFQUFFO1lBQUVzRCxPQUFPO1FBQVcsR0FDN0ZVLElBQUksQ0FBQzlDLENBQUFBO1lBQ0osSUFBSSxDQUFDQSxFQUFFcUMsRUFBRSxFQUFFLE1BQU0sSUFBSUMsTUFBTSxDQUFDLEtBQUssRUFBRXhELEVBQUUsQ0FBQyxFQUFFa0IsRUFBRXVDLE1BQU0sRUFBRTtZQUNsRCxPQUFPdkMsRUFBRXlDLElBQUk7UUFDZixHQUNDTSxLQUFLLENBQUNDLENBQUFBLElBQU07Z0JBQUV2RixRQUFRcUI7Z0JBQUdtRSxNQUFNdkYsT0FBT3NGO1lBQUc7SUFDNUMsT0FBTzVCLFFBQVFDLEdBQUcsQ0FBQ3RFO0FBQ3JCIiwic291cmNlcyI6WyJIOlxcVXNlcnNcXEd1c1xcc291cmNlXFxyZXBvXFxkeW5hbWljc1xcZHluYW1pY3MtYlxcY3J5cHRvcGktZHluYW1pY3NcXHNyY1xcY29yZVxcc291cmNlc1xcYmluYW5jZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29yZS9zb3VyY2VzL2JpbmFuY2UudHNcclxuLy8gUHVibGljIFJFU1QgYWRhcHRlciB3aXRoIHRpY2tlciwga2xpbmVzIGFuZCBvcmRlcmJvb2s7IHNldHRpbmdzLWF3YXJlLlxyXG5cclxuaW1wb3J0IHsgZmV0Y2hKc29uIH0gZnJvbSBcIkAvY29yZS9zb3VyY2VzL2JpbmFuY2VDbGllbnRcIjtcclxuaW1wb3J0IHsgZ2V0QWxsIGFzIGdldFNldHRpbmdzIH0gZnJvbSBcIkAvbGliL3NldHRpbmdzL3NlcnZlclwiO1xyXG5cclxudHlwZSBJbnRlcnZhbCA9IFwiMW1cInxcIjNtXCJ8XCI1bVwifFwiMTVtXCJ8XCIzMG1cInxcIjFoXCJ8XCIyaFwifFwiNGhcInxcIjZoXCJ8XCI4aFwifFwiMTJoXCJ8XCIxZFwiO1xyXG5cclxuY29uc3QgbnVtID0gKHg6IGFueSwgZD1OYU4pID0+IHsgY29uc3QgbiA9IE51bWJlcih4KTsgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShuKSA/IG4gOiBkOyB9O1xyXG5cclxuLy8gLS0tLSAyNGggdGlja2VyIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbmV4cG9ydCB0eXBlIFRpY2tlcjI0aCA9IHtcclxuICBzeW1ib2w6IHN0cmluZztcclxuICB3ZWlnaHRlZEF2Z1ByaWNlPzogc3RyaW5nO1xyXG4gIGxhc3RQcmljZT86IHN0cmluZztcclxuICBwcmljZUNoYW5nZVBlcmNlbnQ/OiBzdHJpbmc7IC8vIHBlcmNlbnQgdW5pdHMgKGUuZy4gXCIwLjkzOTdcIilcclxuICBwcmljZUNoYW5nZT86IHN0cmluZzsgICAgICAgIC8vIGFic29sdXRlIGRlbHRhIChzYW1lIHVuaXRzIGFzIGxhc3RQcmljZSlcclxuICBvcGVuUHJpY2U/OiBzdHJpbmc7XHJcbn07XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2gyNGhBbGwoc3ltYm9sczogc3RyaW5nW10pOiBQcm9taXNlPFRpY2tlcjI0aFtdPiB7XHJcbiAgaWYgKCFzeW1ib2xzPy5sZW5ndGgpIHJldHVybiBbXTtcclxuICBjb25zdCBxcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBzeW1ib2xzOiBKU09OLnN0cmluZ2lmeShzeW1ib2xzKSB9KTtcclxuICBjb25zdCBhcnIgPSBhd2FpdCBmZXRjaEpzb248YW55W10+KGAvYXBpL3YzL3RpY2tlci8yNGhyPyR7cXMudG9TdHJpbmcoKX1gKTtcclxuICByZXR1cm4gKEFycmF5LmlzQXJyYXkoYXJyKSA/IGFyciA6IFtdKS5tYXAodCA9PiAoe1xyXG4gICAgc3ltYm9sOiBTdHJpbmcodC5zeW1ib2wpLFxyXG4gICAgd2VpZ2h0ZWRBdmdQcmljZTogdC53ZWlnaHRlZEF2Z1ByaWNlLFxyXG4gICAgbGFzdFByaWNlOiB0Lmxhc3RQcmljZSxcclxuICAgIHByaWNlQ2hhbmdlUGVyY2VudDogdC5wcmljZUNoYW5nZVBlcmNlbnQsXHJcbiAgICBwcmljZUNoYW5nZTogdC5wcmljZUNoYW5nZSxcclxuICAgIG9wZW5QcmljZTogdC5vcGVuUHJpY2UsXHJcbiAgfSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWFwVGlja2VyQnlTeW1ib2woYXJyOiBUaWNrZXIyNGhbXSk6IFJlY29yZDxzdHJpbmcsIFRpY2tlcjI0aD4ge1xyXG4gIGNvbnN0IG91dDogUmVjb3JkPHN0cmluZywgVGlja2VyMjRoPiA9IHt9O1xyXG4gIGZvciAoY29uc3QgdCBvZiBhcnIpIG91dFt0LnN5bWJvbF0gPSB0O1xyXG4gIHJldHVybiBvdXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vcm1Db2lucyhsaXN0Pzogc3RyaW5nW10pIHtcclxuICBjb25zdCBzZXQgPSBuZXcgU2V0PHN0cmluZz4oKSwgb3V0OiBzdHJpbmdbXSA9IFtdO1xyXG4gIGZvciAoY29uc3QgYyBvZiBsaXN0ID8/IFtdKSB7XHJcbiAgICBjb25zdCB1ID0gU3RyaW5nKGN8fFwiXCIpLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgaWYgKCF1IHx8IHNldC5oYXModSkpIGNvbnRpbnVlOyBzZXQuYWRkKHUpOyBvdXQucHVzaCh1KTtcclxuICB9XHJcbiAgaWYgKCFzZXQuaGFzKFwiVVNEVFwiKSkgb3V0LnB1c2goXCJVU0RUXCIpO1xyXG4gIHJldHVybiBvdXQ7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTZXR0aW5nc0NvaW5zKCk6IFByb21pc2U8c3RyaW5nW10+IHtcclxuICBjb25zdCBzID0gYXdhaXQgZ2V0U2V0dGluZ3MoKTtcclxuICBjb25zdCBmcm9tID0gbm9ybUNvaW5zKHMuY29pblVuaXZlcnNlPy5sZW5ndGggPyBzLmNvaW5Vbml2ZXJzZSA6IFtdKTtcclxuICByZXR1cm4gZnJvbS5sZW5ndGggPyBmcm9tIDogbm9ybUNvaW5zKFtcIkJUQ1wiLFwiRVRIXCIsXCJCTkJcIixcIlNPTFwiLFwiQURBXCIsXCJYUlBcIixcIlBFUEVcIixcIlVTRFRcIl0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNkdFN5bWJvbHNGb3IoY29pbnM6IHN0cmluZ1tdKSB7XHJcbiAgcmV0dXJuIGNvaW5zLmZpbHRlcihjID0+IGMgIT09IFwiVVNEVFwiKS5tYXAoYyA9PiBgJHtjfVVTRFRgKTtcclxufVxyXG5cclxuLy8gQnVsayBVU0RUIHZpZXcgdXNlZCBmb3IgdHJpYW5ndWxhdGlvbiAoa2VwdCBhcy1pcywgYnV0IG5vdyB0eXBlcyBhcmUgcmljaGVyKS5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoVGlja2Vyc0ZvckNvaW5zKGNvaW5zPzogc3RyaW5nW10pIHtcclxuICBjb25zdCB1bmkgPSBub3JtQ29pbnMoY29pbnMgPz8gKGF3YWl0IGdldFNldHRpbmdzQ29pbnMoKSkpO1xyXG4gIGNvbnN0IGJ5ID0gbWFwVGlja2VyQnlTeW1ib2woYXdhaXQgZmV0Y2gyNGhBbGwodXNkdFN5bWJvbHNGb3IodW5pKSkpO1xyXG4gIGNvbnN0IG91dDogUmVjb3JkPHN0cmluZyx7IHByaWNlOm51bWJlcjsgcGN0MjRoOm51bWJlciB9PiA9IHsgVVNEVDogeyBwcmljZToxLCBwY3QyNGg6MCB9IH07XHJcbiAgZm9yIChjb25zdCBjIG9mIHVuaSkge1xyXG4gICAgaWYgKGMgPT09IFwiVVNEVFwiKSBjb250aW51ZTtcclxuICAgIGNvbnN0IHQgPSBieVtgJHtjfVVTRFRgXTtcclxuICAgIGNvbnN0IHByaWNlID0gdD8ubGFzdFByaWNlICE9IG51bGwgPyBOdW1iZXIodC5sYXN0UHJpY2UpIDogTnVtYmVyKHQ/LndlaWdodGVkQXZnUHJpY2UpO1xyXG4gICAgY29uc3QgcGN0ID0gdD8ucHJpY2VDaGFuZ2VQZXJjZW50ICE9IG51bGwgPyBOdW1iZXIodC5wcmljZUNoYW5nZVBlcmNlbnQpIDogTmFOO1xyXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShwcmljZSkpIG91dFtjXSA9IHsgcHJpY2UsIHBjdDI0aDogTnVtYmVyLmlzRmluaXRlKHBjdCkgPyBwY3QgOiAwIH07XHJcbiAgfVxyXG4gIHJldHVybiBvdXQ7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFRpY2tlcjI0aChzeW1ib2w6IHN0cmluZyk6IFByb21pc2U8VGlja2VyMjRoPiB7XHJcbiAgcmV0dXJuIGZldGNoSnNvbjxUaWNrZXIyNGg+KFwiL2FwaS92My90aWNrZXIvMjRoclwiLCB7IHN5bWJvbDogc3ltYm9sLnRvVXBwZXJDYXNlKCkgfSk7XHJcbn1cclxuXHJcbi8qKiBOb3JtYWxpemVkIG51bWVyaWMgaGVscGVyOiBsYXN0LCBwY3QyNGggKHBlcmNlbnQgdW5pdHMpLCBkZWx0YSAoYWJzb2x1dGUpICYgb3BlbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hUaWNrZXIyNGhOdW0oc3ltYm9sOiBzdHJpbmcpOiBQcm9taXNlPHtcclxuICBzeW1ib2w6IHN0cmluZztcclxuICBsYXN0OiBudW1iZXIgfCBudWxsO1xyXG4gIHBjdDI0aDogbnVtYmVyIHwgbnVsbDsgIC8vIGUuZy4gMC45Mzk3XHJcbiAgZGVsdGE6IG51bWJlciB8IG51bGw7ICAgLy8gYWJzb2x1dGUgcHJpY2VDaGFuZ2VcclxuICBvcGVuOiBudW1iZXIgfCBudWxsO1xyXG59PiB7XHJcbiAgY29uc3QgdCA9IGF3YWl0IGZldGNoVGlja2VyMjRoKHN5bWJvbCk7XHJcbiAgY29uc3QgbGFzdCA9IG51bSh0Lmxhc3RQcmljZSwgTmFOKTtcclxuICBjb25zdCBwY3QgID0gbnVtKHQucHJpY2VDaGFuZ2VQZXJjZW50LCBOYU4pOyAvLyBwZXJjZW50IHVuaXRzXHJcbiAgbGV0IGRlbHRhICA9IG51bSh0LnByaWNlQ2hhbmdlLCBOYU4pO1xyXG4gIC8vIHJvYnVzdCBvcGVuIGFuZCBkZWx0YSBpZiBkZWx0YSBtaXNzaW5nXHJcbiAgbGV0IG9wZW4gPSBudW0odC5vcGVuUHJpY2UsIE5hTik7XHJcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUob3BlbikgJiYgTnVtYmVyLmlzRmluaXRlKGxhc3QpICYmIE51bWJlci5pc0Zpbml0ZShwY3QpKSB7XHJcbiAgICBjb25zdCByID0gcGN0IC8gMTAwO1xyXG4gICAgb3BlbiA9IGxhc3QgLyAoMSArIHIpO1xyXG4gIH1cclxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShkZWx0YSkgJiYgTnVtYmVyLmlzRmluaXRlKGxhc3QpICYmIE51bWJlci5pc0Zpbml0ZShvcGVuKSkge1xyXG4gICAgZGVsdGEgPSBsYXN0IC0gb3BlbjtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHN5bWJvbDogdC5zeW1ib2wsXHJcbiAgICBsYXN0OiBOdW1iZXIuaXNGaW5pdGUobGFzdCkgPyBsYXN0IDogbnVsbCxcclxuICAgIHBjdDI0aDogTnVtYmVyLmlzRmluaXRlKHBjdCkgPyBwY3QgOiBudWxsLFxyXG4gICAgZGVsdGE6IE51bWJlci5pc0Zpbml0ZShkZWx0YSkgPyBkZWx0YSA6IG51bGwsXHJcbiAgICBvcGVuOiBOdW1iZXIuaXNGaW5pdGUob3BlbikgPyBvcGVuIDogbnVsbCxcclxuICB9O1xyXG59XHJcblxyXG4vLyAtLS0tIGtsaW5lcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuZXhwb3J0IHR5cGUgUmF3S2xpbmUgPSBbbnVtYmVyLHN0cmluZyxzdHJpbmcsc3RyaW5nLHN0cmluZyxzdHJpbmcsbnVtYmVyLHN0cmluZyxudW1iZXIsc3RyaW5nLHN0cmluZyxzdHJpbmddO1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hLbGluZXMoc3ltYm9sOiBzdHJpbmcsIGludGVydmFsOiBJbnRlcnZhbCwgbGltaXQ9MTI4KTogUHJvbWlzZTxSYXdLbGluZVtdPiB7XHJcbiAgcmV0dXJuIGZldGNoSnNvbjxSYXdLbGluZVtdPihcIi9hcGkvdjMva2xpbmVzXCIsIHsgc3ltYm9sLCBpbnRlcnZhbCwgbGltaXQgfSk7XHJcbn1cclxuXHJcbi8vIC0tLS0gb3JkZXJib29rICsgYm9va1RpY2tlciAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG50eXBlIERlcHRoTGV2ZWwgPSBbc3RyaW5nLHN0cmluZ107XHJcbmV4cG9ydCB0eXBlIERlcHRoU25hcHNob3QgPSB7IGxhc3RVcGRhdGVJZDpudW1iZXI7IGJpZHM6RGVwdGhMZXZlbFtdOyBhc2tzOkRlcHRoTGV2ZWxbXSB9O1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoT3JkZXJCb29rKHN5bWJvbDogc3RyaW5nLCBsaW1pdDogNXwxMHwyMHw1MHwxMDB8NTAwfDEwMDAgPSAxMDApIHtcclxuICBjb25zdCBkZXB0aCA9IGF3YWl0IGZldGNoSnNvbjxEZXB0aFNuYXBzaG90PihcIi9hcGkvdjMvZGVwdGhcIiwgeyBzeW1ib2wsIGxpbWl0IH0pO1xyXG4gIGNvbnN0IHRzID0gRGF0ZS5ub3coKTtcclxuICBjb25zdCBiZXN0QmlkID0gbnVtKGRlcHRoLmJpZHNbMF0/LlswXSk7XHJcbiAgY29uc3QgYmVzdEFzayA9IG51bShkZXB0aC5hc2tzWzBdPy5bMF0pO1xyXG4gIGNvbnN0IG1pZCA9IE51bWJlci5pc0Zpbml0ZShiZXN0QmlkKSAmJiBOdW1iZXIuaXNGaW5pdGUoYmVzdEFzaykgPyAoYmVzdEJpZCArIGJlc3RBc2spLzIgOiBOYU47XHJcbiAgY29uc3QgYmlkVm9sID0gZGVwdGguYmlkcy5yZWR1Y2UoKHMsIFtfLHFdKSA9PiBzICsgbnVtKHEsMCksIDApO1xyXG4gIGNvbnN0IGFza1ZvbCA9IGRlcHRoLmFza3MucmVkdWNlKChzLCBbXyxxXSkgPT4gcyArIG51bShxLDApLCAwKTtcclxuICByZXR1cm4geyBkZXB0aCwgdHMsIGJlc3RCaWQsIGJlc3RBc2ssIG1pZCwgYmlkVm9sLCBhc2tWb2wgfTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoT3JkZXJCb29rc0ZvclN5bWJvbHMoXHJcbiAgc3ltYm9sczogc3RyaW5nW10sXHJcbiAgbGltaXQ6IDV8MTB8MjB8NTB8MTAwfDUwMHwxMDAwID0gMTAwXHJcbikge1xyXG4gIGNvbnN0IG91dDogUmVjb3JkPHN0cmluZyx7IG1pZDpudW1iZXI7IGJpZFZvbDpudW1iZXI7IGFza1ZvbDpudW1iZXIgfT4gPSB7fTtcclxuICBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgIChzeW1ib2xzID8/IFtdKS5tYXAoYXN5bmMgKHMpID0+IHtcclxuICAgICAgY29uc3Qgc3ltID0gU3RyaW5nKHMgfHwgXCJcIikudG9VcHBlckNhc2UoKTtcclxuICAgICAgY29uc3QgeyBtaWQsIGJpZFZvbCwgYXNrVm9sIH0gPSBhd2FpdCBmZXRjaE9yZGVyQm9vayhzeW0sIGxpbWl0KTtcclxuICAgICAgb3V0W3N5bV0gPSB7IG1pZCwgYmlkVm9sLCBhc2tWb2wgfTtcclxuICAgIH0pXHJcbiAgKTtcclxuICByZXR1cm4gb3V0O1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hPcmRlckJvb2tzRm9yQ29pbnMoXHJcbiAgY29pbnM6IHN0cmluZ1tdLFxyXG4gIGxpbWl0OiA1IHwgMTAgfCAyMCB8IDUwIHwgMTAwIHwgNTAwIHwgMTAwMCA9IDEwMFxyXG4pIHtcclxuICBjb25zdCBsaXN0ID0gQXJyYXkuaXNBcnJheShjb2lucykgPyBjb2lucy5tYXAoKGMpID0+IFN0cmluZyhjIHx8ICcnKS50b1VwcGVyQ2FzZSgpKS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcclxuICBjb25zdCBzeW1ib2xzID0gdXNkdFN5bWJvbHNGb3IobGlzdCk7XHJcbiAgY29uc3QgYm9va3MgPSBhd2FpdCBmZXRjaE9yZGVyQm9va3NGb3JTeW1ib2xzKHN5bWJvbHMsIGxpbWl0KTtcclxuICBjb25zdCBvdXQ6IFJlY29yZDxzdHJpbmcsIHsgbWlkOiBudW1iZXI7IGJpZFZvbDogbnVtYmVyOyBhc2tWb2w6IG51bWJlciB9PiA9IHt9O1xyXG4gIGZvciAoY29uc3QgY29pbiBvZiBsaXN0KSB7XHJcbiAgICBpZiAoY29pbiA9PT0gXCJVU0RUXCIpIHtcclxuICAgICAgb3V0W2NvaW5dID0geyBtaWQ6IDEsIGJpZFZvbDogMCwgYXNrVm9sOiAwIH07XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZW50cnkgPSBib29rc1tgJHtjb2lufVVTRFRgXTtcclxuICAgIG91dFtjb2luXSA9IGVudHJ5ID8/IHsgbWlkOiBOYU4sIGJpZFZvbDogMCwgYXNrVm9sOiAwIH07XHJcbiAgfVxyXG4gIGlmICghb3V0LlVTRFQpIHtcclxuICAgIG91dC5VU0RUID0geyBtaWQ6IDEsIGJpZFZvbDogMCwgYXNrVm9sOiAwIH07XHJcbiAgfVxyXG4gIHJldHVybiBvdXQ7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaEJvb2tUaWNrZXIoc3ltYm9sOiBzdHJpbmcpIHtcclxuICBjb25zdCBqID0gYXdhaXQgZmV0Y2hKc29uPHsgYmlkUHJpY2U6c3RyaW5nOyBhc2tQcmljZTpzdHJpbmcgfT4oXCIvYXBpL3YzL3RpY2tlci9ib29rVGlja2VyXCIsIHsgc3ltYm9sIH0pO1xyXG4gIGNvbnN0IGJpZFByaWNlID0gbnVtKGouYmlkUHJpY2UpLCBhc2tQcmljZSA9IG51bShqLmFza1ByaWNlKTtcclxuICBjb25zdCBtaWQgPSBOdW1iZXIuaXNGaW5pdGUoYmlkUHJpY2UpJiZOdW1iZXIuaXNGaW5pdGUoYXNrUHJpY2UpID8gKGJpZFByaWNlK2Fza1ByaWNlKS8yIDogTmFOO1xyXG4gIHJldHVybiB7IGJpZFByaWNlLCBhc2tQcmljZSwgbWlkIH07XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBmZXRjaDI0aEFsbCwgbWFwVGlja2VyQnlTeW1ib2wsIGZldGNoVGlja2Vyc0ZvckNvaW5zLCBnZXRTZXR0aW5nc0NvaW5zLCB1c2R0U3ltYm9sc0ZvcixcclxuICBmZXRjaEtsaW5lcywgZmV0Y2hPcmRlckJvb2ssIGZldGNoT3JkZXJCb29rc0ZvclN5bWJvbHMsIGZldGNoT3JkZXJCb29rc0ZvckNvaW5zLCBmZXRjaEJvb2tUaWNrZXIsXHJcbiAgZmV0Y2hUaWNrZXIyNGgsIGZldGNoVGlja2VyMjRoTnVtLFxyXG59O1xyXG5cclxuLy8gc3JjL3NvdXJjZXMvYmluYW5jZS50c1xyXG4vLyBNaW5pbWFsIGhlbHBlcnMgdG8gbGlzdCBzeW1ib2xzIGFuZCBmZXRjaCAyNGggc3RhdHMuXHJcbi8vIEFkanVzdCBiYXNlIFVSTCBvciBmZXRjaCB3cmFwcGVyIHRvIHlvdXIgcHJvamVjdCBjb252ZW50aW9ucyBpZiBuZWVkZWQuXHJcblxyXG5jb25zdCBCQVNFID0gXCJodHRwczovL2FwaS5iaW5hbmNlLmNvbVwiO1xyXG5cclxudHlwZSBFeFN5bWJvbCA9IHtcclxuICBzeW1ib2w6IHN0cmluZztcclxuICBzdGF0dXM6IHN0cmluZztcclxuICBiYXNlQXNzZXQ6IHN0cmluZztcclxuICBxdW90ZUFzc2V0OiBzdHJpbmc7XHJcbn07XHJcbnR5cGUgRXhjaGFuZ2VJbmZvID0geyBzeW1ib2xzOiBFeFN5bWJvbFtdIH07XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbGlzdFN5bWJvbHNCeVF1b3RlKHF1b3RlID0gXCJVU0RUXCIpOiBQcm9taXNlPHN0cmluZ1tdPiB7XHJcbiAgY29uc3QgciA9IGF3YWl0IGZldGNoKGAke0JBU0V9L2FwaS92My9leGNoYW5nZUluZm9gLCB7IGNhY2hlOiBcIm5vLXN0b3JlXCIgfSk7XHJcbiAgaWYgKCFyLm9rKSB0aHJvdyBuZXcgRXJyb3IoYGV4Y2hhbmdlSW5mbyAke3Iuc3RhdHVzfWApO1xyXG4gIGNvbnN0IGluZm8gPSAoYXdhaXQgci5qc29uKCkpIGFzIEV4Y2hhbmdlSW5mbztcclxuICBjb25zdCBzeW1zID0gaW5mby5zeW1ib2xzXHJcbiAgICAuZmlsdGVyKHMgPT4gcy5zdGF0dXMgPT09IFwiVFJBRElOR1wiICYmIHMucXVvdGVBc3NldC50b1VwcGVyQ2FzZSgpID09PSBxdW90ZS50b1VwcGVyQ2FzZSgpKVxyXG4gICAgLm1hcChzID0+IHMuc3ltYm9sKVxyXG4gICAgLnNvcnQoKTtcclxuICAvLyBkZS1kdXBcclxuICBjb25zdCBvdXQ6IHN0cmluZ1tdID0gW107XHJcbiAgZm9yIChjb25zdCBzIG9mIHN5bXMpIGlmICghb3V0Lmxlbmd0aCB8fCBvdXRbb3V0Lmxlbmd0aCAtIDFdICE9PSBzKSBvdXQucHVzaChzKTtcclxuICByZXR1cm4gb3V0O1xyXG59XHJcblxyXG4vLyBJZiB5b3UgYWxyZWFkeSBoYXZlIGEgcHJvamVjdC1zcGVjaWZpYyBmZXRjaDI0aCBmb3Igb25lIHN5bWJvbCwgcmV1c2UgaXQgaW5zaWRlIGhlcmUuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaDI0aEZvclN5bWJvbHMoc3ltYm9sczogc3RyaW5nW10pOiBQcm9taXNlPGFueVtdPiB7XHJcbiAgLy8gQmF0Y2ggd2l0aCBQcm9taXNlLmFsbCBvdmVyIC9hcGkvdjMvdGlja2VyLzI0aHI/c3ltYm9sPVhYWFhcclxuICAvLyAoQmluYW5jZSBhbHNvIHN1cHBvcnRzIC90aWNrZXIvMjRociB3aXRob3V0IHN5bWJvbCByZXR1cm5pbmcgQUxMLCBidXQgaXQncyBoZWF2eTtcclxuICAvLyBpZiB5b3UgcHJlZmVyIHRoYXQsIHlvdSBjYW4gZmV0Y2ggb25jZSBhbmQgZmlsdGVyLilcclxuICBjb25zdCBxcyA9IHN5bWJvbHMubWFwKHMgPT4gZmV0Y2goYCR7QkFTRX0vYXBpL3YzL3RpY2tlci8yNGhyP3N5bWJvbD0ke3N9YCwgeyBjYWNoZTogXCJuby1zdG9yZVwiIH0pXHJcbiAgICAudGhlbihyID0+IHtcclxuICAgICAgaWYgKCFyLm9rKSB0aHJvdyBuZXcgRXJyb3IoYDI0aHIgJHtzfSAke3Iuc3RhdHVzfWApO1xyXG4gICAgICByZXR1cm4gci5qc29uKCk7XHJcbiAgICB9KVxyXG4gICAgLmNhdGNoKGUgPT4gKHsgc3ltYm9sOiBzLCBfZXJyOiBTdHJpbmcoZSkgfSkpKTtcclxuICByZXR1cm4gUHJvbWlzZS5hbGwocXMpO1xyXG59XHJcblxyXG5cclxuXHJcbiJdLCJuYW1lcyI6WyJmZXRjaEpzb24iLCJnZXRBbGwiLCJnZXRTZXR0aW5ncyIsIm51bSIsIngiLCJkIiwiTmFOIiwibiIsIk51bWJlciIsImlzRmluaXRlIiwiZmV0Y2gyNGhBbGwiLCJzeW1ib2xzIiwibGVuZ3RoIiwicXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJKU09OIiwic3RyaW5naWZ5IiwiYXJyIiwidG9TdHJpbmciLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJ0Iiwic3ltYm9sIiwiU3RyaW5nIiwid2VpZ2h0ZWRBdmdQcmljZSIsImxhc3RQcmljZSIsInByaWNlQ2hhbmdlUGVyY2VudCIsInByaWNlQ2hhbmdlIiwib3BlblByaWNlIiwibWFwVGlja2VyQnlTeW1ib2wiLCJvdXQiLCJub3JtQ29pbnMiLCJsaXN0Iiwic2V0IiwiU2V0IiwiYyIsInUiLCJ0cmltIiwidG9VcHBlckNhc2UiLCJoYXMiLCJhZGQiLCJwdXNoIiwiZ2V0U2V0dGluZ3NDb2lucyIsInMiLCJmcm9tIiwiY29pblVuaXZlcnNlIiwidXNkdFN5bWJvbHNGb3IiLCJjb2lucyIsImZpbHRlciIsImZldGNoVGlja2Vyc0ZvckNvaW5zIiwidW5pIiwiYnkiLCJVU0RUIiwicHJpY2UiLCJwY3QyNGgiLCJwY3QiLCJmZXRjaFRpY2tlcjI0aCIsImZldGNoVGlja2VyMjRoTnVtIiwibGFzdCIsImRlbHRhIiwib3BlbiIsInIiLCJmZXRjaEtsaW5lcyIsImludGVydmFsIiwibGltaXQiLCJmZXRjaE9yZGVyQm9vayIsImRlcHRoIiwidHMiLCJEYXRlIiwibm93IiwiYmVzdEJpZCIsImJpZHMiLCJiZXN0QXNrIiwiYXNrcyIsIm1pZCIsImJpZFZvbCIsInJlZHVjZSIsIl8iLCJxIiwiYXNrVm9sIiwiZmV0Y2hPcmRlckJvb2tzRm9yU3ltYm9scyIsIlByb21pc2UiLCJhbGwiLCJzeW0iLCJmZXRjaE9yZGVyQm9va3NGb3JDb2lucyIsIkJvb2xlYW4iLCJib29rcyIsImNvaW4iLCJlbnRyeSIsImZldGNoQm9va1RpY2tlciIsImoiLCJiaWRQcmljZSIsImFza1ByaWNlIiwiQkFTRSIsImxpc3RTeW1ib2xzQnlRdW90ZSIsInF1b3RlIiwiZmV0Y2giLCJjYWNoZSIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJpbmZvIiwianNvbiIsInN5bXMiLCJxdW90ZUFzc2V0Iiwic29ydCIsImZldGNoMjRoRm9yU3ltYm9scyIsInRoZW4iLCJjYXRjaCIsImUiLCJfZXJyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/core/sources/binance.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/sources/binanceClient.ts":
/*!*******************************************!*\
  !*** ./src/core/sources/binanceClient.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchJson: () => (/* binding */ fetchJson)\n/* harmony export */ });\n// src/core/sources/binanceClient.ts\n// Lightweight helper for Binance public REST calls used across the pipeline.\nconst DEFAULT_BASE = process.env.BINANCE_BASE_URL?.trim() || \"https://api.binance.com\";\nfunction buildUrl(path, query) {\n    const url = path.startsWith(\"http\") ? new URL(path) : new URL(path, DEFAULT_BASE);\n    if (query) {\n        for (const [key, value] of Object.entries(query)){\n            if (value === undefined || value === null) continue;\n            url.searchParams.set(key, String(value));\n        }\n    }\n    return url;\n}\nasync function fetchJson(path, query, init) {\n    const url = buildUrl(path, query);\n    const response = await fetch(url.toString(), {\n        method: \"GET\",\n        headers: {\n            Accept: \"application/json\",\n            ...init?.headers ?? {}\n        },\n        ...init\n    });\n    if (!response.ok) {\n        const text = await response.text().catch(()=>\"<no-body>\");\n        throw new Error(`binance ${url.pathname} -> ${response.status} ${text}`);\n    }\n    return await response.json();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9zb3VyY2VzL2JpbmFuY2VDbGllbnQudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG9DQUFvQztBQUNwQyw2RUFBNkU7QUFFN0UsTUFBTUEsZUFBZUMsUUFBUUMsR0FBRyxDQUFDQyxnQkFBZ0IsRUFBRUMsVUFBVTtBQUU3RCxTQUFTQyxTQUFTQyxJQUFZLEVBQUVDLEtBQW1EO0lBQ2pGLE1BQU1DLE1BQU1GLEtBQUtHLFVBQVUsQ0FBQyxVQUFVLElBQUlDLElBQUlKLFFBQVEsSUFBSUksSUFBSUosTUFBTU47SUFDcEUsSUFBSU8sT0FBTztRQUNULEtBQUssTUFBTSxDQUFDSSxLQUFLQyxNQUFNLElBQUlDLE9BQU9DLE9BQU8sQ0FBQ1AsT0FBUTtZQUNoRCxJQUFJSyxVQUFVRyxhQUFhSCxVQUFVLE1BQU07WUFDM0NKLElBQUlRLFlBQVksQ0FBQ0MsR0FBRyxDQUFDTixLQUFLTyxPQUFPTjtRQUNuQztJQUNGO0lBQ0EsT0FBT0o7QUFDVDtBQUVPLGVBQWVXLFVBQ3BCYixJQUFZLEVBQ1pDLEtBQW1ELEVBQ25EYSxJQUFrQjtJQUVsQixNQUFNWixNQUFNSCxTQUFTQyxNQUFNQztJQUMzQixNQUFNYyxXQUFXLE1BQU1DLE1BQU1kLElBQUllLFFBQVEsSUFBSTtRQUMzQ0MsUUFBUTtRQUNSQyxTQUFTO1lBQUVDLFFBQVE7WUFBb0IsR0FBSU4sTUFBTUssV0FBVyxDQUFDLENBQUM7UUFBRTtRQUNoRSxHQUFHTCxJQUFJO0lBQ1Q7SUFFQSxJQUFJLENBQUNDLFNBQVNNLEVBQUUsRUFBRTtRQUNoQixNQUFNQyxPQUFPLE1BQU1QLFNBQVNPLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU07UUFDL0MsTUFBTSxJQUFJQyxNQUFNLENBQUMsUUFBUSxFQUFFdEIsSUFBSXVCLFFBQVEsQ0FBQyxJQUFJLEVBQUVWLFNBQVNXLE1BQU0sQ0FBQyxDQUFDLEVBQUVKLE1BQU07SUFDekU7SUFFQSxPQUFRLE1BQU1QLFNBQVNZLElBQUk7QUFDN0IiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxjb3JlXFxzb3VyY2VzXFxiaW5hbmNlQ2xpZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb3JlL3NvdXJjZXMvYmluYW5jZUNsaWVudC50c1xuLy8gTGlnaHR3ZWlnaHQgaGVscGVyIGZvciBCaW5hbmNlIHB1YmxpYyBSRVNUIGNhbGxzIHVzZWQgYWNyb3NzIHRoZSBwaXBlbGluZS5cblxuY29uc3QgREVGQVVMVF9CQVNFID0gcHJvY2Vzcy5lbnYuQklOQU5DRV9CQVNFX1VSTD8udHJpbSgpIHx8IFwiaHR0cHM6Ly9hcGkuYmluYW5jZS5jb21cIjtcblxuZnVuY3Rpb24gYnVpbGRVcmwocGF0aDogc3RyaW5nLCBxdWVyeT86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IHVuZGVmaW5lZD4pIHtcbiAgY29uc3QgdXJsID0gcGF0aC5zdGFydHNXaXRoKFwiaHR0cFwiKSA/IG5ldyBVUkwocGF0aCkgOiBuZXcgVVJMKHBhdGgsIERFRkFVTFRfQkFTRSk7XG4gIGlmIChxdWVyeSkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5KSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCBTdHJpbmcodmFsdWUpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoSnNvbjxUID0gdW5rbm93bj4oXG4gIHBhdGg6IHN0cmluZyxcbiAgcXVlcnk/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCB1bmRlZmluZWQ+LFxuICBpbml0PzogUmVxdWVzdEluaXQsXG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgdXJsID0gYnVpbGRVcmwocGF0aCwgcXVlcnkpO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnM6IHsgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiwgLi4uKGluaXQ/LmhlYWRlcnMgPz8ge30pIH0sXG4gICAgLi4uaW5pdCxcbiAgfSk7XG5cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkuY2F0Y2goKCkgPT4gXCI8bm8tYm9keT5cIik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBiaW5hbmNlICR7dXJsLnBhdGhuYW1lfSAtPiAke3Jlc3BvbnNlLnN0YXR1c30gJHt0ZXh0fWApO1xuICB9XG5cbiAgcmV0dXJuIChhd2FpdCByZXNwb25zZS5qc29uKCkpIGFzIFQ7XG59XHJcbiJdLCJuYW1lcyI6WyJERUZBVUxUX0JBU0UiLCJwcm9jZXNzIiwiZW52IiwiQklOQU5DRV9CQVNFX1VSTCIsInRyaW0iLCJidWlsZFVybCIsInBhdGgiLCJxdWVyeSIsInVybCIsInN0YXJ0c1dpdGgiLCJVUkwiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJ1bmRlZmluZWQiLCJzZWFyY2hQYXJhbXMiLCJzZXQiLCJTdHJpbmciLCJmZXRjaEpzb24iLCJpbml0IiwicmVzcG9uc2UiLCJmZXRjaCIsInRvU3RyaW5nIiwibWV0aG9kIiwiaGVhZGVycyIsIkFjY2VwdCIsIm9rIiwidGV4dCIsImNhdGNoIiwiRXJyb3IiLCJwYXRobmFtZSIsInN0YXR1cyIsImpzb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/core/sources/binanceClient.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/sources/pairs.ts":
/*!***********************************!*\
  !*** ./src/core/sources/pairs.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildValidPairsFromCoins: () => (/* binding */ buildValidPairsFromCoins),\n/* harmony export */   fetchTradableSymbols: () => (/* binding */ fetchTradableSymbols),\n/* harmony export */   parseSymbol: () => (/* binding */ parseSymbol),\n/* harmony export */   validatePair: () => (/* binding */ validatePair)\n/* harmony export */ });\n/* harmony import */ var _core_sources_binanceClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/sources/binanceClient */ \"(rsc)/./src/core/sources/binanceClient.ts\");\n// src/core/sources/pairs.ts\n// Discover & validate Binance trading pairs for a given coin universe.\n// Uses public /api/v3/exchangeInfo endpoint (no API key).\n\n// light in-memory cache (to keep network low for UIs switching panels)\nlet symbolCacheAt = 0;\nlet cachedSymbols = null;\nconst SYMBOL_TTL_MS = 60000; // 60s\nasync function fetchTradableSymbols() {\n    const now = Date.now();\n    if (cachedSymbols && now - symbolCacheAt < SYMBOL_TTL_MS) {\n        return cachedSymbols.filter((s)=>s.status === \"TRADING\");\n    }\n    const info = await (0,_core_sources_binanceClient__WEBPACK_IMPORTED_MODULE_0__.fetchJson)(\"/api/v3/exchangeInfo\");\n    const list = Array.isArray(info.symbols) ? info.symbols : [];\n    cachedSymbols = list.map((entry)=>({\n            symbol: String(entry.symbol ?? \"\"),\n            base: String(entry.baseAsset ?? \"\"),\n            quote: String(entry.quoteAsset ?? \"\"),\n            status: String(entry.status ?? \"\")\n        }));\n    symbolCacheAt = now;\n    return cachedSymbols.filter((s)=>s.status === \"TRADING\");\n}\n/** From a coin list, build all directionally valid pairs that Binance lists. */ async function buildValidPairsFromCoins(coins) {\n    const tradables = await fetchTradableSymbols();\n    const map = new Map();\n    for (const s of tradables)map.set(`${s.base}|${s.quote}`, s);\n    const seen = new Set();\n    const out = [];\n    for (const base of coins){\n        for (const quote of coins){\n            if (!base || !quote || base === quote) continue;\n            const key = `${base.toUpperCase()}|${quote.toUpperCase()}`;\n            const hit = map.get(key);\n            if (hit && !seen.has(hit.symbol)) {\n                seen.add(hit.symbol);\n                out.push({\n                    symbol: hit.symbol,\n                    base: hit.base,\n                    quote: hit.quote\n                });\n            }\n        }\n    }\n    return out;\n}\n/** Validate a requested base/quote; returns the Binance symbol or null. */ async function validatePair(base, quote) {\n    const tradables = await fetchTradableSymbols();\n    const found = tradables.find((s)=>s.base.toUpperCase() === base.toUpperCase() && s.quote.toUpperCase() === quote.toUpperCase());\n    return found ? found.symbol : null;\n}\n/** Validate a requested symbol (e.g., \"ETHBTC\"); returns {base, quote} or null. */ async function parseSymbol(symbol) {\n    const tradables = await fetchTradableSymbols();\n    const normalized = String(symbol || \"\").toUpperCase();\n    const hit = tradables.find((s)=>s.symbol.toUpperCase() === normalized);\n    return hit ? {\n        base: hit.base,\n        quote: hit.quote\n    } : null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBT1U7SUFDN0QsT0FBT1QsTUFBTTtRQUFFZCxNQUFNYyxJQUFJZCxJQUFJO1FBQUVFLE9BQU9ZLElBQUlaLEtBQUs7SUFBQyxJQUFJO0FBQ3REIiwic291cmNlcyI6WyJIOlxcVXNlcnNcXEd1c1xcc291cmNlXFxyZXBvXFxkeW5hbWljc1xcZHluYW1pY3MtYlxcY3J5cHRvcGktZHluYW1pY3NcXHNyY1xcY29yZVxcc291cmNlc1xccGFpcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvcmUvc291cmNlcy9wYWlycy50c1xyXG4vLyBEaXNjb3ZlciAmIHZhbGlkYXRlIEJpbmFuY2UgdHJhZGluZyBwYWlycyBmb3IgYSBnaXZlbiBjb2luIHVuaXZlcnNlLlxyXG4vLyBVc2VzIHB1YmxpYyAvYXBpL3YzL2V4Y2hhbmdlSW5mbyBlbmRwb2ludCAobm8gQVBJIGtleSkuXHJcblxyXG5pbXBvcnQgeyBmZXRjaEpzb24gfSBmcm9tIFwiQC9jb3JlL3NvdXJjZXMvYmluYW5jZUNsaWVudFwiO1xyXG5cclxudHlwZSBFeGNoYW5nZUluZm9TeW1ib2wgPSB7XHJcbiAgc3ltYm9sPzogc3RyaW5nO1xyXG4gIGJhc2VBc3NldD86IHN0cmluZztcclxuICBxdW90ZUFzc2V0Pzogc3RyaW5nO1xyXG4gIHN0YXR1cz86IHN0cmluZztcclxufTtcclxuXHJcbnR5cGUgRXhjaGFuZ2VJbmZvUmVzcG9uc2UgPSB7XHJcbiAgc3ltYm9scz86IEV4Y2hhbmdlSW5mb1N5bWJvbFtdO1xyXG59O1xyXG5cclxuLy8gbGlnaHQgaW4tbWVtb3J5IGNhY2hlICh0byBrZWVwIG5ldHdvcmsgbG93IGZvciBVSXMgc3dpdGNoaW5nIHBhbmVscylcclxubGV0IHN5bWJvbENhY2hlQXQgPSAwO1xyXG5sZXQgY2FjaGVkU3ltYm9sczogQXJyYXk8eyBzeW1ib2w6IHN0cmluZzsgYmFzZTogc3RyaW5nOyBxdW90ZTogc3RyaW5nOyBzdGF0dXM6IHN0cmluZyB9PiB8IG51bGwgPSBudWxsO1xyXG5jb25zdCBTWU1CT0xfVFRMX01TID0gNjBfMDAwOyAvLyA2MHNcclxuXHJcbmV4cG9ydCB0eXBlIFRyYWRhYmxlU3ltYm9sID0geyBzeW1ib2w6IHN0cmluZzsgYmFzZTogc3RyaW5nOyBxdW90ZTogc3RyaW5nIH07XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hUcmFkYWJsZVN5bWJvbHMoKTogUHJvbWlzZTxUcmFkYWJsZVN5bWJvbFtdPiB7XHJcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICBpZiAoY2FjaGVkU3ltYm9scyAmJiBub3cgLSBzeW1ib2xDYWNoZUF0IDwgU1lNQk9MX1RUTF9NUykge1xyXG4gICAgcmV0dXJuIGNhY2hlZFN5bWJvbHMuZmlsdGVyKChzKSA9PiBzLnN0YXR1cyA9PT0gXCJUUkFESU5HXCIpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaW5mbyA9IGF3YWl0IGZldGNoSnNvbjxFeGNoYW5nZUluZm9SZXNwb25zZT4oXCIvYXBpL3YzL2V4Y2hhbmdlSW5mb1wiKTtcclxuICBjb25zdCBsaXN0ID0gQXJyYXkuaXNBcnJheShpbmZvLnN5bWJvbHMpID8gaW5mby5zeW1ib2xzIDogW107XHJcbiAgY2FjaGVkU3ltYm9scyA9IGxpc3QubWFwKChlbnRyeSkgPT4gKHtcclxuICAgIHN5bWJvbDogU3RyaW5nKGVudHJ5LnN5bWJvbCA/PyBcIlwiKSxcclxuICAgIGJhc2U6IFN0cmluZyhlbnRyeS5iYXNlQXNzZXQgPz8gXCJcIiksXHJcbiAgICBxdW90ZTogU3RyaW5nKGVudHJ5LnF1b3RlQXNzZXQgPz8gXCJcIiksXHJcbiAgICBzdGF0dXM6IFN0cmluZyhlbnRyeS5zdGF0dXMgPz8gXCJcIiksXHJcbiAgfSkpO1xyXG4gIHN5bWJvbENhY2hlQXQgPSBub3c7XHJcbiAgcmV0dXJuIGNhY2hlZFN5bWJvbHMuZmlsdGVyKChzKSA9PiBzLnN0YXR1cyA9PT0gXCJUUkFESU5HXCIpO1xyXG59XHJcblxyXG4vKiogRnJvbSBhIGNvaW4gbGlzdCwgYnVpbGQgYWxsIGRpcmVjdGlvbmFsbHkgdmFsaWQgcGFpcnMgdGhhdCBCaW5hbmNlIGxpc3RzLiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYnVpbGRWYWxpZFBhaXJzRnJvbUNvaW5zKGNvaW5zOiBzdHJpbmdbXSk6IFByb21pc2U8VHJhZGFibGVTeW1ib2xbXT4ge1xyXG4gIGNvbnN0IHRyYWRhYmxlcyA9IGF3YWl0IGZldGNoVHJhZGFibGVTeW1ib2xzKCk7XHJcbiAgY29uc3QgbWFwID0gbmV3IE1hcDxzdHJpbmcsIFRyYWRhYmxlU3ltYm9sPigpO1xyXG4gIGZvciAoY29uc3QgcyBvZiB0cmFkYWJsZXMpIG1hcC5zZXQoYCR7cy5iYXNlfXwke3MucXVvdGV9YCwgcyk7XHJcblxyXG4gIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICBjb25zdCBvdXQ6IFRyYWRhYmxlU3ltYm9sW10gPSBbXTtcclxuICBmb3IgKGNvbnN0IGJhc2Ugb2YgY29pbnMpIHtcclxuICAgIGZvciAoY29uc3QgcXVvdGUgb2YgY29pbnMpIHtcclxuICAgICAgaWYgKCFiYXNlIHx8ICFxdW90ZSB8fCBiYXNlID09PSBxdW90ZSkgY29udGludWU7XHJcbiAgICAgIGNvbnN0IGtleSA9IGAke2Jhc2UudG9VcHBlckNhc2UoKX18JHtxdW90ZS50b1VwcGVyQ2FzZSgpfWA7XHJcbiAgICAgIGNvbnN0IGhpdCA9IG1hcC5nZXQoa2V5KTtcclxuICAgICAgaWYgKGhpdCAmJiAhc2Vlbi5oYXMoaGl0LnN5bWJvbCkpIHtcclxuICAgICAgICBzZWVuLmFkZChoaXQuc3ltYm9sKTtcclxuICAgICAgICBvdXQucHVzaCh7IHN5bWJvbDogaGl0LnN5bWJvbCwgYmFzZTogaGl0LmJhc2UsIHF1b3RlOiBoaXQucXVvdGUgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG91dDtcclxufVxyXG5cclxuLyoqIFZhbGlkYXRlIGEgcmVxdWVzdGVkIGJhc2UvcXVvdGU7IHJldHVybnMgdGhlIEJpbmFuY2Ugc3ltYm9sIG9yIG51bGwuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVBhaXIoYmFzZTogc3RyaW5nLCBxdW90ZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XHJcbiAgY29uc3QgdHJhZGFibGVzID0gYXdhaXQgZmV0Y2hUcmFkYWJsZVN5bWJvbHMoKTtcclxuICBjb25zdCBmb3VuZCA9IHRyYWRhYmxlcy5maW5kKFxyXG4gICAgKHMpID0+IHMuYmFzZS50b1VwcGVyQ2FzZSgpID09PSBiYXNlLnRvVXBwZXJDYXNlKCkgJiYgcy5xdW90ZS50b1VwcGVyQ2FzZSgpID09PSBxdW90ZS50b1VwcGVyQ2FzZSgpXHJcbiAgKTtcclxuICByZXR1cm4gZm91bmQgPyBmb3VuZC5zeW1ib2wgOiBudWxsO1xyXG59XHJcblxyXG4vKiogVmFsaWRhdGUgYSByZXF1ZXN0ZWQgc3ltYm9sIChlLmcuLCBcIkVUSEJUQ1wiKTsgcmV0dXJucyB7YmFzZSwgcXVvdGV9IG9yIG51bGwuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZVN5bWJvbChzeW1ib2w6IHN0cmluZyk6IFByb21pc2U8eyBiYXNlOiBzdHJpbmc7IHF1b3RlOiBzdHJpbmcgfSB8IG51bGw+IHtcclxuICBjb25zdCB0cmFkYWJsZXMgPSBhd2FpdCBmZXRjaFRyYWRhYmxlU3ltYm9scygpO1xyXG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBTdHJpbmcoc3ltYm9sIHx8IFwiXCIpLnRvVXBwZXJDYXNlKCk7XHJcbiAgY29uc3QgaGl0ID0gdHJhZGFibGVzLmZpbmQoKHMpID0+IHMuc3ltYm9sLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWQpO1xyXG4gIHJldHVybiBoaXQgPyB7IGJhc2U6IGhpdC5iYXNlLCBxdW90ZTogaGl0LnF1b3RlIH0gOiBudWxsO1xyXG59XHJcblxyXG4iXSwibmFtZXMiOlsiZmV0Y2hKc29uIiwic3ltYm9sQ2FjaGVBdCIsImNhY2hlZFN5bWJvbHMiLCJTWU1CT0xfVFRMX01TIiwiZmV0Y2hUcmFkYWJsZVN5bWJvbHMiLCJub3ciLCJEYXRlIiwiZmlsdGVyIiwicyIsInN0YXR1cyIsImluZm8iLCJsaXN0IiwiQXJyYXkiLCJpc0FycmF5Iiwic3ltYm9scyIsIm1hcCIsImVudHJ5Iiwic3ltYm9sIiwiU3RyaW5nIiwiYmFzZSIsImJhc2VBc3NldCIsInF1b3RlIiwicXVvdGVBc3NldCIsImJ1aWxkVmFsaWRQYWlyc0Zyb21Db2lucyIsImNvaW5zIiwidHJhZGFibGVzIiwiTWFwIiwic2V0Iiwic2VlbiIsIlNldCIsIm91dCIsImtleSIsInRvVXBwZXJDYXNlIiwiaGl0IiwiZ2V0IiwiaGFzIiwiYWRkIiwicHVzaCIsInZhbGlkYXRlUGFpciIsImZvdW5kIiwiZmluZCIsInBhcnNlU3ltYm9sIiwibm9ybWFsaXplZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/core/sources/pairs.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/markets/availability.ts":
/*!*****************************************!*\
  !*** ./src/lib/markets/availability.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   maskUnavailableMatrix: () => (/* binding */ maskUnavailableMatrix),\n/* harmony export */   resolvePairAvailability: () => (/* binding */ resolvePairAvailability)\n/* harmony export */ });\n/* harmony import */ var _core_sources_pairs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/sources/pairs */ \"(rsc)/./src/core/sources/pairs.ts\");\n// src/lib/markets/availability.ts\n// Resolve tradable symbol availability and helper utilities to align UI matrices.\n\nconst normalizeCoins = (coins)=>{\n    const out = [];\n    const seen = new Set();\n    for (const coin of coins ?? []){\n        const normalized = String(coin ?? \"\").trim().toUpperCase();\n        if (!normalized || seen.has(normalized)) continue;\n        seen.add(normalized);\n        out.push(normalized);\n    }\n    return out;\n};\nasync function resolvePairAvailability(coins) {\n    const normalized = normalizeCoins(coins);\n    if (!normalized.length) {\n        return {\n            pairs: [],\n            symbols: [],\n            set: new Set()\n        };\n    }\n    const pairs = await (0,_core_sources_pairs__WEBPACK_IMPORTED_MODULE_0__.buildValidPairsFromCoins)(normalized);\n    const symbols = pairs.map((entry)=>String(entry.symbol ?? \"\").toUpperCase());\n    const set = new Set(symbols);\n    return {\n        pairs,\n        symbols,\n        set\n    };\n}\nconst upper = (value)=>String(value ?? \"\").toUpperCase();\nfunction maskUnavailableMatrix(matrix, allowed, replacement = null) {\n    if (!matrix || !allowed.size) return;\n    for (const [baseKey, row] of Object.entries(matrix)){\n        if (!row || typeof row !== \"object\") continue;\n        const base = upper(baseKey);\n        for (const quoteKey of Object.keys(row)){\n            const quote = upper(quoteKey);\n            if (base === quote) continue;\n            const symbol = `${base}${quote}`;\n            if (!allowed.has(symbol)) {\n                row[quoteKey] = replacement;\n            }\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL21hcmtldHMvYXZhaWxhYmlsaXR5LnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGtDQUFrQztBQUNsQyxrRkFBa0Y7QUFFRztBQUVyRixNQUFNQyxpQkFBaUIsQ0FBQ0M7SUFDdEIsTUFBTUMsTUFBZ0IsRUFBRTtJQUN4QixNQUFNQyxPQUFPLElBQUlDO0lBQ2pCLEtBQUssTUFBTUMsUUFBUUosU0FBUyxFQUFFLENBQUU7UUFDOUIsTUFBTUssYUFBYUMsT0FBT0YsUUFBUSxJQUFJRyxJQUFJLEdBQUdDLFdBQVc7UUFDeEQsSUFBSSxDQUFDSCxjQUFjSCxLQUFLTyxHQUFHLENBQUNKLGFBQWE7UUFDekNILEtBQUtRLEdBQUcsQ0FBQ0w7UUFDVEosSUFBSVUsSUFBSSxDQUFDTjtJQUNYO0lBQ0EsT0FBT0o7QUFDVDtBQVFPLGVBQWVXLHdCQUNwQlosS0FBd0I7SUFFeEIsTUFBTUssYUFBYU4sZUFBZUM7SUFDbEMsSUFBSSxDQUFDSyxXQUFXUSxNQUFNLEVBQUU7UUFDdEIsT0FBTztZQUFFQyxPQUFPLEVBQUU7WUFBRUMsU0FBUyxFQUFFO1lBQUVDLEtBQUssSUFBSWI7UUFBYztJQUMxRDtJQUVBLE1BQU1XLFFBQVEsTUFBTWhCLDZFQUF3QkEsQ0FBQ087SUFDN0MsTUFBTVUsVUFBVUQsTUFBTUcsR0FBRyxDQUFDLENBQUNDLFFBQVVaLE9BQU9ZLE1BQU1DLE1BQU0sSUFBSSxJQUFJWCxXQUFXO0lBQzNFLE1BQU1RLE1BQU0sSUFBSWIsSUFBSVk7SUFDcEIsT0FBTztRQUFFRDtRQUFPQztRQUFTQztJQUFJO0FBQy9CO0FBRUEsTUFBTUksUUFBUSxDQUFDQyxRQUFrQmYsT0FBT2UsU0FBUyxJQUFJYixXQUFXO0FBRXpELFNBQVNjLHNCQUNkQyxNQUEyRCxFQUMzREMsT0FBb0IsRUFDcEJDLGNBQXVCLElBQUk7SUFFM0IsSUFBSSxDQUFDRixVQUFVLENBQUNDLFFBQVFFLElBQUksRUFBRTtJQUU5QixLQUFLLE1BQU0sQ0FBQ0MsU0FBU0MsSUFBSSxJQUFJQyxPQUFPQyxPQUFPLENBQUNQLFFBQVM7UUFDbkQsSUFBSSxDQUFDSyxPQUFPLE9BQU9BLFFBQVEsVUFBVTtRQUNyQyxNQUFNRyxPQUFPWCxNQUFNTztRQUNuQixLQUFLLE1BQU1LLFlBQVlILE9BQU9JLElBQUksQ0FBQ0wsS0FBTTtZQUN2QyxNQUFNTSxRQUFRZCxNQUFNWTtZQUNwQixJQUFJRCxTQUFTRyxPQUFPO1lBQ3BCLE1BQU1mLFNBQVMsR0FBR1ksT0FBT0csT0FBTztZQUNoQyxJQUFJLENBQUNWLFFBQVFmLEdBQUcsQ0FBQ1UsU0FBUztnQkFDdkJTLEdBQStCLENBQUNJLFNBQVMsR0FBR1A7WUFDL0M7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxsaWJcXG1hcmtldHNcXGF2YWlsYWJpbGl0eS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbGliL21hcmtldHMvYXZhaWxhYmlsaXR5LnRzXG4vLyBSZXNvbHZlIHRyYWRhYmxlIHN5bWJvbCBhdmFpbGFiaWxpdHkgYW5kIGhlbHBlciB1dGlsaXRpZXMgdG8gYWxpZ24gVUkgbWF0cmljZXMuXG5cbmltcG9ydCB7IGJ1aWxkVmFsaWRQYWlyc0Zyb21Db2lucywgdHlwZSBUcmFkYWJsZVN5bWJvbCB9IGZyb20gXCJAL2NvcmUvc291cmNlcy9wYWlyc1wiO1xuXG5jb25zdCBub3JtYWxpemVDb2lucyA9IChjb2luczogcmVhZG9ubHkgc3RyaW5nW10pOiBzdHJpbmdbXSA9PiB7XG4gIGNvbnN0IG91dDogc3RyaW5nW10gPSBbXTtcbiAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnMgPz8gW10pIHtcbiAgICBjb25zdCBub3JtYWxpemVkID0gU3RyaW5nKGNvaW4gPz8gXCJcIikudHJpbSgpLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKCFub3JtYWxpemVkIHx8IHNlZW4uaGFzKG5vcm1hbGl6ZWQpKSBjb250aW51ZTtcbiAgICBzZWVuLmFkZChub3JtYWxpemVkKTtcbiAgICBvdXQucHVzaChub3JtYWxpemVkKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuZXhwb3J0IHR5cGUgUGFpckF2YWlsYWJpbGl0eVNuYXBzaG90ID0ge1xuICBwYWlyczogVHJhZGFibGVTeW1ib2xbXTtcbiAgc3ltYm9sczogc3RyaW5nW107XG4gIHNldDogU2V0PHN0cmluZz47XG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVBhaXJBdmFpbGFiaWxpdHkoXG4gIGNvaW5zOiByZWFkb25seSBzdHJpbmdbXVxuKTogUHJvbWlzZTxQYWlyQXZhaWxhYmlsaXR5U25hcHNob3Q+IHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNvaW5zKGNvaW5zKTtcbiAgaWYgKCFub3JtYWxpemVkLmxlbmd0aCkge1xuICAgIHJldHVybiB7IHBhaXJzOiBbXSwgc3ltYm9sczogW10sIHNldDogbmV3IFNldDxzdHJpbmc+KCkgfTtcbiAgfVxuXG4gIGNvbnN0IHBhaXJzID0gYXdhaXQgYnVpbGRWYWxpZFBhaXJzRnJvbUNvaW5zKG5vcm1hbGl6ZWQpO1xuICBjb25zdCBzeW1ib2xzID0gcGFpcnMubWFwKChlbnRyeSkgPT4gU3RyaW5nKGVudHJ5LnN5bWJvbCA/PyBcIlwiKS50b1VwcGVyQ2FzZSgpKTtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldChzeW1ib2xzKTtcbiAgcmV0dXJuIHsgcGFpcnMsIHN5bWJvbHMsIHNldCB9O1xufVxuXG5jb25zdCB1cHBlciA9ICh2YWx1ZTogc3RyaW5nKSA9PiBTdHJpbmcodmFsdWUgPz8gXCJcIikudG9VcHBlckNhc2UoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1hc2tVbmF2YWlsYWJsZU1hdHJpeChcbiAgbWF0cml4OiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4gfCB1bmRlZmluZWQsXG4gIGFsbG93ZWQ6IFNldDxzdHJpbmc+LFxuICByZXBsYWNlbWVudDogdW5rbm93biA9IG51bGxcbikge1xuICBpZiAoIW1hdHJpeCB8fCAhYWxsb3dlZC5zaXplKSByZXR1cm47XG5cbiAgZm9yIChjb25zdCBbYmFzZUtleSwgcm93XSBvZiBPYmplY3QuZW50cmllcyhtYXRyaXgpKSB7XG4gICAgaWYgKCFyb3cgfHwgdHlwZW9mIHJvdyAhPT0gXCJvYmplY3RcIikgY29udGludWU7XG4gICAgY29uc3QgYmFzZSA9IHVwcGVyKGJhc2VLZXkpO1xuICAgIGZvciAoY29uc3QgcXVvdGVLZXkgb2YgT2JqZWN0LmtleXMocm93KSkge1xuICAgICAgY29uc3QgcXVvdGUgPSB1cHBlcihxdW90ZUtleSk7XG4gICAgICBpZiAoYmFzZSA9PT0gcXVvdGUpIGNvbnRpbnVlO1xuICAgICAgY29uc3Qgc3ltYm9sID0gYCR7YmFzZX0ke3F1b3RlfWA7XG4gICAgICBpZiAoIWFsbG93ZWQuaGFzKHN5bWJvbCkpIHtcbiAgICAgICAgKHJvdyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilbcXVvdGVLZXldID0gcmVwbGFjZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbiJdLCJuYW1lcyI6WyJidWlsZFZhbGlkUGFpcnNGcm9tQ29pbnMiLCJub3JtYWxpemVDb2lucyIsImNvaW5zIiwib3V0Iiwic2VlbiIsIlNldCIsImNvaW4iLCJub3JtYWxpemVkIiwiU3RyaW5nIiwidHJpbSIsInRvVXBwZXJDYXNlIiwiaGFzIiwiYWRkIiwicHVzaCIsInJlc29sdmVQYWlyQXZhaWxhYmlsaXR5IiwibGVuZ3RoIiwicGFpcnMiLCJzeW1ib2xzIiwic2V0IiwibWFwIiwiZW50cnkiLCJzeW1ib2wiLCJ1cHBlciIsInZhbHVlIiwibWFza1VuYXZhaWxhYmxlTWF0cml4IiwibWF0cml4IiwiYWxsb3dlZCIsInJlcGxhY2VtZW50Iiwic2l6ZSIsImJhc2VLZXkiLCJyb3ciLCJPYmplY3QiLCJlbnRyaWVzIiwiYmFzZSIsInF1b3RlS2V5Iiwia2V5cyIsInF1b3RlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/markets/availability.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/markets/pairs.ts":
/*!**********************************!*\
  !*** ./src/lib/markets/pairs.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crossPairsFromCoins: () => (/* binding */ crossPairsFromCoins),\n/* harmony export */   dedupeCoins: () => (/* binding */ dedupeCoins),\n/* harmony export */   normalizeCoin: () => (/* binding */ normalizeCoin),\n/* harmony export */   pairsFromSettings: () => (/* binding */ pairsFromSettings),\n/* harmony export */   usdtLegsFromCoins: () => (/* binding */ usdtLegsFromCoins)\n/* harmony export */ });\n// src/lib/markets/pairs.ts\n// Shared, deterministic pair helpers used by both UI and API.\nconst QUOTE_SUFFIXES = [\n    \"USDT\",\n    \"USDC\",\n    \"FDUSD\",\n    \"TUSD\",\n    \"BUSD\"\n];\n/**\n * Normalizes a token symbol:\n * - Uppercase\n * - Remove non A-Z characters\n * - Strip known quote suffixes so cross combos never double-append quotes\n */ const normalizeCoin = (c)=>{\n    const upper = String(c || \"\").toUpperCase().replace(/[^A-Z]/g, \"\");\n    if (!upper) return \"\";\n    for (const suffix of QUOTE_SUFFIXES){\n        if (upper === suffix) return upper;\n        if (upper.endsWith(suffix) && upper.length > suffix.length) {\n            return upper.slice(0, -suffix.length);\n        }\n    }\n    return upper;\n};\nfunction dedupeCoins(bases) {\n    return Array.from(new Set((bases ?? []).map(normalizeCoin))).filter(Boolean);\n}\nfunction usdtLegsFromCoins(bases) {\n    const uniq = dedupeCoins(bases).filter((c)=>c && c !== \"USDT\");\n    return uniq.map((b)=>`${b}USDT`);\n}\n// Ordered permutations A->B (A !== B). No verification here.\nfunction crossPairsFromCoins(bases) {\n    const coins = dedupeCoins(bases).filter((c)=>c && c !== \"USDT\");\n    const out = [];\n    for(let i = 0; i < coins.length; i++){\n        for(let j = 0; j < coins.length; j++){\n            if (i === j) continue;\n            out.push(`${coins[i]}${coins[j]}`);\n        }\n    }\n    return out;\n}\n/**\n * Async builder with optional preview verification.\n * - If `verify` is provided, we filter USDT + cross by it.\n * - If not, we return only USDT legs (no synthetic crosses on the client).\n */ async function pairsFromSettings(bases, opts) {\n    const preferVerifiedUsdt = opts?.preferVerifiedUsdt ?? true;\n    const usdtCand = usdtLegsFromCoins(bases);\n    const crossCand = crossPairsFromCoins(bases);\n    if (!opts?.verify) {\n        return {\n            usdt: usdtCand,\n            cross: [],\n            all: usdtCand.slice()\n        };\n    }\n    const verified = await opts.verify([\n        ...usdtCand,\n        ...crossCand\n    ]);\n    const has = (s)=>verified.has(s.toUpperCase());\n    const usdt = verified.size && preferVerifiedUsdt ? usdtCand.filter(has) : usdtCand;\n    const cross = crossCand.filter(has);\n    const all = Array.from(new Set([\n        ...usdt,\n        ...cross\n    ]));\n    return {\n        usdt,\n        cross,\n        all\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL21hcmtldHMvcGFpcnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSwyQkFBMkI7QUFDM0IsOERBQThEO0FBSTlELE1BQU1BLGlCQUFpQjtJQUFDO0lBQVE7SUFBUTtJQUFTO0lBQVE7Q0FBTztBQUVoRTs7Ozs7Q0FLQyxHQUNNLE1BQU1DLGdCQUFnQixDQUFDQztJQUM1QixNQUFNQyxRQUFRQyxPQUFPRixLQUFLLElBQUlHLFdBQVcsR0FBR0MsT0FBTyxDQUFDLFdBQVc7SUFDL0QsSUFBSSxDQUFDSCxPQUFPLE9BQU87SUFDbkIsS0FBSyxNQUFNSSxVQUFVUCxlQUFnQjtRQUNuQyxJQUFJRyxVQUFVSSxRQUFRLE9BQU9KO1FBQzdCLElBQUlBLE1BQU1LLFFBQVEsQ0FBQ0QsV0FBV0osTUFBTU0sTUFBTSxHQUFHRixPQUFPRSxNQUFNLEVBQUU7WUFDMUQsT0FBT04sTUFBTU8sS0FBSyxDQUFDLEdBQUcsQ0FBQ0gsT0FBT0UsTUFBTTtRQUN0QztJQUNGO0lBQ0EsT0FBT047QUFDVCxFQUFFO0FBRUssU0FBU1EsWUFBWUMsS0FBZTtJQUN6QyxPQUFPQyxNQUFNQyxJQUFJLENBQUMsSUFBSUMsSUFBSSxDQUFDSCxTQUFTLEVBQUUsRUFBRUksR0FBRyxDQUFDZixpQkFBaUJnQixNQUFNLENBQUNDO0FBQ3RFO0FBRU8sU0FBU0Msa0JBQWtCUCxLQUFlO0lBQy9DLE1BQU1RLE9BQU9ULFlBQVlDLE9BQU9LLE1BQU0sQ0FBQyxDQUFDZixJQUFNQSxLQUFLQSxNQUFNO0lBQ3pELE9BQU9rQixLQUFLSixHQUFHLENBQUMsQ0FBQ0ssSUFBTSxHQUFHQSxFQUFFLElBQUksQ0FBQztBQUNuQztBQUVBLDZEQUE2RDtBQUN0RCxTQUFTQyxvQkFBb0JWLEtBQWU7SUFDakQsTUFBTVcsUUFBUVosWUFBWUMsT0FBT0ssTUFBTSxDQUFDLENBQUNmLElBQU1BLEtBQUtBLE1BQU07SUFDMUQsTUFBTXNCLE1BQWdCLEVBQUU7SUFDeEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLE1BQU1kLE1BQU0sRUFBRWdCLElBQUs7UUFDckMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILE1BQU1kLE1BQU0sRUFBRWlCLElBQUs7WUFDckMsSUFBSUQsTUFBTUMsR0FBRztZQUNiRixJQUFJRyxJQUFJLENBQUMsR0FBR0osS0FBSyxDQUFDRSxFQUFFLEdBQUdGLEtBQUssQ0FBQ0csRUFBRSxFQUFFO1FBQ25DO0lBQ0Y7SUFDQSxPQUFPRjtBQUNUO0FBRUE7Ozs7Q0FJQyxHQUNNLGVBQWVJLGtCQUNwQmhCLEtBQWUsRUFDZmlCLElBR0M7SUFFRCxNQUFNQyxxQkFBcUJELE1BQU1DLHNCQUFzQjtJQUV2RCxNQUFNQyxXQUFXWixrQkFBa0JQO0lBQ25DLE1BQU1vQixZQUFZVixvQkFBb0JWO0lBRXRDLElBQUksQ0FBQ2lCLE1BQU1JLFFBQVE7UUFDakIsT0FBTztZQUFFQyxNQUFNSDtZQUFVSSxPQUFPLEVBQUU7WUFBRUMsS0FBS0wsU0FBU3JCLEtBQUs7UUFBRztJQUM1RDtJQUVBLE1BQU0yQixXQUFXLE1BQU1SLEtBQUtJLE1BQU0sQ0FBQztXQUFJRjtXQUFhQztLQUFVO0lBQzlELE1BQU1NLE1BQU0sQ0FBQ0MsSUFBY0YsU0FBU0MsR0FBRyxDQUFDQyxFQUFFbEMsV0FBVztJQUVyRCxNQUFNNkIsT0FDSkcsU0FBU0csSUFBSSxJQUFJVixxQkFBcUJDLFNBQVNkLE1BQU0sQ0FBQ3FCLE9BQU9QO0lBQy9ELE1BQU1JLFFBQVFILFVBQVVmLE1BQU0sQ0FBQ3FCO0lBQy9CLE1BQU1GLE1BQU12QixNQUFNQyxJQUFJLENBQUMsSUFBSUMsSUFBSTtXQUFJbUI7V0FBU0M7S0FBTTtJQUNsRCxPQUFPO1FBQUVEO1FBQU1DO1FBQU9DO0lBQUk7QUFDNUIiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxsaWJcXG1hcmtldHNcXHBhaXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9saWIvbWFya2V0cy9wYWlycy50c1xuLy8gU2hhcmVkLCBkZXRlcm1pbmlzdGljIHBhaXIgaGVscGVycyB1c2VkIGJ5IGJvdGggVUkgYW5kIEFQSS5cblxuZXhwb3J0IHR5cGUgUGFpckF2YWlsYWJpbGl0eSA9IHsgdXNkdDogc3RyaW5nW107IGNyb3NzOiBzdHJpbmdbXTsgYWxsOiBzdHJpbmdbXSB9O1xuXG5jb25zdCBRVU9URV9TVUZGSVhFUyA9IFtcIlVTRFRcIiwgXCJVU0RDXCIsIFwiRkRVU0RcIiwgXCJUVVNEXCIsIFwiQlVTRFwiXSBhcyBjb25zdDtcblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgdG9rZW4gc3ltYm9sOlxuICogLSBVcHBlcmNhc2VcbiAqIC0gUmVtb3ZlIG5vbiBBLVogY2hhcmFjdGVyc1xuICogLSBTdHJpcCBrbm93biBxdW90ZSBzdWZmaXhlcyBzbyBjcm9zcyBjb21ib3MgbmV2ZXIgZG91YmxlLWFwcGVuZCBxdW90ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZUNvaW4gPSAoYzogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgY29uc3QgdXBwZXIgPSBTdHJpbmcoYyB8fCBcIlwiKS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL1teQS1aXS9nLCBcIlwiKTtcbiAgaWYgKCF1cHBlcikgcmV0dXJuIFwiXCI7XG4gIGZvciAoY29uc3Qgc3VmZml4IG9mIFFVT1RFX1NVRkZJWEVTKSB7XG4gICAgaWYgKHVwcGVyID09PSBzdWZmaXgpIHJldHVybiB1cHBlcjtcbiAgICBpZiAodXBwZXIuZW5kc1dpdGgoc3VmZml4KSAmJiB1cHBlci5sZW5ndGggPiBzdWZmaXgubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdXBwZXIuc2xpY2UoMCwgLXN1ZmZpeC5sZW5ndGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdXBwZXI7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVkdXBlQ29pbnMoYmFzZXM6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KChiYXNlcyA/PyBbXSkubWFwKG5vcm1hbGl6ZUNvaW4pKSkuZmlsdGVyKEJvb2xlYW4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNkdExlZ3NGcm9tQ29pbnMoYmFzZXM6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICBjb25zdCB1bmlxID0gZGVkdXBlQ29pbnMoYmFzZXMpLmZpbHRlcigoYykgPT4gYyAmJiBjICE9PSBcIlVTRFRcIik7XG4gIHJldHVybiB1bmlxLm1hcCgoYikgPT4gYCR7Yn1VU0RUYCk7XG59XG5cbi8vIE9yZGVyZWQgcGVybXV0YXRpb25zIEEtPkIgKEEgIT09IEIpLiBObyB2ZXJpZmljYXRpb24gaGVyZS5cbmV4cG9ydCBmdW5jdGlvbiBjcm9zc1BhaXJzRnJvbUNvaW5zKGJhc2VzOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgY29uc3QgY29pbnMgPSBkZWR1cGVDb2lucyhiYXNlcykuZmlsdGVyKChjKSA9PiBjICYmIGMgIT09IFwiVVNEVFwiKTtcbiAgY29uc3Qgb3V0OiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2lucy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGkgPT09IGopIGNvbnRpbnVlO1xuICAgICAgb3V0LnB1c2goYCR7Y29pbnNbaV19JHtjb2luc1tqXX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBc3luYyBidWlsZGVyIHdpdGggb3B0aW9uYWwgcHJldmlldyB2ZXJpZmljYXRpb24uXG4gKiAtIElmIGB2ZXJpZnlgIGlzIHByb3ZpZGVkLCB3ZSBmaWx0ZXIgVVNEVCArIGNyb3NzIGJ5IGl0LlxuICogLSBJZiBub3QsIHdlIHJldHVybiBvbmx5IFVTRFQgbGVncyAobm8gc3ludGhldGljIGNyb3NzZXMgb24gdGhlIGNsaWVudCkuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYWlyc0Zyb21TZXR0aW5ncyhcbiAgYmFzZXM6IHN0cmluZ1tdLFxuICBvcHRzPzoge1xuICAgIHZlcmlmeT86IChzeW1ib2xzOiBzdHJpbmdbXSkgPT4gUHJvbWlzZTxTZXQ8c3RyaW5nPj47XG4gICAgcHJlZmVyVmVyaWZpZWRVc2R0PzogYm9vbGVhbjsgLy8gZGVmYXVsdCB0cnVlXG4gIH1cbik6IFByb21pc2U8UGFpckF2YWlsYWJpbGl0eT4ge1xuICBjb25zdCBwcmVmZXJWZXJpZmllZFVzZHQgPSBvcHRzPy5wcmVmZXJWZXJpZmllZFVzZHQgPz8gdHJ1ZTtcblxuICBjb25zdCB1c2R0Q2FuZCA9IHVzZHRMZWdzRnJvbUNvaW5zKGJhc2VzKTtcbiAgY29uc3QgY3Jvc3NDYW5kID0gY3Jvc3NQYWlyc0Zyb21Db2lucyhiYXNlcyk7XG5cbiAgaWYgKCFvcHRzPy52ZXJpZnkpIHtcbiAgICByZXR1cm4geyB1c2R0OiB1c2R0Q2FuZCwgY3Jvc3M6IFtdLCBhbGw6IHVzZHRDYW5kLnNsaWNlKCkgfTtcbiAgfVxuXG4gIGNvbnN0IHZlcmlmaWVkID0gYXdhaXQgb3B0cy52ZXJpZnkoWy4uLnVzZHRDYW5kLCAuLi5jcm9zc0NhbmRdKTtcbiAgY29uc3QgaGFzID0gKHM6IHN0cmluZykgPT4gdmVyaWZpZWQuaGFzKHMudG9VcHBlckNhc2UoKSk7XG5cbiAgY29uc3QgdXNkdCA9XG4gICAgdmVyaWZpZWQuc2l6ZSAmJiBwcmVmZXJWZXJpZmllZFVzZHQgPyB1c2R0Q2FuZC5maWx0ZXIoaGFzKSA6IHVzZHRDYW5kO1xuICBjb25zdCBjcm9zcyA9IGNyb3NzQ2FuZC5maWx0ZXIoaGFzKTtcbiAgY29uc3QgYWxsID0gQXJyYXkuZnJvbShuZXcgU2V0KFsuLi51c2R0LCAuLi5jcm9zc10pKTtcbiAgcmV0dXJuIHsgdXNkdCwgY3Jvc3MsIGFsbCB9O1xufVxuIl0sIm5hbWVzIjpbIlFVT1RFX1NVRkZJWEVTIiwibm9ybWFsaXplQ29pbiIsImMiLCJ1cHBlciIsIlN0cmluZyIsInRvVXBwZXJDYXNlIiwicmVwbGFjZSIsInN1ZmZpeCIsImVuZHNXaXRoIiwibGVuZ3RoIiwic2xpY2UiLCJkZWR1cGVDb2lucyIsImJhc2VzIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwibWFwIiwiZmlsdGVyIiwiQm9vbGVhbiIsInVzZHRMZWdzRnJvbUNvaW5zIiwidW5pcSIsImIiLCJjcm9zc1BhaXJzRnJvbUNvaW5zIiwiY29pbnMiLCJvdXQiLCJpIiwiaiIsInB1c2giLCJwYWlyc0Zyb21TZXR0aW5ncyIsIm9wdHMiLCJwcmVmZXJWZXJpZmllZFVzZHQiLCJ1c2R0Q2FuZCIsImNyb3NzQ2FuZCIsInZlcmlmeSIsInVzZHQiLCJjcm9zcyIsImFsbCIsInZlcmlmaWVkIiwiaGFzIiwicyIsInNpemUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/markets/pairs.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/mea/mood.ts":
/*!*****************************!*\
  !*** ./src/lib/mea/mood.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeMoodCoeffV1: () => (/* binding */ computeMoodCoeffV1),\n/* harmony export */   moodUUIDFromBuckets: () => (/* binding */ moodUUIDFromBuckets),\n/* harmony export */   normalizeMoodInputs: () => (/* binding */ normalizeMoodInputs)\n/* harmony export */ });\n// mood.ts  formula, buckets, UUID\nconst clamp = (x, lo, hi)=>Math.min(Math.max(x, lo), hi);\n// --- Ranges\nconst V_TEND_ABS_MAX = 1.2;\nconst V_SWAP_ABS_MAX = 0.5;\nconst GFM_MIN = 0.8, GFM_MAX = 1.2;\n// --- Helpers\nfunction eqCuts(maxAbs, bins) {\n    const step = maxAbs / bins;\n    return Array.from({\n        length: bins - 1\n    }, (_, i)=>step * (i + 1)); // absolute cuts\n}\nfunction binSigned(x, absCuts, upBins, downBins) {\n    const a = Math.abs(x);\n    let idx = 0;\n    while(idx < absCuts.length && a > absCuts[idx])idx++;\n    return x >= 0 ? Math.min(idx, upBins - 1) : upBins + Math.min(idx, downBins - 1);\n}\nfunction binAroundOne(gfm) {\n    // map to 8 bins: 0..3 for >=1.0, 4..7 for <1.0\n    const delta = Math.abs((gfm ?? 1) - 1);\n    // cuts every 0.05 up to 0.20\n    const cuts = [\n        0.05,\n        0.10,\n        0.15\n    ];\n    let idx = 0;\n    while(idx < cuts.length && delta > cuts[idx])idx++;\n    if (idx > 3) idx = 3;\n    return (gfm ?? 1) >= 1 ? idx : 4 + idx;\n}\n// --- UUID alphabets\nconst VT_UP = [\n    \"A\",\n    \"B\",\n    \"C\",\n    \"D\",\n    \"E\",\n    \"F\"\n];\nconst VT_DN = [\n    \"G\",\n    \"H\",\n    \"I\",\n    \"J\",\n    \"K\",\n    \"L\"\n];\nconst VS_UP = [\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\"\n];\nconst VS_DN = [\n    \"g\",\n    \"h\",\n    \"i\",\n    \"j\",\n    \"k\",\n    \"l\"\n];\n// --- Public API\nfunction computeMoodCoeffV1(inp) {\n    const vT = Math.sign(inp.vTendency ?? 0) * clamp(Math.abs(inp.vTendency ?? 0), 0, V_TEND_ABS_MAX);\n    const vS = Math.sign(inp.vSwap ?? 0) * clamp(Math.abs(inp.vSwap ?? 0), 0, V_SWAP_ABS_MAX);\n    const gf = clamp(inp.GFM ?? 1, GFM_MIN, GFM_MAX);\n    // Your formula\n    let coeff = (vT || 0) / (gf || 1) + (vS || 0);\n    coeff = clamp(coeff, 0.2, 2.0);\n    // Buckets\n    const vtCuts = eqCuts(V_TEND_ABS_MAX, 6);\n    const vsCuts = eqCuts(V_SWAP_ABS_MAX, 6);\n    const vTIdx = binSigned(vT, vtCuts, 6, 6);\n    const vSIdx = binSigned(vS, vsCuts, 6, 6);\n    const gIdx = binAroundOne(gf);\n    return {\n        coeff,\n        buckets: {\n            vTendencyIdx: vTIdx,\n            vSwapIdx: vSIdx,\n            GFMIdx: gIdx\n        }\n    };\n}\nfunction moodUUIDFromBuckets(b) {\n    const vt = b.vTendencyIdx < 6 ? VT_UP[b.vTendencyIdx] : VT_DN[b.vTendencyIdx - 6];\n    const vs = b.vSwapIdx < 6 ? VS_UP[b.vSwapIdx] : VS_DN[b.vSwapIdx - 6];\n    const g = String(b.GFMIdx); // 0..7\n    return `${vt}${vs}${g}`;\n}\n// Convert raw  normalized MoodInputs\nfunction normalizeMoodInputs(raw, ref) {\n    const eps = 1e-9;\n    const Kg = ref.gfmScale ?? 20;\n    const GFM = Math.min(Math.max(1 + Kg * raw.gfmDeltaPct, 0.8), 1.2);\n    const zT = Math.max(-1, Math.min(1, (raw.tendencyRaw - ref.vtMu) / (ref.vtSigma || eps)));\n    const vTendency = 0.8 + 0.4 * zT;\n    const zS = (raw.swapRaw - ref.vsMu) / (ref.vsSigma || eps);\n    const vSwap = 0.5 * Math.tanh((ref.vsAlpha ?? 0.75) * zS);\n    return {\n        vTendency,\n        GFM,\n        vSwap\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL21lYS9tb29kLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG1DQUFtQztBQVduQyxNQUFNQSxRQUFRLENBQUNDLEdBQVdDLElBQVlDLEtBQWVDLEtBQUtDLEdBQUcsQ0FBQ0QsS0FBS0UsR0FBRyxDQUFDTCxHQUFHQyxLQUFLQztBQUUvRSxhQUFhO0FBQ2IsTUFBTUksaUJBQWlCO0FBQ3ZCLE1BQU1DLGlCQUFpQjtBQUN2QixNQUFNQyxVQUFVLEtBQUtDLFVBQVU7QUFFL0IsY0FBYztBQUNkLFNBQVNDLE9BQU9DLE1BQWMsRUFBRUMsSUFBWTtJQUMxQyxNQUFNQyxPQUFPRixTQUFTQztJQUN0QixPQUFPRSxNQUFNQyxJQUFJLENBQUM7UUFBRUMsUUFBUUosT0FBTztJQUFFLEdBQUcsQ0FBQ0ssR0FBR0MsSUFBTUwsT0FBUUssQ0FBQUEsSUFBSSxLQUFLLGdCQUFnQjtBQUNyRjtBQUNBLFNBQVNDLFVBQVVuQixDQUFTLEVBQUVvQixPQUFpQixFQUFFQyxNQUFjLEVBQUVDLFFBQWdCO0lBQy9FLE1BQU1DLElBQUlwQixLQUFLcUIsR0FBRyxDQUFDeEI7SUFDbkIsSUFBSXlCLE1BQU07SUFDVixNQUFPQSxNQUFNTCxRQUFRSixNQUFNLElBQUlPLElBQUlILE9BQU8sQ0FBQ0ssSUFBSSxDQUFFQTtJQUNqRCxPQUFPekIsS0FBSyxJQUFJRyxLQUFLQyxHQUFHLENBQUNxQixLQUFLSixTQUFTLEtBQUtBLFNBQVNsQixLQUFLQyxHQUFHLENBQUNxQixLQUFLSCxXQUFXO0FBQ2hGO0FBQ0EsU0FBU0ksYUFBYUMsR0FBVztJQUMvQiwrQ0FBK0M7SUFDL0MsTUFBTUMsUUFBUXpCLEtBQUtxQixHQUFHLENBQUMsQ0FBQ0csT0FBTyxLQUFLO0lBQ3BDLDZCQUE2QjtJQUM3QixNQUFNRSxPQUFPO1FBQUM7UUFBTTtRQUFNO0tBQUs7SUFDL0IsSUFBSUosTUFBTTtJQUNWLE1BQU9BLE1BQU1JLEtBQUtiLE1BQU0sSUFBSVksUUFBUUMsSUFBSSxDQUFDSixJQUFJLENBQUVBO0lBQy9DLElBQUlBLE1BQU0sR0FBR0EsTUFBTTtJQUNuQixPQUFPLENBQUNFLE9BQU8sTUFBTSxJQUFJRixNQUFNLElBQUlBO0FBQ3JDO0FBRUEscUJBQXFCO0FBQ3JCLE1BQU1LLFFBQVE7SUFBQztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7Q0FBSTtBQUN2QyxNQUFNQyxRQUFRO0lBQUM7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0NBQUk7QUFDdkMsTUFBTUMsUUFBUTtJQUFDO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtDQUFJO0FBQ3ZDLE1BQU1DLFFBQVE7SUFBQztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7Q0FBSTtBQUV2QyxpQkFBaUI7QUFFVixTQUFTQyxtQkFBbUJDLEdBQWU7SUFDaEQsTUFBTUMsS0FBS2pDLEtBQUtrQyxJQUFJLENBQUNGLElBQUlHLFNBQVMsSUFBSSxLQUFLdkMsTUFBTUksS0FBS3FCLEdBQUcsQ0FBQ1csSUFBSUcsU0FBUyxJQUFJLElBQUksR0FBR2hDO0lBQ2xGLE1BQU1pQyxLQUFLcEMsS0FBS2tDLElBQUksQ0FBQ0YsSUFBSUssS0FBSyxJQUFJLEtBQVN6QyxNQUFNSSxLQUFLcUIsR0FBRyxDQUFDVyxJQUFJSyxLQUFLLElBQUksSUFBUSxHQUFHakM7SUFDbEYsTUFBTWtDLEtBQU0xQyxNQUFNb0MsSUFBSU8sR0FBRyxJQUFJLEdBQUdsQyxTQUFTQztJQUV6QyxlQUFlO0lBQ2YsSUFBSWtDLFFBQVEsQ0FBR1AsTUFBTSxLQUFNSyxDQUFBQSxNQUFNLEtBQVFGLENBQUFBLE1BQU07SUFDL0NJLFFBQVE1QyxNQUFNNEMsT0FBTyxLQUFLO0lBRTFCLFVBQVU7SUFDVixNQUFNQyxTQUFTbEMsT0FBT0osZ0JBQWdCO0lBQ3RDLE1BQU11QyxTQUFTbkMsT0FBT0gsZ0JBQWdCO0lBQ3RDLE1BQU11QyxRQUFTM0IsVUFBVWlCLElBQUlRLFFBQVEsR0FBRztJQUN4QyxNQUFNRyxRQUFTNUIsVUFBVW9CLElBQUlNLFFBQVEsR0FBRztJQUN4QyxNQUFNRyxPQUFTdEIsYUFBYWU7SUFFNUIsT0FBTztRQUFFRTtRQUFPTSxTQUFTO1lBQUVDLGNBQWNKO1lBQU9LLFVBQVVKO1lBQU9LLFFBQVFKO1FBQUs7SUFBaUI7QUFDakc7QUFFTyxTQUFTSyxvQkFBb0JDLENBQWM7SUFDaEQsTUFBTUMsS0FBS0QsRUFBRUosWUFBWSxHQUFHLElBQUlwQixLQUFLLENBQUN3QixFQUFFSixZQUFZLENBQUMsR0FBR25CLEtBQUssQ0FBQ3VCLEVBQUVKLFlBQVksR0FBRyxFQUFFO0lBQ2pGLE1BQU1NLEtBQUtGLEVBQUVILFFBQVEsR0FBTyxJQUFJbkIsS0FBSyxDQUFDc0IsRUFBRUgsUUFBUSxDQUFDLEdBQU9sQixLQUFLLENBQUNxQixFQUFFSCxRQUFRLEdBQUcsRUFBRTtJQUM3RSxNQUFNTSxJQUFLQyxPQUFPSixFQUFFRixNQUFNLEdBQUcsT0FBTztJQUNwQyxPQUFPLEdBQUdHLEtBQUtDLEtBQUtDLEdBQUc7QUFDekI7QUFVQSxzQ0FBc0M7QUFDL0IsU0FBU0Usb0JBQW9CQyxHQUluQyxFQUFFQyxHQUFxQjtJQUN0QixNQUFNQyxNQUFNO0lBQ1osTUFBTUMsS0FBS0YsSUFBSUcsUUFBUSxJQUFJO0lBQzNCLE1BQU10QixNQUFNdkMsS0FBS0MsR0FBRyxDQUFDRCxLQUFLRSxHQUFHLENBQUMsSUFBSTBELEtBQUtILElBQUlLLFdBQVcsRUFBRSxNQUFNO0lBRTlELE1BQU1DLEtBQUsvRCxLQUFLRSxHQUFHLENBQUMsQ0FBQyxHQUFHRixLQUFLQyxHQUFHLENBQUMsR0FBRyxDQUFDd0QsSUFBSU8sV0FBVyxHQUFHTixJQUFJTyxJQUFJLElBQU1QLENBQUFBLElBQUlRLE9BQU8sSUFBSVAsR0FBRTtJQUN0RixNQUFNeEIsWUFBWSxNQUFNLE1BQU00QjtJQUU5QixNQUFNSSxLQUFLLENBQUNWLElBQUlXLE9BQU8sR0FBR1YsSUFBSVcsSUFBSSxJQUFNWCxDQUFBQSxJQUFJWSxPQUFPLElBQUlYLEdBQUU7SUFDekQsTUFBTXRCLFFBQVEsTUFBTXJDLEtBQUt1RSxJQUFJLENBQUMsQ0FBQ2IsSUFBSWMsT0FBTyxJQUFJLElBQUcsSUFBS0w7SUFFdEQsT0FBTztRQUFFaEM7UUFBV0k7UUFBS0Y7SUFBTTtBQUNqQyIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGxpYlxcbWVhXFxtb29kLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIG1vb2QudHMg4oCUIGZvcm11bGEsIGJ1Y2tldHMsIFVVSURcclxuXHJcbmV4cG9ydCB0eXBlIE1vb2RJbnB1dHMgPSB7XHJcbiAgdlRlbmRlbmN5OiBudW1iZXIgfCBudWxsOyAvLyBzaWduZWQsIGZvdW5kYXRpb25hbCwgY2xhbXAgYWJzIHRvIDEuMlxyXG4gIEdGTTogbnVtYmVyIHwgbnVsbDsgICAgICAgLy8gZmFjdG9yLCBjbGFtcCB0byBbMC44Li4xLjJdXHJcbiAgdlN3YXA6IG51bWJlciB8IG51bGw7ICAgICAvLyBzaWduZWQsIGNsYW1wIGFicyB0byAwLjVcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIE1vb2RCdWNrZXRzID0geyB2VGVuZGVuY3lJZHg6IG51bWJlcjsgdlN3YXBJZHg6IG51bWJlcjsgR0ZNSWR4OiBudW1iZXIgfTtcclxuZXhwb3J0IHR5cGUgTW9vZFVVSUQgPSBzdHJpbmc7XHJcblxyXG5jb25zdCBjbGFtcCA9ICh4OiBudW1iZXIsIGxvOiBudW1iZXIsIGhpOiBudW1iZXIpID0+IE1hdGgubWluKE1hdGgubWF4KHgsIGxvKSwgaGkpO1xyXG5cclxuLy8gLS0tIFJhbmdlc1xyXG5jb25zdCBWX1RFTkRfQUJTX01BWCA9IDEuMjtcclxuY29uc3QgVl9TV0FQX0FCU19NQVggPSAwLjU7XHJcbmNvbnN0IEdGTV9NSU4gPSAwLjgsIEdGTV9NQVggPSAxLjI7XHJcblxyXG4vLyAtLS0gSGVscGVyc1xyXG5mdW5jdGlvbiBlcUN1dHMobWF4QWJzOiBudW1iZXIsIGJpbnM6IG51bWJlcik6IG51bWJlcltdIHtcclxuICBjb25zdCBzdGVwID0gbWF4QWJzIC8gYmlucztcclxuICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogYmlucyAtIDEgfSwgKF8sIGkpID0+IHN0ZXAgKiAoaSArIDEpKTsgLy8gYWJzb2x1dGUgY3V0c1xyXG59XHJcbmZ1bmN0aW9uIGJpblNpZ25lZCh4OiBudW1iZXIsIGFic0N1dHM6IG51bWJlcltdLCB1cEJpbnM6IG51bWJlciwgZG93bkJpbnM6IG51bWJlcik6IG51bWJlciB7XHJcbiAgY29uc3QgYSA9IE1hdGguYWJzKHgpO1xyXG4gIGxldCBpZHggPSAwO1xyXG4gIHdoaWxlIChpZHggPCBhYnNDdXRzLmxlbmd0aCAmJiBhID4gYWJzQ3V0c1tpZHhdKSBpZHgrKztcclxuICByZXR1cm4geCA+PSAwID8gTWF0aC5taW4oaWR4LCB1cEJpbnMgLSAxKSA6IHVwQmlucyArIE1hdGgubWluKGlkeCwgZG93bkJpbnMgLSAxKTtcclxufVxyXG5mdW5jdGlvbiBiaW5Bcm91bmRPbmUoZ2ZtOiBudW1iZXIpOiBudW1iZXIge1xyXG4gIC8vIG1hcCB0byA4IGJpbnM6IDAuLjMgZm9yID49MS4wLCA0Li43IGZvciA8MS4wXHJcbiAgY29uc3QgZGVsdGEgPSBNYXRoLmFicygoZ2ZtID8/IDEpIC0gMSk7XHJcbiAgLy8gY3V0cyBldmVyeSAwLjA1IHVwIHRvIDAuMjBcclxuICBjb25zdCBjdXRzID0gWzAuMDUsIDAuMTAsIDAuMTVdO1xyXG4gIGxldCBpZHggPSAwO1xyXG4gIHdoaWxlIChpZHggPCBjdXRzLmxlbmd0aCAmJiBkZWx0YSA+IGN1dHNbaWR4XSkgaWR4Kys7XHJcbiAgaWYgKGlkeCA+IDMpIGlkeCA9IDM7XHJcbiAgcmV0dXJuIChnZm0gPz8gMSkgPj0gMSA/IGlkeCA6IDQgKyBpZHg7XHJcbn1cclxuXHJcbi8vIC0tLSBVVUlEIGFscGhhYmV0c1xyXG5jb25zdCBWVF9VUCA9IFtcIkFcIixcIkJcIixcIkNcIixcIkRcIixcIkVcIixcIkZcIl07XHJcbmNvbnN0IFZUX0ROID0gW1wiR1wiLFwiSFwiLFwiSVwiLFwiSlwiLFwiS1wiLFwiTFwiXTtcclxuY29uc3QgVlNfVVAgPSBbXCJhXCIsXCJiXCIsXCJjXCIsXCJkXCIsXCJlXCIsXCJmXCJdO1xyXG5jb25zdCBWU19ETiA9IFtcImdcIixcImhcIixcImlcIixcImpcIixcImtcIixcImxcIl07XHJcblxyXG4vLyAtLS0gUHVibGljIEFQSVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVNb29kQ29lZmZWMShpbnA6IE1vb2RJbnB1dHMpIHtcclxuICBjb25zdCB2VCA9IE1hdGguc2lnbihpbnAudlRlbmRlbmN5ID8/IDApICogY2xhbXAoTWF0aC5hYnMoaW5wLnZUZW5kZW5jeSA/PyAwKSwgMCwgVl9URU5EX0FCU19NQVgpO1xyXG4gIGNvbnN0IHZTID0gTWF0aC5zaWduKGlucC52U3dhcCA/PyAwKSAgICAgKiBjbGFtcChNYXRoLmFicyhpbnAudlN3YXAgPz8gMCksICAgICAwLCBWX1NXQVBfQUJTX01BWCk7XHJcbiAgY29uc3QgZ2YgID0gY2xhbXAoaW5wLkdGTSA/PyAxLCBHRk1fTUlOLCBHRk1fTUFYKTtcclxuXHJcbiAgLy8gWW91ciBmb3JtdWxhXHJcbiAgbGV0IGNvZWZmID0gKCAodlQgfHwgMCkgLyAoZ2YgfHwgMSkgKSArICh2UyB8fCAwKTtcclxuICBjb2VmZiA9IGNsYW1wKGNvZWZmLCAwLjIsIDIuMCk7XHJcblxyXG4gIC8vIEJ1Y2tldHNcclxuICBjb25zdCB2dEN1dHMgPSBlcUN1dHMoVl9URU5EX0FCU19NQVgsIDYpO1xyXG4gIGNvbnN0IHZzQ3V0cyA9IGVxQ3V0cyhWX1NXQVBfQUJTX01BWCwgNik7XHJcbiAgY29uc3QgdlRJZHggID0gYmluU2lnbmVkKHZULCB2dEN1dHMsIDYsIDYpO1xyXG4gIGNvbnN0IHZTSWR4ICA9IGJpblNpZ25lZCh2UywgdnNDdXRzLCA2LCA2KTtcclxuICBjb25zdCBnSWR4ICAgPSBiaW5Bcm91bmRPbmUoZ2YpO1xyXG5cclxuICByZXR1cm4geyBjb2VmZiwgYnVja2V0czogeyB2VGVuZGVuY3lJZHg6IHZUSWR4LCB2U3dhcElkeDogdlNJZHgsIEdGTUlkeDogZ0lkeCB9IGFzIE1vb2RCdWNrZXRzIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtb29kVVVJREZyb21CdWNrZXRzKGI6IE1vb2RCdWNrZXRzKTogTW9vZFVVSUQge1xyXG4gIGNvbnN0IHZ0ID0gYi52VGVuZGVuY3lJZHggPCA2ID8gVlRfVVBbYi52VGVuZGVuY3lJZHhdIDogVlRfRE5bYi52VGVuZGVuY3lJZHggLSA2XTtcclxuICBjb25zdCB2cyA9IGIudlN3YXBJZHggICAgIDwgNiA/IFZTX1VQW2IudlN3YXBJZHhdICAgICA6IFZTX0ROW2IudlN3YXBJZHggLSA2XTtcclxuICBjb25zdCBnICA9IFN0cmluZyhiLkdGTUlkeCk7IC8vIDAuLjdcclxuICByZXR1cm4gYCR7dnR9JHt2c30ke2d9YDtcclxufVxyXG5cclxuLy8gQWRkIG5lYXIgdG9wOlxyXG5leHBvcnQgdHlwZSBNb29kUmVmZXJlbnRpYWxzID0ge1xyXG4gIGdmbVNjYWxlPzogbnVtYmVyOyAvLyBkZWZhdWx0IDIwXHJcbiAgdnRNdTogbnVtYmVyOyB2dFNpZ21hOiBudW1iZXI7IC8vIEZSViBhbmQgZGlzcGVyc2lvbiBmb3IgdHJlbmRcclxuICB2c011OiBudW1iZXI7IHZzU2lnbWE6IG51bWJlcjsgLy8gRlJWIGFuZCBkaXNwZXJzaW9uIGZvciBzd2FwXHJcbiAgdnNBbHBoYT86IG51bWJlcjsgLy8gZGVmYXVsdCAwLjc1XHJcbn07XHJcblxyXG4vLyBDb252ZXJ0IHJhdyDihpIgbm9ybWFsaXplZCBNb29kSW5wdXRzXHJcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVNb29kSW5wdXRzKHJhdzoge1xyXG4gIGdmbURlbHRhUGN0OiBudW1iZXI7ICAgLy8gZS5nLiwgKzAuMDEgZm9yICsxJVxyXG4gIHRlbmRlbmN5UmF3OiBudW1iZXI7ICAgLy8geW91ciB0cmVuZCBwcm94eVxyXG4gIHN3YXBSYXc6IG51bWJlcjsgICAgICAgLy8geW91ciBzd2FwIHZlbG9jaXR5IHByb3h5XHJcbn0sIHJlZjogTW9vZFJlZmVyZW50aWFscyk6IE1vb2RJbnB1dHMge1xyXG4gIGNvbnN0IGVwcyA9IDFlLTk7XHJcbiAgY29uc3QgS2cgPSByZWYuZ2ZtU2NhbGUgPz8gMjA7XHJcbiAgY29uc3QgR0ZNID0gTWF0aC5taW4oTWF0aC5tYXgoMSArIEtnICogcmF3LmdmbURlbHRhUGN0LCAwLjgpLCAxLjIpO1xyXG5cclxuICBjb25zdCB6VCA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCAocmF3LnRlbmRlbmN5UmF3IC0gcmVmLnZ0TXUpIC8gKChyZWYudnRTaWdtYSB8fCBlcHMpKSkpO1xyXG4gIGNvbnN0IHZUZW5kZW5jeSA9IDAuOCArIDAuNCAqIHpUO1xyXG5cclxuICBjb25zdCB6UyA9IChyYXcuc3dhcFJhdyAtIHJlZi52c011KSAvICgocmVmLnZzU2lnbWEgfHwgZXBzKSk7XHJcbiAgY29uc3QgdlN3YXAgPSAwLjUgKiBNYXRoLnRhbmgoKHJlZi52c0FscGhhID8/IDAuNzUpICogelMpO1xyXG5cclxuICByZXR1cm4geyB2VGVuZGVuY3ksIEdGTSwgdlN3YXAgfTtcclxufVxyXG4iXSwibmFtZXMiOlsiY2xhbXAiLCJ4IiwibG8iLCJoaSIsIk1hdGgiLCJtaW4iLCJtYXgiLCJWX1RFTkRfQUJTX01BWCIsIlZfU1dBUF9BQlNfTUFYIiwiR0ZNX01JTiIsIkdGTV9NQVgiLCJlcUN1dHMiLCJtYXhBYnMiLCJiaW5zIiwic3RlcCIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsIl8iLCJpIiwiYmluU2lnbmVkIiwiYWJzQ3V0cyIsInVwQmlucyIsImRvd25CaW5zIiwiYSIsImFicyIsImlkeCIsImJpbkFyb3VuZE9uZSIsImdmbSIsImRlbHRhIiwiY3V0cyIsIlZUX1VQIiwiVlRfRE4iLCJWU19VUCIsIlZTX0ROIiwiY29tcHV0ZU1vb2RDb2VmZlYxIiwiaW5wIiwidlQiLCJzaWduIiwidlRlbmRlbmN5IiwidlMiLCJ2U3dhcCIsImdmIiwiR0ZNIiwiY29lZmYiLCJ2dEN1dHMiLCJ2c0N1dHMiLCJ2VElkeCIsInZTSWR4IiwiZ0lkeCIsImJ1Y2tldHMiLCJ2VGVuZGVuY3lJZHgiLCJ2U3dhcElkeCIsIkdGTUlkeCIsIm1vb2RVVUlERnJvbUJ1Y2tldHMiLCJiIiwidnQiLCJ2cyIsImciLCJTdHJpbmciLCJub3JtYWxpemVNb29kSW5wdXRzIiwicmF3IiwicmVmIiwiZXBzIiwiS2ciLCJnZm1TY2FsZSIsImdmbURlbHRhUGN0IiwielQiLCJ0ZW5kZW5jeVJhdyIsInZ0TXUiLCJ2dFNpZ21hIiwielMiLCJzd2FwUmF3IiwidnNNdSIsInZzU2lnbWEiLCJ0YW5oIiwidnNBbHBoYSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/mea/mood.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/settings/coin-universe.ts":
/*!*******************************************!*\
  !*** ./src/lib/settings/coin-universe.ts ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchCoinUniverseBases: () => (/* binding */ fetchCoinUniverseBases),\n/* harmony export */   fetchCoinUniverseEntries: () => (/* binding */ fetchCoinUniverseEntries),\n/* harmony export */   fetchPairUniverseCoins: () => (/* binding */ fetchPairUniverseCoins),\n/* harmony export */   fetchPairUniversePairs: () => (/* binding */ fetchPairUniversePairs),\n/* harmony export */   normalizeCoinList: () => (/* binding */ normalizeCoinList),\n/* harmony export */   recordSettingsCookieSnapshot: () => (/* binding */ recordSettingsCookieSnapshot),\n/* harmony export */   syncCoinUniverseFromBases: () => (/* binding */ syncCoinUniverseFromBases)\n/* harmony export */ });\n/* harmony import */ var _core_db_pool_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/db/pool_server */ \"(rsc)/./src/core/db/pool_server.ts\");\n/* harmony import */ var _lib_markets_pairs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/markets/pairs */ \"(rsc)/./src/lib/markets/pairs.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_db_pool_server__WEBPACK_IMPORTED_MODULE_0__]);\n_core_db_pool_server__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\nconst SORT_SENTINEL = 2147483647;\nfunction normalizeCoinList(input) {\n    const arr = Array.isArray(input) ? input : [];\n    const seen = new Set();\n    const out = [];\n    for (const raw of arr){\n        const coin = (0,_lib_markets_pairs__WEBPACK_IMPORTED_MODULE_1__.normalizeCoin)(raw);\n        if (!coin || seen.has(coin)) continue;\n        seen.add(coin);\n        out.push(coin);\n    }\n    if (!seen.has(\"USDT\")) {\n        seen.add(\"USDT\");\n        out.push(\"USDT\");\n    }\n    return out;\n}\nasync function fetchCoinUniverseEntries(options = {}) {\n    try {\n        const { rows } = await (0,_core_db_pool_server__WEBPACK_IMPORTED_MODULE_0__.query)(`\n        select\n          symbol,\n          upper(coalesce(base_asset, (public._split_symbol(symbol)).base)) as base,\n          upper(coalesce(quote_asset, (public._split_symbol(symbol)).quote)) as quote,\n          coalesce(enabled, true) as enabled,\n          sort_order\n        from settings.coin_universe\n        ${options.onlyEnabled ? \"where coalesce(enabled, true) = true\" : \"\"}\n        order by coalesce(sort_order, $1::int), symbol\n      `, [\n            SORT_SENTINEL\n        ]);\n        return rows.filter((row)=>row.base && row.quote).map((row)=>({\n                symbol: row.symbol?.toUpperCase() ?? \"\",\n                base: row.base.toUpperCase(),\n                quote: row.quote.toUpperCase(),\n                enabled: Boolean(row.enabled ?? true),\n                sortOrder: row.sort_order\n            })).filter((entry)=>entry.symbol.length > 0);\n    } catch (err) {\n        console.warn(\"[settings] coin universe query failed:\", err);\n        return [];\n    }\n}\nasync function fetchPairUniversePairs() {\n    try {\n        const { rows } = await (0,_core_db_pool_server__WEBPACK_IMPORTED_MODULE_0__.query)(`\n        select base, quote\n        from matrices.v_pair_universe\n      `);\n        return rows.map((row)=>({\n                base: row.base?.toUpperCase().trim() ?? \"\",\n                quote: row.quote?.toUpperCase().trim() ?? \"\"\n            })).filter((row)=>row.base && row.quote && row.base !== row.quote);\n    } catch (err) {\n        console.warn(\"[settings] pair universe query failed:\", err);\n        return [];\n    }\n}\nasync function fetchPairUniverseCoins() {\n    const pairs = await fetchPairUniversePairs();\n    if (!pairs.length) return [];\n    const set = new Set();\n    for (const { base, quote } of pairs){\n        if (base) set.add(base);\n        if (quote) set.add(quote);\n    }\n    if (!set.has(\"USDT\")) set.add(\"USDT\");\n    return Array.from(set);\n}\nasync function fetchCoinUniverseBases(options = {}) {\n    const entries = await fetchCoinUniverseEntries(options);\n    const bases = entries.filter((entry)=>options.onlyEnabled ? entry.enabled : true).map((entry)=>entry.base);\n    return normalizeCoinList(bases);\n}\nasync function syncCoinUniverseFromBases(bases) {\n    const normalized = normalizeCoinList(bases);\n    if (!normalized.length) return;\n    const symbols = normalized.filter((coin)=>coin !== \"USDT\").map((coin)=>`${coin}USDT`);\n    if (!symbols.length) return;\n    try {\n        await (0,_core_db_pool_server__WEBPACK_IMPORTED_MODULE_0__.query)(`select settings.sp_sync_coin_universe($1::text[])`, [\n            symbols\n        ]);\n    } catch (err) {\n        console.warn(\"[settings] sync coin universe failed:\", err);\n    }\n}\nasync function recordSettingsCookieSnapshot(jsonValue) {\n    if (!jsonValue) return;\n    try {\n        await (0,_core_db_pool_server__WEBPACK_IMPORTED_MODULE_0__.query)(`\n        insert into settings.cookies(name, value, updated_at)\n        values ('appSettings', $1::jsonb, now())\n        on conflict (name) do update\n          set value = excluded.value,\n              updated_at = excluded.updated_at\n      `, [\n            jsonValue\n        ]);\n    } catch (err) {\n        // table might not exist yet; log once for awareness\n        console.warn(\"[settings] cookie snapshot skipped:\", err);\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL3NldHRpbmdzL2NvaW4tdW5pdmVyc2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ007QUFFcEQsTUFBTUUsZ0JBQWdCO0FBbUJmLFNBQVNDLGtCQUFrQkMsS0FBYztJQUM5QyxNQUFNQyxNQUFNQyxNQUFNQyxPQUFPLENBQUNILFNBQVNBLFFBQVEsRUFBRTtJQUM3QyxNQUFNSSxPQUFPLElBQUlDO0lBQ2pCLE1BQU1DLE1BQWdCLEVBQUU7SUFDeEIsS0FBSyxNQUFNQyxPQUFPTixJQUFLO1FBQ3JCLE1BQU1PLE9BQU9YLGlFQUFhQSxDQUFDVTtRQUMzQixJQUFJLENBQUNDLFFBQVFKLEtBQUtLLEdBQUcsQ0FBQ0QsT0FBTztRQUM3QkosS0FBS00sR0FBRyxDQUFDRjtRQUNURixJQUFJSyxJQUFJLENBQUNIO0lBQ1g7SUFDQSxJQUFJLENBQUNKLEtBQUtLLEdBQUcsQ0FBQyxTQUFTO1FBQ3JCTCxLQUFLTSxHQUFHLENBQUM7UUFDVEosSUFBSUssSUFBSSxDQUFDO0lBQ1g7SUFDQSxPQUFPTDtBQUNUO0FBRU8sZUFBZU0seUJBQXlCQyxVQUF3QixDQUFDLENBQUM7SUFDdkUsSUFBSTtRQUNGLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEdBQUcsTUFBTWxCLDJEQUFLQSxDQU8xQixDQUFDOzs7Ozs7OztRQVFDLEVBQUVpQixRQUFRRSxXQUFXLEdBQUcseUNBQXlDLEdBQUc7O01BRXRFLENBQUMsRUFDRDtZQUFDakI7U0FBYztRQUdqQixPQUFPZ0IsS0FDSkUsTUFBTSxDQUFDLENBQUNDLE1BQVFBLElBQUlDLElBQUksSUFBSUQsSUFBSUUsS0FBSyxFQUNyQ0MsR0FBRyxDQUFDLENBQUNILE1BQVM7Z0JBQ2JJLFFBQVFKLElBQUlJLE1BQU0sRUFBRUMsaUJBQWlCO2dCQUNyQ0osTUFBTUQsSUFBSUMsSUFBSSxDQUFFSSxXQUFXO2dCQUMzQkgsT0FBT0YsSUFBSUUsS0FBSyxDQUFFRyxXQUFXO2dCQUM3QkMsU0FBU0MsUUFBUVAsSUFBSU0sT0FBTyxJQUFJO2dCQUNoQ0UsV0FBV1IsSUFBSVMsVUFBVTtZQUMzQixJQUNDVixNQUFNLENBQUMsQ0FBQ1csUUFBVUEsTUFBTU4sTUFBTSxDQUFDTyxNQUFNLEdBQUc7SUFDN0MsRUFBRSxPQUFPQyxLQUFLO1FBQ1pDLFFBQVFDLElBQUksQ0FBQywwQ0FBMENGO1FBQ3ZELE9BQU8sRUFBRTtJQUNYO0FBQ0Y7QUFFTyxlQUFlRztJQUNwQixJQUFJO1FBQ0YsTUFBTSxFQUFFbEIsSUFBSSxFQUFFLEdBQUcsTUFBTWxCLDJEQUFLQSxDQUMxQixDQUFDOzs7TUFHRCxDQUFDO1FBRUgsT0FBT2tCLEtBQ0pNLEdBQUcsQ0FBQyxDQUFDSCxNQUFTO2dCQUNiQyxNQUFNRCxJQUFJQyxJQUFJLEVBQUVJLGNBQWNXLFVBQVU7Z0JBQ3hDZCxPQUFPRixJQUFJRSxLQUFLLEVBQUVHLGNBQWNXLFVBQVU7WUFDNUMsSUFDQ2pCLE1BQU0sQ0FBQyxDQUFDQyxNQUFRQSxJQUFJQyxJQUFJLElBQUlELElBQUlFLEtBQUssSUFBSUYsSUFBSUMsSUFBSSxLQUFLRCxJQUFJRSxLQUFLO0lBQ3BFLEVBQUUsT0FBT1UsS0FBSztRQUNaQyxRQUFRQyxJQUFJLENBQUMsMENBQTBDRjtRQUN2RCxPQUFPLEVBQUU7SUFDWDtBQUNGO0FBRU8sZUFBZUs7SUFDcEIsTUFBTUMsUUFBUSxNQUFNSDtJQUNwQixJQUFJLENBQUNHLE1BQU1QLE1BQU0sRUFBRSxPQUFPLEVBQUU7SUFFNUIsTUFBTVEsTUFBTSxJQUFJL0I7SUFDaEIsS0FBSyxNQUFNLEVBQUVhLElBQUksRUFBRUMsS0FBSyxFQUFFLElBQUlnQixNQUFPO1FBQ25DLElBQUlqQixNQUFNa0IsSUFBSTFCLEdBQUcsQ0FBQ1E7UUFDbEIsSUFBSUMsT0FBT2lCLElBQUkxQixHQUFHLENBQUNTO0lBQ3JCO0lBQ0EsSUFBSSxDQUFDaUIsSUFBSTNCLEdBQUcsQ0FBQyxTQUFTMkIsSUFBSTFCLEdBQUcsQ0FBQztJQUM5QixPQUFPUixNQUFNbUMsSUFBSSxDQUFDRDtBQUNwQjtBQUVPLGVBQWVFLHVCQUF1QnpCLFVBQXdCLENBQUMsQ0FBQztJQUNyRSxNQUFNMEIsVUFBVSxNQUFNM0IseUJBQXlCQztJQUMvQyxNQUFNMkIsUUFBUUQsUUFDWHZCLE1BQU0sQ0FBQyxDQUFDVyxRQUFXZCxRQUFRRSxXQUFXLEdBQUdZLE1BQU1KLE9BQU8sR0FBRyxNQUN6REgsR0FBRyxDQUFDLENBQUNPLFFBQVVBLE1BQU1ULElBQUk7SUFDNUIsT0FBT25CLGtCQUFrQnlDO0FBQzNCO0FBRU8sZUFBZUMsMEJBQTBCRCxLQUFlO0lBQzdELE1BQU1FLGFBQWEzQyxrQkFBa0J5QztJQUNyQyxJQUFJLENBQUNFLFdBQVdkLE1BQU0sRUFBRTtJQUV4QixNQUFNZSxVQUFVRCxXQUNiMUIsTUFBTSxDQUFDLENBQUNSLE9BQVNBLFNBQVMsUUFDMUJZLEdBQUcsQ0FBQyxDQUFDWixPQUFTLEdBQUdBLEtBQUssSUFBSSxDQUFDO0lBRTlCLElBQUksQ0FBQ21DLFFBQVFmLE1BQU0sRUFBRTtJQUVyQixJQUFJO1FBQ0YsTUFBTWhDLDJEQUFLQSxDQUFDLENBQUMsaURBQWlELENBQUMsRUFBRTtZQUFDK0M7U0FBUTtJQUM1RSxFQUFFLE9BQU9kLEtBQUs7UUFDWkMsUUFBUUMsSUFBSSxDQUFDLHlDQUF5Q0Y7SUFDeEQ7QUFDRjtBQUVPLGVBQWVlLDZCQUE2QkMsU0FBb0M7SUFDckYsSUFBSSxDQUFDQSxXQUFXO0lBQ2hCLElBQUk7UUFDRixNQUFNakQsMkRBQUtBLENBQ1QsQ0FBQzs7Ozs7O01BTUQsQ0FBQyxFQUNEO1lBQUNpRDtTQUFVO0lBRWYsRUFBRSxPQUFPaEIsS0FBSztRQUNaLG9EQUFvRDtRQUNwREMsUUFBUUMsSUFBSSxDQUFDLHVDQUF1Q0Y7SUFDdEQ7QUFDRiIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGxpYlxcc2V0dGluZ3NcXGNvaW4tdW5pdmVyc2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcXVlcnkgfSBmcm9tIFwiQC9jb3JlL2RiL3Bvb2xfc2VydmVyXCI7XG5pbXBvcnQgeyBub3JtYWxpemVDb2luIH0gZnJvbSBcIkAvbGliL21hcmtldHMvcGFpcnNcIjtcblxuY29uc3QgU09SVF9TRU5USU5FTCA9IDJfMTQ3XzQ4M182NDc7XG5cbmV4cG9ydCB0eXBlIENvaW5Vbml2ZXJzZUVudHJ5ID0ge1xuICBzeW1ib2w6IHN0cmluZztcbiAgYmFzZTogc3RyaW5nO1xuICBxdW90ZTogc3RyaW5nO1xuICBlbmFibGVkOiBib29sZWFuO1xuICBzb3J0T3JkZXI6IG51bWJlciB8IG51bGw7XG59O1xuXG5leHBvcnQgdHlwZSBQYWlyVW5pdmVyc2VFbnRyeSA9IHtcbiAgYmFzZTogc3RyaW5nO1xuICBxdW90ZTogc3RyaW5nO1xufTtcblxudHlwZSBGZXRjaE9wdGlvbnMgPSB7XG4gIG9ubHlFbmFibGVkPzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVDb2luTGlzdChpbnB1dDogdW5rbm93bik6IHN0cmluZ1tdIHtcbiAgY29uc3QgYXJyID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtdO1xuICBjb25zdCBzZWVuID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGNvbnN0IG91dDogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChjb25zdCByYXcgb2YgYXJyKSB7XG4gICAgY29uc3QgY29pbiA9IG5vcm1hbGl6ZUNvaW4ocmF3IGFzIHN0cmluZyk7XG4gICAgaWYgKCFjb2luIHx8IHNlZW4uaGFzKGNvaW4pKSBjb250aW51ZTtcbiAgICBzZWVuLmFkZChjb2luKTtcbiAgICBvdXQucHVzaChjb2luKTtcbiAgfVxuICBpZiAoIXNlZW4uaGFzKFwiVVNEVFwiKSkge1xuICAgIHNlZW4uYWRkKFwiVVNEVFwiKTtcbiAgICBvdXQucHVzaChcIlVTRFRcIik7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQ29pblVuaXZlcnNlRW50cmllcyhvcHRpb25zOiBGZXRjaE9wdGlvbnMgPSB7fSk6IFByb21pc2U8Q29pblVuaXZlcnNlRW50cnlbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgcm93cyB9ID0gYXdhaXQgcXVlcnk8e1xuICAgICAgc3ltYm9sOiBzdHJpbmc7XG4gICAgICBiYXNlOiBzdHJpbmcgfCBudWxsO1xuICAgICAgcXVvdGU6IHN0cmluZyB8IG51bGw7XG4gICAgICBlbmFibGVkOiBib29sZWFuIHwgbnVsbDtcbiAgICAgIHNvcnRfb3JkZXI6IG51bWJlciB8IG51bGw7XG4gICAgfT4oXG4gICAgICBgXG4gICAgICAgIHNlbGVjdFxuICAgICAgICAgIHN5bWJvbCxcbiAgICAgICAgICB1cHBlcihjb2FsZXNjZShiYXNlX2Fzc2V0LCAocHVibGljLl9zcGxpdF9zeW1ib2woc3ltYm9sKSkuYmFzZSkpIGFzIGJhc2UsXG4gICAgICAgICAgdXBwZXIoY29hbGVzY2UocXVvdGVfYXNzZXQsIChwdWJsaWMuX3NwbGl0X3N5bWJvbChzeW1ib2wpKS5xdW90ZSkpIGFzIHF1b3RlLFxuICAgICAgICAgIGNvYWxlc2NlKGVuYWJsZWQsIHRydWUpIGFzIGVuYWJsZWQsXG4gICAgICAgICAgc29ydF9vcmRlclxuICAgICAgICBmcm9tIHNldHRpbmdzLmNvaW5fdW5pdmVyc2VcbiAgICAgICAgJHtvcHRpb25zLm9ubHlFbmFibGVkID8gXCJ3aGVyZSBjb2FsZXNjZShlbmFibGVkLCB0cnVlKSA9IHRydWVcIiA6IFwiXCJ9XG4gICAgICAgIG9yZGVyIGJ5IGNvYWxlc2NlKHNvcnRfb3JkZXIsICQxOjppbnQpLCBzeW1ib2xcbiAgICAgIGAsXG4gICAgICBbU09SVF9TRU5USU5FTF1cbiAgICApO1xuXG4gICAgcmV0dXJuIHJvd3NcbiAgICAgIC5maWx0ZXIoKHJvdykgPT4gcm93LmJhc2UgJiYgcm93LnF1b3RlKVxuICAgICAgLm1hcCgocm93KSA9PiAoe1xuICAgICAgICBzeW1ib2w6IHJvdy5zeW1ib2w/LnRvVXBwZXJDYXNlKCkgPz8gXCJcIixcbiAgICAgICAgYmFzZTogcm93LmJhc2UhLnRvVXBwZXJDYXNlKCksXG4gICAgICAgIHF1b3RlOiByb3cucXVvdGUhLnRvVXBwZXJDYXNlKCksXG4gICAgICAgIGVuYWJsZWQ6IEJvb2xlYW4ocm93LmVuYWJsZWQgPz8gdHJ1ZSksXG4gICAgICAgIHNvcnRPcmRlcjogcm93LnNvcnRfb3JkZXIsXG4gICAgICB9KSlcbiAgICAgIC5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeS5zeW1ib2wubGVuZ3RoID4gMCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUud2FybihcIltzZXR0aW5nc10gY29pbiB1bml2ZXJzZSBxdWVyeSBmYWlsZWQ6XCIsIGVycik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFBhaXJVbml2ZXJzZVBhaXJzKCk6IFByb21pc2U8UGFpclVuaXZlcnNlRW50cnlbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgcm93cyB9ID0gYXdhaXQgcXVlcnk8eyBiYXNlOiBzdHJpbmcgfCBudWxsOyBxdW90ZTogc3RyaW5nIHwgbnVsbCB9PihcbiAgICAgIGBcbiAgICAgICAgc2VsZWN0IGJhc2UsIHF1b3RlXG4gICAgICAgIGZyb20gbWF0cmljZXMudl9wYWlyX3VuaXZlcnNlXG4gICAgICBgXG4gICAgKTtcbiAgICByZXR1cm4gcm93c1xuICAgICAgLm1hcCgocm93KSA9PiAoe1xuICAgICAgICBiYXNlOiByb3cuYmFzZT8udG9VcHBlckNhc2UoKS50cmltKCkgPz8gXCJcIixcbiAgICAgICAgcXVvdGU6IHJvdy5xdW90ZT8udG9VcHBlckNhc2UoKS50cmltKCkgPz8gXCJcIixcbiAgICAgIH0pKVxuICAgICAgLmZpbHRlcigocm93KSA9PiByb3cuYmFzZSAmJiByb3cucXVvdGUgJiYgcm93LmJhc2UgIT09IHJvdy5xdW90ZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUud2FybihcIltzZXR0aW5nc10gcGFpciB1bml2ZXJzZSBxdWVyeSBmYWlsZWQ6XCIsIGVycik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFBhaXJVbml2ZXJzZUNvaW5zKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgY29uc3QgcGFpcnMgPSBhd2FpdCBmZXRjaFBhaXJVbml2ZXJzZVBhaXJzKCk7XG4gIGlmICghcGFpcnMubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3QgeyBiYXNlLCBxdW90ZSB9IG9mIHBhaXJzKSB7XG4gICAgaWYgKGJhc2UpIHNldC5hZGQoYmFzZSk7XG4gICAgaWYgKHF1b3RlKSBzZXQuYWRkKHF1b3RlKTtcbiAgfVxuICBpZiAoIXNldC5oYXMoXCJVU0RUXCIpKSBzZXQuYWRkKFwiVVNEVFwiKTtcbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQ29pblVuaXZlcnNlQmFzZXMob3B0aW9uczogRmV0Y2hPcHRpb25zID0ge30pOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIGNvbnN0IGVudHJpZXMgPSBhd2FpdCBmZXRjaENvaW5Vbml2ZXJzZUVudHJpZXMob3B0aW9ucyk7XG4gIGNvbnN0IGJhc2VzID0gZW50cmllc1xuICAgIC5maWx0ZXIoKGVudHJ5KSA9PiAob3B0aW9ucy5vbmx5RW5hYmxlZCA/IGVudHJ5LmVuYWJsZWQgOiB0cnVlKSlcbiAgICAubWFwKChlbnRyeSkgPT4gZW50cnkuYmFzZSk7XG4gIHJldHVybiBub3JtYWxpemVDb2luTGlzdChiYXNlcyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzeW5jQ29pblVuaXZlcnNlRnJvbUJhc2VzKGJhc2VzOiBzdHJpbmdbXSk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ29pbkxpc3QoYmFzZXMpO1xuICBpZiAoIW5vcm1hbGl6ZWQubGVuZ3RoKSByZXR1cm47XG5cbiAgY29uc3Qgc3ltYm9scyA9IG5vcm1hbGl6ZWRcbiAgICAuZmlsdGVyKChjb2luKSA9PiBjb2luICE9PSBcIlVTRFRcIilcbiAgICAubWFwKChjb2luKSA9PiBgJHtjb2lufVVTRFRgKTtcblxuICBpZiAoIXN5bWJvbHMubGVuZ3RoKSByZXR1cm47XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBxdWVyeShgc2VsZWN0IHNldHRpbmdzLnNwX3N5bmNfY29pbl91bml2ZXJzZSgkMTo6dGV4dFtdKWAsIFtzeW1ib2xzXSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUud2FybihcIltzZXR0aW5nc10gc3luYyBjb2luIHVuaXZlcnNlIGZhaWxlZDpcIiwgZXJyKTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVjb3JkU2V0dGluZ3NDb29raWVTbmFwc2hvdChqc29uVmFsdWU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgaWYgKCFqc29uVmFsdWUpIHJldHVybjtcbiAgdHJ5IHtcbiAgICBhd2FpdCBxdWVyeShcbiAgICAgIGBcbiAgICAgICAgaW5zZXJ0IGludG8gc2V0dGluZ3MuY29va2llcyhuYW1lLCB2YWx1ZSwgdXBkYXRlZF9hdClcbiAgICAgICAgdmFsdWVzICgnYXBwU2V0dGluZ3MnLCAkMTo6anNvbmIsIG5vdygpKVxuICAgICAgICBvbiBjb25mbGljdCAobmFtZSkgZG8gdXBkYXRlXG4gICAgICAgICAgc2V0IHZhbHVlID0gZXhjbHVkZWQudmFsdWUsXG4gICAgICAgICAgICAgIHVwZGF0ZWRfYXQgPSBleGNsdWRlZC51cGRhdGVkX2F0XG4gICAgICBgLFxuICAgICAgW2pzb25WYWx1ZV1cbiAgICApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyB0YWJsZSBtaWdodCBub3QgZXhpc3QgeWV0OyBsb2cgb25jZSBmb3IgYXdhcmVuZXNzXG4gICAgY29uc29sZS53YXJuKFwiW3NldHRpbmdzXSBjb29raWUgc25hcHNob3Qgc2tpcHBlZDpcIiwgZXJyKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbInF1ZXJ5Iiwibm9ybWFsaXplQ29pbiIsIlNPUlRfU0VOVElORUwiLCJub3JtYWxpemVDb2luTGlzdCIsImlucHV0IiwiYXJyIiwiQXJyYXkiLCJpc0FycmF5Iiwic2VlbiIsIlNldCIsIm91dCIsInJhdyIsImNvaW4iLCJoYXMiLCJhZGQiLCJwdXNoIiwiZmV0Y2hDb2luVW5pdmVyc2VFbnRyaWVzIiwib3B0aW9ucyIsInJvd3MiLCJvbmx5RW5hYmxlZCIsImZpbHRlciIsInJvdyIsImJhc2UiLCJxdW90ZSIsIm1hcCIsInN5bWJvbCIsInRvVXBwZXJDYXNlIiwiZW5hYmxlZCIsIkJvb2xlYW4iLCJzb3J0T3JkZXIiLCJzb3J0X29yZGVyIiwiZW50cnkiLCJsZW5ndGgiLCJlcnIiLCJjb25zb2xlIiwid2FybiIsImZldGNoUGFpclVuaXZlcnNlUGFpcnMiLCJ0cmltIiwiZmV0Y2hQYWlyVW5pdmVyc2VDb2lucyIsInBhaXJzIiwic2V0IiwiZnJvbSIsImZldGNoQ29pblVuaXZlcnNlQmFzZXMiLCJlbnRyaWVzIiwiYmFzZXMiLCJzeW5jQ29pblVuaXZlcnNlRnJvbUJhc2VzIiwibm9ybWFsaXplZCIsInN5bWJvbHMiLCJyZWNvcmRTZXR0aW5nc0Nvb2tpZVNuYXBzaG90IiwianNvblZhbHVlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/settings/coin-universe.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/settings/schema.ts":
/*!************************************!*\
  !*** ./src/lib/settings/schema.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppSettings: () => (/* binding */ AppSettings),\n/* harmony export */   DEFAULT_SETTINGS: () => (/* binding */ DEFAULT_SETTINGS),\n/* harmony export */   SETTINGS_VERSION: () => (/* binding */ SETTINGS_VERSION),\n/* harmony export */   isAppSettings: () => (/* binding */ isAppSettings),\n/* harmony export */   mergeAppSettings: () => (/* binding */ mergeAppSettings),\n/* harmony export */   migrateSettings: () => (/* binding */ migrateSettings),\n/* harmony export */   normalizeCoinUniverse: () => (/* binding */ normalizeCoinUniverse)\n/* harmony export */ });\n// src/lib/settings/schema.ts\nconst SETTINGS_VERSION = 1;\nconst DEFAULT_SETTINGS = {\n    version: SETTINGS_VERSION,\n    coinUniverse: [],\n    profile: {\n        nickname: \"\",\n        email: \"\",\n        binanceKeyId: \"\"\n    },\n    stats: {\n        histogramLen: 64,\n        bmDecimals: 4,\n        idPctDecimals: 6\n    },\n    poll: {\n        cycle40: 40,\n        cycle120: 120,\n        refreshUrl: \"/api/system/refresh\"\n    },\n    timing: {\n        autoRefresh: true,\n        autoRefreshMs: 40000,\n        secondaryEnabled: true,\n        secondaryCycles: 3,\n        strCycles: {\n            m30: 45,\n            h1: 90,\n            h3: 270\n        }\n    },\n    clustering: {\n        clusters: [\n            {\n                id: \"cl-1\",\n                name: \"Cluster 1\",\n                coins: []\n            }\n        ]\n    },\n    params: {\n        values: {\n            eta: 0.02,\n            epsilon: 0.2,\n            iota: 0.5\n        }\n    }\n};\n// ---------- internal helpers ----------\nconst toUpperArray = (value)=>{\n    if (!Array.isArray(value)) return [];\n    const seen = new Set();\n    const result = [];\n    for (const entry of value){\n        const upper = String(entry ?? \"\").trim().toUpperCase();\n        if (!upper || seen.has(upper)) continue;\n        seen.add(upper);\n        result.push(upper);\n    }\n    if (!seen.has(\"USDT\")) result.push(\"USDT\");\n    return result;\n};\nconst toNumber = (value, fallback)=>{\n    const parsed = Number(value);\n    return Number.isFinite(parsed) ? parsed : fallback;\n};\nconst clamp = (value, min, max)=>Math.min(max, Math.max(min, value));\nconst toClusterArray = (value)=>{\n    if (!Array.isArray(value)) return DEFAULT_SETTINGS.clustering.clusters;\n    return value.map((entry, index)=>{\n        const obj = entry && typeof entry === \"object\" ? entry : {};\n        return {\n            id: String(obj.id ?? `cl-${index + 1}`),\n            name: String(obj.name ?? `Cluster ${index + 1}`),\n            coins: toUpperArray(obj.coins)\n        };\n    });\n};\nconst toParams = (value)=>{\n    if (!value || typeof value !== \"object\") return {\n        ...DEFAULT_SETTINGS.params.values\n    };\n    const result = {\n        ...DEFAULT_SETTINGS.params.values\n    };\n    for (const [key, raw] of Object.entries(value)){\n        const parsed = Number(raw);\n        if (Number.isFinite(parsed)) result[key] = parsed;\n    }\n    return result;\n};\nconst toPoll = (value)=>{\n    const base = {\n        cycle40: DEFAULT_SETTINGS.poll.cycle40,\n        cycle120: DEFAULT_SETTINGS.poll.cycle120,\n        refreshUrl: DEFAULT_SETTINGS.poll.refreshUrl\n    };\n    if (!value || typeof value !== \"object\") return base;\n    const obj = value;\n    const sanitizeCycle = (raw, fallback)=>{\n        const parsed = Number(raw);\n        if (!Number.isFinite(parsed)) return fallback;\n        const bounded = Math.floor(parsed);\n        return Math.max(5, Math.min(600, bounded));\n    };\n    const resolveUrl = (raw)=>{\n        if (typeof raw !== \"string\") return null;\n        const trimmed = raw.trim();\n        return trimmed.length ? trimmed : null;\n    };\n    return {\n        cycle40: sanitizeCycle(obj.cycle40, base.cycle40),\n        cycle120: sanitizeCycle(obj.cycle120, base.cycle120),\n        refreshUrl: resolveUrl(obj.refreshUrl) ?? resolveUrl(base.refreshUrl) ?? DEFAULT_SETTINGS.poll.refreshUrl\n    };\n};\n// ---------- public migration (existing) ----------\nfunction migrateSettings(input) {\n    const s = input && typeof input === \"object\" ? input : {};\n    const statsSource = s.stats && typeof s.stats === \"object\" ? s.stats : {};\n    const timingSource = s.timing && typeof s.timing === \"object\" ? s.timing : {};\n    const timingCycles = timingSource.strCycles && typeof timingSource.strCycles === \"object\" ? timingSource.strCycles : {};\n    const out = {\n        version: SETTINGS_VERSION,\n        coinUniverse: toUpperArray(s.coinUniverse),\n        profile: {\n            nickname: String(s.profile?.nickname ?? \"\"),\n            email: String(s.profile?.email ?? \"\"),\n            binanceKeyId: String(s.profile?.binanceKeyId ?? \"\")\n        },\n        stats: {\n            histogramLen: Math.max(16, toNumber(statsSource.histogramLen, DEFAULT_SETTINGS.stats.histogramLen)),\n            bmDecimals: clamp(toNumber(statsSource.bmDecimals, DEFAULT_SETTINGS.stats.bmDecimals), 0, 6),\n            idPctDecimals: clamp(toNumber(statsSource.idPctDecimals, DEFAULT_SETTINGS.stats.idPctDecimals), 0, 8)\n        },\n        poll: toPoll(s.poll),\n        timing: {\n            autoRefresh: Boolean(timingSource.autoRefresh ?? DEFAULT_SETTINGS.timing.autoRefresh),\n            autoRefreshMs: Math.max(500, toNumber(timingSource.autoRefreshMs, DEFAULT_SETTINGS.timing.autoRefreshMs)),\n            secondaryEnabled: Boolean(timingSource.secondaryEnabled ?? DEFAULT_SETTINGS.timing.secondaryEnabled),\n            secondaryCycles: clamp(toNumber(timingSource.secondaryCycles, DEFAULT_SETTINGS.timing.secondaryCycles), 1, 10),\n            strCycles: {\n                m30: Math.max(1, toNumber(timingCycles.m30, DEFAULT_SETTINGS.timing.strCycles.m30)),\n                h1: Math.max(1, toNumber(timingCycles.h1, DEFAULT_SETTINGS.timing.strCycles.h1)),\n                h3: Math.max(1, toNumber(timingCycles.h3, DEFAULT_SETTINGS.timing.strCycles.h3))\n            }\n        },\n        clustering: {\n            clusters: toClusterArray(s.clustering?.clusters)\n        },\n        params: {\n            values: toParams(s.params?.values)\n        }\n    };\n    if (out.coinUniverse.length === 0) {\n        out.coinUniverse = [\n            ...DEFAULT_SETTINGS.coinUniverse\n        ];\n    }\n    return out;\n}\n/** Normalize coins from a string (comma/space-separated) or array; ensures USDT present and uppercase+deduped. */ function normalizeCoinUniverse(input) {\n    if (Array.isArray(input)) return toUpperArray(input);\n    if (typeof input === \"string\") {\n        const parts = input.split(/[,\\s]+/).map((s)=>s.trim()).filter(Boolean);\n        return toUpperArray(parts);\n    }\n    return toUpperArray([]);\n}\n/** Type guard to check if an object already looks like an AppSettings after migration. */ function isAppSettings(x) {\n    return !!x && typeof x === \"object\" && \"version\" in x && \"coinUniverse\" in x;\n}\n/**\n * Factory  create a normalized AppSettings object.\n * - If you pass nothing, you get migrated DEFAULT_SETTINGS.\n * - If you pass a deep-partial or any unknown, it is migrated safely.\n */ function AppSettings(input) {\n    return migrateSettings(input ?? DEFAULT_SETTINGS);\n}\n/** Merge a base AppSettings with a deep-partial patch, then normalize. */ function mergeAppSettings(base, patch) {\n    // shallow-merge at top level; nested objects are re-validated by migrateSettings\n    return migrateSettings({\n        ...base,\n        ...patch\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsVUFBVTFCLEdBQUcsQ0FBQ2tCLENBQUFBLElBQUtBLEVBQUVqQyxJQUFJLElBQUkwQyxNQUFNLENBQUNKO1FBQzlELE9BQU9oRCxhQUFha0Q7SUFDdEI7SUFDQSxPQUFPbEQsYUFBYSxFQUFFO0FBQ3hCO0FBRUEsd0ZBQXdGLEdBQ2pGLFNBQVNxRCxjQUFjQyxDQUFVO0lBQ3RDLE9BQU8sQ0FBQyxDQUFDQSxLQUFLLE9BQU9BLE1BQU0sWUFBWSxhQUFjQSxLQUFhLGtCQUFtQkE7QUFDdkY7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0MsWUFBWWIsS0FBMEM7SUFDcEUsT0FBT0QsZ0JBQWdCQyxTQUFTNUU7QUFDbEM7QUFFQSx3RUFBd0UsR0FDakUsU0FBUzBGLGlCQUFpQnRCLElBQWlCLEVBQUV1QixLQUErQjtJQUNqRixpRkFBaUY7SUFDakYsT0FBT2hCLGdCQUFnQjtRQUFFLEdBQUdQLElBQUk7UUFBRSxHQUFHdUIsS0FBSztJQUFDO0FBQzdDIiwic291cmNlcyI6WyJIOlxcVXNlcnNcXEd1c1xcc291cmNlXFxyZXBvXFxkeW5hbWljc1xcZHluYW1pY3MtYlxcY3J5cHRvcGktZHluYW1pY3NcXHNyY1xcbGliXFxzZXR0aW5nc1xcc2NoZW1hLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9saWIvc2V0dGluZ3Mvc2NoZW1hLnRzXG5leHBvcnQgdHlwZSBDbHVzdGVyID0geyBpZDogc3RyaW5nOyBuYW1lOiBzdHJpbmc7IGNvaW5zOiBzdHJpbmdbXSB9O1xuXG5leHBvcnQgdHlwZSBBcHBTZXR0aW5ncyA9IHtcbiAgdmVyc2lvbjogbnVtYmVyO1xuICBjb2luVW5pdmVyc2U6IHN0cmluZ1tdO1xuICBwcm9maWxlOiB7IG5pY2tuYW1lOiBzdHJpbmc7IGVtYWlsOiBzdHJpbmc7IGJpbmFuY2VLZXlJZDogc3RyaW5nIH07XG4gIHN0YXRzOiB7IGhpc3RvZ3JhbUxlbjogbnVtYmVyOyBibURlY2ltYWxzOiBudW1iZXI7IGlkUGN0RGVjaW1hbHM6IG51bWJlciB9O1xuICBwb2xsOiB7XG4gICAgY3ljbGU0MDogbnVtYmVyO1xuICAgIGN5Y2xlMTIwOiBudW1iZXI7XG4gICAgcmVmcmVzaFVybDogc3RyaW5nO1xuICB9O1xuICB0aW1pbmc6IHtcbiAgICBhdXRvUmVmcmVzaDogYm9vbGVhbjsgICAgICAgICAgIC8vIDwtLSByZXF1aXJlZCBmbGFnXG4gICAgYXV0b1JlZnJlc2hNczogbnVtYmVyO1xuICAgIHNlY29uZGFyeUVuYWJsZWQ6IGJvb2xlYW47XG4gICAgc2Vjb25kYXJ5Q3ljbGVzOiBudW1iZXI7ICAgICAgICAvLyAxLi4xMFxuICAgIHN0ckN5Y2xlczogeyBtMzA6IG51bWJlcjsgaDE6IG51bWJlcjsgaDM6IG51bWJlciB9O1xuICB9O1xuICBjbHVzdGVyaW5nOiB7XG4gICAgY2x1c3RlcnM6IENsdXN0ZXJbXTtcbiAgfTtcbiAgcGFyYW1zOiB7IHZhbHVlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB9O1xufTtcblxuZXhwb3J0IGNvbnN0IFNFVFRJTkdTX1ZFUlNJT04gPSAxO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogQXBwU2V0dGluZ3MgPSB7XG4gIHZlcnNpb246IFNFVFRJTkdTX1ZFUlNJT04sXG4gIGNvaW5Vbml2ZXJzZTogW10sXG4gIHByb2ZpbGU6IHsgbmlja25hbWU6IFwiXCIsIGVtYWlsOiBcIlwiLCBiaW5hbmNlS2V5SWQ6IFwiXCIgfSxcbiAgc3RhdHM6IHsgaGlzdG9ncmFtTGVuOiA2NCwgYm1EZWNpbWFsczogNCwgaWRQY3REZWNpbWFsczogNiB9LFxuICBwb2xsOiB7XG4gICAgY3ljbGU0MDogNDAsXG4gICAgY3ljbGUxMjA6IDEyMCxcbiAgICByZWZyZXNoVXJsOiBcIi9hcGkvc3lzdGVtL3JlZnJlc2hcIixcbiAgfSxcbiAgdGltaW5nOiB7XG4gICAgYXV0b1JlZnJlc2g6IHRydWUsXG4gICAgYXV0b1JlZnJlc2hNczogNDBfMDAwLFxuICAgIHNlY29uZGFyeUVuYWJsZWQ6IHRydWUsXG4gICAgc2Vjb25kYXJ5Q3ljbGVzOiAzLFxuICAgIHN0ckN5Y2xlczogeyBtMzA6IDQ1LCBoMTogOTAsIGgzOiAyNzAgfSxcbiAgfSxcbiAgY2x1c3RlcmluZzogeyBjbHVzdGVyczogW3sgaWQ6IFwiY2wtMVwiLCBuYW1lOiBcIkNsdXN0ZXIgMVwiLCBjb2luczogW10gfV0gfSxcbiAgcGFyYW1zOiB7IHZhbHVlczogeyBldGE6IDAuMDIsIGVwc2lsb246IDAuMiwgaW90YTogMC41IH0gfSxcbiAgXG59O1xuXG4vLyAtLS0tLS0tLS0tIGludGVybmFsIGhlbHBlcnMgLS0tLS0tLS0tLVxuY29uc3QgdG9VcHBlckFycmF5ID0gKHZhbHVlOiB1bmtub3duKTogc3RyaW5nW10gPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gW107XG4gIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgY29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIHZhbHVlKSB7XG4gICAgY29uc3QgdXBwZXIgPSBTdHJpbmcoZW50cnkgPz8gXCJcIikudHJpbSgpLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKCF1cHBlciB8fCBzZWVuLmhhcyh1cHBlcikpIGNvbnRpbnVlO1xuICAgIHNlZW4uYWRkKHVwcGVyKTtcbiAgICByZXN1bHQucHVzaCh1cHBlcik7XG4gIH1cbiAgaWYgKCFzZWVuLmhhcyhcIlVTRFRcIikpIHJlc3VsdC5wdXNoKFwiVVNEVFwiKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHRvTnVtYmVyID0gKHZhbHVlOiB1bmtub3duLCBmYWxsYmFjazogbnVtYmVyKTogbnVtYmVyID0+IHtcbiAgY29uc3QgcGFyc2VkID0gTnVtYmVyKHZhbHVlKTtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShwYXJzZWQpID8gcGFyc2VkIDogZmFsbGJhY2s7XG59O1xuXG5jb25zdCBjbGFtcCA9ICh2YWx1ZTogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIgPT5cbiAgTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZhbHVlKSk7XG5cbmNvbnN0IHRvQ2x1c3RlckFycmF5ID0gKHZhbHVlOiB1bmtub3duKTogQ2x1c3RlcltdID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIERFRkFVTFRfU0VUVElOR1MuY2x1c3RlcmluZy5jbHVzdGVycztcbiAgcmV0dXJuIHZhbHVlLm1hcCgoZW50cnksIGluZGV4KSA9PiB7XG4gICAgY29uc3Qgb2JqID0gKGVudHJ5ICYmIHR5cGVvZiBlbnRyeSA9PT0gXCJvYmplY3RcIikgPyBlbnRyeSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA6IHt9O1xuICAgIHJldHVybiB7XG4gICAgICBpZDogU3RyaW5nKG9iai5pZCA/PyBgY2wtJHtpbmRleCArIDF9YCksXG4gICAgICBuYW1lOiBTdHJpbmcob2JqLm5hbWUgPz8gYENsdXN0ZXIgJHtpbmRleCArIDF9YCksXG4gICAgICBjb2luczogdG9VcHBlckFycmF5KG9iai5jb2lucyksXG4gICAgfTtcbiAgfSk7XG59O1xuXG5jb25zdCB0b1BhcmFtcyA9ICh2YWx1ZTogdW5rbm93bik6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPT4ge1xuICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHsgLi4uREVGQVVMVF9TRVRUSU5HUy5wYXJhbXMudmFsdWVzIH07XG4gIGNvbnN0IHJlc3VsdDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHsgLi4uREVGQVVMVF9TRVRUSU5HUy5wYXJhbXMudmFsdWVzIH07XG4gIGZvciAoY29uc3QgW2tleSwgcmF3XSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBOdW1iZXIocmF3KTtcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHBhcnNlZCkpIHJlc3VsdFtrZXldID0gcGFyc2VkO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCB0b1BvbGwgPSAodmFsdWU6IHVua25vd24pID0+IHtcbiAgY29uc3QgYmFzZSA9IHtcbiAgICBjeWNsZTQwOiBERUZBVUxUX1NFVFRJTkdTLnBvbGwuY3ljbGU0MCxcbiAgICBjeWNsZTEyMDogREVGQVVMVF9TRVRUSU5HUy5wb2xsLmN5Y2xlMTIwLFxuICAgIHJlZnJlc2hVcmw6IERFRkFVTFRfU0VUVElOR1MucG9sbC5yZWZyZXNoVXJsLFxuICB9O1xuICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIGJhc2U7XG4gIGNvbnN0IG9iaiA9IHZhbHVlIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICBjb25zdCBzYW5pdGl6ZUN5Y2xlID0gKHJhdzogdW5rbm93biwgZmFsbGJhY2s6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHBhcnNlZCA9IE51bWJlcihyYXcpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHBhcnNlZCkpIHJldHVybiBmYWxsYmFjaztcbiAgICBjb25zdCBib3VuZGVkID0gTWF0aC5mbG9vcihwYXJzZWQpO1xuICAgIHJldHVybiBNYXRoLm1heCg1LCBNYXRoLm1pbig2MDAsIGJvdW5kZWQpKTtcbiAgfTtcbiAgY29uc3QgcmVzb2x2ZVVybCA9IChyYXc6IHVua25vd24pOiBzdHJpbmcgfCBudWxsID0+IHtcbiAgICBpZiAodHlwZW9mIHJhdyAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgdHJpbW1lZCA9IHJhdy50cmltKCk7XG4gICAgcmV0dXJuIHRyaW1tZWQubGVuZ3RoID8gdHJpbW1lZCA6IG51bGw7XG4gIH07XG4gIHJldHVybiB7XG4gICAgY3ljbGU0MDogc2FuaXRpemVDeWNsZShvYmouY3ljbGU0MCwgYmFzZS5jeWNsZTQwKSxcbiAgICBjeWNsZTEyMDogc2FuaXRpemVDeWNsZShvYmouY3ljbGUxMjAsIGJhc2UuY3ljbGUxMjApLFxuICAgIHJlZnJlc2hVcmw6XG4gICAgICByZXNvbHZlVXJsKG9iai5yZWZyZXNoVXJsKSA/P1xuICAgICAgcmVzb2x2ZVVybChiYXNlLnJlZnJlc2hVcmwpID8/XG4gICAgICBERUZBVUxUX1NFVFRJTkdTLnBvbGwucmVmcmVzaFVybCxcbiAgfTtcbn07XG5cbi8vIC0tLS0tLS0tLS0gcHVibGljIG1pZ3JhdGlvbiAoZXhpc3RpbmcpIC0tLS0tLS0tLS1cbmV4cG9ydCBmdW5jdGlvbiBtaWdyYXRlU2V0dGluZ3MoaW5wdXQ6IHVua25vd24pOiBBcHBTZXR0aW5ncyB7XG4gIGNvbnN0IHMgPSAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSA/IChpbnB1dCBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikgOiB7fTtcblxuICBjb25zdCBzdGF0c1NvdXJjZSA9IChzLnN0YXRzICYmIHR5cGVvZiBzLnN0YXRzID09PSBcIm9iamVjdFwiKSA/IHMuc3RhdHMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gOiB7fTtcbiAgY29uc3QgdGltaW5nU291cmNlID0gKHMudGltaW5nICYmIHR5cGVvZiBzLnRpbWluZyA9PT0gXCJvYmplY3RcIikgPyBzLnRpbWluZyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA6IHt9O1xuICBjb25zdCB0aW1pbmdDeWNsZXMgPSAodGltaW5nU291cmNlLnN0ckN5Y2xlcyAmJiB0eXBlb2YgdGltaW5nU291cmNlLnN0ckN5Y2xlcyA9PT0gXCJvYmplY3RcIilcbiAgICA/IHRpbWluZ1NvdXJjZS5zdHJDeWNsZXMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgICA6IHt9O1xuXG4gIGNvbnN0IG91dDogQXBwU2V0dGluZ3MgPSB7XG4gICAgdmVyc2lvbjogU0VUVElOR1NfVkVSU0lPTixcbiAgICBjb2luVW5pdmVyc2U6IHRvVXBwZXJBcnJheShzLmNvaW5Vbml2ZXJzZSksXG4gICAgcHJvZmlsZToge1xuICAgICAgbmlja25hbWU6IFN0cmluZygocy5wcm9maWxlIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgdW5kZWZpbmVkKT8ubmlja25hbWUgPz8gXCJcIiksXG4gICAgICBlbWFpbDogU3RyaW5nKChzLnByb2ZpbGUgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCB1bmRlZmluZWQpPy5lbWFpbCA/PyBcIlwiKSxcbiAgICAgIGJpbmFuY2VLZXlJZDogU3RyaW5nKChzLnByb2ZpbGUgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCB1bmRlZmluZWQpPy5iaW5hbmNlS2V5SWQgPz8gXCJcIiksXG4gICAgfSxcbiAgICBzdGF0czoge1xuICAgICAgaGlzdG9ncmFtTGVuOiBNYXRoLm1heCgxNiwgdG9OdW1iZXIoc3RhdHNTb3VyY2UuaGlzdG9ncmFtTGVuLCBERUZBVUxUX1NFVFRJTkdTLnN0YXRzLmhpc3RvZ3JhbUxlbikpLFxuICAgICAgYm1EZWNpbWFsczogY2xhbXAodG9OdW1iZXIoc3RhdHNTb3VyY2UuYm1EZWNpbWFscywgREVGQVVMVF9TRVRUSU5HUy5zdGF0cy5ibURlY2ltYWxzKSwgMCwgNiksXG4gICAgICBpZFBjdERlY2ltYWxzOiBjbGFtcCh0b051bWJlcihzdGF0c1NvdXJjZS5pZFBjdERlY2ltYWxzLCBERUZBVUxUX1NFVFRJTkdTLnN0YXRzLmlkUGN0RGVjaW1hbHMpLCAwLCA4KSxcbiAgICB9LFxuICAgIHBvbGw6IHRvUG9sbChzLnBvbGwpLFxuICAgIHRpbWluZzoge1xuICAgICAgYXV0b1JlZnJlc2g6IEJvb2xlYW4odGltaW5nU291cmNlLmF1dG9SZWZyZXNoID8/IERFRkFVTFRfU0VUVElOR1MudGltaW5nLmF1dG9SZWZyZXNoKSxcbiAgICAgIGF1dG9SZWZyZXNoTXM6IE1hdGgubWF4KDUwMCwgdG9OdW1iZXIodGltaW5nU291cmNlLmF1dG9SZWZyZXNoTXMsIERFRkFVTFRfU0VUVElOR1MudGltaW5nLmF1dG9SZWZyZXNoTXMpKSxcbiAgICAgIHNlY29uZGFyeUVuYWJsZWQ6IEJvb2xlYW4odGltaW5nU291cmNlLnNlY29uZGFyeUVuYWJsZWQgPz8gREVGQVVMVF9TRVRUSU5HUy50aW1pbmcuc2Vjb25kYXJ5RW5hYmxlZCksXG4gICAgICBzZWNvbmRhcnlDeWNsZXM6IGNsYW1wKHRvTnVtYmVyKHRpbWluZ1NvdXJjZS5zZWNvbmRhcnlDeWNsZXMsIERFRkFVTFRfU0VUVElOR1MudGltaW5nLnNlY29uZGFyeUN5Y2xlcyksIDEsIDEwKSxcbiAgICAgIHN0ckN5Y2xlczoge1xuICAgICAgICBtMzA6IE1hdGgubWF4KDEsIHRvTnVtYmVyKHRpbWluZ0N5Y2xlcy5tMzAsIERFRkFVTFRfU0VUVElOR1MudGltaW5nLnN0ckN5Y2xlcy5tMzApKSxcbiAgICAgICAgaDE6IE1hdGgubWF4KDEsIHRvTnVtYmVyKHRpbWluZ0N5Y2xlcy5oMSwgREVGQVVMVF9TRVRUSU5HUy50aW1pbmcuc3RyQ3ljbGVzLmgxKSksXG4gICAgICAgIGgzOiBNYXRoLm1heCgxLCB0b051bWJlcih0aW1pbmdDeWNsZXMuaDMsIERFRkFVTFRfU0VUVElOR1MudGltaW5nLnN0ckN5Y2xlcy5oMykpLFxuICAgICAgfSxcbiAgICB9LFxuICAgIGNsdXN0ZXJpbmc6IHsgY2x1c3RlcnM6IHRvQ2x1c3RlckFycmF5KChzLmNsdXN0ZXJpbmcgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCB1bmRlZmluZWQpPy5jbHVzdGVycykgfSxcbiAgICBwYXJhbXM6IHsgdmFsdWVzOiB0b1BhcmFtcygocy5wYXJhbXMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCB1bmRlZmluZWQpPy52YWx1ZXMpIH0sXG4gIH07XG5cbiAgaWYgKG91dC5jb2luVW5pdmVyc2UubGVuZ3RoID09PSAwKSB7XG4gICAgb3V0LmNvaW5Vbml2ZXJzZSA9IFsuLi5ERUZBVUxUX1NFVFRJTkdTLmNvaW5Vbml2ZXJzZV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuXG4vLyAtLS0tLS0tLS0tIE5FVzogcHVibGljLCBlcmdvbm9taWMgaGVscGVycyAtLS0tLS0tLS0tXG4vKiogRGVlcCBwYXJ0aWFsIHR5cGUgZm9yIGVyZ29ub21pYyBwYXRjaGluZy9jcmVhdGlvbi4gKi9cbmV4cG9ydCB0eXBlIERlZXBQYXJ0aWFsPFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUXT86IFRbS10gZXh0ZW5kcyBvYmplY3QgPyBEZWVwUGFydGlhbDxUW0tdPiA6IFRbS107XG59O1xuXG4vKiogTm9ybWFsaXplIGNvaW5zIGZyb20gYSBzdHJpbmcgKGNvbW1hL3NwYWNlLXNlcGFyYXRlZCkgb3IgYXJyYXk7IGVuc3VyZXMgVVNEVCBwcmVzZW50IGFuZCB1cHBlcmNhc2UrZGVkdXBlZC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVDb2luVW5pdmVyc2UoaW5wdXQ6IHN0cmluZyB8IHN0cmluZ1tdIHwgdW5rbm93bik6IHN0cmluZ1tdIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSByZXR1cm4gdG9VcHBlckFycmF5KGlucHV0KTtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHBhcnRzID0gaW5wdXQuc3BsaXQoL1ssXFxzXSsvKS5tYXAocyA9PiBzLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIHJldHVybiB0b1VwcGVyQXJyYXkocGFydHMpO1xuICB9XG4gIHJldHVybiB0b1VwcGVyQXJyYXkoW10pO1xufVxuXG4vKiogVHlwZSBndWFyZCB0byBjaGVjayBpZiBhbiBvYmplY3QgYWxyZWFkeSBsb29rcyBsaWtlIGFuIEFwcFNldHRpbmdzIGFmdGVyIG1pZ3JhdGlvbi4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FwcFNldHRpbmdzKHg6IHVua25vd24pOiB4IGlzIEFwcFNldHRpbmdzIHtcbiAgcmV0dXJuICEheCAmJiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiBcInZlcnNpb25cIiBpbiAoeCBhcyBhbnkpICYmIFwiY29pblVuaXZlcnNlXCIgaW4gKHggYXMgYW55KTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IOKAlCBjcmVhdGUgYSBub3JtYWxpemVkIEFwcFNldHRpbmdzIG9iamVjdC5cbiAqIC0gSWYgeW91IHBhc3Mgbm90aGluZywgeW91IGdldCBtaWdyYXRlZCBERUZBVUxUX1NFVFRJTkdTLlxuICogLSBJZiB5b3UgcGFzcyBhIGRlZXAtcGFydGlhbCBvciBhbnkgdW5rbm93biwgaXQgaXMgbWlncmF0ZWQgc2FmZWx5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gQXBwU2V0dGluZ3MoaW5wdXQ/OiBEZWVwUGFydGlhbDxBcHBTZXR0aW5ncz4gfCB1bmtub3duKTogQXBwU2V0dGluZ3Mge1xuICByZXR1cm4gbWlncmF0ZVNldHRpbmdzKGlucHV0ID8/IERFRkFVTFRfU0VUVElOR1MpO1xufVxuXG4vKiogTWVyZ2UgYSBiYXNlIEFwcFNldHRpbmdzIHdpdGggYSBkZWVwLXBhcnRpYWwgcGF0Y2gsIHRoZW4gbm9ybWFsaXplLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQXBwU2V0dGluZ3MoYmFzZTogQXBwU2V0dGluZ3MsIHBhdGNoOiBEZWVwUGFydGlhbDxBcHBTZXR0aW5ncz4pOiBBcHBTZXR0aW5ncyB7XG4gIC8vIHNoYWxsb3ctbWVyZ2UgYXQgdG9wIGxldmVsOyBuZXN0ZWQgb2JqZWN0cyBhcmUgcmUtdmFsaWRhdGVkIGJ5IG1pZ3JhdGVTZXR0aW5nc1xuICByZXR1cm4gbWlncmF0ZVNldHRpbmdzKHsgLi4uYmFzZSwgLi4ucGF0Y2ggfSk7XG59XG4iXSwibmFtZXMiOlsiU0VUVElOR1NfVkVSU0lPTiIsIkRFRkFVTFRfU0VUVElOR1MiLCJ2ZXJzaW9uIiwiY29pblVuaXZlcnNlIiwicHJvZmlsZSIsIm5pY2tuYW1lIiwiZW1haWwiLCJiaW5hbmNlS2V5SWQiLCJzdGF0cyIsImhpc3RvZ3JhbUxlbiIsImJtRGVjaW1hbHMiLCJpZFBjdERlY2ltYWxzIiwicG9sbCIsImN5Y2xlNDAiLCJjeWNsZTEyMCIsInJlZnJlc2hVcmwiLCJ0aW1pbmciLCJhdXRvUmVmcmVzaCIsImF1dG9SZWZyZXNoTXMiLCJzZWNvbmRhcnlFbmFibGVkIiwic2Vjb25kYXJ5Q3ljbGVzIiwic3RyQ3ljbGVzIiwibTMwIiwiaDEiLCJoMyIsImNsdXN0ZXJpbmciLCJjbHVzdGVycyIsImlkIiwibmFtZSIsImNvaW5zIiwicGFyYW1zIiwidmFsdWVzIiwiZXRhIiwiZXBzaWxvbiIsImlvdGEiLCJ0b1VwcGVyQXJyYXkiLCJ2YWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsInNlZW4iLCJTZXQiLCJyZXN1bHQiLCJlbnRyeSIsInVwcGVyIiwiU3RyaW5nIiwidHJpbSIsInRvVXBwZXJDYXNlIiwiaGFzIiwiYWRkIiwicHVzaCIsInRvTnVtYmVyIiwiZmFsbGJhY2siLCJwYXJzZWQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImNsYW1wIiwibWluIiwibWF4IiwiTWF0aCIsInRvQ2x1c3RlckFycmF5IiwibWFwIiwiaW5kZXgiLCJvYmoiLCJ0b1BhcmFtcyIsImtleSIsInJhdyIsIk9iamVjdCIsImVudHJpZXMiLCJ0b1BvbGwiLCJiYXNlIiwic2FuaXRpemVDeWNsZSIsImJvdW5kZWQiLCJmbG9vciIsInJlc29sdmVVcmwiLCJ0cmltbWVkIiwibGVuZ3RoIiwibWlncmF0ZVNldHRpbmdzIiwiaW5wdXQiLCJzIiwic3RhdHNTb3VyY2UiLCJ0aW1pbmdTb3VyY2UiLCJ0aW1pbmdDeWNsZXMiLCJvdXQiLCJCb29sZWFuIiwibm9ybWFsaXplQ29pblVuaXZlcnNlIiwicGFydHMiLCJzcGxpdCIsImZpbHRlciIsImlzQXBwU2V0dGluZ3MiLCJ4IiwiQXBwU2V0dGluZ3MiLCJtZXJnZUFwcFNldHRpbmdzIiwicGF0Y2giXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/settings/schema.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/settings/server.ts":
/*!************************************!*\
  !*** ./src/lib/settings/server.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAll: () => (/* binding */ getAll),\n/* harmony export */   resolveCoinsFromSettings: () => (/* binding */ resolveCoinsFromSettings),\n/* harmony export */   serializeSettingsCookie: () => (/* binding */ serializeSettingsCookie),\n/* harmony export */   setAll: () => (/* binding */ setAll)\n/* harmony export */ });\n/* harmony import */ var private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! private-next-rsc-server-reference */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js\");\n/* harmony import */ var private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! private-next-rsc-action-encryption */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/app-render/encryption.js\");\n/* harmony import */ var private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_headers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/headers */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/api/headers.js\");\n/* harmony import */ var _lib_settings_coin_universe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/settings/coin-universe */ \"(rsc)/./src/lib/settings/coin-universe.ts\");\n/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./schema */ \"(rsc)/./src/lib/settings/schema.ts\");\n/* harmony import */ var private_next_rsc_action_validate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! private-next-rsc-action-validate */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-flight-loader/action-validate.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_settings_coin_universe__WEBPACK_IMPORTED_MODULE_3__]);\n_lib_settings_coin_universe__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n// src/lib/settings/server.ts\n/* __next_internal_action_entry_do_not_use__ {\"00532f31c65bd9d7119874b7c000efa42c3a9e2e3a\":\"getAll\",\"00696b0d07c16ebe05246c326940d3b9133dac036c\":\"resolveCoinsFromSettings\",\"402b519d81502a95cf319ddb5b60bce32907aa6f08\":\"setAll\",\"40f9a1c8f3a3ab5d85ba51065396bf00a061db869e\":\"serializeSettingsCookie\"} */ \n\n\n\n\nconst COOKIE_KEY = \"appSettings\";\nconst LEGACY_COOKIE_KEYS = [\n    \"cp_settings_v1\"\n];\nconst ONE_YEAR = 60 * 60 * 24 * 365;\nfunction safeParseJSON(value) {\n    if (!value) return null;\n    try {\n        return JSON.parse(value);\n    } catch  {\n        return null;\n    }\n}\nasync function getAll() {\n    const jar = await (0,next_headers__WEBPACK_IMPORTED_MODULE_2__.cookies)();\n    const raw = jar.get(COOKIE_KEY)?.value;\n    const parsed = safeParseJSON(raw);\n    const settings = (0,_schema__WEBPACK_IMPORTED_MODULE_4__.migrateSettings)(parsed ?? _schema__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_SETTINGS);\n    const dbCoins = await (0,_lib_settings_coin_universe__WEBPACK_IMPORTED_MODULE_3__.fetchCoinUniverseBases)({\n        onlyEnabled: true\n    });\n    settings.coinUniverse = dbCoins.length ? dbCoins : (0,_lib_settings_coin_universe__WEBPACK_IMPORTED_MODULE_3__.normalizeCoinList)(settings.coinUniverse);\n    return settings;\n}\nasync function serializeSettingsCookie(nextValue) {\n    const current = await getAll();\n    const merged = (0,_schema__WEBPACK_IMPORTED_MODULE_4__.migrateSettings)({\n        ...current,\n        ...nextValue\n    });\n    const normalizedCoins = (0,_lib_settings_coin_universe__WEBPACK_IMPORTED_MODULE_3__.normalizeCoinList)(merged.coinUniverse);\n    await (0,_lib_settings_coin_universe__WEBPACK_IMPORTED_MODULE_3__.syncCoinUniverseFromBases)(normalizedCoins);\n    const normalized = {\n        ...merged,\n        coinUniverse: normalizedCoins\n    };\n    const value = JSON.stringify(normalized);\n    const cookie = {\n        name: COOKIE_KEY,\n        value,\n        options: {\n            httpOnly: false,\n            sameSite: \"lax\",\n            path: \"/\",\n            maxAge: ONE_YEAR\n        }\n    };\n    await (0,_lib_settings_coin_universe__WEBPACK_IMPORTED_MODULE_3__.recordSettingsCookieSnapshot)(value);\n    return {\n        settings: normalized,\n        cookie\n    };\n}\nasync function setAll(nextValue) {\n    const jar = await (0,next_headers__WEBPACK_IMPORTED_MODULE_2__.cookies)();\n    const { settings, cookie } = await serializeSettingsCookie(nextValue);\n    jar.set(cookie.name, cookie.value, cookie.options);\n    const mutable = jar;\n    if (mutable.delete) {\n        for (const legacy of LEGACY_COOKIE_KEYS){\n            if (legacy !== cookie.name) mutable.delete(legacy);\n        }\n    }\n    return settings;\n}\nasync function resolveCoinsFromSettings() {\n    const dbCoins = await (0,_lib_settings_coin_universe__WEBPACK_IMPORTED_MODULE_3__.fetchCoinUniverseBases)({\n        onlyEnabled: true\n    });\n    if (dbCoins.length) return dbCoins;\n    return (0,_lib_settings_coin_universe__WEBPACK_IMPORTED_MODULE_3__.normalizeCoinList)(_schema__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_SETTINGS.coinUniverse);\n}\n\n(0,private_next_rsc_action_validate__WEBPACK_IMPORTED_MODULE_5__.ensureServerEntryExports)([\n    getAll,\n    serializeSettingsCookie,\n    setAll,\n    resolveCoinsFromSettings\n]);\n(0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(getAll, \"00532f31c65bd9d7119874b7c000efa42c3a9e2e3a\", null);\n(0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(serializeSettingsCookie, \"40f9a1c8f3a3ab5d85ba51065396bf00a061db869e\", null);\n(0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(setAll, \"402b519d81502a95cf319ddb5b60bce32907aa6f08\", null);\n(0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(resolveCoinsFromSettings, \"00696b0d07c16ebe05246c326940d3b9133dac036c\", null);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL3NldHRpbmdzL3NlcnZlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZCQUE2Qjs7O0FBR1U7QUFNRDtBQUN5QztBQUUvRSxNQUFNTyxhQUFhO0FBQ25CLE1BQU1DLHFCQUFxQjtJQUFDO0NBQWlCO0FBQzdDLE1BQU1DLFdBQVcsS0FBSyxLQUFLLEtBQUs7QUFFaEMsU0FBU0MsY0FBY0MsS0FBZ0M7SUFDckQsSUFBSSxDQUFDQSxPQUFPLE9BQU87SUFDbkIsSUFBSTtRQUNGLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0Y7SUFDcEIsRUFBRSxPQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0Y7QUFFTyxlQUFlRztJQUNwQixNQUFNQyxNQUFNLE1BQU1mLHFEQUFPQTtJQUN6QixNQUFNZ0IsTUFBTUQsSUFBSUUsR0FBRyxDQUFDVixhQUFhSTtJQUNqQyxNQUFNTyxTQUFTUixjQUFjTTtJQUM3QixNQUFNRyxXQUFXYix3REFBZUEsQ0FBQ1ksVUFBVWIscURBQWdCQTtJQUMzRCxNQUFNZSxVQUFVLE1BQU1uQixtRkFBc0JBLENBQUM7UUFBRW9CLGFBQWE7SUFBSztJQUNqRUYsU0FBU0csWUFBWSxHQUFHRixRQUFRRyxNQUFNLEdBQUdILFVBQVVsQiw4RUFBaUJBLENBQUNpQixTQUFTRyxZQUFZO0lBQzFGLE9BQU9IO0FBQ1Q7QUFFTyxlQUFlSyx3QkFBd0JDLFNBQWtCO0lBSTlELE1BQU1DLFVBQVUsTUFBTVo7SUFDdEIsTUFBTWEsU0FBU3JCLHdEQUFlQSxDQUFDO1FBQUUsR0FBR29CLE9BQU87UUFBRSxHQUFJRCxTQUFTO0lBQVM7SUFFbkUsTUFBTUcsa0JBQWtCMUIsOEVBQWlCQSxDQUFDeUIsT0FBT0wsWUFBWTtJQUM3RCxNQUFNbEIsc0ZBQXlCQSxDQUFDd0I7SUFFaEMsTUFBTUMsYUFBMEI7UUFDOUIsR0FBR0YsTUFBTTtRQUNUTCxjQUFjTTtJQUNoQjtJQUVBLE1BQU1qQixRQUFRQyxLQUFLa0IsU0FBUyxDQUFDRDtJQUM3QixNQUFNRSxTQUFTO1FBQ2JDLE1BQU16QjtRQUNOSTtRQUNBc0IsU0FBUztZQUNQQyxVQUFVO1lBQ1ZDLFVBQVU7WUFDVkMsTUFBTTtZQUNOQyxRQUFRNUI7UUFDVjtJQUNGO0lBRUEsTUFBTU4seUZBQTRCQSxDQUFDUTtJQUVuQyxPQUFPO1FBQUVRLFVBQVVVO1FBQVlFO0lBQU87QUFDeEM7QUFFTyxlQUFlTyxPQUFPYixTQUFrQjtJQUM3QyxNQUFNVixNQUFNLE1BQU1mLHFEQUFPQTtJQUN6QixNQUFNLEVBQUVtQixRQUFRLEVBQUVZLE1BQU0sRUFBRSxHQUFHLE1BQU1QLHdCQUF3QkM7SUFDM0RWLElBQUl3QixHQUFHLENBQUNSLE9BQU9DLElBQUksRUFBRUQsT0FBT3BCLEtBQUssRUFBRW9CLE9BQU9FLE9BQU87SUFFakQsTUFBTU8sVUFBVXpCO0lBQ2hCLElBQUl5QixRQUFRQyxNQUFNLEVBQUU7UUFDbEIsS0FBSyxNQUFNQyxVQUFVbEMsbUJBQW9CO1lBQ3ZDLElBQUlrQyxXQUFXWCxPQUFPQyxJQUFJLEVBQUVRLFFBQVFDLE1BQU0sQ0FBQ0M7UUFDN0M7SUFDRjtJQUNBLE9BQU92QjtBQUNUO0FBRU8sZUFBZXdCO0lBQ3BCLE1BQU12QixVQUFVLE1BQU1uQixtRkFBc0JBLENBQUM7UUFBRW9CLGFBQWE7SUFBSztJQUNqRSxJQUFJRCxRQUFRRyxNQUFNLEVBQUUsT0FBT0g7SUFDM0IsT0FBT2xCLDhFQUFpQkEsQ0FBQ0cscURBQWdCQSxDQUFDaUIsWUFBWTtBQUN4RDs7O0lBNURzQlI7SUFVQVU7SUFnQ0FjO0lBY0FLOztBQXhEQTdCLDBGQUFBQSxDQUFBQTtBQVVBVSwwRkFBQUEsQ0FBQUE7QUFnQ0FjLDBGQUFBQSxDQUFBQTtBQWNBSywwRkFBQUEsQ0FBQUEiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxsaWJcXHNldHRpbmdzXFxzZXJ2ZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2xpYi9zZXR0aW5ncy9zZXJ2ZXIudHNcblwidXNlIHNlcnZlclwiO1xuXG5pbXBvcnQgeyBjb29raWVzIH0gZnJvbSBcIm5leHQvaGVhZGVyc1wiO1xuaW1wb3J0IHtcbiAgZmV0Y2hDb2luVW5pdmVyc2VCYXNlcyxcbiAgbm9ybWFsaXplQ29pbkxpc3QsXG4gIHJlY29yZFNldHRpbmdzQ29va2llU25hcHNob3QsXG4gIHN5bmNDb2luVW5pdmVyc2VGcm9tQmFzZXMsXG59IGZyb20gXCJAL2xpYi9zZXR0aW5ncy9jb2luLXVuaXZlcnNlXCI7XG5pbXBvcnQgeyBERUZBVUxUX1NFVFRJTkdTLCBtaWdyYXRlU2V0dGluZ3MsIHR5cGUgQXBwU2V0dGluZ3MgfSBmcm9tIFwiLi9zY2hlbWFcIjtcblxuY29uc3QgQ09PS0lFX0tFWSA9IFwiYXBwU2V0dGluZ3NcIjtcbmNvbnN0IExFR0FDWV9DT09LSUVfS0VZUyA9IFtcImNwX3NldHRpbmdzX3YxXCJdO1xuY29uc3QgT05FX1lFQVIgPSA2MCAqIDYwICogMjQgKiAzNjU7XG5cbmZ1bmN0aW9uIHNhZmVQYXJzZUpTT04odmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGwpOiBhbnkgfCBudWxsIHtcbiAgaWYgKCF2YWx1ZSkgcmV0dXJuIG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsKCk6IFByb21pc2U8QXBwU2V0dGluZ3M+IHtcbiAgY29uc3QgamFyID0gYXdhaXQgY29va2llcygpO1xuICBjb25zdCByYXcgPSBqYXIuZ2V0KENPT0tJRV9LRVkpPy52YWx1ZTtcbiAgY29uc3QgcGFyc2VkID0gc2FmZVBhcnNlSlNPTihyYXcpO1xuICBjb25zdCBzZXR0aW5ncyA9IG1pZ3JhdGVTZXR0aW5ncyhwYXJzZWQgPz8gREVGQVVMVF9TRVRUSU5HUyk7XG4gIGNvbnN0IGRiQ29pbnMgPSBhd2FpdCBmZXRjaENvaW5Vbml2ZXJzZUJhc2VzKHsgb25seUVuYWJsZWQ6IHRydWUgfSk7XG4gIHNldHRpbmdzLmNvaW5Vbml2ZXJzZSA9IGRiQ29pbnMubGVuZ3RoID8gZGJDb2lucyA6IG5vcm1hbGl6ZUNvaW5MaXN0KHNldHRpbmdzLmNvaW5Vbml2ZXJzZSk7XG4gIHJldHVybiBzZXR0aW5ncztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlcmlhbGl6ZVNldHRpbmdzQ29va2llKG5leHRWYWx1ZTogdW5rbm93bik6IFByb21pc2U8e1xuICBzZXR0aW5nczogQXBwU2V0dGluZ3M7XG4gIGNvb2tpZTogeyBuYW1lOiBzdHJpbmc7IHZhbHVlOiBzdHJpbmc7IG9wdGlvbnM6IFBhcmFtZXRlcnM8QXdhaXRlZDxSZXR1cm5UeXBlPHR5cGVvZiBjb29raWVzPj5bXCJzZXRcIl0+WzJdIH07XG59PiB7XG4gIGNvbnN0IGN1cnJlbnQgPSBhd2FpdCBnZXRBbGwoKTtcbiAgY29uc3QgbWVyZ2VkID0gbWlncmF0ZVNldHRpbmdzKHsgLi4uY3VycmVudCwgLi4uKG5leHRWYWx1ZSBhcyBhbnkpIH0pO1xuXG4gIGNvbnN0IG5vcm1hbGl6ZWRDb2lucyA9IG5vcm1hbGl6ZUNvaW5MaXN0KG1lcmdlZC5jb2luVW5pdmVyc2UpO1xuICBhd2FpdCBzeW5jQ29pblVuaXZlcnNlRnJvbUJhc2VzKG5vcm1hbGl6ZWRDb2lucyk7XG5cbiAgY29uc3Qgbm9ybWFsaXplZDogQXBwU2V0dGluZ3MgPSB7XG4gICAgLi4ubWVyZ2VkLFxuICAgIGNvaW5Vbml2ZXJzZTogbm9ybWFsaXplZENvaW5zLFxuICB9O1xuXG4gIGNvbnN0IHZhbHVlID0gSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZCk7XG4gIGNvbnN0IGNvb2tpZSA9IHtcbiAgICBuYW1lOiBDT09LSUVfS0VZLFxuICAgIHZhbHVlLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGh0dHBPbmx5OiBmYWxzZSxcbiAgICAgIHNhbWVTaXRlOiBcImxheFwiIGFzIGNvbnN0LFxuICAgICAgcGF0aDogXCIvXCIsXG4gICAgICBtYXhBZ2U6IE9ORV9ZRUFSLFxuICAgIH0sXG4gIH07XG5cbiAgYXdhaXQgcmVjb3JkU2V0dGluZ3NDb29raWVTbmFwc2hvdCh2YWx1ZSk7XG5cbiAgcmV0dXJuIHsgc2V0dGluZ3M6IG5vcm1hbGl6ZWQsIGNvb2tpZSB9O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0QWxsKG5leHRWYWx1ZTogdW5rbm93bik6IFByb21pc2U8QXBwU2V0dGluZ3M+IHtcbiAgY29uc3QgamFyID0gYXdhaXQgY29va2llcygpO1xuICBjb25zdCB7IHNldHRpbmdzLCBjb29raWUgfSA9IGF3YWl0IHNlcmlhbGl6ZVNldHRpbmdzQ29va2llKG5leHRWYWx1ZSk7XG4gIGphci5zZXQoY29va2llLm5hbWUsIGNvb2tpZS52YWx1ZSwgY29va2llLm9wdGlvbnMpO1xuXG4gIGNvbnN0IG11dGFibGUgPSBqYXIgYXMgdW5rbm93biBhcyB7IGRlbGV0ZT86IChuYW1lOiBzdHJpbmcpID0+IHZvaWQgfTtcbiAgaWYgKG11dGFibGUuZGVsZXRlKSB7XG4gICAgZm9yIChjb25zdCBsZWdhY3kgb2YgTEVHQUNZX0NPT0tJRV9LRVlTKSB7XG4gICAgICBpZiAobGVnYWN5ICE9PSBjb29raWUubmFtZSkgbXV0YWJsZS5kZWxldGUobGVnYWN5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNldHRpbmdzO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUNvaW5zRnJvbVNldHRpbmdzKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgY29uc3QgZGJDb2lucyA9IGF3YWl0IGZldGNoQ29pblVuaXZlcnNlQmFzZXMoeyBvbmx5RW5hYmxlZDogdHJ1ZSB9KTtcbiAgaWYgKGRiQ29pbnMubGVuZ3RoKSByZXR1cm4gZGJDb2lucztcbiAgcmV0dXJuIG5vcm1hbGl6ZUNvaW5MaXN0KERFRkFVTFRfU0VUVElOR1MuY29pblVuaXZlcnNlKTtcbn1cbiJdLCJuYW1lcyI6WyJjb29raWVzIiwiZmV0Y2hDb2luVW5pdmVyc2VCYXNlcyIsIm5vcm1hbGl6ZUNvaW5MaXN0IiwicmVjb3JkU2V0dGluZ3NDb29raWVTbmFwc2hvdCIsInN5bmNDb2luVW5pdmVyc2VGcm9tQmFzZXMiLCJERUZBVUxUX1NFVFRJTkdTIiwibWlncmF0ZVNldHRpbmdzIiwiQ09PS0lFX0tFWSIsIkxFR0FDWV9DT09LSUVfS0VZUyIsIk9ORV9ZRUFSIiwic2FmZVBhcnNlSlNPTiIsInZhbHVlIiwiSlNPTiIsInBhcnNlIiwiZ2V0QWxsIiwiamFyIiwicmF3IiwiZ2V0IiwicGFyc2VkIiwic2V0dGluZ3MiLCJkYkNvaW5zIiwib25seUVuYWJsZWQiLCJjb2luVW5pdmVyc2UiLCJsZW5ndGgiLCJzZXJpYWxpemVTZXR0aW5nc0Nvb2tpZSIsIm5leHRWYWx1ZSIsImN1cnJlbnQiLCJtZXJnZWQiLCJub3JtYWxpemVkQ29pbnMiLCJub3JtYWxpemVkIiwic3RyaW5naWZ5IiwiY29va2llIiwibmFtZSIsIm9wdGlvbnMiLCJodHRwT25seSIsInNhbWVTaXRlIiwicGF0aCIsIm1heEFnZSIsInNldEFsbCIsInNldCIsIm11dGFibGUiLCJkZWxldGUiLCJsZWdhY3kiLCJyZXNvbHZlQ29pbnNGcm9tU2V0dGluZ3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/settings/server.ts\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!**************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \**************************************************************************************************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "../app-render/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/server/app-render/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/action-async-storage.external.js");

/***/ }),

/***/ "../app-render/after-task-async-storage.external":
/*!***********************************************************************************!*\
  !*** external "next/dist/server/app-render/after-task-async-storage.external.js" ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ "../app-render/work-async-storage.external":
/*!*****************************************************************************!*\
  !*** external "next/dist/server/app-render/work-async-storage.external.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ "../app-render/work-unit-async-storage.external":
/*!**********************************************************************************!*\
  !*** external "next/dist/server/app-render/work-unit-async-storage.external.js" ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "module":
/*!*************************!*\
  !*** external "module" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("module");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "next/dist/shared/lib/no-fallback-error.external":
/*!******************************************************************!*\
  !*** external "next/dist/shared/lib/no-fallback-error.external" ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/no-fallback-error.external");

/***/ }),

/***/ "next/dist/shared/lib/router/utils/app-paths":
/*!**************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/app-paths" ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/app-paths");

/***/ }),

/***/ "node:child_process":
/*!*************************************!*\
  !*** external "node:child_process" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:child_process");

/***/ }),

/***/ "node:fs":
/*!**************************!*\
  !*** external "node:fs" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:fs");

/***/ }),

/***/ "node:path":
/*!****************************!*\
  !*** external "node:path" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:path");

/***/ }),

/***/ "node:url":
/*!***************************!*\
  !*** external "node:url" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:url");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "pg":
/*!*********************!*\
  !*** external "pg" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = import("pg");;

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5"], () => (__webpack_exec__("(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fmoo-aux%2Froute&page=%2Fapi%2Fmoo-aux%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fmoo-aux%2Froute.ts&appDir=H%3A%5CUsers%5CGus%5Csource%5Crepo%5Cdynamics%5Cdynamics-b%5Ccryptopi-dynamics%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=H%3A%5CUsers%5CGus%5Csource%5Crepo%5Cdynamics%5Cdynamics-b%5Ccryptopi-dynamics&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!")));
module.exports = __webpack_exports__;

})();