/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/str-aux/stats/route";
exports.ids = ["app/api/str-aux/stats/route"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fstr-aux%2Fstats%2Froute&page=%2Fapi%2Fstr-aux%2Fstats%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fstr-aux%2Fstats%2Froute.ts&appDir=H%3A%5CUsers%5CGus%5Csource%5Crepo%5Cdynamics%5Cdynamics-b%5Ccryptopi-dynamics%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=H%3A%5CUsers%5CGus%5Csource%5Crepo%5Cdynamics%5Cdynamics-b%5Ccryptopi-dynamics&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fstr-aux%2Fstats%2Froute&page=%2Fapi%2Fstr-aux%2Fstats%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fstr-aux%2Fstats%2Froute.ts&appDir=H%3A%5CUsers%5CGus%5Csource%5Crepo%5Cdynamics%5Cdynamics-b%5Ccryptopi-dynamics%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=H%3A%5CUsers%5CGus%5Csource%5Crepo%5Cdynamics%5Cdynamics-b%5Ccryptopi-dynamics&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=! ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handler: () => (/* binding */ handler),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   workAsyncStorage: () => (/* binding */ workAsyncStorage),\n/* harmony export */   workUnitAsyncStorage: () => (/* binding */ workUnitAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/server/request-meta */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/request-meta.js\");\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/shared/lib/router/utils/app-paths */ \"next/dist/shared/lib/router/utils/app-paths\");\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/base-http/node */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/base-http/node.js\");\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! next/dist/server/web/spec-extension/adapters/next-request */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/web/spec-extension/adapters/next-request.js\");\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! next/dist/server/instrumentation/utils */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/instrumentation/utils.js\");\n/* harmony import */ var next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! next/dist/server/send-response */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/send-response.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! next/dist/server/web/utils */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/web/utils.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! next/dist/server/lib/cache-control */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/lib/cache-control.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! next/dist/lib/constants */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/lib/constants.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! next/dist/shared/lib/no-fallback-error.external */ \"next/dist/shared/lib/no-fallback-error.external\");\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! next/dist/server/response-cache */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/response-cache/index.js\");\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var H_Users_Gus_source_repo_dynamics_dynamics_b_cryptopi_dynamics_src_app_api_str_aux_stats_route_ts__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/app/api/str-aux/stats/route.ts */ \"(rsc)/./src/app/api/str-aux/stats/route.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/str-aux/stats/route\",\n        pathname: \"/api/str-aux/stats\",\n        filename: \"route\",\n        bundlePath: \"app/api/str-aux/stats/route\"\n    },\n    distDir: \".next\" || 0,\n    relativeProjectDir:  false || '',\n    resolvedPagePath: \"H:\\\\Users\\\\Gus\\\\source\\\\repo\\\\dynamics\\\\dynamics-b\\\\cryptopi-dynamics\\\\src\\\\app\\\\api\\\\str-aux\\\\stats\\\\route.ts\",\n    nextConfigOutput,\n    userland: H_Users_Gus_source_repo_dynamics_dynamics_b_cryptopi_dynamics_src_app_api_str_aux_stats_route_ts__WEBPACK_IMPORTED_MODULE_16__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n\nasync function handler(req, res, ctx) {\n    var _nextConfig_experimental;\n    let srcPage = \"/api/str-aux/stats/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {} else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = false;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname } = prepareResult;\n    const normalizedSrcPage = (0,next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__.normalizeAppPath)(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                throw new next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isRevalidate = isIsr && !supportsDynamicResponse;\n    const method = req.method || 'GET';\n    const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.getTracer)();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            supportsDynamicResponse,\n            incrementalCache: (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'incrementalCache'),\n            cacheLifeProfiles: (_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.cacheLife,\n            isRevalidate,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextRequest(req);\n    const nodeNextRes = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextResponse(res);\n    const nextReq = next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.NextRequestAdapter.fromNodeNextRequest(nodeNextReq, (0,next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.signalFromNodeResponse)(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        };\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.toNodeOutgoingHttpHeaders)(response.headers);\n                        if (cacheTags) {\n                            headers[next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                                isRevalidate,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode')) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.fromNodeOutgoingHttpHeaders)(cacheEntry.value.headers);\n            if (!((0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isIsr)) {\n                headers.delete(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', (0,next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__.getCacheControlHeader)(cacheEntry.cacheControl));\n            }\n            await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        // if we aren't wrapped by base-server handle here\n        if (!activeSpan && !(err instanceof next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                    isRevalidate,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS41LjJfQHBsYXl3cmlnaHQrdGVzX2I3ZTZjMjgwZTlhMWI0MzA5MzQ3YzBiZjBhYjQ3NmQ1L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtYXBwLWxvYWRlci9pbmRleC5qcz9uYW1lPWFwcCUyRmFwaSUyRnN0ci1hdXglMkZzdGF0cyUyRnJvdXRlJnBhZ2U9JTJGYXBpJTJGc3RyLWF1eCUyRnN0YXRzJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGc3RyLWF1eCUyRnN0YXRzJTJGcm91dGUudHMmYXBwRGlyPUglM0ElNUNVc2VycyU1Q0d1cyU1Q3NvdXJjZSU1Q3JlcG8lNUNkeW5hbWljcyU1Q2R5bmFtaWNzLWIlNUNjcnlwdG9waS1keW5hbWljcyU1Q3NyYyU1Q2FwcCZwYWdlRXh0ZW5zaW9ucz10c3gmcGFnZUV4dGVuc2lvbnM9dHMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPWpzJnJvb3REaXI9SCUzQSU1Q1VzZXJzJTVDR3VzJTVDc291cmNlJTVDcmVwbyU1Q2R5bmFtaWNzJTVDZHluYW1pY3MtYiU1Q2NyeXB0b3BpLWR5bmFtaWNzJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEJmlzR2xvYmFsTm90Rm91bmRFbmFibGVkPSEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0Y7QUFDdkM7QUFDcUI7QUFDZDtBQUNTO0FBQ087QUFDSztBQUNtQztBQUNqRDtBQUNPO0FBQ2Y7QUFDc0M7QUFDekI7QUFDTTtBQUNDO0FBQ2hCO0FBQ3lFO0FBQzNJO0FBQ0E7QUFDQTtB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O0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3RkFBMkI7QUFDdkQsa0JBQWtCLDZFQUFjO0FBQ2hDLCtCQUErQiw0RUFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMEZBQXFCO0FBQ2xFO0FBQ0Esa0JBQWtCLDZFQUFZO0FBQzlCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZFQUE2RSxnRkFBYztBQUMzRixpQ0FBaUMsUUFBUSxFQUFFLFFBQVE7QUFDbkQsMEJBQTBCLHVFQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNENBQTRDLDZGQUFlO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJGQUFtQjtBQUNyRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2RUFBWTtBQUMxQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgeyBnZXRSZXF1ZXN0TWV0YSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3QtbWV0YVwiO1xuaW1wb3J0IHsgZ2V0VHJhY2VyLCBTcGFuS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi90cmFjZS90cmFjZXJcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZUFwcFBhdGggfSBmcm9tIFwibmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FwcC1wYXRoc1wiO1xuaW1wb3J0IHsgTm9kZU5leHRSZXF1ZXN0LCBOb2RlTmV4dFJlc3BvbnNlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvYmFzZS1odHRwL25vZGVcIjtcbmltcG9ydCB7IE5leHRSZXF1ZXN0QWRhcHRlciwgc2lnbmFsRnJvbU5vZGVSZXNwb25zZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9uZXh0LXJlcXVlc3RcIjtcbmltcG9ydCB7IEJhc2VTZXJ2ZXJTcGFuIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3RyYWNlL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZ2V0UmV2YWxpZGF0ZVJlYXNvbiB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2luc3RydW1lbnRhdGlvbi91dGlsc1wiO1xuaW1wb3J0IHsgc2VuZFJlc3BvbnNlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvc2VuZC1yZXNwb25zZVwiO1xuaW1wb3J0IHsgZnJvbU5vZGVPdXRnb2luZ0h0dHBIZWFkZXJzLCB0b05vZGVPdXRnb2luZ0h0dHBIZWFkZXJzIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvd2ViL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXRDYWNoZUNvbnRyb2xIZWFkZXIgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvY2FjaGUtY29udHJvbFwiO1xuaW1wb3J0IHsgSU5GSU5JVEVfQ0FDSEUsIE5FWFRfQ0FDSEVfVEFHU19IRUFERVIgfSBmcm9tIFwibmV4dC9kaXN0L2xpYi9jb25zdGFudHNcIjtcbmltcG9ydCB7IE5vRmFsbGJhY2tFcnJvciB9IGZyb20gXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9uby1mYWxsYmFjay1lcnJvci5leHRlcm5hbFwiO1xuaW1wb3J0IHsgQ2FjaGVkUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcmVzcG9uc2UtY2FjaGVcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCJIOlxcXFxVc2Vyc1xcXFxHdXNcXFxcc291cmNlXFxcXHJlcG9cXFxcZHluYW1pY3NcXFxcZHluYW1pY3MtYlxcXFxjcnlwdG9waS1keW5hbWljc1xcXFxzcmNcXFxcYXBwXFxcXGFwaVxcXFxzdHItYXV4XFxcXHN0YXRzXFxcXHJvdXRlLnRzXCI7XG4vLyBXZSBpbmplY3QgdGhlIG5leHRDb25maWdPdXRwdXQgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IG5leHRDb25maWdPdXRwdXQgPSBcIlwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9zdHItYXV4L3N0YXRzL3JvdXRlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvc3RyLWF1eC9zdGF0c1wiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvc3RyLWF1eC9zdGF0cy9yb3V0ZVwiXG4gICAgfSxcbiAgICBkaXN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfRElTVF9ESVIgfHwgJycsXG4gICAgcmVsYXRpdmVQcm9qZWN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfUFJPSkVDVF9ESVIgfHwgJycsXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCJIOlxcXFxVc2Vyc1xcXFxHdXNcXFxcc291cmNlXFxcXHJlcG9cXFxcZHluYW1pY3NcXFxcZHluYW1pY3MtYlxcXFxjcnlwdG9waS1keW5hbWljc1xcXFxzcmNcXFxcYXBwXFxcXGFwaVxcXFxzdHItYXV4XFxcXHN0YXRzXFxcXHJvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgd29ya0FzeW5jU3RvcmFnZSwgd29ya1VuaXRBc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgd29ya0FzeW5jU3RvcmFnZSxcbiAgICAgICAgd29ya1VuaXRBc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCB3b3JrQXN5bmNTdG9yYWdlLCB3b3JrVW5pdEFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIHBhdGNoRmV0Y2gsICB9O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxLCByZXMsIGN0eCkge1xuICAgIHZhciBfbmV4dENvbmZpZ19leHBlcmltZW50YWw7XG4gICAgbGV0IHNyY1BhZ2UgPSBcIi9hcGkvc3RyLWF1eC9zdGF0cy9yb3V0ZVwiO1xuICAgIC8vIHR1cmJvcGFjayBkb2Vzbid0IG5vcm1hbGl6ZSBgL2luZGV4YCBpbiB0aGUgcGFnZSBuYW1lXG4gICAgLy8gc28gd2UgbmVlZCB0byB0byBwcm9jZXNzIGR5bmFtaWMgcm91dGVzIHByb3Blcmx5XG4gICAgLy8gVE9ETzogZml4IHR1cmJvcGFjayBwcm92aWRpbmcgZGlmZmVyaW5nIHZhbHVlIGZyb20gd2VicGFja1xuICAgIGlmIChwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICAgICAgc3JjUGFnZSA9IHNyY1BhZ2UucmVwbGFjZSgvXFwvaW5kZXgkLywgJycpIHx8ICcvJztcbiAgICB9IGVsc2UgaWYgKHNyY1BhZ2UgPT09ICcvaW5kZXgnKSB7XG4gICAgICAgIC8vIHdlIGFsd2F5cyBub3JtYWxpemUgL2luZGV4IHNwZWNpZmljYWxseVxuICAgICAgICBzcmNQYWdlID0gJy8nO1xuICAgIH1cbiAgICBjb25zdCBtdWx0aVpvbmVEcmFmdE1vZGUgPSBwcm9jZXNzLmVudi5fX05FWFRfTVVMVElfWk9ORV9EUkFGVF9NT0RFO1xuICAgIGNvbnN0IHByZXBhcmVSZXN1bHQgPSBhd2FpdCByb3V0ZU1vZHVsZS5wcmVwYXJlKHJlcSwgcmVzLCB7XG4gICAgICAgIHNyY1BhZ2UsXG4gICAgICAgIG11bHRpWm9uZURyYWZ0TW9kZVxuICAgIH0pO1xuICAgIGlmICghcHJlcGFyZVJlc3VsdCkge1xuICAgICAgICByZXMuc3RhdHVzQ29kZSA9IDQwMDtcbiAgICAgICAgcmVzLmVuZCgnQmFkIFJlcXVlc3QnKTtcbiAgICAgICAgY3R4LndhaXRVbnRpbCA9PSBudWxsID8gdm9pZCAwIDogY3R4LndhaXRVbnRpbC5jYWxsKGN0eCwgUHJvbWlzZS5yZXNvbHZlKCkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeyBidWlsZElkLCBwYXJhbXMsIG5leHRDb25maWcsIGlzRHJhZnRNb2RlLCBwcmVyZW5kZXJNYW5pZmVzdCwgcm91dGVyU2VydmVyQ29udGV4dCwgaXNPbkRlbWFuZFJldmFsaWRhdGUsIHJldmFsaWRhdGVPbmx5R2VuZXJhdGVkLCByZXNvbHZlZFBhdGhuYW1lIH0gPSBwcmVwYXJlUmVzdWx0O1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRTcmNQYWdlID0gbm9ybWFsaXplQXBwUGF0aChzcmNQYWdlKTtcbiAgICBsZXQgaXNJc3IgPSBCb29sZWFuKHByZXJlbmRlck1hbmlmZXN0LmR5bmFtaWNSb3V0ZXNbbm9ybWFsaXplZFNyY1BhZ2VdIHx8IHByZXJlbmRlck1hbmlmZXN0LnJvdXRlc1tyZXNvbHZlZFBhdGhuYW1lXSk7XG4gICAgaWYgKGlzSXNyICYmICFpc0RyYWZ0TW9kZSkge1xuICAgICAgICBjb25zdCBpc1ByZXJlbmRlcmVkID0gQm9vbGVhbihwcmVyZW5kZXJNYW5pZmVzdC5yb3V0ZXNbcmVzb2x2ZWRQYXRobmFtZV0pO1xuICAgICAgICBjb25zdCBwcmVyZW5kZXJJbmZvID0gcHJlcmVuZGVyTWFuaWZlc3QuZHluYW1pY1JvdXRlc1tub3JtYWxpemVkU3JjUGFnZV07XG4gICAgICAgIGlmIChwcmVyZW5kZXJJbmZvKSB7XG4gICAgICAgICAgICBpZiAocHJlcmVuZGVySW5mby5mYWxsYmFjayA9PT0gZmFsc2UgJiYgIWlzUHJlcmVuZGVyZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9GYWxsYmFja0Vycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNhY2hlS2V5ID0gbnVsbDtcbiAgICBpZiAoaXNJc3IgJiYgIXJvdXRlTW9kdWxlLmlzRGV2ICYmICFpc0RyYWZ0TW9kZSkge1xuICAgICAgICBjYWNoZUtleSA9IHJlc29sdmVkUGF0aG5hbWU7XG4gICAgICAgIC8vIGVuc3VyZSAvaW5kZXggYW5kIC8gaXMgbm9ybWFsaXplZCB0byBvbmUga2V5XG4gICAgICAgIGNhY2hlS2V5ID0gY2FjaGVLZXkgPT09ICcvaW5kZXgnID8gJy8nIDogY2FjaGVLZXk7XG4gICAgfVxuICAgIGNvbnN0IHN1cHBvcnRzRHluYW1pY1Jlc3BvbnNlID0gLy8gSWYgd2UncmUgaW4gZGV2ZWxvcG1lbnQsIHdlIGFsd2F5cyBzdXBwb3J0IGR5bmFtaWMgSFRNTFxuICAgIHJvdXRlTW9kdWxlLmlzRGV2ID09PSB0cnVlIHx8IC8vIElmIHRoaXMgaXMgbm90IFNTRyBvciBkb2VzIG5vdCBoYXZlIHN0YXRpYyBwYXRocywgdGhlbiBpdCBzdXBwb3J0c1xuICAgIC8vIGR5bmFtaWMgSFRNTC5cbiAgICAhaXNJc3I7XG4gICAgLy8gVGhpcyBpcyBhIHJldmFsaWRhdGlvbiByZXF1ZXN0IGlmIHRoZSByZXF1ZXN0IGlzIGZvciBhIHN0YXRpY1xuICAgIC8vIHBhZ2UgYW5kIGl0IGlzIG5vdCBiZWluZyByZXN1bWVkIGZyb20gYSBwb3N0cG9uZWQgcmVuZGVyIGFuZFxuICAgIC8vIGl0IGlzIG5vdCBhIGR5bmFtaWMgUlNDIHJlcXVlc3QgdGhlbiBpdCBpcyBhIHJldmFsaWRhdGlvblxuICAgIC8vIHJlcXVlc3QuXG4gICAgY29uc3QgaXNSZXZhbGlkYXRlID0gaXNJc3IgJiYgIXN1cHBvcnRzRHluYW1pY1Jlc3BvbnNlO1xuICAgIGNvbnN0IG1ldGhvZCA9IHJlcS5tZXRob2QgfHwgJ0dFVCc7XG4gICAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKCk7XG4gICAgY29uc3QgYWN0aXZlU3BhbiA9IHRyYWNlci5nZXRBY3RpdmVTY29wZVNwYW4oKTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHByZXJlbmRlck1hbmlmZXN0LFxuICAgICAgICByZW5kZXJPcHRzOiB7XG4gICAgICAgICAgICBleHBlcmltZW50YWw6IHtcbiAgICAgICAgICAgICAgICBjYWNoZUNvbXBvbmVudHM6IEJvb2xlYW4obmV4dENvbmZpZy5leHBlcmltZW50YWwuY2FjaGVDb21wb25lbnRzKSxcbiAgICAgICAgICAgICAgICBhdXRoSW50ZXJydXB0czogQm9vbGVhbihuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5hdXRoSW50ZXJydXB0cylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdXBwb3J0c0R5bmFtaWNSZXNwb25zZSxcbiAgICAgICAgICAgIGluY3JlbWVudGFsQ2FjaGU6IGdldFJlcXVlc3RNZXRhKHJlcSwgJ2luY3JlbWVudGFsQ2FjaGUnKSxcbiAgICAgICAgICAgIGNhY2hlTGlmZVByb2ZpbGVzOiAoX25leHRDb25maWdfZXhwZXJpbWVudGFsID0gbmV4dENvbmZpZy5leHBlcmltZW50YWwpID09IG51bGwgPyB2b2lkIDAgOiBfbmV4dENvbmZpZ19leHBlcmltZW50YWwuY2FjaGVMaWZlLFxuICAgICAgICAgICAgaXNSZXZhbGlkYXRlLFxuICAgICAgICAgICAgd2FpdFVudGlsOiBjdHgud2FpdFVudGlsLFxuICAgICAgICAgICAgb25DbG9zZTogKGNiKT0+e1xuICAgICAgICAgICAgICAgIHJlcy5vbignY2xvc2UnLCBjYik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25BZnRlclRhc2tFcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb25JbnN0cnVtZW50YXRpb25SZXF1ZXN0RXJyb3I6IChlcnJvciwgX3JlcXVlc3QsIGVycm9yQ29udGV4dCk9PnJvdXRlTW9kdWxlLm9uUmVxdWVzdEVycm9yKHJlcSwgZXJyb3IsIGVycm9yQ29udGV4dCwgcm91dGVyU2VydmVyQ29udGV4dClcbiAgICAgICAgfSxcbiAgICAgICAgc2hhcmVkQ29udGV4dDoge1xuICAgICAgICAgICAgYnVpbGRJZFxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBub2RlTmV4dFJlcSA9IG5ldyBOb2RlTmV4dFJlcXVlc3QocmVxKTtcbiAgICBjb25zdCBub2RlTmV4dFJlcyA9IG5ldyBOb2RlTmV4dFJlc3BvbnNlKHJlcyk7XG4gICAgY29uc3QgbmV4dFJlcSA9IE5leHRSZXF1ZXN0QWRhcHRlci5mcm9tTm9kZU5leHRSZXF1ZXN0KG5vZGVOZXh0UmVxLCBzaWduYWxGcm9tTm9kZVJlc3BvbnNlKHJlcykpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGludm9rZVJvdXRlTW9kdWxlID0gYXN5bmMgKHNwYW4pPT57XG4gICAgICAgICAgICByZXR1cm4gcm91dGVNb2R1bGUuaGFuZGxlKG5leHRSZXEsIGNvbnRleHQpLmZpbmFsbHkoKCk9PntcbiAgICAgICAgICAgICAgICBpZiAoIXNwYW4pIHJldHVybjtcbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAnaHR0cC5zdGF0dXNfY29kZSc6IHJlcy5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgICAnbmV4dC5yc2MnOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvb3RTcGFuQXR0cmlidXRlcyA9IHRyYWNlci5nZXRSb290U3BhbkF0dHJpYnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAvLyBXZSB3ZXJlIHVuYWJsZSB0byBnZXQgYXR0cmlidXRlcywgcHJvYmFibHkgT1RFTCBpcyBub3QgZW5hYmxlZFxuICAgICAgICAgICAgICAgIGlmICghcm9vdFNwYW5BdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RTcGFuQXR0cmlidXRlcy5nZXQoJ25leHQuc3Bhbl90eXBlJykgIT09IEJhc2VTZXJ2ZXJTcGFuLmhhbmRsZVJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmV4cGVjdGVkIHJvb3Qgc3BhbiB0eXBlICcke3Jvb3RTcGFuQXR0cmlidXRlcy5nZXQoJ25leHQuc3Bhbl90eXBlJyl9Jy4gUGxlYXNlIHJlcG9ydCB0aGlzIE5leHQuanMgaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGUgPSByb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnJvdXRlJyk7XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBgJHttZXRob2R9ICR7cm91dGV9YDtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXh0LnJvdXRlJzogcm91dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC5yb3V0ZSc6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ25leHQuc3Bhbl9uYW1lJzogbmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi51cGRhdGVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4udXBkYXRlTmFtZShgJHttZXRob2R9ICR7cmVxLnVybH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFuZGxlUmVzcG9uc2UgPSBhc3luYyAoY3VycmVudFNwYW4pPT57XG4gICAgICAgICAgICB2YXIgX2NhY2hlRW50cnlfdmFsdWU7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUdlbmVyYXRvciA9IGFzeW5jICh7IHByZXZpb3VzQ2FjaGVFbnRyeSB9KT0+e1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2V0UmVxdWVzdE1ldGEocmVxLCAnbWluaW1hbE1vZGUnKSAmJiBpc09uRGVtYW5kUmV2YWxpZGF0ZSAmJiByZXZhbGlkYXRlT25seUdlbmVyYXRlZCAmJiAhcHJldmlvdXNDYWNoZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuc3RhdHVzQ29kZSA9IDQwNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uLWRlbWFuZCByZXZhbGlkYXRlIGFsd2F5cyBzZXRzIHRoaXMgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuc2V0SGVhZGVyKCd4LW5leHRqcy1jYWNoZScsICdSRVZBTElEQVRFRCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmVuZCgnVGhpcyBwYWdlIGNvdWxkIG5vdCBiZSBmb3VuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBpbnZva2VSb3V0ZU1vZHVsZShjdXJyZW50U3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5mZXRjaE1ldHJpY3MgPSBjb250ZXh0LnJlbmRlck9wdHMuZmV0Y2hNZXRyaWNzO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGVuZGluZ1dhaXRVbnRpbCA9IGNvbnRleHQucmVuZGVyT3B0cy5wZW5kaW5nV2FpdFVudGlsO1xuICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHVzaW5nIHByb3ZpZGVkIHdhaXRVbnRpbCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQncyBub3Qgd2UgZmFsbGJhY2sgdG8gc2VuZFJlc3BvbnNlJ3MgaGFuZGxpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdXYWl0VW50aWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHgud2FpdFVudGlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LndhaXRVbnRpbChwZW5kaW5nV2FpdFVudGlsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nV2FpdFVudGlsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlVGFncyA9IGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRUYWdzO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdCBpcyBmb3IgYSBzdGF0aWMgcmVzcG9uc2UsIHdlIGNhbiBjYWNoZSBpdCBzbyBsb25nXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIGl0J3Mgbm90IGVkZ2UuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0lzcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcHkgdGhlIGhlYWRlcnMgZnJvbSB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gdG9Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyhyZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZVRhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW05FWFRfQ0FDSEVfVEFHU19IRUFERVJdID0gY2FjaGVUYWdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoZWFkZXJzWydjb250ZW50LXR5cGUnXSAmJiBibG9iLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IGJsb2IudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldmFsaWRhdGUgPSB0eXBlb2YgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZFJldmFsaWRhdGUgPT09ICd1bmRlZmluZWQnIHx8IGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRSZXZhbGlkYXRlID49IElORklOSVRFX0NBQ0hFID8gZmFsc2UgOiBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkUmV2YWxpZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cGlyZSA9IHR5cGVvZiBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkRXhwaXJlID09PSAndW5kZWZpbmVkJyB8fCBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkRXhwaXJlID49IElORklOSVRFX0NBQ0hFID8gdW5kZWZpbmVkIDogY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgY2FjaGUgZW50cnkgZm9yIHRoZSByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlRW50cnkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogQ2FjaGVkUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IEJ1ZmZlci5mcm9tKGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlQ29udHJvbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZhbGlkYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBpcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlRW50cnk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZW5kIHJlc3BvbnNlIHdpdGhvdXQgY2FjaGluZyBpZiBub3QgSVNSXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCByZXNwb25zZSwgY29udGV4dC5yZW5kZXJPcHRzLnBlbmRpbmdXYWl0VW50aWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGJhY2tncm91bmQgcmV2YWxpZGF0ZSB3ZSBuZWVkIHRvIHJlcG9ydFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCBlcnJvciBoZXJlIGFzIGl0IHdvbid0IGJlIGJ1YmJsZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzQ2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogcHJldmlvdXNDYWNoZUVudHJ5LmlzU3RhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJvdXRlTW9kdWxlLm9uUmVxdWVzdEVycm9yKHJlcSwgZXJyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyS2luZDogJ0FwcCBSb3V0ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlUGF0aDogc3JjUGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVR5cGU6ICdyb3V0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZVJlYXNvbjogZ2V0UmV2YWxpZGF0ZVJlYXNvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNPbkRlbWFuZFJldmFsaWRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcm91dGVyU2VydmVyQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjYWNoZUVudHJ5ID0gYXdhaXQgcm91dGVNb2R1bGUuaGFuZGxlUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgIGNhY2hlS2V5LFxuICAgICAgICAgICAgICAgIHJvdXRlS2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgICAgICAgICBpc0ZhbGxiYWNrOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcmVyZW5kZXJNYW5pZmVzdCxcbiAgICAgICAgICAgICAgICBpc1JvdXRlUFBSRW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNPbkRlbWFuZFJldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0ZU9ubHlHZW5lcmF0ZWQsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VHZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgd2FpdFVudGlsOiBjdHgud2FpdFVudGlsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNyZWF0ZSBhIGNhY2hlRW50cnkgZm9yIElTUlxuICAgICAgICAgICAgaWYgKCFpc0lzcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChjYWNoZUVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiAoX2NhY2hlRW50cnlfdmFsdWUgPSBjYWNoZUVudHJ5LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2NhY2hlRW50cnlfdmFsdWUua2luZCkgIT09IENhY2hlZFJvdXRlS2luZC5BUFBfUk9VVEUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2NhY2hlRW50cnlfdmFsdWUxO1xuICAgICAgICAgICAgICAgIHRocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgRXJyb3IoYEludmFyaWFudDogYXBwLXJvdXRlIHJlY2VpdmVkIGludmFsaWQgY2FjaGUgZW50cnkgJHtjYWNoZUVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiAoX2NhY2hlRW50cnlfdmFsdWUxID0gY2FjaGVFbnRyeS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jYWNoZUVudHJ5X3ZhbHVlMS5raW5kfWApLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiRTcwMVwiLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWdldFJlcXVlc3RNZXRhKHJlcSwgJ21pbmltYWxNb2RlJykpIHtcbiAgICAgICAgICAgICAgICByZXMuc2V0SGVhZGVyKCd4LW5leHRqcy1jYWNoZScsIGlzT25EZW1hbmRSZXZhbGlkYXRlID8gJ1JFVkFMSURBVEVEJyA6IGNhY2hlRW50cnkuaXNNaXNzID8gJ01JU1MnIDogY2FjaGVFbnRyeS5pc1N0YWxlID8gJ1NUQUxFJyA6ICdISVQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERyYWZ0IG1vZGUgc2hvdWxkIG5ldmVyIGJlIGNhY2hlZFxuICAgICAgICAgICAgaWYgKGlzRHJhZnRNb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcignQ2FjaGUtQ29udHJvbCcsICdwcml2YXRlLCBuby1jYWNoZSwgbm8tc3RvcmUsIG1heC1hZ2U9MCwgbXVzdC1yZXZhbGlkYXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gZnJvbU5vZGVPdXRnb2luZ0h0dHBIZWFkZXJzKGNhY2hlRW50cnkudmFsdWUuaGVhZGVycyk7XG4gICAgICAgICAgICBpZiAoIShnZXRSZXF1ZXN0TWV0YShyZXEsICdtaW5pbWFsTW9kZScpICYmIGlzSXNyKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuZGVsZXRlKE5FWFRfQ0FDSEVfVEFHU19IRUFERVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgY2FjaGUgY29udHJvbCBpcyBhbHJlYWR5IHNldCBvbiB0aGUgcmVzcG9uc2Ugd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlIGl0IHRvIGFsbG93IHVzZXJzIHRvIGN1c3RvbWl6ZSBpdCB2aWEgbmV4dC5jb25maWdcbiAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5LmNhY2hlQ29udHJvbCAmJiAhcmVzLmdldEhlYWRlcignQ2FjaGUtQ29udHJvbCcpICYmICFoZWFkZXJzLmdldCgnQ2FjaGUtQ29udHJvbCcpKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5zZXQoJ0NhY2hlLUNvbnRyb2wnLCBnZXRDYWNoZUNvbnRyb2xIZWFkZXIoY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHNlbmRSZXNwb25zZShub2RlTmV4dFJlcSwgbm9kZU5leHRSZXMsIG5ldyBSZXNwb25zZShjYWNoZUVudHJ5LnZhbHVlLmJvZHksIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIHN0YXR1czogY2FjaGVFbnRyeS52YWx1ZS5zdGF0dXMgfHwgMjAwXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETzogYWN0aXZlU3BhbiBjb2RlIHBhdGggaXMgZm9yIHdoZW4gd3JhcHBlZCBieVxuICAgICAgICAvLyBuZXh0LXNlcnZlciBjYW4gYmUgcmVtb3ZlZCB3aGVuIHRoaXMgaXMgbm8gbG9uZ2VyIHVzZWRcbiAgICAgICAgaWYgKGFjdGl2ZVNwYW4pIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZVJlc3BvbnNlKGFjdGl2ZVNwYW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdHJhY2VyLndpdGhQcm9wYWdhdGVkQ29udGV4dChyZXEuaGVhZGVycywgKCk9PnRyYWNlci50cmFjZShCYXNlU2VydmVyU3Bhbi5oYW5kbGVSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW5OYW1lOiBgJHttZXRob2R9ICR7cmVxLnVybH1gLFxuICAgICAgICAgICAgICAgICAgICBraW5kOiBTcGFuS2luZC5TRVJWRVIsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdodHRwLm1ldGhvZCc6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdodHRwLnRhcmdldCc6IHJlcS51cmxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGhhbmRsZVJlc3BvbnNlKSk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gaWYgd2UgYXJlbid0IHdyYXBwZWQgYnkgYmFzZS1zZXJ2ZXIgaGFuZGxlIGhlcmVcbiAgICAgICAgaWYgKCFhY3RpdmVTcGFuICYmICEoZXJyIGluc3RhbmNlb2YgTm9GYWxsYmFja0Vycm9yKSkge1xuICAgICAgICAgICAgYXdhaXQgcm91dGVNb2R1bGUub25SZXF1ZXN0RXJyb3IocmVxLCBlcnIsIHtcbiAgICAgICAgICAgICAgICByb3V0ZXJLaW5kOiAnQXBwIFJvdXRlcicsXG4gICAgICAgICAgICAgICAgcm91dGVQYXRoOiBub3JtYWxpemVkU3JjUGFnZSxcbiAgICAgICAgICAgICAgICByb3V0ZVR5cGU6ICdyb3V0ZScsXG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0ZVJlYXNvbjogZ2V0UmV2YWxpZGF0ZVJlYXNvbih7XG4gICAgICAgICAgICAgICAgICAgIGlzUmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNPbkRlbWFuZFJldmFsaWRhdGVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0aHJvdyBzbyB0aGF0IHdlIGNhbiBoYW5kbGUgc2VydmluZyBlcnJvciBwYWdlXG4gICAgICAgIC8vIElmIHRoaXMgaXMgZHVyaW5nIHN0YXRpYyBnZW5lcmF0aW9uLCB0aHJvdyB0aGUgZXJyb3IgYWdhaW4uXG4gICAgICAgIGlmIChpc0lzcikgdGhyb3cgZXJyO1xuICAgICAgICAvLyBPdGhlcndpc2UsIHNlbmQgYSA1MDAgcmVzcG9uc2UuXG4gICAgICAgIGF3YWl0IHNlbmRSZXNwb25zZShub2RlTmV4dFJlcSwgbm9kZU5leHRSZXMsIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgICAgICBzdGF0dXM6IDUwMFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fstr-aux%2Fstats%2Froute&page=%2Fapi%2Fstr-aux%2Fstats%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fstr-aux%2Fstats%2Froute.ts&appDir=H%3A%5CUsers%5CGus%5Csource%5Crepo%5Cdynamics%5Cdynamics-b%5Ccryptopi-dynamics%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=H%3A%5CUsers%5CGus%5Csource%5Crepo%5Cdynamics%5Cdynamics-b%5Ccryptopi-dynamics&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-flight-action-entry-loader.js?actions=%5B%5B%22H%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%2C%5B%7B%22id%22%3A%2200532f31c65bd9d7119874b7c000efa42c3a9e2e3a%22%2C%22exportedName%22%3A%22getAll%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%2C%7B%22id%22%3A%2200696b0d07c16ebe05246c326940d3b9133dac036c%22%2C%22exportedName%22%3A%22resolveCoinsFromSettings%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%2C%7B%22id%22%3A%22402b519d81502a95cf319ddb5b60bce32907aa6f08%22%2C%22exportedName%22%3A%22setAll%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%2C%7B%22id%22%3A%2240f9a1c8f3a3ab5d85ba51065396bf00a061db869e%22%2C%22exportedName%22%3A%22serializeSettingsCookie%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%5D%5D%5D&__client_imported__=!":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-flight-action-entry-loader.js?actions=%5B%5B%22H%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%2C%5B%7B%22id%22%3A%2200532f31c65bd9d7119874b7c000efa42c3a9e2e3a%22%2C%22exportedName%22%3A%22getAll%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%2C%7B%22id%22%3A%2200696b0d07c16ebe05246c326940d3b9133dac036c%22%2C%22exportedName%22%3A%22resolveCoinsFromSettings%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%2C%7B%22id%22%3A%22402b519d81502a95cf319ddb5b60bce32907aa6f08%22%2C%22exportedName%22%3A%22setAll%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%2C%7B%22id%22%3A%2240f9a1c8f3a3ab5d85ba51065396bf00a061db869e%22%2C%22exportedName%22%3A%22serializeSettingsCookie%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%5D%5D%5D&__client_imported__=! ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"00532f31c65bd9d7119874b7c000efa42c3a9e2e3a\": () => (/* reexport safe */ H_Users_Gus_source_repo_dynamics_dynamics_b_cryptopi_dynamics_src_lib_settings_server_ts__WEBPACK_IMPORTED_MODULE_0__.getAll),\n/* harmony export */   \"00696b0d07c16ebe05246c326940d3b9133dac036c\": () => (/* reexport safe */ H_Users_Gus_source_repo_dynamics_dynamics_b_cryptopi_dynamics_src_lib_settings_server_ts__WEBPACK_IMPORTED_MODULE_0__.resolveCoinsFromSettings),\n/* harmony export */   \"402b519d81502a95cf319ddb5b60bce32907aa6f08\": () => (/* reexport safe */ H_Users_Gus_source_repo_dynamics_dynamics_b_cryptopi_dynamics_src_lib_settings_server_ts__WEBPACK_IMPORTED_MODULE_0__.setAll),\n/* harmony export */   \"40f9a1c8f3a3ab5d85ba51065396bf00a061db869e\": () => (/* reexport safe */ H_Users_Gus_source_repo_dynamics_dynamics_b_cryptopi_dynamics_src_lib_settings_server_ts__WEBPACK_IMPORTED_MODULE_0__.serializeSettingsCookie)\n/* harmony export */ });\n/* harmony import */ var H_Users_Gus_source_repo_dynamics_dynamics_b_cryptopi_dynamics_src_lib_settings_server_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/lib/settings/server.ts */ \"(rsc)/./src/lib/settings/server.ts\");\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS41LjJfQHBsYXl3cmlnaHQrdGVzX2I3ZTZjMjgwZTlhMWI0MzA5MzQ3YzBiZjBhYjQ3NmQ1L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWFjdGlvbi1lbnRyeS1sb2FkZXIuanM/YWN0aW9ucz0lNUIlNUIlMjJIJTNBJTVDJTVDVXNlcnMlNUMlNUNHdXMlNUMlNUNzb3VyY2UlNUMlNUNyZXBvJTVDJTVDZHluYW1pY3MlNUMlNUNkeW5hbWljcy1iJTVDJTVDY3J5cHRvcGktZHluYW1pY3MlNUMlNUNzcmMlNUMlNUNsaWIlNUMlNUNzZXR0aW5ncyU1QyU1Q3NlcnZlci50cyUyMiUyQyU1QiU3QiUyMmlkJTIyJTNBJTIyMDA1MzJmMzFjNjViZDlkNzExOTg3NGI3YzAwMGVmYTQyYzNhOWUyZTNhJTIyJTJDJTIyZXhwb3J0ZWROYW1lJTIyJTNBJTIyZ2V0QWxsJTIyJTJDJTIyZmlsZW5hbWUlMjIlM0ElMjIuLiUyRkglM0ElNUMlNUNVc2VycyU1QyU1Q0d1cyU1QyU1Q3NvdXJjZSU1QyU1Q3JlcG8lNUMlNUNkeW5hbWljcyU1QyU1Q2R5bmFtaWNzLWIlNUMlNUNjcnlwdG9waS1keW5hbWljcyU1QyU1Q3NyYyU1QyU1Q2xpYiU1QyU1Q3NldHRpbmdzJTVDJTVDc2VydmVyLnRzJTIyJTdEJTJDJTdCJTIyaWQlMjIlM0ElMjIwMDY5NmIwZDA3YzE2ZWJlMDUyNDZjMzI2OTQwZDNiOTEzM2RhYzAzNmMlMjIlMkMlMjJleHBvcnRlZE5hbWUlMjIlM0ElMjJyZXNvbHZlQ29pbnNGcm9tU2V0dGluZ3MlMjIlMkMlMjJmaWxlbmFtZSUyMiUzQSUyMi4uJTJGSCUzQSU1QyU1Q1VzZXJzJTVDJTVDR3VzJTVDJTVDc291cmNlJTVDJTVDcmVwbyU1QyU1Q2R5bmFtaWNzJTVDJTVDZHluYW1pY3MtYiU1QyU1Q2NyeXB0b3BpLWR5bmFtaWNzJTVDJTVDc3JjJTVDJTVDbGliJTVDJTVDc2V0dGluZ3MlNUMlNUNzZXJ2ZXIudHMlMjIlN0QlMkMlN0IlMjJpZCUyMiUzQSUyMjQwMmI1MTlkODE1MDJhOTVjZjMxOWRkYjViNjBiY2UzMjkwN2FhNmYwOCUyMiUyQyUyMmV4cG9ydGVkTmFtZSUyMiUzQSUyMnNldEFsbCUyMiUyQyUyMmZpbGVuYW1lJTIyJTNBJTIyLi4lMkZIJTNBJTVDJTVDVXNlcnMlNUMlNUNHdXMlNUMlNUNzb3VyY2UlNUMlNUNyZXBvJTVDJTVDZHluYW1pY3MlNUMlNUNkeW5hbWljcy1iJTVDJTVDY3J5cHRvcGktZHluYW1pY3MlNUMlNUNzcmMlNUMlNUNsaWIlNUMlNUNzZXR0aW5ncyU1QyU1Q3NlcnZlci50cyUyMiU3RCUyQyU3QiUyMmlkJTIyJTNBJTIyNDBmOWExYzhmM2EzYWI1ZDg1YmE1MTA2NTM5NmJmMDBhMDYxZGI4NjllJTIyJTJDJTIyZXhwb3J0ZWROYW1lJTIyJTNBJTIyc2VyaWFsaXplU2V0dGluZ3NDb29raWUlMjIlMkMlMjJmaWxlbmFtZSUyMiUzQSUyMi4uJTJGSCUzQSU1QyU1Q1VzZXJzJTVDJTVDR3VzJTVDJTVDc291cmNlJTVDJTVDcmVwbyU1QyU1Q2R5bmFtaWNzJTVDJTVDZHluYW1pY3MtYiU1QyU1Q2NyeXB0b3BpLWR5bmFtaWNzJTVDJTVDc3JjJTVDJTVDbGliJTVDJTVDc2V0dGluZ3MlNUMlNUNzZXJ2ZXIudHMlMjIlN0QlNUQlNUQlNUQmX19jbGllbnRfaW1wb3J0ZWRfXz0hIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUM2SztBQUNrQjtBQUNsQjtBQUNpQiIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuZXhwb3J0IHsgZ2V0QWxsIGFzIFwiMDA1MzJmMzFjNjViZDlkNzExOTg3NGI3YzAwMGVmYTQyYzNhOWUyZTNhXCIgfSBmcm9tIFwiSDpcXFxcVXNlcnNcXFxcR3VzXFxcXHNvdXJjZVxcXFxyZXBvXFxcXGR5bmFtaWNzXFxcXGR5bmFtaWNzLWJcXFxcY3J5cHRvcGktZHluYW1pY3NcXFxcc3JjXFxcXGxpYlxcXFxzZXR0aW5nc1xcXFxzZXJ2ZXIudHNcIlxuZXhwb3J0IHsgcmVzb2x2ZUNvaW5zRnJvbVNldHRpbmdzIGFzIFwiMDA2OTZiMGQwN2MxNmViZTA1MjQ2YzMyNjk0MGQzYjkxMzNkYWMwMzZjXCIgfSBmcm9tIFwiSDpcXFxcVXNlcnNcXFxcR3VzXFxcXHNvdXJjZVxcXFxyZXBvXFxcXGR5bmFtaWNzXFxcXGR5bmFtaWNzLWJcXFxcY3J5cHRvcGktZHluYW1pY3NcXFxcc3JjXFxcXGxpYlxcXFxzZXR0aW5nc1xcXFxzZXJ2ZXIudHNcIlxuZXhwb3J0IHsgc2V0QWxsIGFzIFwiNDAyYjUxOWQ4MTUwMmE5NWNmMzE5ZGRiNWI2MGJjZTMyOTA3YWE2ZjA4XCIgfSBmcm9tIFwiSDpcXFxcVXNlcnNcXFxcR3VzXFxcXHNvdXJjZVxcXFxyZXBvXFxcXGR5bmFtaWNzXFxcXGR5bmFtaWNzLWJcXFxcY3J5cHRvcGktZHluYW1pY3NcXFxcc3JjXFxcXGxpYlxcXFxzZXR0aW5nc1xcXFxzZXJ2ZXIudHNcIlxuZXhwb3J0IHsgc2VyaWFsaXplU2V0dGluZ3NDb29raWUgYXMgXCI0MGY5YTFjOGYzYTNhYjVkODViYTUxMDY1Mzk2YmYwMGEwNjFkYjg2OWVcIiB9IGZyb20gXCJIOlxcXFxVc2Vyc1xcXFxHdXNcXFxcc291cmNlXFxcXHJlcG9cXFxcZHluYW1pY3NcXFxcZHluYW1pY3MtYlxcXFxjcnlwdG9waS1keW5hbWljc1xcXFxzcmNcXFxcbGliXFxcXHNldHRpbmdzXFxcXHNlcnZlci50c1wiXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-flight-action-entry-loader.js?actions=%5B%5B%22H%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%2C%5B%7B%22id%22%3A%2200532f31c65bd9d7119874b7c000efa42c3a9e2e3a%22%2C%22exportedName%22%3A%22getAll%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%2C%7B%22id%22%3A%2200696b0d07c16ebe05246c326940d3b9133dac036c%22%2C%22exportedName%22%3A%22resolveCoinsFromSettings%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%2C%7B%22id%22%3A%22402b519d81502a95cf319ddb5b60bce32907aa6f08%22%2C%22exportedName%22%3A%22setAll%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%2C%7B%22id%22%3A%2240f9a1c8f3a3ab5d85ba51065396bf00a061db869e%22%2C%22exportedName%22%3A%22serializeSettingsCookie%22%2C%22filename%22%3A%22..%2FH%3A%5C%5CUsers%5C%5CGus%5C%5Csource%5C%5Crepo%5C%5Cdynamics%5C%5Cdynamics-b%5C%5Ccryptopi-dynamics%5C%5Csrc%5C%5Clib%5C%5Csettings%5C%5Cserver.ts%22%7D%5D%5D%5D&__client_imported__=!\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!**************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \**************************************************************************************************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(rsc)/./src/app/api/str-aux/stats/route.ts":
/*!********************************************!*\
  !*** ./src/app/api/str-aux/stats/route.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   runtime: () => (/* binding */ runtime)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/api/server.js\");\n/* harmony import */ var _core_features_str_aux_calc_panel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/core/features/str-aux/calc/panel */ \"(rsc)/./src/core/features/str-aux/calc/panel.ts\");\n/* harmony import */ var _core_features_str_aux_frame_analytics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/core/features/str-aux/frame/analytics */ \"(rsc)/./src/core/features/str-aux/frame/analytics.ts\");\n/* harmony import */ var _core_features_str_aux_symbols__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/core/features/str-aux/symbols */ \"(rsc)/./src/core/features/str-aux/symbols/index.ts\");\n// src/app/api/str-aux/stats/route.ts\n\nconst runtime = 'nodejs';\nconst dynamic = 'force-dynamic';\n\n\n\nfunction parseWindow(s) {\n    const v = (s ?? '30m').toLowerCase();\n    return v === '30m' || v === '1h' || v === '3h' ? v : '30m';\n}\nfunction parseBinsParam(s, dflt = 128) {\n    const n = Number(s ?? dflt);\n    return Number.isFinite(n) && n > 0 ? Math.min(2048, Math.floor(n)) : dflt;\n}\nasync function fetchTicker24h(symbol) {\n    const r = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`, {\n        cache: 'no-store'\n    });\n    if (!r.ok) return {\n        price: NaN,\n        pct24h: NaN\n    };\n    const j = await r.json();\n    const price = Number(j.lastPrice ?? j.weightedAvgPrice ?? NaN);\n    const pct24h = Number(j.priceChangePercent ?? NaN);\n    return {\n        price,\n        pct24h\n    };\n}\nfunction pctDrv(prev, cur) {\n    return 100 * (cur / prev - 1);\n}\nfunction disruptionFromCounts(counts) {\n    if (!Array.isArray(counts) || counts.length === 0) return null;\n    let total = 0;\n    for(let i = 1; i < counts.length; i++){\n        total += Math.abs((Number(counts[i]) || 0) - (Number(counts[i - 1]) || 0));\n    }\n    return counts.length ? total / counts.length : null;\n}\nconst SHIFT = globalThis.__STR_AUX_SHIFT__ ?? new Map();\nglobalThis.__STR_AUX_SHIFT__ = SHIFT;\nconst shiftKey = (sess, sym)=>`${sess}:${sym}`;\nfunction getShiftState(appSessionId, symbol) {\n    const key = shiftKey(appSessionId, symbol);\n    const cur = SHIFT.get(key);\n    if (cur) {\n        if (!cur.streams) cur.streams = {\n            maxStamps: 64\n        };\n        return cur;\n    }\n    const init = {\n        refGfm01: 0.5,\n        window: {\n            exceed: [],\n            shifts: 0\n        },\n        streams: {\n            maxStamps: 64\n        },\n        uiEpoch: 0,\n        shifts: 0\n    };\n    SHIFT.set(key, init);\n    return init;\n}\nconst toNullable = (value)=>Number.isFinite(value) ? value : null;\nconst updateStreamScalar = (row, next)=>{\n    if (next === null || !Number.isFinite(next)) return row;\n    const prevCur = Number.isFinite(row?.cur ?? NaN) ? row.cur : null;\n    const prevGreatest = Number.isFinite(row?.greatest ?? NaN) ? Math.abs(row.greatest) : 0;\n    const greatest = Math.max(prevGreatest, Math.abs(next));\n    return {\n        prev: prevCur,\n        cur: next,\n        greatest: greatest > 0 ? greatest : null\n    };\n};\nasync function GET(req) {\n    try {\n        const url = new URL(req.url);\n        const selection = await (0,_core_features_str_aux_symbols__WEBPACK_IMPORTED_MODULE_3__.resolveSymbolSelection)(url);\n        const symbols = selection.symbols;\n        const windowKey = parseWindow(url.searchParams.get('window'));\n        const binsN = parseBinsParam(url.searchParams.get('bins'), 128);\n        const appSessionId = (url.searchParams.get('sessionId') ?? 'ui').slice(0, 64);\n        const epsPct = Number(url.searchParams.get('eps') ?? '0.35');\n        const kCycles = Math.max(1, Math.floor(Number(url.searchParams.get('k') ?? '5')));\n        const now = Date.now();\n        if (!symbols.length) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                ok: true,\n                symbols: [],\n                out: {},\n                window: windowKey,\n                ts: now\n            });\n        }\n        const baseStatsOptions = {\n            idhr: {\n                alpha: 2.5,\n                sMin: 1e-6,\n                smooth: 3,\n                topK: 8\n            },\n            epsGfmPct: epsPct,\n            epsBfmPct: epsPct,\n            vScale: 100,\n            tendencyWin: 30,\n            tendencyNorm: 'mad'\n        };\n        const out = {};\n        for (const symbol of symbols){\n            let metrics = null;\n            try {\n                const store = getShiftState(appSessionId, symbol);\n                const statsOptions = {\n                    ...baseStatsOptions,\n                    idhr: {\n                        ...baseStatsOptions.idhr ?? {},\n                        topK: baseStatsOptions.idhr?.topK ?? 8\n                    }\n                };\n                const [met, t24] = await Promise.all([\n                    (0,_core_features_str_aux_calc_panel__WEBPACK_IMPORTED_MODULE_1__.computeSampledMetricsForSymbol)(symbol, {\n                        window: windowKey,\n                        bins: binsN,\n                        stats: statsOptions\n                    }),\n                    fetchTicker24h(symbol)\n                ]);\n                metrics = met;\n                if (!metrics.ok) {\n                    out[symbol] = {\n                        ok: false,\n                        error: metrics.error,\n                        bins: binsN,\n                        window: windowKey,\n                        sampling: metrics.sampling\n                    };\n                    continue;\n                }\n                const stats = metrics.stats;\n                const { meta, sampling, hist, extrema } = metrics;\n                const ap = (0,_core_features_str_aux_frame_analytics__WEBPACK_IMPORTED_MODULE_2__.applyGfmShiftAndStreams)(stats.bfm01, store.refGfm01, store.window, store.streams, {\n                    epsilonPct: epsPct,\n                    windowSize: kCycles,\n                    nowTs: meta.lastUpdateTs,\n                    price: meta.last\n                });\n                store.window = ap.window;\n                store.streams = ap.streams;\n                if (ap.isShift) {\n                    store.refGfm01 = stats.bfm01;\n                    store.uiEpoch += 1;\n                    store.shifts += 1;\n                }\n                const inertiaTotal = toNullable(stats.inertia?.total);\n                const inertiaStaticVal = toNullable(stats.inertia?.static);\n                const inertiaGrowthVal = toNullable(stats.inertia?.growth);\n                const ampVal = toNullable(stats.amp);\n                const voltVal = toNullable(stats.volt);\n                const efficiencyVal = toNullable(stats.efficiency);\n                store.streams.inertia = updateStreamScalar(store.streams.inertia, inertiaTotal);\n                store.streams.amp = updateStreamScalar(store.streams.amp, ampVal);\n                store.streams.volt = updateStreamScalar(store.streams.volt, voltVal);\n                store.streams.efficiency = updateStreamScalar(store.streams.efficiency, efficiencyVal);\n                const pct24hVal = Number.isFinite(t24.pct24h) ? t24.pct24h : null;\n                const pctDrvVal = meta.n > 1 && Number.isFinite(meta.prev) && Number.isFinite(meta.last) && meta.prev !== 0 ? pctDrv(meta.prev, meta.last) : null;\n                store.streams.pct24h = updateStreamScalar(store.streams.pct24h, pct24hVal);\n                store.streams.pct_drv = updateStreamScalar(store.streams.pct_drv, pctDrvVal);\n                const histCountsForDisruption = Array.isArray(stats.histogram?.counts) && stats.histogram.counts.length ? stats.histogram.counts.map((c)=>Number(c) || 0) : Array.isArray(hist.counts) ? hist.counts.map((c)=>Number(c) || 0) : [];\n                const disruptionVal = disruptionFromCounts(histCountsForDisruption);\n                const gfmAbsVal = toNullable(stats.gfmAbs);\n                const gfmRefVal = toNullable(stats.refGfmAbs);\n                const deltaGfmAbsVal = toNullable(stats.deltaGfmAbs);\n                const deltaGfmPctVal = toNullable(stats.deltaGfmPct);\n                const bfmVal = toNullable(stats.bfm01);\n                const bfmRefVal = toNullable(stats.refBfm01);\n                const deltaBfmVal = toNullable(stats.deltaBfm01);\n                const deltaBfmPctVal = toNullable(stats.deltaBfmPct);\n                const sigmaVal = toNullable(stats.sigma);\n                const zAbsVal = toNullable(stats.zAbs);\n                const openingVal = toNullable(stats.opening);\n                const lastVal = toNullable(stats.last);\n                const prevVal = toNullable(stats.prev);\n                store.streams.benchmark = updateStreamScalar(store.streams.benchmark, lastVal);\n                const inertiaOut = stats.inertia ? {\n                    static: inertiaStaticVal,\n                    growth: inertiaGrowthVal,\n                    total: inertiaTotal,\n                    face: stats.inertia.face ?? null\n                } : null;\n                const metricsOut = {\n                    dispersion: {\n                        sigma: sigmaVal,\n                        zAbs: zAbsVal\n                    },\n                    gfm: {\n                        absolute: gfmAbsVal,\n                        reference: gfmRefVal,\n                        deltaAbs: deltaGfmAbsVal,\n                        deltaPct: deltaGfmPctVal,\n                        shifted: Boolean(stats.shiftedGfm)\n                    },\n                    bfm: {\n                        value: bfmVal,\n                        reference: bfmRefVal,\n                        delta: deltaBfmVal,\n                        deltaPct: deltaBfmPctVal,\n                        shifted: Boolean(stats.shiftedBfm)\n                    },\n                    intrinsic: {\n                        inertia: inertiaOut,\n                        amp: ampVal,\n                        volt: voltVal,\n                        efficiency: efficiencyVal\n                    },\n                    disruption: disruptionVal\n                };\n                const statsOut = {\n                    sigma: sigmaVal,\n                    zAbs: zAbsVal,\n                    gfmAbs: gfmAbsVal,\n                    refGfmAbs: gfmRefVal,\n                    deltaGfmAbs: deltaGfmAbsVal,\n                    deltaGfmPct: deltaGfmPctVal,\n                    shiftedGfm: Boolean(stats.shiftedGfm),\n                    bfm01: bfmVal,\n                    refBfm01: bfmRefVal,\n                    deltaBfm01: deltaBfmVal,\n                    deltaBfmPct: deltaBfmPctVal,\n                    shiftedBfm: Boolean(stats.shiftedBfm),\n                    inertia: inertiaOut,\n                    amp: ampVal,\n                    volt: voltVal,\n                    efficiency: efficiencyVal,\n                    histogram: stats.histogram ?? null,\n                    opening: openingVal,\n                    last: lastVal,\n                    prev: prevVal\n                };\n                const gfmDelta = {\n                    anchorPrice: gfmAbsVal,\n                    price: lastVal,\n                    absPct: deltaGfmPctVal\n                };\n                out[symbol] = {\n                    ok: true,\n                    window: windowKey,\n                    n: meta.n,\n                    cards: {\n                        opening: {\n                            benchmark: openingVal,\n                            pct24h: pct24hVal\n                        },\n                        live: {\n                            benchmark: lastVal,\n                            pct_drv: pctDrvVal,\n                            pct24h: pct24hVal\n                        }\n                    },\n                    stats: statsOut,\n                    metrics: metricsOut,\n                    fm: {\n                        gfm: gfmAbsVal,\n                        gfm_price: gfmAbsVal,\n                        gfm_calc_price: gfmAbsVal,\n                        gfm_ref_price: gfmRefVal,\n                        bfm01: bfmVal,\n                        bfm_ref: bfmRefVal,\n                        bfm_delta01: deltaBfmVal,\n                        bfm_delta_pct: deltaBfmPctVal,\n                        bfm_shifted: Boolean(stats.shiftedBfm),\n                        sigma: sigmaVal,\n                        zAbs: zAbsVal,\n                        inertia: inertiaTotal,\n                        disruption: disruptionVal,\n                        amp: ampVal,\n                        volt: voltVal,\n                        efficiency: efficiencyVal\n                    },\n                    gfmDelta,\n                    streams: store.streams,\n                    shifts: {\n                        nShifts: store.shifts,\n                        latestTs: meta.lastUpdateTs\n                    },\n                    shift_stamp: ap.isShift,\n                    hist,\n                    extrema,\n                    meta: {\n                        uiEpoch: store.uiEpoch,\n                        epsPct,\n                        kCycles\n                    },\n                    lastUpdateTs: meta.lastUpdateTs,\n                    sampling\n                };\n            } catch (e) {\n                const sampling = metrics && 'sampling' in metrics ? metrics.sampling : undefined;\n                out[symbol] = {\n                    ok: false,\n                    error: String(e?.message ?? e),\n                    window: windowKey,\n                    bins: binsN,\n                    sampling\n                };\n            }\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            ok: true,\n            symbols,\n            out,\n            window: windowKey,\n            ts: now,\n            universe: {\n                quote: selection.quote,\n                quotes: selection.quotes,\n                bases: selection.bases,\n                defaults: selection.defaults,\n                extras: selection.extras,\n                explicit: selection.explicit,\n                source: selection.source\n            }\n        });\n    } catch (err) {\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            ok: false,\n            error: String(err?.message ?? err)\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvYXBwL2FwaS9zdHItYXV4L3N0YXRzL3JvdXRlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxxQ0FBcUM7QUFDTTtBQUVwQyxNQUFNQyxVQUFVLFNBQVM7QUFDekIsTUFBTUMsVUFBVSxnQkFBZ0I7QUFFd0U7QUFDYTtBQUduRDtBQUl6RSxTQUFTSSxZQUFZQyxDQUE0QjtJQUMvQyxNQUFNQyxJQUFJLENBQUNELEtBQUssS0FBSSxFQUFHRSxXQUFXO0lBQ2xDLE9BQU8sTUFBTyxTQUFTRCxNQUFNLFFBQVFBLE1BQU0sT0FBU0EsSUFBa0I7QUFDeEU7QUFDQSxTQUFTRSxlQUFlSCxDQUE0QixFQUFFSSxPQUFPLEdBQUc7SUFDOUQsTUFBTUMsSUFBSUMsT0FBT04sS0FBS0k7SUFDdEIsT0FBT0UsT0FBT0MsUUFBUSxDQUFDRixNQUFNQSxJQUFJLElBQUlHLEtBQUtDLEdBQUcsQ0FBQyxNQUFNRCxLQUFLRSxLQUFLLENBQUNMLE1BQU1EO0FBQ3ZFO0FBRUEsZUFBZU8sZUFBZUMsTUFBYztJQUMxQyxNQUFNQyxJQUFJLE1BQU1DLE1BQU0sQ0FBQyxrREFBa0QsRUFBRUYsUUFBUSxFQUFFO1FBQUVHLE9BQU87SUFBVztJQUN6RyxJQUFJLENBQUNGLEVBQUVHLEVBQUUsRUFBRSxPQUFPO1FBQUVDLE9BQU9DO1FBQUtDLFFBQVFEO0lBQUk7SUFDNUMsTUFBTUUsSUFBSSxNQUFNUCxFQUFFUSxJQUFJO0lBQ3RCLE1BQU1KLFFBQVFYLE9BQU9jLEVBQUVFLFNBQVMsSUFBSUYsRUFBRUcsZ0JBQWdCLElBQUlMO0lBQzFELE1BQU1DLFNBQVNiLE9BQU9jLEVBQUVJLGtCQUFrQixJQUFJTjtJQUM5QyxPQUFPO1FBQUVEO1FBQU9FO0lBQU87QUFDekI7QUFFQSxTQUFTTSxPQUFPQyxJQUFZLEVBQUVDLEdBQVc7SUFBWSxPQUFPLE1BQU8sT0FBT0QsT0FBUTtBQUFJO0FBRXRGLFNBQVNFLHFCQUFxQkMsTUFBZ0I7SUFDNUMsSUFBSSxDQUFDQyxNQUFN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bUksUUFBUTtnQkFDNUJDLFFBQVFwSSxVQUFVb0ksTUFBTTtnQkFDeEJDLFVBQVVySSxVQUFVcUksUUFBUTtnQkFDNUJDLFFBQVF0SSxVQUFVc0ksTUFBTTtZQUMxQjtRQUNGO0lBQ0YsRUFBRSxPQUFPQyxLQUFVO1FBQ2pCLE9BQU9uTixxREFBWUEsQ0FBQzRCLElBQUksQ0FBQztZQUFFTCxJQUFJO1lBQU9xRixPQUFPNkYsT0FBT1UsS0FBS1QsV0FBV1M7UUFBSyxHQUFHO1lBQUVDLFFBQVE7UUFBSTtJQUM1RjtBQUNGIiwic291cmNlcyI6WyJIOlxcVXNlcnNcXEd1c1xcc291cmNlXFxyZXBvXFxkeW5hbWljc1xcZHluYW1pY3MtYlxcY3J5cHRvcGktZHluYW1pY3NcXHNyY1xcYXBwXFxhcGlcXHN0ci1hdXhcXHN0YXRzXFxyb3V0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvYXBwL2FwaS9zdHItYXV4L3N0YXRzL3JvdXRlLnRzXG5pbXBvcnQgeyBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcic7XG5cbmV4cG9ydCBjb25zdCBydW50aW1lID0gJ25vZGVqcyc7XG5leHBvcnQgY29uc3QgZHluYW1pYyA9ICdmb3JjZS1keW5hbWljJztcblxuaW1wb3J0IHsgY29tcHV0ZVNhbXBsZWRNZXRyaWNzRm9yU3ltYm9sLCB0eXBlIFNhbXBsZWRNZXRyaWNzUmVzdWx0IH0gZnJvbSAnQC9jb3JlL2ZlYXR1cmVzL3N0ci1hdXgvY2FsYy9wYW5lbCc7XG5pbXBvcnQgeyBhcHBseUdmbVNoaWZ0QW5kU3RyZWFtcywgdHlwZSBTaGlmdFdpbmRvd1N0YXRlLCB0eXBlIFN0cmVhbXNTdGF0ZSB9IGZyb20gJ0AvY29yZS9mZWF0dXJlcy9zdHItYXV4L2ZyYW1lL2FuYWx5dGljcyc7XG5pbXBvcnQgdHlwZSB7IFNhbXBsaW5nV2luZG93S2V5IH0gZnJvbSAnQC9jb3JlL2ZlYXR1cmVzL3N0ci1hdXgvc2FtcGxpbmcnO1xuaW1wb3J0IHR5cGUgeyBTdGF0c09wdGlvbnMgfSBmcm9tICdAL2NvcmUvZmVhdHVyZXMvc3RyLWF1eC9jYWxjL3N0YXRzJztcbmltcG9ydCB7IHJlc29sdmVTeW1ib2xTZWxlY3Rpb24gfSBmcm9tICdAL2NvcmUvZmVhdHVyZXMvc3RyLWF1eC9zeW1ib2xzJztcblxudHlwZSBXaW5kb3dLZXkgPSBTYW1wbGluZ1dpbmRvd0tleTtcblxuZnVuY3Rpb24gcGFyc2VXaW5kb3coczogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFdpbmRvd0tleSB7XG4gIGNvbnN0IHYgPSAocyA/PyAnMzBtJykudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuICh2ID09PSAnMzBtJyB8fCB2ID09PSAnMWgnIHx8IHYgPT09ICczaCcpID8gKHYgYXMgV2luZG93S2V5KSA6ICczMG0nO1xufVxuZnVuY3Rpb24gcGFyc2VCaW5zUGFyYW0oczogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCwgZGZsdCA9IDEyOCkge1xuICBjb25zdCBuID0gTnVtYmVyKHMgPz8gZGZsdCk7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobikgJiYgbiA+IDAgPyBNYXRoLm1pbigyMDQ4LCBNYXRoLmZsb29yKG4pKSA6IGRmbHQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoVGlja2VyMjRoKHN5bWJvbDogc3RyaW5nKSB7XG4gIGNvbnN0IHIgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9hcGkuYmluYW5jZS5jb20vYXBpL3YzL3RpY2tlci8yNGhyP3N5bWJvbD0ke3N5bWJvbH1gLCB7IGNhY2hlOiAnbm8tc3RvcmUnIH0pO1xuICBpZiAoIXIub2spIHJldHVybiB7IHByaWNlOiBOYU4sIHBjdDI0aDogTmFOIH07XG4gIGNvbnN0IGogPSBhd2FpdCByLmpzb24oKSBhcyBhbnk7XG4gIGNvbnN0IHByaWNlID0gTnVtYmVyKGoubGFzdFByaWNlID8/IGoud2VpZ2h0ZWRBdmdQcmljZSA/PyBOYU4pO1xuICBjb25zdCBwY3QyNGggPSBOdW1iZXIoai5wcmljZUNoYW5nZVBlcmNlbnQgPz8gTmFOKTtcbiAgcmV0dXJuIHsgcHJpY2UsIHBjdDI0aCB9O1xufVxuXG5mdW5jdGlvbiBwY3REcnYocHJldjogbnVtYmVyLCBjdXI6IG51bWJlcik6IG51bWJlciB7IHJldHVybiAxMDAgKiAoKGN1ciAvIHByZXYpIC0gMSk7IH1cblxuZnVuY3Rpb24gZGlzcnVwdGlvbkZyb21Db3VudHMoY291bnRzOiBudW1iZXJbXSk6IG51bWJlciB8IG51bGwge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY291bnRzKSB8fCBjb3VudHMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgbGV0IHRvdGFsID0gMDtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBjb3VudHMubGVuZ3RoOyBpKyspIHtcbiAgICB0b3RhbCArPSBNYXRoLmFicygoTnVtYmVyKGNvdW50c1tpXSkgfHwgMCkgLSAoTnVtYmVyKGNvdW50c1tpIC0gMV0pIHx8IDApKTtcbiAgfVxuICByZXR1cm4gY291bnRzLmxlbmd0aCA/IHRvdGFsIC8gY291bnRzLmxlbmd0aCA6IG51bGw7XG59XG5cbnR5cGUgU2hpZnRTdG9yZSA9IHtcbiAgcmVmR2ZtMDE6IG51bWJlcjtcbiAgd2luZG93OiBTaGlmdFdpbmRvd1N0YXRlO1xuICBzdHJlYW1zOiBTdHJlYW1zU3RhdGU7XG4gIHVpRXBvY2g6IG51bWJlcjtcbiAgc2hpZnRzOiBudW1iZXI7XG59O1xuZGVjbGFyZSBnbG9iYWwgeyB2YXIgX19TVFJfQVVYX1NISUZUX186IE1hcDxzdHJpbmcsIFNoaWZ0U3RvcmU+IHwgdW5kZWZpbmVkOyB9XG5jb25zdCBTSElGVDogTWFwPHN0cmluZywgU2hpZnRTdG9yZT4gPSAoZ2xvYmFsVGhpcyBhcyBhbnkpLl9fU1RSX0FVWF9TSElGVF9fID8/IG5ldyBNYXAoKTtcbihnbG9iYWxUaGlzIGFzIGFueSkuX19TVFJfQVVYX1NISUZUX18gPSBTSElGVDtcbmNvbnN0IHNoaWZ0S2V5ID0gKHNlc3M6IHN0cmluZywgc3ltOiBzdHJpbmcpID0+IGAke3Nlc3N9OiR7c3ltfWA7XG5mdW5jdGlvbiBnZXRTaGlmdFN0YXRlKGFwcFNlc3Npb25JZDogc3RyaW5nLCBzeW1ib2w6IHN0cmluZyk6IFNoaWZ0U3RvcmUge1xuICBjb25zdCBrZXkgPSBzaGlmdEtleShhcHBTZXNzaW9uSWQsIHN5bWJvbCk7XG4gIGNvbnN0IGN1ciA9IFNISUZULmdldChrZXkpO1xuICBpZiAoY3VyKSB7XG4gICAgaWYgKCFjdXIuc3RyZWFtcykgY3VyLnN0cmVhbXMgPSB7IG1heFN0YW1wczogNjQgfTtcbiAgICByZXR1cm4gY3VyO1xuICB9XG4gIGNvbnN0IGluaXQ6IFNoaWZ0U3RvcmUgPSB7XG4gICAgcmVmR2ZtMDE6IDAuNSxcbiAgICB3aW5kb3c6IHsgZXhjZWVkOiBbXSwgc2hpZnRzOiAwIH0sXG4gICAgc3RyZWFtczogeyBtYXhTdGFtcHM6IDY0IH0sXG4gICAgdWlFcG9jaDogMCxcbiAgICBzaGlmdHM6IDAsXG4gIH07XG4gIFNISUZULnNldChrZXksIGluaXQpO1xuICByZXR1cm4gaW5pdDtcbn1cblxuY29uc3QgdG9OdWxsYWJsZSA9ICh2YWx1ZTogdW5rbm93bik6IG51bWJlciB8IG51bGwgPT5cbiAgTnVtYmVyLmlzRmluaXRlKHZhbHVlIGFzIG51bWJlcikgPyAodmFsdWUgYXMgbnVtYmVyKSA6IG51bGw7XG5cbnR5cGUgU3RyZWFtU2NhbGFyID0geyBwcmV2OiBudW1iZXIgfCBudWxsOyBjdXI6IG51bWJlciB8IG51bGw7IGdyZWF0ZXN0OiBudW1iZXIgfCBudWxsIH07XG5jb25zdCB1cGRhdGVTdHJlYW1TY2FsYXIgPSAocm93OiBTdHJlYW1TY2FsYXIgfCB1bmRlZmluZWQsIG5leHQ6IG51bWJlciB8IG51bGwpOiBTdHJlYW1TY2FsYXIgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAobmV4dCA9PT0gbnVsbCB8fCAhTnVtYmVyLmlzRmluaXRlKG5leHQpKSByZXR1cm4gcm93O1xuICBjb25zdCBwcmV2Q3VyID0gTnVtYmVyLmlzRmluaXRlKHJvdz8uY3VyID8/IE5hTikgPyByb3chLmN1ciEgOiBudWxsO1xuICBjb25zdCBwcmV2R3JlYXRlc3QgPSBOdW1iZXIuaXNGaW5pdGUocm93Py5ncmVhdGVzdCA/PyBOYU4pID8gTWF0aC5hYnMocm93IS5ncmVhdGVzdCEpIDogMDtcbiAgY29uc3QgZ3JlYXRlc3QgPSBNYXRoLm1heChwcmV2R3JlYXRlc3QsIE1hdGguYWJzKG5leHQpKTtcbiAgcmV0dXJuIHsgcHJldjogcHJldkN1ciwgY3VyOiBuZXh0LCBncmVhdGVzdDogZ3JlYXRlc3QgPiAwID8gZ3JlYXRlc3QgOiBudWxsIH07XG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gR0VUKHJlcTogUmVxdWVzdCkge1xuICB0cnkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxLnVybCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gYXdhaXQgcmVzb2x2ZVN5bWJvbFNlbGVjdGlvbih1cmwpO1xuICAgIGNvbnN0IHN5bWJvbHMgPSBzZWxlY3Rpb24uc3ltYm9scztcbiAgICBjb25zdCB3aW5kb3dLZXkgPSBwYXJzZVdpbmRvdyh1cmwuc2VhcmNoUGFyYW1zLmdldCgnd2luZG93JykpO1xuICAgIGNvbnN0IGJpbnNOID0gcGFyc2VCaW5zUGFyYW0odXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2JpbnMnKSwgMTI4KTtcbiAgICBjb25zdCBhcHBTZXNzaW9uSWQgPSAodXJsLnNlYXJjaFBhcmFtcy5nZXQoJ3Nlc3Npb25JZCcpID8/ICd1aScpLnNsaWNlKDAsIDY0KTtcbiAgICBjb25zdCBlcHNQY3QgPSBOdW1iZXIodXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2VwcycpID8/ICcwLjM1Jyk7XG4gICAgY29uc3Qga0N5Y2xlcyA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoTnVtYmVyKHVybC5zZWFyY2hQYXJhbXMuZ2V0KCdrJykgPz8gJzUnKSkpO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBpZiAoIXN5bWJvbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBvazogdHJ1ZSwgc3ltYm9sczogW10sIG91dDoge30sIHdpbmRvdzogd2luZG93S2V5LCB0czogbm93IH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGJhc2VTdGF0c09wdGlvbnM6IFN0YXRzT3B0aW9ucyA9IHtcbiAgICAgIGlkaHI6IHsgYWxwaGE6IDIuNSwgc01pbjogMWUtNiwgc21vb3RoOiAzLCB0b3BLOiA4IH0sXG4gICAgICBlcHNHZm1QY3Q6IGVwc1BjdCxcbiAgICAgIGVwc0JmbVBjdDogZXBzUGN0LFxuICAgICAgdlNjYWxlOiAxMDAsXG4gICAgICB0ZW5kZW5jeVdpbjogMzAsXG4gICAgICB0ZW5kZW5jeU5vcm06ICdtYWQnLFxuICAgIH07XG5cbiAgICBjb25zdCBvdXQ6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcblxuICAgIGZvciAoY29uc3Qgc3ltYm9sIG9mIHN5bWJvbHMpIHtcbiAgICAgIGxldCBtZXRyaWNzOiBTYW1wbGVkTWV0cmljc1Jlc3VsdCB8IG51bGwgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBnZXRTaGlmdFN0YXRlKGFwcFNlc3Npb25JZCwgc3ltYm9sKTtcbiAgICAgICAgY29uc3Qgc3RhdHNPcHRpb25zOiBTdGF0c09wdGlvbnMgPSB7XG4gICAgICAgICAgLi4uYmFzZVN0YXRzT3B0aW9ucyxcbiAgICAgICAgICBpZGhyOiB7IC4uLihiYXNlU3RhdHNPcHRpb25zLmlkaHIgPz8ge30pLCB0b3BLOiBiYXNlU3RhdHNPcHRpb25zLmlkaHI/LnRvcEsgPz8gOCB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBbbWV0LCB0MjRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIGNvbXB1dGVTYW1wbGVkTWV0cmljc0ZvclN5bWJvbChzeW1ib2wsIHsgd2luZG93OiB3aW5kb3dLZXksIGJpbnM6IGJpbnNOLCBzdGF0czogc3RhdHNPcHRpb25zIH0pLFxuICAgICAgICAgIGZldGNoVGlja2VyMjRoKHN5bWJvbCksXG4gICAgICAgIF0pO1xuICAgICAgICBtZXRyaWNzID0gbWV0O1xuXG4gICAgICAgIGlmICghbWV0cmljcy5vaykge1xuICAgICAgICAgIG91dFtzeW1ib2xdID0ge1xuICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IG1ldHJpY3MuZXJyb3IsXG4gICAgICAgICAgICBiaW5zOiBiaW5zTixcbiAgICAgICAgICAgIHdpbmRvdzogd2luZG93S2V5LFxuICAgICAgICAgICAgc2FtcGxpbmc6IG1ldHJpY3Muc2FtcGxpbmcsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXRzID0gbWV0cmljcy5zdGF0cztcbiAgICAgICAgY29uc3QgeyBtZXRhLCBzYW1wbGluZywgaGlzdCwgZXh0cmVtYSB9ID0gbWV0cmljcztcbiAgICAgICAgY29uc3QgYXAgPSBhcHBseUdmbVNoaWZ0QW5kU3RyZWFtcyhcbiAgICAgICAgICBzdGF0cy5iZm0wMSxcbiAgICAgICAgICBzdG9yZS5yZWZHZm0wMSxcbiAgICAgICAgICBzdG9yZS53aW5kb3csXG4gICAgICAgICAgc3RvcmUuc3RyZWFtcyxcbiAgICAgICAgICB7IGVwc2lsb25QY3Q6IGVwc1BjdCwgd2luZG93U2l6ZToga0N5Y2xlcywgbm93VHM6IG1ldGEubGFzdFVwZGF0ZVRzLCBwcmljZTogbWV0YS5sYXN0IH0sXG4gICAgICAgICk7XG4gICAgICAgIHN0b3JlLndpbmRvdyA9IGFwLndpbmRvdztcbiAgICAgICAgc3RvcmUuc3RyZWFtcyA9IGFwLnN0cmVhbXM7XG4gICAgICAgIGlmIChhcC5pc1NoaWZ0KSB7XG4gICAgICAgICAgc3RvcmUucmVmR2ZtMDEgPSBzdGF0cy5iZm0wMTtcbiAgICAgICAgICBzdG9yZS51aUVwb2NoICs9IDE7XG4gICAgICAgICAgc3RvcmUuc2hpZnRzICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbmVydGlhVG90YWwgPSB0b051bGxhYmxlKHN0YXRzLmluZXJ0aWE/LnRvdGFsKTtcbiAgICAgICAgY29uc3QgaW5lcnRpYVN0YXRpY1ZhbCA9IHRvTnVsbGFibGUoc3RhdHMuaW5lcnRpYT8uc3RhdGljKTtcbiAgICAgICAgY29uc3QgaW5lcnRpYUdyb3d0aFZhbCA9IHRvTnVsbGFibGUoc3RhdHMuaW5lcnRpYT8uZ3Jvd3RoKTtcblxuICAgICAgICBjb25zdCBhbXBWYWwgPSB0b051bGxhYmxlKHN0YXRzLmFtcCk7XG4gICAgICAgIGNvbnN0IHZvbHRWYWwgPSB0b051bGxhYmxlKHN0YXRzLnZvbHQpO1xuICAgICAgICBjb25zdCBlZmZpY2llbmN5VmFsID0gdG9OdWxsYWJsZShzdGF0cy5lZmZpY2llbmN5KTtcblxuICAgICAgICBzdG9yZS5zdHJlYW1zLmluZXJ0aWEgPSB1cGRhdGVTdHJlYW1TY2FsYXIoc3RvcmUuc3RyZWFtcy5pbmVydGlhLCBpbmVydGlhVG90YWwpO1xuICAgICAgICBzdG9yZS5zdHJlYW1zLmFtcCA9IHVwZGF0ZVN0cmVhbVNjYWxhcihzdG9yZS5zdHJlYW1zLmFtcCwgYW1wVmFsKTtcbiAgICAgICAgc3RvcmUuc3RyZWFtcy52b2x0ID0gdXBkYXRlU3RyZWFtU2NhbGFyKHN0b3JlLnN0cmVhbXMudm9sdCwgdm9sdFZhbCk7XG4gICAgICAgIHN0b3JlLnN0cmVhbXMuZWZmaWNpZW5jeSA9IHVwZGF0ZVN0cmVhbVNjYWxhcihzdG9yZS5zdHJlYW1zLmVmZmljaWVuY3ksIGVmZmljaWVuY3lWYWwpO1xuXG4gICAgICAgIGNvbnN0IHBjdDI0aFZhbCA9IE51bWJlci5pc0Zpbml0ZSh0MjQucGN0MjRoKSA/IHQyNC5wY3QyNGggOiBudWxsO1xuICAgICAgICBjb25zdCBwY3REcnZWYWwgPVxuICAgICAgICAgIG1ldGEubiA+IDEgJiZcbiAgICAgICAgICBOdW1iZXIuaXNGaW5pdGUobWV0YS5wcmV2KSAmJlxuICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShtZXRhLmxhc3QpICYmXG4gICAgICAgICAgbWV0YS5wcmV2ICE9PSAwXG4gICAgICAgICAgICA/IHBjdERydihtZXRhLnByZXYsIG1ldGEubGFzdClcbiAgICAgICAgICAgIDogbnVsbDtcblxuICAgICAgICBzdG9yZS5zdHJlYW1zLnBjdDI0aCA9IHVwZGF0ZVN0cmVhbVNjYWxhcihzdG9yZS5zdHJlYW1zLnBjdDI0aCwgcGN0MjRoVmFsKTtcbiAgICAgICAgc3RvcmUuc3RyZWFtcy5wY3RfZHJ2ID0gdXBkYXRlU3RyZWFtU2NhbGFyKHN0b3JlLnN0cmVhbXMucGN0X2RydiwgcGN0RHJ2VmFsKTtcblxuICAgICAgICBjb25zdCBoaXN0Q291bnRzRm9yRGlzcnVwdGlvbiA9IEFycmF5LmlzQXJyYXkoc3RhdHMuaGlzdG9ncmFtPy5jb3VudHMpICYmIHN0YXRzLmhpc3RvZ3JhbSEuY291bnRzLmxlbmd0aFxuICAgICAgICAgID8gc3RhdHMuaGlzdG9ncmFtIS5jb3VudHMubWFwKChjOiBhbnkpID0+IE51bWJlcihjKSB8fCAwKVxuICAgICAgICAgIDogQXJyYXkuaXNBcnJheShoaXN0LmNvdW50cykgPyBoaXN0LmNvdW50cy5tYXAoKGM6IGFueSkgPT4gTnVtYmVyKGMpIHx8IDApIDogW107XG4gICAgICAgIGNvbnN0IGRpc3J1cHRpb25WYWwgPSBkaXNydXB0aW9uRnJvbUNvdW50cyhoaXN0Q291bnRzRm9yRGlzcnVwdGlvbik7XG5cbiAgICAgICAgY29uc3QgZ2ZtQWJzVmFsID0gdG9OdWxsYWJsZShzdGF0cy5nZm1BYnMpO1xuICAgICAgICBjb25zdCBnZm1SZWZWYWwgPSB0b051bGxhYmxlKHN0YXRzLnJlZkdmbUFicyk7XG4gICAgICAgIGNvbnN0IGRlbHRhR2ZtQWJzVmFsID0gdG9OdWxsYWJsZShzdGF0cy5kZWx0YUdmbUFicyk7XG4gICAgICAgIGNvbnN0IGRlbHRhR2ZtUGN0VmFsID0gdG9OdWxsYWJsZShzdGF0cy5kZWx0YUdmbVBjdCk7XG5cbiAgICAgICAgY29uc3QgYmZtVmFsID0gdG9OdWxsYWJsZShzdGF0cy5iZm0wMSk7XG4gICAgICAgIGNvbnN0IGJmbVJlZlZhbCA9IHRvTnVsbGFibGUoc3RhdHMucmVmQmZtMDEpO1xuICAgICAgICBjb25zdCBkZWx0YUJmbVZhbCA9IHRvTnVsbGFibGUoc3RhdHMuZGVsdGFCZm0wMSk7XG4gICAgICAgIGNvbnN0IGRlbHRhQmZtUGN0VmFsID0gdG9OdWxsYWJsZShzdGF0cy5kZWx0YUJmbVBjdCk7XG5cbiAgICAgICAgY29uc3Qgc2lnbWFWYWwgPSB0b051bGxhYmxlKHN0YXRzLnNpZ21hKTtcbiAgICAgICAgY29uc3QgekFic1ZhbCA9IHRvTnVsbGFibGUoc3RhdHMuekFicyk7XG5cbiAgICAgICAgY29uc3Qgb3BlbmluZ1ZhbCA9IHRvTnVsbGFibGUoc3RhdHMub3BlbmluZyk7XG4gICAgICAgIGNvbnN0IGxhc3RWYWwgPSB0b051bGxhYmxlKHN0YXRzLmxhc3QpO1xuICAgICAgICBjb25zdCBwcmV2VmFsID0gdG9OdWxsYWJsZShzdGF0cy5wcmV2KTtcblxuICAgICAgICBzdG9yZS5zdHJlYW1zLmJlbmNobWFyayA9IHVwZGF0ZVN0cmVhbVNjYWxhcihzdG9yZS5zdHJlYW1zLmJlbmNobWFyaywgbGFzdFZhbCk7XG5cbiAgICAgICAgY29uc3QgaW5lcnRpYU91dCA9IHN0YXRzLmluZXJ0aWFcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgc3RhdGljOiBpbmVydGlhU3RhdGljVmFsLFxuICAgICAgICAgICAgICBncm93dGg6IGluZXJ0aWFHcm93dGhWYWwsXG4gICAgICAgICAgICAgIHRvdGFsOiBpbmVydGlhVG90YWwsXG4gICAgICAgICAgICAgIGZhY2U6IHN0YXRzLmluZXJ0aWEuZmFjZSA/PyBudWxsLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogbnVsbDtcblxuICAgICAgICBjb25zdCBtZXRyaWNzT3V0ID0ge1xuICAgICAgICAgIGRpc3BlcnNpb246IHsgc2lnbWE6IHNpZ21hVmFsLCB6QWJzOiB6QWJzVmFsIH0sXG4gICAgICAgICAgZ2ZtOiB7XG4gICAgICAgICAgICBhYnNvbHV0ZTogZ2ZtQWJzVmFsLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiBnZm1SZWZWYWwsXG4gICAgICAgICAgICBkZWx0YUFiczogZGVsdGFHZm1BYnNWYWwsXG4gICAgICAgICAgICBkZWx0YVBjdDogZGVsdGFHZm1QY3RWYWwsXG4gICAgICAgICAgICBzaGlmdGVkOiBCb29sZWFuKHN0YXRzLnNoaWZ0ZWRHZm0pLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYmZtOiB7XG4gICAgICAgICAgICB2YWx1ZTogYmZtVmFsLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiBiZm1SZWZWYWwsXG4gICAgICAgICAgICBkZWx0YTogZGVsdGFCZm1WYWwsXG4gICAgICAgICAgICBkZWx0YVBjdDogZGVsdGFCZm1QY3RWYWwsXG4gICAgICAgICAgICBzaGlmdGVkOiBCb29sZWFuKHN0YXRzLnNoaWZ0ZWRCZm0pLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaW50cmluc2ljOiB7XG4gICAgICAgICAgICBpbmVydGlhOiBpbmVydGlhT3V0LFxuICAgICAgICAgICAgYW1wOiBhbXBWYWwsXG4gICAgICAgICAgICB2b2x0OiB2b2x0VmFsLFxuICAgICAgICAgICAgZWZmaWNpZW5jeTogZWZmaWNpZW5jeVZhbCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc3J1cHRpb246IGRpc3J1cHRpb25WYWwsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgc3RhdHNPdXQgPSB7XG4gICAgICAgICAgc2lnbWE6IHNpZ21hVmFsLFxuICAgICAgICAgIHpBYnM6IHpBYnNWYWwsXG4gICAgICAgICAgZ2ZtQWJzOiBnZm1BYnNWYWwsXG4gICAgICAgICAgcmVmR2ZtQWJzOiBnZm1SZWZWYWwsXG4gICAgICAgICAgZGVsdGFHZm1BYnM6IGRlbHRhR2ZtQWJzVmFsLFxuICAgICAgICAgIGRlbHRhR2ZtUGN0OiBkZWx0YUdmbVBjdFZhbCxcbiAgICAgICAgICBzaGlmdGVkR2ZtOiBCb29sZWFuKHN0YXRzLnNoaWZ0ZWRHZm0pLFxuICAgICAgICAgIGJmbTAxOiBiZm1WYWwsXG4gICAgICAgICAgcmVmQmZtMDE6IGJmbVJlZlZhbCxcbiAgICAgICAgICBkZWx0YUJmbTAxOiBkZWx0YUJmbVZhbCxcbiAgICAgICAgICBkZWx0YUJmbVBjdDogZGVsdGFCZm1QY3RWYWwsXG4gICAgICAgICAgc2hpZnRlZEJmbTogQm9vbGVhbihzdGF0cy5zaGlmdGVkQmZtKSxcbiAgICAgICAgICBpbmVydGlhOiBpbmVydGlhT3V0LFxuICAgICAgICAgIGFtcDogYW1wVmFsLFxuICAgICAgICAgIHZvbHQ6IHZvbHRWYWwsXG4gICAgICAgICAgZWZmaWNpZW5jeTogZWZmaWNpZW5jeVZhbCxcbiAgICAgICAgICBoaXN0b2dyYW06IHN0YXRzLmhpc3RvZ3JhbSA/PyBudWxsLFxuICAgICAgICAgIG9wZW5pbmc6IG9wZW5pbmdWYWwsXG4gICAgICAgICAgbGFzdDogbGFzdFZhbCxcbiAgICAgICAgICBwcmV2OiBwcmV2VmFsLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGdmbURlbHRhID0ge1xuICAgICAgICAgIGFuY2hvclByaWNlOiBnZm1BYnNWYWwsXG4gICAgICAgICAgcHJpY2U6IGxhc3RWYWwsXG4gICAgICAgICAgYWJzUGN0OiBkZWx0YUdmbVBjdFZhbCxcbiAgICAgICAgfTtcblxuICAgICAgICBvdXRbc3ltYm9sXSA9IHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICB3aW5kb3c6IHdpbmRvd0tleSxcbiAgICAgICAgICBuOiBtZXRhLm4sXG4gICAgICAgICAgY2FyZHM6IHtcbiAgICAgICAgICAgIG9wZW5pbmc6IHsgYmVuY2htYXJrOiBvcGVuaW5nVmFsLCBwY3QyNGg6IHBjdDI0aFZhbCB9LFxuICAgICAgICAgICAgbGl2ZTogeyBiZW5jaG1hcms6IGxhc3RWYWwsIHBjdF9kcnY6IHBjdERydlZhbCwgcGN0MjRoOiBwY3QyNGhWYWwgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0YXRzOiBzdGF0c091dCxcbiAgICAgICAgICBtZXRyaWNzOiBtZXRyaWNzT3V0LFxuICAgICAgICAgIGZtOiB7XG4gICAgICAgICAgICBnZm06IGdmbUFic1ZhbCxcbiAgICAgICAgICAgIGdmbV9wcmljZTogZ2ZtQWJzVmFsLFxuICAgICAgICAgICAgZ2ZtX2NhbGNfcHJpY2U6IGdmbUFic1ZhbCxcbiAgICAgICAgICAgIGdmbV9yZWZfcHJpY2U6IGdmbVJlZlZhbCxcbiAgICAgICAgICAgIGJmbTAxOiBiZm1WYWwsXG4gICAgICAgICAgICBiZm1fcmVmOiBiZm1SZWZWYWwsXG4gICAgICAgICAgICBiZm1fZGVsdGEwMTogZGVsdGFCZm1WYWwsXG4gICAgICAgICAgICBiZm1fZGVsdGFfcGN0OiBkZWx0YUJmbVBjdFZhbCxcbiAgICAgICAgICAgIGJmbV9zaGlmdGVkOiBCb29sZWFuKHN0YXRzLnNoaWZ0ZWRCZm0pLFxuICAgICAgICAgICAgc2lnbWE6IHNpZ21hVmFsLFxuICAgICAgICAgICAgekFiczogekFic1ZhbCxcbiAgICAgICAgICAgIGluZXJ0aWE6IGluZXJ0aWFUb3RhbCxcbiAgICAgICAgICAgIGRpc3J1cHRpb246IGRpc3J1cHRpb25WYWwsXG4gICAgICAgICAgICBhbXA6IGFtcFZhbCxcbiAgICAgICAgICAgIHZvbHQ6IHZvbHRWYWwsXG4gICAgICAgICAgICBlZmZpY2llbmN5OiBlZmZpY2llbmN5VmFsLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2ZtRGVsdGEsXG4gICAgICAgICAgc3RyZWFtczogc3RvcmUuc3RyZWFtcyxcbiAgICAgICAgICBzaGlmdHM6IHsgblNoaWZ0czogc3RvcmUuc2hpZnRzLCBsYXRlc3RUczogbWV0YS5sYXN0VXBkYXRlVHMgfSxcbiAgICAgICAgICBzaGlmdF9zdGFtcDogYXAuaXNTaGlmdCxcbiAgICAgICAgICBoaXN0LFxuICAgICAgICAgIGV4dHJlbWEsXG4gICAgICAgICAgbWV0YTogeyB1aUVwb2NoOiBzdG9yZS51aUVwb2NoLCBlcHNQY3QsIGtDeWNsZXMgfSxcbiAgICAgICAgICBsYXN0VXBkYXRlVHM6IG1ldGEubGFzdFVwZGF0ZVRzLFxuICAgICAgICAgIHNhbXBsaW5nLFxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgIGNvbnN0IHNhbXBsaW5nID0gbWV0cmljcyAmJiAnc2FtcGxpbmcnIGluIG1ldHJpY3MgPyBtZXRyaWNzLnNhbXBsaW5nIDogdW5kZWZpbmVkO1xuICAgICAgICBvdXRbc3ltYm9sXSA9IHtcbiAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IFN0cmluZyhlPy5tZXNzYWdlID8/IGUpLFxuICAgICAgICAgIHdpbmRvdzogd2luZG93S2V5LFxuICAgICAgICAgIGJpbnM6IGJpbnNOLFxuICAgICAgICAgIHNhbXBsaW5nLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICBvazogdHJ1ZSxcbiAgICAgIHN5bWJvbHMsXG4gICAgICBvdXQsXG4gICAgICB3aW5kb3c6IHdpbmRvd0tleSxcbiAgICAgIHRzOiBub3csXG4gICAgICB1bml2ZXJzZToge1xuICAgICAgICBxdW90ZTogc2VsZWN0aW9uLnF1b3RlLFxuICAgICAgICBxdW90ZXM6IHNlbGVjdGlvbi5xdW90ZXMsXG4gICAgICAgIGJhc2VzOiBzZWxlY3Rpb24uYmFzZXMsXG4gICAgICAgIGRlZmF1bHRzOiBzZWxlY3Rpb24uZGVmYXVsdHMsXG4gICAgICAgIGV4dHJhczogc2VsZWN0aW9uLmV4dHJhcyxcbiAgICAgICAgZXhwbGljaXQ6IHNlbGVjdGlvbi5leHBsaWNpdCxcbiAgICAgICAgc291cmNlOiBzZWxlY3Rpb24uc291cmNlLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBvazogZmFsc2UsIGVycm9yOiBTdHJpbmcoZXJyPy5tZXNzYWdlID8/IGVycikgfSwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsInJ1bnRpbWUiLCJkeW5hbWljIiwiY29tcHV0ZVNhbXBsZWRNZXRyaWNzRm9yU3ltYm9sIiwiYXBwbHlHZm1TaGlmdEFuZFN0cmVhbXMiLCJyZXNvbHZlU3ltYm9sU2VsZWN0aW9uIiwicGFyc2VXaW5kb3ciLCJzIiwidiIsInRvTG93ZXJDYXNlIiwicGFyc2VCaW5zUGFyYW0iLCJkZmx0IiwibiIsIk51bWJlciIsImlzRmluaXRlIiwiTWF0aCIsIm1pbiIsImZsb29yIiwiZmV0Y2hUaWNrZXIyNGgiLCJzeW1ib2wiLCJyIiwiZmV0Y2giLCJjYWNoZSIsIm9rIiwicHJpY2UiLCJOYU4iLCJwY3QyNGgiLCJqIiwianNvbiIsImxhc3RQcmljZSIsIndlaWdodGVkQXZnUHJpY2UiLCJwcmljZUNoYW5nZVBlcmNlbnQiLCJwY3REcnYiLCJwcmV2IiwiY3VyIiwiZGlzcnVwdGlvbkZyb21Db3VudHMiLCJjb3VudHMiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJ0b3RhbCIsImkiLCJhYnMiLCJTSElGVCIsImdsb2JhbFRoaXMiLCJfX1NUUl9BVVhfU0hJRlRfXyIsIk1hcCIsInNoaWZ0S2V5Iiwic2VzcyIsInN5bSIsImdldFNoaWZ0U3RhdGUiLCJhcHBTZXNzaW9uSWQiLCJrZXkiLCJnZXQiLCJzdHJlYW1zIiwibWF4U3RhbXBzIiwiaW5pdCIsInJlZkdmbTAxIiwid2luZG93IiwiZXhjZWVkIiwic2hpZnRzIiwidWlFcG9jaCIsInNldCIsInRvTnVsbGFibGUiLCJ2YWx1ZSIsInVwZGF0ZVN0cmVhbVNjYWxhciIsInJvdyIsIm5leHQiLCJwcmV2Q3VyIiwicHJldkdyZWF0ZXN0IiwiZ3JlYXRlc3QiLCJtYXgiLCJHRVQiLCJyZXEiLCJ1cmwiLCJVUkwiLCJzZWxlY3Rpb24iLCJzeW1ib2xzIiwid2luZG93S2V5Iiwic2VhcmNoUGFyYW1zIiwiYmluc04iLCJzbGljZSIsImVwc1BjdCIsImtDeWNsZXMiLCJub3ciLCJEYXRlIiwib3V0IiwidHMiLCJiYXNlU3RhdHNPcHRpb25zIiwiaWRociIsImFscGhhIiwic01pbiIsInNtb290aCIsInRvcEsiLCJlcHNHZm1QY3QiLCJlcHNCZm1QY3QiLCJ2U2NhbGUiLCJ0ZW5kZW5jeVdpbiIsInRlbmRlbmN5Tm9ybSIsIm1ldHJpY3MiLCJzdG9yZSIsInN0YXRzT3B0aW9ucyIsIm1ldCIsInQyNCIsIlByb21pc2UiLCJhbGwiLCJiaW5zIiwic3RhdHMiLCJlcnJvciIsInNhbXBsaW5nIiwibWV0YSIsImhpc3QiLCJleHRyZW1hIiwiYXAiLCJiZm0wMSIsImVwc2lsb25QY3QiLCJ3aW5kb3dTaXplIiwibm93VHMiLCJsYXN0VXBkYXRlVHMiLCJsYXN0IiwiaXNTaGlmdCIsImluZXJ0aWFUb3RhbCIsImluZXJ0aWEiLCJpbmVydGlhU3RhdGljVmFsIiwic3RhdGljIiwiaW5lcnRpYUdyb3d0aFZhbCIsImdyb3d0aCIsImFtcFZhbCIsImFtcCIsInZvbHRWYWwiLCJ2b2x0IiwiZWZmaWNpZW5jeVZhbCIsImVmZmljaWVuY3kiLCJwY3QyNGhWYWwiLCJwY3REcnZWYWwiLCJwY3RfZHJ2IiwiaGlzdENvdW50c0ZvckRpc3J1cHRpb24iLCJoaXN0b2dyYW0iLCJtYXAiLCJjIiwiZGlzcnVwdGlvblZhbCIsImdmbUFic1ZhbCIsImdmbUFicyIsImdmbVJlZlZhbCIsInJlZkdmbUFicyIsImRlbHRhR2ZtQWJzVmFsIiwiZGVsdGFHZm1BYnMiLCJkZWx0YUdmbVBjdFZhbCIsImRlbHRhR2ZtUGN0IiwiYmZtVmFsIiwiYmZtUmVmVmFsIiwicmVmQmZtMDEiLCJkZWx0YUJmbVZhbCIsImRlbHRhQmZtMDEiLCJkZWx0YUJmbVBjdFZhbCIsImRlbHRhQmZtUGN0Iiwic2lnbWFWYWwiLCJzaWdtYSIsInpBYnNWYWwiLCJ6QWJzIiwib3BlbmluZ1ZhbCIsIm9wZW5pbmciLCJsYXN0VmFsIiwicHJldlZhbCIsImJlbmNobWFyayIsImluZXJ0aWFPdXQiLCJmYWNlIiwibWV0cmljc091dCIsImRpc3BlcnNpb24iLCJnZm0iLCJhYnNvbHV0ZSIsInJlZmVyZW5jZSIsImRlbHRhQWJzIiwiZGVsdGFQY3QiLCJzaGlmdGVkIiwiQm9vbGVhbiIsInNoaWZ0ZWRHZm0iLCJiZm0iLCJkZWx0YSIsInNoaWZ0ZWRCZm0iLCJpbnRyaW5zaWMiLCJkaXNydXB0aW9uIiwic3RhdHNPdXQiLCJnZm1EZWx0YSIsImFuY2hvclByaWNlIiwiYWJzUGN0IiwiY2FyZHMiLCJsaXZlIiwiZm0iLCJnZm1fcHJpY2UiLCJnZm1fY2FsY19wcmljZSIsImdmbV9yZWZfcHJpY2UiLCJiZm1fcmVmIiwiYmZtX2RlbHRhMDEiLCJiZm1fZGVsdGFfcGN0IiwiYmZtX3NoaWZ0ZWQiLCJuU2hpZnRzIiwibGF0ZXN0VHMiLCJzaGlmdF9zdGFtcCIsImUiLCJ1bmRlZmluZWQiLCJTdHJpbmciLCJtZXNzYWdlIiwidW5pdmVyc2UiLCJxdW90ZSIsInF1b3RlcyIsImJhc2VzIiwiZGVmYXVsdHMiLCJleHRyYXMiLCJleHBsaWNpdCIsInNvdXJjZSIsImVyciIsInN0YXR1cyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/str-aux/stats/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/calc/executive.ts":
/*!*****************************************************!*\
  !*** ./src/core/features/str-aux/calc/executive.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeSampledMetrics: () => (/* binding */ computeSampledMetrics),\n/* harmony export */   computeSampledMetricsForSymbol: () => (/* binding */ computeSampledMetricsForSymbol),\n/* harmony export */   executeCalcAndUpdateSession: () => (/* binding */ executeCalcAndUpdateSession)\n/* harmony export */ });\n/* harmony import */ var _core_features_str_aux_frame_idhr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/features/str-aux/frame/idhr */ \"(rsc)/./src/core/features/str-aux/frame/idhr.ts\");\n/* harmony import */ var _core_features_str_aux_calc_tendency__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/core/features/str-aux/calc/tendency */ \"(rsc)/./src/core/features/str-aux/calc/tendency.ts\");\n/* harmony import */ var _core_features_str_aux_calc_metrics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/core/features/str-aux/calc/metrics */ \"(rsc)/./src/core/features/str-aux/calc/metrics.ts\");\n/* harmony import */ var _core_features_str_aux_frame_session__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/core/features/str-aux/frame/session */ \"(rsc)/./src/core/features/str-aux/frame/session.ts\");\n/* harmony import */ var _core_features_str_aux_calc_stats__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/core/features/str-aux/calc/stats */ \"(rsc)/./src/core/features/str-aux/calc/stats.ts\");\n/* harmony import */ var _core_features_str_aux_sampling__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/core/features/str-aux/sampling */ \"(rsc)/./src/core/features/str-aux/sampling/index.ts\");\n// src/core/features/str-aux/calc/executive.ts\n // IDHR + gfm  :contentReference[oaicite:11]{index=11}\n // vectors     :contentReference[oaicite:12]{index=12}\n // inertia.    :contentReference[oaicite:13]{index=13}\n // session API :contentReference[oaicite:14]{index=14}\n\n\nfunction toSeries(payload) {\n    const ts = payload.snapshot.tick.cycleTs ?? payload.frames.cycleStart;\n    const out = {};\n    for (const p of payload.snapshot.points){\n        const price = Number(p.mid ?? NaN);\n        if (!Number.isFinite(price)) continue;\n        (out[p.symbol] ??= []).push({\n            ts,\n            price\n        });\n    }\n    return out;\n}\nfunction openingFromSeries(series) {\n    const first = series.find((p)=>Number.isFinite(p.price));\n    return {\n        benchmark: first ? first.price : null\n    };\n}\nfunction executeCalcAndUpdateSession(appSessionId, payload, seriesBuffers, pct24hMap) {\n    const res = [];\n    const seriesNow = toSeries(payload);\n    for (const [pair, pts] of Object.entries(seriesNow)){\n        // append into buffers\n        const buf = seriesBuffers[pair] = (seriesBuffers[pair] ?? []).concat(pts).slice(-3600);\n        const opening = openingFromSeries(buf);\n        const idhr = (0,_core_features_str_aux_frame_idhr__WEBPACK_IMPORTED_MODULE_0__.computeFM)(buf, opening); // returns { gfm, sigmaGlobal, zMeanAbs, nuclei }  :contentReference[oaicite:15]{index=15}\n        const gfmCalcPrice = Number.isFinite(idhr?.gfm) ? idhr.gfm : NaN;\n        // simple tendency from last N returns (use z as unitless)\n        const returns = buf.slice(-60).map((p, i, a)=>i ? 100 * (p.price / a[i - 1].price - 1) : 0).slice(1);\n        const vin = returns.length ? _core_features_str_aux_calc_tendency__WEBPACK_IMPORTED_MODULE_1__.vInner({\n            values: returns\n        }, {\n            scale: 100\n        }) : 0;\n        const vout = returns.length ? _core_features_str_aux_calc_tendency__WEBPACK_IMPORTED_MODULE_1__.vOuter([\n            {\n                values: returns\n            }\n        ], undefined, {\n            scale: 100\n        }) : 0;\n        const vt = returns.length ? _core_features_str_aux_calc_tendency__WEBPACK_IMPORTED_MODULE_1__.vTendencyFromSeries(returns, {\n            scale: 100\n        }).score : 0;\n        // inertia example: from returns only (window=returns.length)\n        const inertia = returns.length ? _core_features_str_aux_calc_metrics__WEBPACK_IMPORTED_MODULE_2__.inertiaFromReturns(returns, {\n            window: returns.length\n        }) : null;\n        // session update\n        const nowTs = payload.frames.cycleEnd ?? payload.snapshot.tick.cycleTs ?? Date.now();\n        const priceNow = buf[buf.length - 1]?.price ?? NaN;\n        const pct24hNow = Number(pct24hMap?.[pair] ?? 0);\n        const ss = (0,_core_features_str_aux_frame_session__WEBPACK_IMPORTED_MODULE_3__.getOrInitSymbolSession)(appSessionId, pair, opening.benchmark ?? priceNow ?? 0, nowTs);\n        const upd = (0,_core_features_str_aux_frame_session__WEBPACK_IMPORTED_MODULE_3__.updateSymbolSession)(ss, priceNow, nowTs, gfmCalcPrice, pct24hNow); // :contentReference[oaicite:17]{index=17}\n        res.push({\n            pair,\n            idhr: {\n                gfm: Number.isFinite(idhr.gfm) ? idhr.gfm : null,\n                sigmaGlobal: Number.isFinite(idhr.sigmaGlobal) ? idhr.sigmaGlobal : null,\n                zMeanAbs: Number.isFinite(idhr.zMeanAbs) ? idhr.zMeanAbs : null,\n                nuclei: idhr.nuclei ?? []\n            },\n            vectors: {\n                vInner: vin,\n                vOuter: vout,\n                vTendency: vt\n            },\n            metrics: {\n                inertia\n            },\n            session: {\n                uiEpoch: upd.uiEpoch,\n                gfmRefPrice: upd.gfmRefPrice,\n                gfmCalcPrice: upd.gfmCalcPrice,\n                gfmDeltaAbsPct: upd.gfmDeltaAbsPct\n            }\n        });\n    }\n    return res;\n}\nasync function computeSampledMetricsForSymbol(symbol, opts) {\n    const sampler = (0,_core_features_str_aux_sampling__WEBPACK_IMPORTED_MODULE_5__.getSamplingStore)();\n    let snapshot;\n    if (opts.collect === false) {\n        snapshot = sampler.snapshot(symbol);\n    } else {\n        try {\n            const collected = await sampler.collect(symbol);\n            snapshot = collected.snapshot;\n        } catch  {\n            snapshot = sampler.snapshot(symbol);\n        }\n    }\n    const sampling = (0,_core_features_str_aux_sampling__WEBPACK_IMPORTED_MODULE_5__.summarizeSnapshotWindow)(snapshot, opts.window);\n    const points = sampler.getPoints(symbol, opts.window);\n    const series = pointsToStatPoints(points);\n    if (!series.length) {\n        return {\n            ok: false,\n            symbol,\n            error: \"no_points\",\n            sampling\n        };\n    }\n    const bins = Math.max(1, Math.floor(opts.bins ?? 1));\n    const opening = series[0].price;\n    const statsOptions = {\n        ...opts.stats ?? {},\n        idhr: {\n            ...opts.stats?.idhr ?? {},\n            bins\n        }\n    };\n    const stats = (0,_core_features_str_aux_calc_stats__WEBPACK_IMPORTED_MODULE_4__.computeStats)(series, {\n        benchmark: opening\n    }, statsOptions);\n    const priceValues = series.map((p)=>p.price);\n    const priceMin = Math.min(...priceValues);\n    const priceMax = Math.max(...priceValues);\n    const benchValues = series.map((p)=>benchPct(opening, p.price));\n    const benchPctMin = Math.min(...benchValues);\n    const benchPctMax = Math.max(...benchValues);\n    const histogram = stats.histogram;\n    const lastPoint = series[series.length - 1];\n    const fallbackHistogram = ()=>{\n        const counts = makeCounts(series, opening, bins);\n        const total = counts.reduce((s, c)=>s + c, 0);\n        const probs = total > 0 ? counts.map((c)=>c / total) : counts.map(()=>0);\n        return {\n            counts,\n            edges: [],\n            probs,\n            densest: [],\n            muR: 0,\n            sigmaR: 0,\n            total,\n            binWidth: null,\n            rMin: null,\n            rMax: null,\n            returnsPct: []\n        };\n    };\n    const histOut = histogram && histogram.counts?.length ? {\n        counts: histogram.counts,\n        edges: histogram.edges,\n        probs: histogram.probs,\n        densest: histogram.densest,\n        muR: histogram.muR,\n        sigmaR: histogram.sigmaR,\n        total: histogram.total,\n        binWidth: histogram.edges.length > 1 ? histogram.edges[1] - histogram.edges[0] : null,\n        rMin: histogram.edges[0] ?? null,\n        rMax: histogram.edges[histogram.edges.length - 1] ?? null,\n        returnsPct: histogram.edges.map((r)=>{\n            const pct = Math.expm1(r) * 100;\n            return Number.isFinite(pct) ? pct : 0;\n        })\n    } : fallbackHistogram();\n    return {\n        ok: true,\n        symbol,\n        stats,\n        hist: histOut,\n        extrema: {\n            priceMin,\n            priceMax,\n            benchPctMin,\n            benchPctMax\n        },\n        meta: {\n            opening: stats.opening,\n            last: stats.last,\n            prev: stats.prev,\n            lastUpdateTs: lastPoint.ts,\n            n: series.length\n        },\n        sampling\n    };\n}\nasync function computeSampledMetrics(symbols, opts) {\n    const pairs = await Promise.all(symbols.map(async (sym)=>[\n            sym,\n            await computeSampledMetricsForSymbol(sym, opts)\n        ]));\n    const out = {};\n    for (const [sym, result] of pairs)out[sym] = result;\n    return out;\n}\nfunction pointsToStatPoints(points) {\n    return points.filter((p)=>Number.isFinite(p.mid) && p.mid > 0).map((p)=>{\n        const bid = Number.isFinite(p.bidVolume) ? p.bidVolume : 0;\n        const ask = Number.isFinite(p.askVolume) ? p.askVolume : 0;\n        return {\n            ts: p.ts,\n            price: p.mid,\n            volume: Math.max(0, bid + ask)\n        };\n    });\n}\nfunction makeCounts(points, opening, totalBins) {\n    const bins = Math.max(1, totalBins);\n    if (!points.length || !(opening > 0)) return Array(bins).fill(0);\n    const rets = points.map((p)=>Math.log(p.price / opening));\n    const min = Math.min(...rets);\n    const max = Math.max(...rets);\n    const lo = min === max ? min - 1e-6 : min;\n    const hi = min === max ? max + 1e-6 : max;\n    const counts = Array(bins).fill(0);\n    for (const r of rets){\n        const t = (r - lo) / (hi - lo);\n        const idx = Math.max(0, Math.min(bins - 1, Math.floor(t * bins)));\n        counts[idx] += 1;\n    }\n    return counts;\n}\nfunction benchPct(opening, cur) {\n    return 100 * (cur / opening - 1);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L2NhbGMvZXhlY3V0aXZlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLDhDQUE4QztBQUVpQixDQUFpQixzREFBc0Q7QUFDeEUsQ0FBTyxzREFBc0Q7QUFDL0QsQ0FBb0Isc0RBQXNEO0FBS3ZGLENBQTJDLHNEQUFzRDtBQU1wRztBQU9GO0FBSzFDLFNBQVNRLFNBQVNDLE9BQXlCO0lBQ3pDLE1BQU1DLEtBQUtELFFBQVFFLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDQyxPQUFPLElBQUlKLFFBQVFLLE1BQU0sQ0FBQ0MsVUFBVTtJQUNyRSxNQUFNQyxNQUFxQyxDQUFDO0lBQzVDLEtBQUssTUFBTUMsS0FBS1IsUUFBUUUsUUFBUSxDQUFDTyxNQUFNLENBQUU7UUFDdkMsTUFBTUMsUUFBUUMsT0FBT0gsRUFBRUksR0FBRyxJQUFJQztRQUM5QixJQUFJLENBQUNGLE9BQU9HLFFBQVEsQ0FBQ0osUUFBUTtRQUM1QkgsQ0FBQUEsR0FBRyxDQUFDQyxFQUFFTyxNQUFNLENBQUMsS0FBSyxFQUFFLEVBQUVDLElBQUksQ0FBQztZQUFFZjtZQUFJUztRQUFNO0lBQzFDO0lBQ0EsT0FBT0g7QUFDVDtBQUVBLFNBQVNVLGtCQUFrQkMsTUFBcUI7SUFDOUMsTUFBTUMsUUFBUUQsT0FBT0UsSUFBSSxDQUFDLENBQUNaLElBQU1HLE9BQU9HLFFBQVEsQ0FBQ04sRUFBRUUsS0FBSztJQUN4RCxPQUFPO1FBQUVXLFdBQVdGLFFBQVFBLE1BQU1ULEtBQUssR0FBRztJQUFLO0FBQ2pEO0FBYU8sU0FBU1ksNEJBQ2RDLFlBQW9CLEVBQ3BCdkIsT0FBeUIsRUFDekJ3QixhQUE0QyxFQUM1Q0MsU0FBa0M7SUFFbEMsTUFBTUMsTUFBb0IsRUFBRTtJQUM1QixNQUFNQyxZQUFZNUIsU0FBU0M7SUFFM0IsS0FBSyxNQUFNLENBQUM0QixNQUFNQyxJQUFJLElBQUlDLE9BQU9DLE9BQU8sQ0FBQ0osV0FBWTtRQUNuRCxzQkFBc0I7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LE9BQU8sR0FBR0MsS0FBS0UsS0FBSyxDQUFDNEQsSUFBSS9EO1FBQzFEaUIsTUFBTSxDQUFDK0MsSUFBSSxJQUFJO0lBQ2pCO0lBQ0EsT0FBTy9DO0FBQ1Q7QUFFQSxTQUFTTixTQUFTN0QsT0FBZSxFQUFFbUgsR0FBVztJQUM1QyxPQUFPLE1BQU8sT0FBT25ILFVBQVc7QUFDbEMiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxjb3JlXFxmZWF0dXJlc1xcc3RyLWF1eFxcY2FsY1xcZXhlY3V0aXZlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb3JlL2ZlYXR1cmVzL3N0ci1hdXgvY2FsYy9leGVjdXRpdmUudHNcbmltcG9ydCB0eXBlIHsgU25hcHNob3RXaXRoUmVmcyB9IGZyb20gXCIuLi9mcmFtZVwiO1xuaW1wb3J0IHsgY29tcHV0ZUZNIH0gZnJvbSBcIkAvY29yZS9mZWF0dXJlcy9zdHItYXV4L2ZyYW1lL2lkaHJcIjsgICAgICAgICAgICAgICAgIC8vIElESFIgKyBnZm0gIDpjb250ZW50UmVmZXJlbmNlW29haWNpdGU6MTFde2luZGV4PTExfVxuaW1wb3J0ICogYXMgVGVuZCBmcm9tIFwiQC9jb3JlL2ZlYXR1cmVzL3N0ci1hdXgvY2FsYy90ZW5kZW5jeVwiOyAgICAgICAvLyB2ZWN0b3JzICAgICA6Y29udGVudFJlZmVyZW5jZVtvYWljaXRlOjEyXXtpbmRleD0xMn1cbmltcG9ydCAqIGFzIE1ldCBmcm9tIFwiQC9jb3JlL2ZlYXR1cmVzL3N0ci1hdXgvY2FsYy9tZXRyaWNzXCI7ICAgICAgICAgICAgICAgICAgICAvLyBpbmVydGlhLiAgICA6Y29udGVudFJlZmVyZW5jZVtvYWljaXRlOjEzXXtpbmRleD0xM31cbmltcG9ydCB7XG4gIGdldE9ySW5pdFN5bWJvbFNlc3Npb24sXG4gIHVwZGF0ZVN5bWJvbFNlc3Npb24sXG4gIHR5cGUgU25hcHNob3QgYXMgU2Vzc1NuYXBcbn0gZnJvbSBcIkAvY29yZS9mZWF0dXJlcy9zdHItYXV4L2ZyYW1lL3Nlc3Npb25cIjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2Vzc2lvbiBBUEkgOmNvbnRlbnRSZWZlcmVuY2Vbb2FpY2l0ZToxNF17aW5kZXg9MTR9XG5pbXBvcnQge1xuICBjb21wdXRlU3RhdHMsXG4gIHR5cGUgUG9pbnQgYXMgU3RhdFBvaW50LFxuICB0eXBlIFN0YXRzLFxuICB0eXBlIFN0YXRzT3B0aW9ucyxcbn0gZnJvbSBcIkAvY29yZS9mZWF0dXJlcy9zdHItYXV4L2NhbGMvc3RhdHNcIjtcbmltcG9ydCB7XG4gIGdldFNhbXBsaW5nU3RvcmUsXG4gIHN1bW1hcml6ZVNuYXBzaG90V2luZG93LFxuICB0eXBlIFNhbXBsaW5nUG9pbnQsXG4gIHR5cGUgU2FtcGxpbmdXaW5kb3dEaWdlc3QsXG4gIHR5cGUgU2FtcGxpbmdXaW5kb3dLZXksXG59IGZyb20gXCJAL2NvcmUvZmVhdHVyZXMvc3RyLWF1eC9zYW1wbGluZ1wiO1xuXG5leHBvcnQgdHlwZSBNYXJrZXRQb2ludCA9IHsgdHM6IG51bWJlcjsgcHJpY2U6IG51bWJlciB9O1xuZXhwb3J0IHR5cGUgT3BlbmluZ0V4YWN0ID0geyBiZW5jaG1hcms6IG51bWJlciB8IG51bGwgfTtcblxuZnVuY3Rpb24gdG9TZXJpZXMocGF5bG9hZDogU25hcHNob3RXaXRoUmVmcyk6IFJlY29yZDxzdHJpbmcsIE1hcmtldFBvaW50W10+IHtcbiAgY29uc3QgdHMgPSBwYXlsb2FkLnNuYXBzaG90LnRpY2suY3ljbGVUcyA/PyBwYXlsb2FkLmZyYW1lcy5jeWNsZVN0YXJ0O1xuICBjb25zdCBvdXQ6IFJlY29yZDxzdHJpbmcsIE1hcmtldFBvaW50W10+ID0ge307XG4gIGZvciAoY29uc3QgcCBvZiBwYXlsb2FkLnNuYXBzaG90LnBvaW50cykge1xuICAgIGNvbnN0IHByaWNlID0gTnVtYmVyKHAubWlkID8/IE5hTik7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocHJpY2UpKSBjb250aW51ZTtcbiAgICAob3V0W3Auc3ltYm9sXSA/Pz0gW10pLnB1c2goeyB0cywgcHJpY2UgfSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gb3BlbmluZ0Zyb21TZXJpZXMoc2VyaWVzOiBNYXJrZXRQb2ludFtdKTogT3BlbmluZ0V4YWN0IHtcbiAgY29uc3QgZmlyc3QgPSBzZXJpZXMuZmluZCgocCkgPT4gTnVtYmVyLmlzRmluaXRlKHAucHJpY2UpKTtcbiAgcmV0dXJuIHsgYmVuY2htYXJrOiBmaXJzdCA/IGZpcnN0LnByaWNlIDogbnVsbCB9O1xufVxuXG5leHBvcnQgdHlwZSBFeGVjUmVzdWx0ID0ge1xuICBwYWlyOiBzdHJpbmc7XG4gIGlkaHI6IHsgZ2ZtOiBudW1iZXIgfCBudWxsOyBzaWdtYUdsb2JhbDogbnVtYmVyIHwgbnVsbDsgek1lYW5BYnM6IG51bWJlciB8IG51bGw7IG51Y2xlaTogYW55W10gfTtcbiAgdmVjdG9yczogeyB2SW5uZXI/OiBudW1iZXI7IHZPdXRlcj86IG51bWJlcjsgdlRlbmRlbmN5PzogbnVtYmVyIH07XG4gIG1ldHJpY3M6IHsgaW5lcnRpYT86IHsgc3RhdGljOiBudW1iZXI7IGdyb3d0aDogbnVtYmVyOyB0b3RhbDogbnVtYmVyIH0gfCBudWxsIH07XG4gIHNlc3Npb246IHtcbiAgICB1aUVwb2NoOiBudW1iZXI7IGdmbVJlZlByaWNlOiBudW1iZXIgfCBudWxsOyBnZm1DYWxjUHJpY2U6IG51bWJlciB8IG51bGw7IGdmbURlbHRhQWJzUGN0OiBudW1iZXI7XG4gICAgc25hcHNob3Q6IFNlc3NTbmFwO1xuICB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVDYWxjQW5kVXBkYXRlU2Vzc2lvbihcbiAgYXBwU2Vzc2lvbklkOiBzdHJpbmcsXG4gIHBheWxvYWQ6IFNuYXBzaG90V2l0aFJlZnMsXG4gIHNlcmllc0J1ZmZlcnM6IFJlY29yZDxzdHJpbmcsIE1hcmtldFBvaW50W10+LCAgLy8gcmluZy1idWZmZXJzIHBlciBcIkJBU0UvUVVPVEVcIlxuICBwY3QyNGhNYXA/OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LCAgICAgICAgICAgLy8gb3B0aW9uYWwgMjRoICVcbik6IEV4ZWNSZXN1bHRbXSB7XG4gIGNvbnN0IHJlczogRXhlY1Jlc3VsdFtdID0gW107XG4gIGNvbnN0IHNlcmllc05vdyA9IHRvU2VyaWVzKHBheWxvYWQpO1xuXG4gIGZvciAoY29uc3QgW3BhaXIsIHB0c10gb2YgT2JqZWN0LmVudHJpZXMoc2VyaWVzTm93KSkge1xuICAgIC8vIGFwcGVuZCBpbnRvIGJ1ZmZlcnNcbiAgICBjb25zdCBidWYgPSBzZXJpZXNCdWZmZXJzW3BhaXJdID0gKHNlcmllc0J1ZmZlcnNbcGFpcl0gPz8gW10pLmNvbmNhdChwdHMpLnNsaWNlKC0zNjAwKTtcblxuICAgIGNvbnN0IG9wZW5pbmcgPSBvcGVuaW5nRnJvbVNlcmllcyhidWYpO1xuICAgIGNvbnN0IGlkaHIgPSBjb21wdXRlRk0oYnVmIGFzIGFueSwgb3BlbmluZyBhcyBhbnkpOyAvLyByZXR1cm5zIHsgZ2ZtLCBzaWdtYUdsb2JhbCwgek1lYW5BYnMsIG51Y2xlaSB9ICA6Y29udGVudFJlZmVyZW5jZVtvYWljaXRlOjE1XXtpbmRleD0xNX1cbiAgICBjb25zdCBnZm1DYWxjUHJpY2UgPSBOdW1iZXIuaXNGaW5pdGUoaWRocj8uZ2ZtKSA/IGlkaHIuZ2ZtIDogTmFOO1xuXG4gICAgLy8gc2ltcGxlIHRlbmRlbmN5IGZyb20gbGFzdCBOIHJldHVybnMgKHVzZSB6IGFzIHVuaXRsZXNzKVxuICAgIGNvbnN0IHJldHVybnMgPSBidWZcbiAgICAgIC5zbGljZSgtNjApXG4gICAgICAubWFwKChwLCBpLCBhKSA9PiAoaSA/IDEwMCAqIChwLnByaWNlIC8gYVtpIC0gMV0ucHJpY2UgLSAxKSA6IDApKVxuICAgICAgLnNsaWNlKDEpO1xuICAgIGNvbnN0IHZpbiA9IHJldHVybnMubGVuZ3RoID8gVGVuZC52SW5uZXIoeyB2YWx1ZXM6IHJldHVybnMgfSwgeyBzY2FsZTogMTAwIH0pIDogMDtcbiAgICBjb25zdCB2b3V0ID0gcmV0dXJucy5sZW5ndGggPyBUZW5kLnZPdXRlcihbeyB2YWx1ZXM6IHJldHVybnMgfV0sIHVuZGVmaW5lZCwgeyBzY2FsZTogMTAwIH0pIDogMDtcbiAgICBjb25zdCB2dCA9IHJldHVybnMubGVuZ3RoID8gVGVuZC52VGVuZGVuY3lGcm9tU2VyaWVzKHJldHVybnMsIHsgc2NhbGU6IDEwMCB9KS5zY29yZSA6IDA7XG5cbiAgICAvLyBpbmVydGlhIGV4YW1wbGU6IGZyb20gcmV0dXJucyBvbmx5ICh3aW5kb3c9cmV0dXJucy5sZW5ndGgpXG4gICAgY29uc3QgaW5lcnRpYSA9IHJldHVybnMubGVuZ3RoXG4gICAgICA/IE1ldC5pbmVydGlhRnJvbVJldHVybnMocmV0dXJucywgeyB3aW5kb3c6IHJldHVybnMubGVuZ3RoIH0pXG4gICAgICA6IG51bGw7XG5cbiAgICAvLyBzZXNzaW9uIHVwZGF0ZVxuICAgIGNvbnN0IG5vd1RzID0gcGF5bG9hZC5mcmFtZXMuY3ljbGVFbmQgPz8gcGF5bG9hZC5zbmFwc2hvdC50aWNrLmN5Y2xlVHMgPz8gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBwcmljZU5vdyA9IGJ1ZltidWYubGVuZ3RoIC0gMV0/LnByaWNlID8/IE5hTjtcbiAgICBjb25zdCBwY3QyNGhOb3cgPSBOdW1iZXIocGN0MjRoTWFwPy5bcGFpcl0gPz8gMCk7XG5cbiAgICBjb25zdCBzcyA9IGdldE9ySW5pdFN5bWJvbFNlc3Npb24oYXBwU2Vzc2lvbklkLCBwYWlyLCBvcGVuaW5nLmJlbmNobWFyayA/PyBwcmljZU5vdyA/PyAwLCBub3dUcyk7XG4gICAgY29uc3QgdXBkID0gdXBkYXRlU3ltYm9sU2Vzc2lvbihzcywgcHJpY2VOb3csIG5vd1RzLCBnZm1DYWxjUHJpY2UsIHBjdDI0aE5vdyk7ICAgICAgICAgICAgICAgICAgICAgLy8gOmNvbnRlbnRSZWZlcmVuY2Vbb2FpY2l0ZToxN117aW5kZXg9MTd9XG5cbiAgICByZXMucHVzaCh7XG4gICAgICBwYWlyLFxuICAgICAgaWRocjoge1xuICAgICAgICBnZm06IE51bWJlci5pc0Zpbml0ZShpZGhyLmdmbSkgPyBpZGhyLmdmbSA6IG51bGwsXG4gICAgICAgIHNpZ21hR2xvYmFsOiBOdW1iZXIuaXNGaW5pdGUoaWRoci5zaWdtYUdsb2JhbCkgPyBpZGhyLnNpZ21hR2xvYmFsIDogbnVsbCxcbiAgICAgICAgek1lYW5BYnM6IE51bWJlci5pc0Zpbml0ZShpZGhyLnpNZWFuQWJzKSA/IGlkaHIuek1lYW5BYnMgOiBudWxsLFxuICAgICAgICBudWNsZWk6IGlkaHIubnVjbGVpID8/IFtdLFxuICAgICAgfSxcbiAgICAgIHZlY3RvcnM6IHsgdklubmVyOiB2aW4sIHZPdXRlcjogdm91dCwgdlRlbmRlbmN5OiB2dCB9LFxuICAgICAgbWV0cmljczogeyBpbmVydGlhIH0sXG4gICAgICBzZXNzaW9uOiB7XG4gICAgICAgIHVpRXBvY2g6IHVwZC51aUVwb2NoLFxuICAgICAgICBnZm1SZWZQcmljZTogdXBkLmdmbVJlZlByaWNlLFxuICAgICAgICBnZm1DYWxjUHJpY2U6IHVwZC5nZm1DYWxjUHJpY2UsXG4gICAgICAgIGdmbURlbHRhQWJzUGN0OiB1cGQuZ2ZtRGVsdGFBYnNQY3QsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTYW1wbGluZy1iYWNrZWQgbWV0cmljcyBvcmNoZXN0cmF0aW9uICh1c2VkIGJ5IC9hcGkvc3RyLWF1eC9zdGF0cyAmIGZyaWVuZHMpXG5cbmV4cG9ydCB0eXBlIFNhbXBsZWRTZXJpZXNNZXRhID0ge1xuICBvcGVuaW5nOiBudW1iZXI7XG4gIGxhc3Q6IG51bWJlcjtcbiAgcHJldjogbnVtYmVyO1xuICBsYXN0VXBkYXRlVHM6IG51bWJlcjtcbiAgbjogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgU2FtcGxlZE1ldHJpY3NTdWNjZXNzID0ge1xuICBvazogdHJ1ZTtcbiAgc3ltYm9sOiBzdHJpbmc7XG4gIHN0YXRzOiBTdGF0cztcbiAgaGlzdDoge1xuICAgIGNvdW50czogbnVtYmVyW107XG4gICAgZWRnZXM6IG51bWJlcltdO1xuICAgIHByb2JzOiBudW1iZXJbXTtcbiAgICBkZW5zZXN0OiBudW1iZXJbXTtcbiAgICBtdVI6IG51bWJlcjtcbiAgICBzaWdtYVI6IG51bWJlcjtcbiAgICB0b3RhbDogbnVtYmVyO1xuICAgIGJpbldpZHRoOiBudW1iZXIgfCBudWxsO1xuICAgIHJNaW46IG51bWJlciB8IG51bGw7XG4gICAgck1heDogbnVtYmVyIHwgbnVsbDtcbiAgICByZXR1cm5zUGN0OiBudW1iZXJbXTtcbiAgfTtcbiAgZXh0cmVtYTogeyBwcmljZU1pbjogbnVtYmVyOyBwcmljZU1heDogbnVtYmVyOyBiZW5jaFBjdE1pbjogbnVtYmVyOyBiZW5jaFBjdE1heDogbnVtYmVyIH07XG4gIG1ldGE6IFNhbXBsZWRTZXJpZXNNZXRhO1xuICBzYW1wbGluZzogU2FtcGxpbmdXaW5kb3dEaWdlc3Q7XG59O1xuXG5leHBvcnQgdHlwZSBTYW1wbGVkTWV0cmljc0Vycm9yID0ge1xuICBvazogZmFsc2U7XG4gIHN5bWJvbDogc3RyaW5nO1xuICBlcnJvcjogc3RyaW5nO1xuICBzYW1wbGluZz86IFNhbXBsaW5nV2luZG93RGlnZXN0O1xufTtcblxuZXhwb3J0IHR5cGUgU2FtcGxlZE1ldHJpY3NSZXN1bHQgPSBTYW1wbGVkTWV0cmljc1N1Y2Nlc3MgfCBTYW1wbGVkTWV0cmljc0Vycm9yO1xuXG5leHBvcnQgdHlwZSBTYW1wbGVkTWV0cmljc09wdGlvbnMgPSB7XG4gIHdpbmRvdzogU2FtcGxpbmdXaW5kb3dLZXk7XG4gIGJpbnM6IG51bWJlcjtcbiAgY29sbGVjdD86IGJvb2xlYW47XG4gIHN0YXRzPzogU3RhdHNPcHRpb25zO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVTYW1wbGVkTWV0cmljc0ZvclN5bWJvbChcbiAgc3ltYm9sOiBzdHJpbmcsXG4gIG9wdHM6IFNhbXBsZWRNZXRyaWNzT3B0aW9uc1xuKTogUHJvbWlzZTxTYW1wbGVkTWV0cmljc1Jlc3VsdD4ge1xuICBjb25zdCBzYW1wbGVyID0gZ2V0U2FtcGxpbmdTdG9yZSgpO1xuICBsZXQgc25hcHNob3Q7XG5cbiAgaWYgKG9wdHMuY29sbGVjdCA9PT0gZmFsc2UpIHtcbiAgICBzbmFwc2hvdCA9IHNhbXBsZXIuc25hcHNob3Qoc3ltYm9sKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29sbGVjdGVkID0gYXdhaXQgc2FtcGxlci5jb2xsZWN0KHN5bWJvbCk7XG4gICAgICBzbmFwc2hvdCA9IGNvbGxlY3RlZC5zbmFwc2hvdDtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHNuYXBzaG90ID0gc2FtcGxlci5zbmFwc2hvdChzeW1ib2wpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNhbXBsaW5nID0gc3VtbWFyaXplU25hcHNob3RXaW5kb3coc25hcHNob3QsIG9wdHMud2luZG93KTtcbiAgY29uc3QgcG9pbnRzID0gc2FtcGxlci5nZXRQb2ludHMoc3ltYm9sLCBvcHRzLndpbmRvdyk7XG4gIGNvbnN0IHNlcmllcyA9IHBvaW50c1RvU3RhdFBvaW50cyhwb2ludHMpO1xuXG4gIGlmICghc2VyaWVzLmxlbmd0aCkge1xuICAgIHJldHVybiB7XG4gICAgICBvazogZmFsc2UsXG4gICAgICBzeW1ib2wsXG4gICAgICBlcnJvcjogXCJub19wb2ludHNcIixcbiAgICAgIHNhbXBsaW5nLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBiaW5zID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihvcHRzLmJpbnMgPz8gMSkpO1xuICBjb25zdCBvcGVuaW5nID0gc2VyaWVzWzBdLnByaWNlO1xuICBjb25zdCBzdGF0c09wdGlvbnM6IFN0YXRzT3B0aW9ucyA9IHtcbiAgICAuLi4ob3B0cy5zdGF0cyA/PyB7fSksXG4gICAgaWRocjogeyAuLi4ob3B0cy5zdGF0cz8uaWRociA/PyB7fSksIGJpbnMgfSxcbiAgfTtcblxuICBjb25zdCBzdGF0cyA9IGNvbXB1dGVTdGF0cyhzZXJpZXMsIHsgYmVuY2htYXJrOiBvcGVuaW5nIH0sIHN0YXRzT3B0aW9ucyk7XG4gIGNvbnN0IHByaWNlVmFsdWVzID0gc2VyaWVzLm1hcCgocCkgPT4gcC5wcmljZSk7XG4gIGNvbnN0IHByaWNlTWluID0gTWF0aC5taW4oLi4ucHJpY2VWYWx1ZXMpO1xuICBjb25zdCBwcmljZU1heCA9IE1hdGgubWF4KC4uLnByaWNlVmFsdWVzKTtcbiAgY29uc3QgYmVuY2hWYWx1ZXMgPSBzZXJpZXMubWFwKChwKSA9PiBiZW5jaFBjdChvcGVuaW5nLCBwLnByaWNlKSk7XG4gIGNvbnN0IGJlbmNoUGN0TWluID0gTWF0aC5taW4oLi4uYmVuY2hWYWx1ZXMpO1xuICBjb25zdCBiZW5jaFBjdE1heCA9IE1hdGgubWF4KC4uLmJlbmNoVmFsdWVzKTtcbiAgY29uc3QgaGlzdG9ncmFtID0gc3RhdHMuaGlzdG9ncmFtO1xuICBjb25zdCBsYXN0UG9pbnQgPSBzZXJpZXNbc2VyaWVzLmxlbmd0aCAtIDFdO1xuXG4gIGNvbnN0IGZhbGxiYWNrSGlzdG9ncmFtID0gKCkgPT4ge1xuICAgIGNvbnN0IGNvdW50cyA9IG1ha2VDb3VudHMoc2VyaWVzLCBvcGVuaW5nLCBiaW5zKTtcbiAgICBjb25zdCB0b3RhbCA9IGNvdW50cy5yZWR1Y2UoKHMsIGMpID0+IHMgKyBjLCAwKTtcbiAgICBjb25zdCBwcm9icyA9IHRvdGFsID4gMCA/IGNvdW50cy5tYXAoKGMpID0+IGMgLyB0b3RhbCkgOiBjb3VudHMubWFwKCgpID0+IDApO1xuICAgIHJldHVybiB7XG4gICAgICBjb3VudHMsXG4gICAgICBlZGdlczogW10gYXMgbnVtYmVyW10sXG4gICAgICBwcm9icyxcbiAgICAgIGRlbnNlc3Q6IFtdIGFzIG51bWJlcltdLFxuICAgICAgbXVSOiAwLFxuICAgICAgc2lnbWFSOiAwLFxuICAgICAgdG90YWwsXG4gICAgICBiaW5XaWR0aDogbnVsbCBhcyBudW1iZXIgfCBudWxsLFxuICAgICAgck1pbjogbnVsbCBhcyBudW1iZXIgfCBudWxsLFxuICAgICAgck1heDogbnVsbCBhcyBudW1iZXIgfCBudWxsLFxuICAgICAgcmV0dXJuc1BjdDogW10gYXMgbnVtYmVyW10sXG4gICAgfTtcbiAgfTtcblxuICBjb25zdCBoaXN0T3V0ID0gaGlzdG9ncmFtICYmIGhpc3RvZ3JhbS5jb3VudHM/Lmxlbmd0aFxuICAgID8ge1xuICAgICAgICBjb3VudHM6IGhpc3RvZ3JhbS5jb3VudHMsXG4gICAgICAgIGVkZ2VzOiBoaXN0b2dyYW0uZWRnZXMsXG4gICAgICAgIHByb2JzOiBoaXN0b2dyYW0ucHJvYnMsXG4gICAgICAgIGRlbnNlc3Q6IGhpc3RvZ3JhbS5kZW5zZXN0LFxuICAgICAgICBtdVI6IGhpc3RvZ3JhbS5tdVIsXG4gICAgICAgIHNpZ21hUjogaGlzdG9ncmFtLnNpZ21hUixcbiAgICAgICAgdG90YWw6IGhpc3RvZ3JhbS50b3RhbCxcbiAgICAgICAgYmluV2lkdGg6IGhpc3RvZ3JhbS5lZGdlcy5sZW5ndGggPiAxID8gaGlzdG9ncmFtLmVkZ2VzWzFdIC0gaGlzdG9ncmFtLmVkZ2VzWzBdIDogbnVsbCxcbiAgICAgICAgck1pbjogaGlzdG9ncmFtLmVkZ2VzWzBdID8/IG51bGwsXG4gICAgICAgIHJNYXg6IGhpc3RvZ3JhbS5lZGdlc1toaXN0b2dyYW0uZWRnZXMubGVuZ3RoIC0gMV0gPz8gbnVsbCxcbiAgICAgICAgcmV0dXJuc1BjdDogaGlzdG9ncmFtLmVkZ2VzLm1hcCgocikgPT4ge1xuICAgICAgICAgIGNvbnN0IHBjdCA9IE1hdGguZXhwbTEocikgKiAxMDA7XG4gICAgICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShwY3QpID8gcGN0IDogMDtcbiAgICAgICAgfSksXG4gICAgICB9XG4gICAgOiBmYWxsYmFja0hpc3RvZ3JhbSgpO1xuXG4gIHJldHVybiB7XG4gICAgb2s6IHRydWUsXG4gICAgc3ltYm9sLFxuICAgIHN0YXRzLFxuICAgIGhpc3Q6IGhpc3RPdXQsXG4gICAgZXh0cmVtYTogeyBwcmljZU1pbiwgcHJpY2VNYXgsIGJlbmNoUGN0TWluLCBiZW5jaFBjdE1heCB9LFxuICAgIG1ldGE6IHtcbiAgICAgIG9wZW5pbmc6IHN0YXRzLm9wZW5pbmcsXG4gICAgICBsYXN0OiBzdGF0cy5sYXN0LFxuICAgICAgcHJldjogc3RhdHMucHJldixcbiAgICAgIGxhc3RVcGRhdGVUczogbGFzdFBvaW50LnRzLFxuICAgICAgbjogc2VyaWVzLmxlbmd0aCxcbiAgICB9LFxuICAgIHNhbXBsaW5nLFxuICB9O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVNhbXBsZWRNZXRyaWNzKFxuICBzeW1ib2xzOiBzdHJpbmdbXSxcbiAgb3B0czogU2FtcGxlZE1ldHJpY3NPcHRpb25zXG4pOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIFNhbXBsZWRNZXRyaWNzUmVzdWx0Pj4ge1xuICBjb25zdCBwYWlycyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHN5bWJvbHMubWFwKGFzeW5jIChzeW0pID0+IFtzeW0sIGF3YWl0IGNvbXB1dGVTYW1wbGVkTWV0cmljc0ZvclN5bWJvbChzeW0sIG9wdHMpXSBhcyBjb25zdClcbiAgKTtcbiAgY29uc3Qgb3V0OiBSZWNvcmQ8c3RyaW5nLCBTYW1wbGVkTWV0cmljc1Jlc3VsdD4gPSB7fTtcbiAgZm9yIChjb25zdCBbc3ltLCByZXN1bHRdIG9mIHBhaXJzKSBvdXRbc3ltXSA9IHJlc3VsdDtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gcG9pbnRzVG9TdGF0UG9pbnRzKHBvaW50czogU2FtcGxpbmdQb2ludFtdKTogU3RhdFBvaW50W10ge1xuICByZXR1cm4gcG9pbnRzXG4gICAgLmZpbHRlcigocCkgPT4gTnVtYmVyLmlzRmluaXRlKHAubWlkKSAmJiBwLm1pZCA+IDApXG4gICAgLm1hcCgocCkgPT4ge1xuICAgICAgY29uc3QgYmlkID0gTnVtYmVyLmlzRmluaXRlKHAuYmlkVm9sdW1lKSA/IHAuYmlkVm9sdW1lIDogMDtcbiAgICAgIGNvbnN0IGFzayA9IE51bWJlci5pc0Zpbml0ZShwLmFza1ZvbHVtZSkgPyBwLmFza1ZvbHVtZSA6IDA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0czogcC50cyxcbiAgICAgICAgcHJpY2U6IHAubWlkLFxuICAgICAgICB2b2x1bWU6IE1hdGgubWF4KDAsIGJpZCArIGFzayksXG4gICAgICB9O1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBtYWtlQ291bnRzKHBvaW50czogU3RhdFBvaW50W10sIG9wZW5pbmc6IG51bWJlciwgdG90YWxCaW5zOiBudW1iZXIpOiBudW1iZXJbXSB7XG4gIGNvbnN0IGJpbnMgPSBNYXRoLm1heCgxLCB0b3RhbEJpbnMpO1xuICBpZiAoIXBvaW50cy5sZW5ndGggfHwgIShvcGVuaW5nID4gMCkpIHJldHVybiBBcnJheShiaW5zKS5maWxsKDApO1xuICBjb25zdCByZXRzID0gcG9pbnRzLm1hcCgocCkgPT4gTWF0aC5sb2cocC5wcmljZSAvIG9wZW5pbmcpKTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4oLi4ucmV0cyk7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLnJldHMpO1xuICBjb25zdCBsbyA9IG1pbiA9PT0gbWF4ID8gbWluIC0gMWUtNiA6IG1pbjtcbiAgY29uc3QgaGkgPSBtaW4gPT09IG1heCA/IG1heCArIDFlLTYgOiBtYXg7XG4gIGNvbnN0IGNvdW50cyA9IEFycmF5KGJpbnMpLmZpbGwoMCk7XG4gIGZvciAoY29uc3QgciBvZiByZXRzKSB7XG4gICAgY29uc3QgdCA9IChyIC0gbG8pIC8gKGhpIC0gbG8pO1xuICAgIGNvbnN0IGlkeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGJpbnMgLSAxLCBNYXRoLmZsb29yKHQgKiBiaW5zKSkpO1xuICAgIGNvdW50c1tpZHhdICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50cztcbn1cblxuZnVuY3Rpb24gYmVuY2hQY3Qob3BlbmluZzogbnVtYmVyLCBjdXI6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiAxMDAgKiAoKGN1ciAvIG9wZW5pbmcpIC0gMSk7XG59XG4iXSwibmFtZXMiOlsiY29tcHV0ZUZNIiwiVGVuZCIsIk1ldCIsImdldE9ySW5pdFN5bWJvbFNlc3Npb24iLCJ1cGRhdGVTeW1ib2xTZXNzaW9uIiwiY29tcHV0ZVN0YXRzIiwiZ2V0U2FtcGxpbmdTdG9yZSIsInN1bW1hcml6ZVNuYXBzaG90V2luZG93IiwidG9TZXJpZXMiLCJwYXlsb2FkIiwidHMiLCJzbmFwc2hvdCIsInRpY2siLCJjeWNsZVRzIiwiZnJhbWVzIiwiY3ljbGVTdGFydCIsIm91dCIsInAiLCJwb2ludHMiLCJwcmljZSIsIk51bWJlciIsIm1pZCIsIk5hTiIsImlzRmluaXRlIiwic3ltYm9sIiwicHVzaCIsIm9wZW5pbmdGcm9tU2VyaWVzIiwic2VyaWVzIiwiZmlyc3QiLCJmaW5kIiwiYmVuY2htYXJrIiwiZXhlY3V0ZUNhbGNBbmRVcGRhdGVTZXNzaW9uIiwiYXBwU2Vzc2lvbklkIiwic2VyaWVzQnVmZmVycyIsInBjdDI0aE1hcCIsInJlcyIsInNlcmllc05vdyIsInBhaXIiLCJwdHMiLCJPYmplY3QiLCJlbnRyaWVzIiwiYnVmIiwiY29uY2F0Iiwic2xpY2UiLCJvcGVuaW5nIiwiaWRociIsImdmbUNhbGNQcmljZSIsImdmbSIsInJldHVybnMiLCJtYXAiLCJpIiwiYSIsInZpbiIsImxlbmd0aCIsInZJbm5lciIsInZhbHVlcyIsInNjYWxlIiwidm91dCIsInZPdXRlciIsInVuZGVmaW5lZCIsInZ0IiwidlRlbmRlbmN5RnJvbVNlcmllcyIsInNjb3JlIiwiaW5lcnRpYSIsImluZXJ0aWFGcm9tUmV0dXJucyIsIndpbmRvdyIsIm5vd1RzIiwiY3ljbGVFbmQiLCJEYXRlIiwibm93IiwicHJpY2VOb3ciLCJwY3QyNGhOb3ciLCJzcyIsInVwZCIsInNpZ21hR2xvYmFsIiwiek1lYW5BYnMiLCJudWNsZWkiLCJ2ZWN0b3JzIiwidlRlbmRlbmN5IiwibWV0cmljcyIsInNlc3Npb24iLCJ1aUVwb2NoIiwiZ2ZtUmVmUHJpY2UiLCJnZm1EZWx0YUFic1BjdCIsImNvbXB1dGVTYW1wbGVkTWV0cmljc0ZvclN5bWJvbCIsIm9wdHMiLCJzYW1wbGVyIiwiY29sbGVjdCIsImNvbGxlY3RlZCIsInNhbXBsaW5nIiwiZ2V0UG9pbnRzIiwicG9pbnRzVG9TdGF0UG9pbnRzIiwib2siLCJlcnJvciIsImJpbnMiLCJNYXRoIiwibWF4IiwiZmxvb3IiLCJzdGF0c09wdGlvbnMiLCJzdGF0cyIsInByaWNlVmFsdWVzIiwicHJpY2VNaW4iLCJtaW4iLCJwcmljZU1heCIsImJlbmNoVmFsdWVzIiwiYmVuY2hQY3QiLCJiZW5jaFBjdE1pbiIsImJlbmNoUGN0TWF4IiwiaGlzdG9ncmFtIiwibGFzdFBvaW50IiwiZmFsbGJhY2tIaXN0b2dyYW0iLCJjb3VudHMiLCJtYWtlQ291bnRzIiwidG90YWwiLCJyZWR1Y2UiLCJzIiwiYyIsInByb2JzIiwiZWRnZXMiLCJkZW5zZXN0IiwibXVSIiwic2lnbWFSIiwiYmluV2lkdGgiLCJyTWluIiwick1heCIsInJldHVybnNQY3QiLCJoaXN0T3V0IiwiciIsInBjdCIsImV4cG0xIiwiaGlzdCIsImV4dHJlbWEiLCJtZXRhIiwibGFzdCIsInByZXYiLCJsYXN0VXBkYXRlVHMiLCJuIiwiY29tcHV0ZVNhbXBsZWRNZXRyaWNzIiwic3ltYm9scyIsInBhaXJzIiwiUHJvbWlzZSIsImFsbCIsInN5bSIsInJlc3VsdCIsImZpbHRlciIsImJpZCIsImJpZFZvbHVtZSIsImFzayIsImFza1ZvbHVtZSIsInZvbHVtZSIsInRvdGFsQmlucyIsIkFycmF5IiwiZmlsbCIsInJldHMiLCJsb2ciLCJsbyIsImhpIiwidCIsImlkeCIsImN1ciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/calc/executive.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/calc/metrics.ts":
/*!***************************************************!*\
  !*** ./src/core/features/str-aux/calc/metrics.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ampFromSeries: () => (/* binding */ ampFromSeries),\n/* harmony export */   artificialityScore: () => (/* binding */ artificialityScore),\n/* harmony export */   disruptionInstant: () => (/* binding */ disruptionInstant),\n/* harmony export */   disruptionSystemic: () => (/* binding */ disruptionSystemic),\n/* harmony export */   efficiencyScore: () => (/* binding */ efficiencyScore),\n/* harmony export */   inertiaFromReturns: () => (/* binding */ inertiaFromReturns),\n/* harmony export */   inflDefLevel: () => (/* binding */ inflDefLevel),\n/* harmony export */   inflDefRate: () => (/* binding */ inflDefRate),\n/* harmony export */   voltFromDivergence: () => (/* binding */ voltFromDivergence),\n/* harmony export */   voltFromReturns: () => (/* binding */ voltFromReturns),\n/* harmony export */   voltFromSeries: () => (/* binding */ voltFromSeries)\n/* harmony export */ });\n// src/core/maths/metrics.ts\n// Metrics aligned to your definitions (IDHR/ecosystem-aware).\n// Scales: strengths  [0..100], directional  [-100..100].\n/*  basics  */ const clamp = (x, lo, hi)=>Math.max(lo, Math.min(hi, x));\nconst tanh = (x)=>{\n    const e = Math.exp(2 * x);\n    return (e - 1) / (e + 1);\n};\nconst sum = (xs)=>xs.reduce((a, b)=>a + b, 0);\nconst mean = (xs)=>xs.length ? sum(xs) / xs.length : 0;\nconst sign = (x)=>x > 0 ? 1 : x < 0 ? -1 : 0;\nfunction median(xs) {\n    if (!xs.length) return 0;\n    const s = xs.slice().sort((a, b)=>a - b);\n    const m = Math.floor(s.length / 2);\n    return s.length % 2 ? s[m] : (s[m - 1] + s[m]) / 2;\n}\nfunction mad(xs) {\n    if (!xs.length) return 0;\n    const m = median(xs);\n    const dev = xs.map((x)=>Math.abs(x - m));\n    return median(dev);\n}\nfunction iqr(xs) {\n    if (!xs.length) return 0;\n    const s = xs.slice().sort((a, b)=>a - b);\n    const q = (p)=>{\n        const idx = (s.length - 1) * p, lo = Math.floor(idx), hi = Math.ceil(idx);\n        return lo === hi ? s[lo] : s[lo] + (s[hi] - s[lo]) * (idx - lo);\n    };\n    return q(0.75) - q(0.25);\n}\nfunction fracFlips(xs) {\n    let flips = 0, valid = 0, prev = null;\n    for (const v of xs){\n        const s = sign(v);\n        if (s === 0) continue;\n        if (prev === null) {\n            prev = s;\n            continue;\n        }\n        valid++;\n        if (s !== prev) {\n            flips++;\n            prev = s;\n        }\n    }\n    return valid ? flips / valid : 0;\n}\nfunction hhi(shares) {\n    const s = shares.map((x)=>Math.max(0, x));\n    const Z = sum(s);\n    if (!Z) return 0;\n    return s.reduce((a, x)=>a + Math.pow(x / Z, 2), 0); // [1/K..1]\n}\n/*  inputs \r\n   r_t  : coin growth/return series (unitless, can be in S)\r\n   M_t  : ecosystem baseline series (same length as r_t)\r\n   _t  : divergence series (r_t - M_t) if you prefer to pass directly\r\n   W    : window (ticks/steps)\r\n   S    : envelope scale (default 100)\r\n       : epsilon guard for divisions\r\n */ /*  Inertia \r\n   Your meaning:\r\n   - Static inertia: stays put (no growth), low step noise.\r\n   - Growth inertia: keeps the same growth pattern; large steady median vs noise.\r\n   Returns components in [0..100] and a unified \"face\".\r\n */ function inertiaFromReturns(r, opts = {}) {\n    const W = Math.max(5, Math.floor(opts.window ?? Math.min(30, r.length)));\n    if (r.length < 3) return {\n        static: 0,\n        growth: 0,\n        total: 0,\n        face: \"static\"\n    };\n    const y = r.slice(-W);\n    const diffs = [];\n    for(let i = 1; i < y.length; i++)diffs.push(y[i] - y[i - 1]);\n    const mu = median(y), spreadD = mad(diffs);\n    const beta_s = opts.beta_s ?? 1.0;\n    const beta_m = opts.beta_m ?? 1.0;\n    const beta_g = opts.beta_g ?? 1.0;\n    const tau0 = opts.tau0 ?? 0.01; // \"near zero\" target for static\n    // static: small steps + median ~ 0\n    const staticU = tanh(beta_s * (1 / (1 + spreadD))) * tanh(beta_m * (tau0 / (Math.abs(mu) + 1e-9)));\n    // growth: large |median| vs small step noise\n    const growthU = tanh(beta_g * (Math.abs(mu) / (spreadD + 1e-9)));\n    const s = 100 * clamp(staticU, 0, 1);\n    const g = 100 * clamp(growthU, 0, 1);\n    const face = g > s ? \"growth\" : \"static\";\n    return {\n        static: s,\n        growth: g,\n        total: Math.max(s, g),\n        face\n    };\n}\n/*  Disruption \r\n   Your meaning: instant move out of inertia; systemic = proportion of coins.\r\n */ function disruptionInstant(rNow, refWindow// recent returns (window W) for the SAME coin\n, gamma = 1.0) {\n    const mu = median(refWindow);\n    const spreadD = mad(refWindow.length > 1 ? refWindow.map((v, i, a)=>i ? v - a[i - 1] : 0).slice(1) : [\n        0\n    ]);\n    const u = tanh(gamma * (Math.abs(rNow - mu) / (spreadD + 1e-9)));\n    return 100 * clamp(u, 0, 1);\n}\n/** systemic disruption = share of coins whose instant disruption >= threshold */ function disruptionSystemic(disruptions, threshold = 60) {\n    if (!disruptions.length) return 0;\n    const k = disruptions.filter((d)=>d >= threshold).length;\n    return k / disruptions.length * 100; // percent of universe\n}\n/*  Amp (amperage) \r\n   Your meaning: tendency to flip between growth/shrink; swap frequency matters.\r\n   Amp = swing size  flip rate  [0..100].\r\n */ function ampFromSeries(r, opts = {}) {\n    const W = Math.max(5, Math.floor(opts.window ?? Math.min(30, r.length)));\n    if (r.length < 3) return 0;\n    const y = r.slice(-W);\n    const S = opts.S ?? 100;\n    const swing = mad(y); // typical swing size (unitless)\n    const flips = fracFlips(y); // 0..1\n    const u = tanh((opts.etaA ?? 1.0) * (swing / (S || 100))) * tanh((opts.etaF ?? 1.0) * flips);\n    return 100 * clamp(u, 0, 1);\n}\n/*  Volt (voltage) \r\n   Your meaning: persistent imbalance (insulation) vs ecosystem.\r\n   Use divergence _t = r_t - M_t. Volt  [0..100].\r\n */ function voltFromDivergence(delta, opts) {\n    const W = Math.max(5, Math.floor(opts?.window ?? Math.min(30, delta.length)));\n    if (delta.length < 3) return 0;\n    const d = delta.slice(-W);\n    // FIXED: avoid mixing ?? and ||, also guard against 0\n    const spread = Math.max(1e-9, opts?.spread ?? mad(d));\n    const avgAbsZ = mean(d.map((x)=>Math.abs(x) / spread));\n    const u = tanh((opts?.lambda ?? 1.0) * avgAbsZ);\n    return 100 * clamp(u, 0, 1);\n}\n/** helper if you have r_t and M_t instead of _t */ function voltFromReturns(r, M, opts) {\n    const n = Math.min(r.length, M.length);\n    const delta = [];\n    for(let i = 0; i < n; i++)delta.push(r[i] - M[i]);\n    return voltFromDivergence(delta, {\n        window: opts?.window,\n        lambda: opts?.lambda\n    });\n}\nfunction voltFromSeries(y, opts) {\n    const W = Math.max(5, Math.floor(opts?.window ?? Math.min(30, y.length)));\n    if (y.length < 3) return 0;\n    const slice = y.slice(-W);\n    const diffs = [];\n    for(let i = 1; i < slice.length; i++)diffs.push(slice[i] - slice[i - 1]);\n    const S = opts?.S ?? 100;\n    const lambda = opts?.lambda ?? 1.0;\n    return 100 * tanh(lambda * (mad(diffs) / S));\n}\n/*  Inflation / Deflation (systemic) \r\n   Your meaning: position vs the system (ecosystemic analysis).\r\n   Level variant: L_t vs system level M_t^  signed in [-100..100].\r\n */ function inflDefLevel(L_now, M_now, opts = {}) {\n    const S = opts.S ?? 100;\n    const kappa = opts.kappa ?? 1.0;\n    const ratio = M_now > 0 ? L_now / M_now : 1;\n    const R = Math.log(Math.max(1e-9, ratio)); // + inflation (richer), - deflation\n    return clamp(S * tanh(kappa * R), -S, S);\n}\n/** rate variant (change vs previous step) if you want an infl/def rate later */ function inflDefRate(R_now, R_prev, opts = {}) {\n    const S = opts.S ?? 100;\n    const kappa = opts.kappa ?? 1.0;\n    const dR = R_now - R_prev; // already unitless\n    return clamp(S * tanh(kappa * dR), -S, S);\n}\nfunction artificialityScore(inp, weights = {}) {\n    const wM = weights.wMismatch ?? 0.5;\n    const wE = weights.wExec ?? 0.3;\n    const wH = weights.wHHI ?? 0.2;\n    // (1) Impact mismatch (0..1): large if book suggests big move but price barely moves (or vice-versa)\n    const mismatch = Math.abs(inp.expectedImpact) / (Math.abs(inp.observedChange) + 1e-9);\n    const M = clamp(tanh(0.75 * Math.log(1 + mismatch)), 0, 1); // soft-bounded 0..1\n    // (2) Execution ratio (0..1): churny if (placed+cancel)/executed is large\n    let E = 0;\n    if ((inp.executed ?? 0) > 0) {\n        const ratio = ((inp.placed ?? 0) + (inp.canceled ?? 0)) / (inp.executed ?? 1);\n        E = clamp(tanh(0.5 * Math.log(1 + ratio)), 0, 1);\n    }\n    // (3) Concentration via normalized HHI (0..1)\n    let H = 0;\n    if (inp.contribShares && inp.contribShares.length) {\n        const raw = hhi(inp.contribShares);\n        // normalize: minimal ~0 (broad)  0, maximal 1  1 (we skip 1/K floor; unknown K)\n        H = clamp((raw - 0) / (1 - 0), 0, 1);\n    }\n    const A = clamp(wM * M + wE * E + wH * H, 0, 1);\n    return 100 * A; // 0..100 (higher = more artificial)\n}\nfunction efficiencyScore(inp, weights = {}) {\n    const wT = weights.wTrend ?? 0.6;\n    const wV = weights.wVolt ?? 0.2;\n    const wA = weights.wArt ?? 0.2;\n    const alpha = weights.alpha ?? 1.2;\n    const S = weights.S ?? 100;\n    // Organic growth: direction  strength ([-1,1])\n    const trend = clamp(inp.tendencyDirection, -1, 1) * clamp(inp.tendencyStrength, 0, 1);\n    const volt = clamp(inp.volt01 ?? 0, 0, 1); // penalty\n    const art = clamp(inp.artificiality01 ?? 0, 0, 1); // penalty\n    const raw = wT * trend - wV * volt - wA * art;\n    return clamp(S * tanh(alpha * raw), -S, S); // [-S,S]\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L2NhbGMvbWV0cmljcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLDRCQUE0QjtBQUM1Qiw4REFBOEQ7QUFDOUQsMkRBQTJEO0FBRTNELHNFQUFzRSxHQUl0RSxNQUFNQSxRQUFRLENBQUNDLEdBQVdDLElBQVlDLEtBQWVDLEtBQUtDLEdBQUcsQ0FBQ0gsSUFBSUUsS0FBS0UsR0FBRyxDQUFDSCxJQUFJRjtBQUMvRSxNQUFNTSxPQUFPLENBQUNOO0lBQWdCLE1BQU1PLElBQUlKLEtBQUtLLEdBQUcsQ0FBQyxJQUFJUjtJQUFJLE9BQU8sQ0FBQ08sSUFBSSxLQUFNQSxDQUFBQSxJQUFJO0FBQUk7QUFDbkYsTUFBTUUsTUFBTSxDQUFDQyxLQUFpQkEsR0FBR0MsTUFBTSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELElBQUlDLEdBQUc7QUFDekQsTUFBTUMsT0FBTyxDQUFDSixLQUFrQkEsR0FBR0ssTUFBTSxHQUFHTixJQUFJQyxNQUFNQSxHQUFHSyxNQUFNLEdBQUc7QUFDbEUsTUFBTUMsT0FBTyxDQUFDaEIsSUFBZUEsSUFBSSxJQUFJLElBQUlBLElBQUksSUFBSSxDQUFDLElBQUk7QUFFdEQsU0FBU2lCLE9BQU9QLEVBQVk7SUFDMUIsSUFBSSxDQUFDQSxHQUFHSyxNQUFNLEVBQUUsT0FBTztJQUN2QixNQUFNRyxJQUFJUixHQUFHUyxLQUFLLEdBQUdDLElBQUksQ0FBQyxDQUFDUixHQUFHQyxJQUFNRCxJQUFJQztJQUFJLE1BQU1RLElBQUlsQixLQUFLbUIsS0FBSyxDQUFDSixFQUFFSCxNQUFNLEdBQUc7SUFDNUUsT0FBT0csRUFBRUgsTUFBTSxHQUFHLElBQUlHLENBQUMsQ0FBQ0csRUFBRSxHQUFHLENBQUNILENBQUMsQ0FBQ0csSUFBSSxFQUFFLEdBQUdILENBQUMsQ0FBQ0csRUFBRSxJQUFJO0FBQ25EO0FBQ0EsU0FBU0UsSUFBSWIsRUFBWTtJQUN2QixJQUFJLENBQUNBLEdBQUdL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O0lBQzVCLE1BQU1DLEtBQUt2QixRQUFRd0IsSUFBSSxJQUFJO0lBQzNCLE1BQU1DLFFBQVF6QixRQUFReUIsS0FBSyxJQUFJO0lBQy9CLE1BQU1uRCxJQUFJMEIsUUFBUTFCLENBQUMsSUFBSTtJQUV2QixrREFBa0Q7SUFDbEQsTUFBTW9ELFFBQVFoSSxNQUFNcUcsSUFBSTRCLGlCQUFpQixFQUFFLENBQUMsR0FBRyxLQUFLakksTUFBTXFHLElBQUk2QixnQkFBZ0IsRUFBRSxHQUFHO0lBQ25GLE1BQU1DLE9BQU9uSSxNQUFNcUcsSUFBSStCLE1BQU0sSUFBSSxHQUFHLEdBQUcsSUFBZ0IsVUFBVTtJQUNqRSxNQUFNQyxNQUFPckksTUFBTXFHLElBQUlpQyxlQUFlLElBQUksR0FBRyxHQUFHLElBQU8sVUFBVTtJQUVqRSxNQUFNaEIsTUFBTUcsS0FBS08sUUFBUUwsS0FBS1EsT0FBT04sS0FBS1E7SUFDMUMsT0FBT3JJLE1BQU00RSxJQUFJckUsS0FBS3dILFFBQVFULE1BQU0sQ0FBQzFDLEdBQUdBLElBQWUsU0FBUztBQUNsRSIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGNvcmVcXGZlYXR1cmVzXFxzdHItYXV4XFxjYWxjXFxtZXRyaWNzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb3JlL21hdGhzL21ldHJpY3MudHNcclxuLy8gTWV0cmljcyBhbGlnbmVkIHRvIHlvdXIgZGVmaW5pdGlvbnMgKElESFIvZWNvc3lzdGVtLWF3YXJlKS5cclxuLy8gU2NhbGVzOiBzdHJlbmd0aHMg4oaSIFswLi4xMDBdLCBkaXJlY3Rpb25hbCDihpIgWy0xMDAuLjEwMF0uXHJcblxyXG4vKiDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgYmFzaWNzIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCAqL1xyXG5cclxuZXhwb3J0IHR5cGUgU2NhbGUgPSBudW1iZXI7IC8vIGVudmVsb3BlOyBkZWZhdWx0IFMgPSAxMDBcclxuXHJcbmNvbnN0IGNsYW1wID0gKHg6IG51bWJlciwgbG86IG51bWJlciwgaGk6IG51bWJlcikgPT4gTWF0aC5tYXgobG8sIE1hdGgubWluKGhpLCB4KSk7XHJcbmNvbnN0IHRhbmggPSAoeDogbnVtYmVyKSA9PiB7IGNvbnN0IGUgPSBNYXRoLmV4cCgyICogeCk7IHJldHVybiAoZSAtIDEpIC8gKGUgKyAxKTsgfTtcclxuY29uc3Qgc3VtID0gKHhzOiBudW1iZXJbXSkgPT4geHMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XHJcbmNvbnN0IG1lYW4gPSAoeHM6IG51bWJlcltdKSA9PiAoeHMubGVuZ3RoID8gc3VtKHhzKSAvIHhzLmxlbmd0aCA6IDApO1xyXG5jb25zdCBzaWduID0gKHg6IG51bWJlcikgPT4gKHggPiAwID8gMSA6IHggPCAwID8gLTEgOiAwKTtcclxuXHJcbmZ1bmN0aW9uIG1lZGlhbih4czogbnVtYmVyW10pIHtcclxuICBpZiAoIXhzLmxlbmd0aCkgcmV0dXJuIDA7XHJcbiAgY29uc3QgcyA9IHhzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYSAtIGIpOyBjb25zdCBtID0gTWF0aC5mbG9vcihzLmxlbmd0aCAvIDIpO1xyXG4gIHJldHVybiBzLmxlbmd0aCAlIDIgPyBzW21dIDogKHNbbSAtIDFdICsgc1ttXSkgLyAyO1xyXG59XHJcbmZ1bmN0aW9uIG1hZCh4czogbnVtYmVyW10pIHtcclxuICBpZiAoIXhzLmxlbmd0aCkgcmV0dXJuIDA7XHJcbiAgY29uc3QgbSA9IG1lZGlhbih4cyk7IGNvbnN0IGRldiA9IHhzLm1hcCh4ID0+IE1hdGguYWJzKHggLSBtKSk7XHJcbiAgcmV0dXJuIG1lZGlhbihkZXYpO1xyXG59XHJcbmZ1bmN0aW9uIGlxcih4czogbnVtYmVyW10pIHtcclxuICBpZiAoIXhzLmxlbmd0aCkgcmV0dXJuIDA7XHJcbiAgY29uc3QgcyA9IHhzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG4gIGNvbnN0IHEgPSAocDogbnVtYmVyKSA9PiB7XHJcbiAgICBjb25zdCBpZHggPSAocy5sZW5ndGggLSAxKSAqIHAsIGxvID0gTWF0aC5mbG9vcihpZHgpLCBoaSA9IE1hdGguY2VpbChpZHgpO1xyXG4gICAgcmV0dXJuIGxvID09PSBoaSA/IHNbbG9dIDogc1tsb10gKyAoc1toaV0gLSBzW2xvXSkgKiAoaWR4IC0gbG8pO1xyXG4gIH07XHJcbiAgcmV0dXJuIHEoMC43NSkgLSBxKDAuMjUpO1xyXG59XHJcbmZ1bmN0aW9uIGZyYWNGbGlwcyh4czogbnVtYmVyW10pIHtcclxuICBsZXQgZmxpcHMgPSAwLCB2YWxpZCA9IDAsIHByZXY6IG51bWJlciB8IG51bGwgPSBudWxsO1xyXG4gIGZvciAoY29uc3QgdiBvZiB4cykge1xyXG4gICAgY29uc3QgcyA9IHNpZ24odik7IGlmIChzID09PSAwKSBjb250aW51ZTtcclxuICAgIGlmIChwcmV2ID09PSBudWxsKSB7IHByZXYgPSBzOyBjb250aW51ZTsgfVxyXG4gICAgdmFsaWQrKzsgaWYgKHMgIT09IHByZXYpIHsgZmxpcHMrKzsgcHJldiA9IHM7IH1cclxuICB9XHJcbiAgcmV0dXJuIHZhbGlkID8gZmxpcHMgLyB2YWxpZCA6IDA7XHJcbn1cclxuZnVuY3Rpb24gaGhpKHNoYXJlczogbnVtYmVyW10pIHtcclxuICBjb25zdCBzID0gc2hhcmVzLm1hcCh4ID0+IE1hdGgubWF4KDAsIHgpKTsgY29uc3QgWiA9IHN1bShzKTtcclxuICBpZiAoIVopIHJldHVybiAwO1xyXG4gIHJldHVybiBzLnJlZHVjZSgoYSwgeCkgPT4gYSArIE1hdGgucG93KHggLyBaLCAyKSwgMCk7IC8vIFsxL0suLjFdXHJcbn1cclxuXHJcbi8qIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBpbnB1dHMg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXHJcbiAgIHJfdCAgOiBjb2luIGdyb3d0aC9yZXR1cm4gc2VyaWVzICh1bml0bGVzcywgY2FuIGJlIGluIMKxUylcclxuICAgTV90ICA6IGVjb3N5c3RlbSBiYXNlbGluZSBzZXJpZXMgKHNhbWUgbGVuZ3RoIGFzIHJfdClcclxuICAgzpRfdCAgOiBkaXZlcmdlbmNlIHNlcmllcyAocl90IC0gTV90KSBpZiB5b3UgcHJlZmVyIHRvIHBhc3MgZGlyZWN0bHlcclxuICAgVyAgICA6IHdpbmRvdyAodGlja3Mvc3RlcHMpXHJcbiAgIFMgICAgOiBlbnZlbG9wZSBzY2FsZSAoZGVmYXVsdCAxMDApXHJcbiAgIM61ICAgIDogZXBzaWxvbiBndWFyZCBmb3IgZGl2aXNpb25zXHJcbuKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCAqL1xyXG5cclxuLyog4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIEluZXJ0aWEg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXHJcbiAgIFlvdXIgbWVhbmluZzpcclxuICAgLSBTdGF0aWMgaW5lcnRpYTogc3RheXMgcHV0IChubyBncm93dGgpLCBsb3cgc3RlcCBub2lzZS5cclxuICAgLSBHcm93dGggaW5lcnRpYToga2VlcHMgdGhlIHNhbWUgZ3Jvd3RoIHBhdHRlcm47IGxhcmdlIHN0ZWFkeSBtZWRpYW4gdnMgbm9pc2UuXHJcbiAgIFJldHVybnMgY29tcG9uZW50cyBpbiBbMC4uMTAwXSBhbmQgYSB1bmlmaWVkIFwiZmFjZVwiLlxyXG7ilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbmVydGlhRnJvbVJldHVybnMoXHJcbiAgcjogbnVtYmVyW10sXHJcbiAgb3B0czogeyB3aW5kb3c/OiBudW1iZXI7IGJldGFfcz86IG51bWJlcjsgYmV0YV9tPzogbnVtYmVyOyBiZXRhX2c/OiBudW1iZXI7IHRhdTA/OiBudW1iZXIgfSA9IHt9XHJcbik6IHsgc3RhdGljOiBudW1iZXI7IGdyb3d0aDogbnVtYmVyOyB0b3RhbDogbnVtYmVyOyBmYWNlOiBcInN0YXRpY1wiIHwgXCJncm93dGhcIiB9IHtcclxuICBjb25zdCBXID0gTWF0aC5tYXgoNSwgTWF0aC5mbG9vcihvcHRzLndpbmRvdyA/PyBNYXRoLm1pbigzMCwgci5sZW5ndGgpKSk7XHJcbiAgaWYgKHIubGVuZ3RoIDwgMykgcmV0dXJuIHsgc3RhdGljOiAwLCBncm93dGg6IDAsIHRvdGFsOiAwLCBmYWNlOiBcInN0YXRpY1wiIH07XHJcbiAgY29uc3QgeSA9IHIuc2xpY2UoLVcpO1xyXG4gIGNvbnN0IGRpZmZzID0gW107IGZvciAobGV0IGkgPSAxOyBpIDwgeS5sZW5ndGg7IGkrKykgZGlmZnMucHVzaCh5W2ldIC0geVtpIC0gMV0pO1xyXG4gIGNvbnN0IG11ID0gbWVkaWFuKHkpLCBzcHJlYWREID0gbWFkKGRpZmZzKTtcclxuICBjb25zdCBiZXRhX3MgPSBvcHRzLmJldGFfcyA/PyAxLjA7XHJcbiAgY29uc3QgYmV0YV9tID0gb3B0cy5iZXRhX20gPz8gMS4wO1xyXG4gIGNvbnN0IGJldGFfZyA9IG9wdHMuYmV0YV9nID8/IDEuMDtcclxuICBjb25zdCB0YXUwID0gb3B0cy50YXUwID8/IDAuMDE7IC8vIFwibmVhciB6ZXJvXCIgdGFyZ2V0IGZvciBzdGF0aWNcclxuXHJcbiAgLy8gc3RhdGljOiBzbWFsbCBzdGVwcyArIG1lZGlhbiB+IDBcclxuICBjb25zdCBzdGF0aWNVID0gdGFuaChiZXRhX3MgKiAoMSAvICgxICsgc3ByZWFkRCkpKSAqIHRhbmgoYmV0YV9tICogKHRhdTAgLyAoTWF0aC5hYnMobXUpICsgMWUtOSkpKTtcclxuICAvLyBncm93dGg6IGxhcmdlIHxtZWRpYW58IHZzIHNtYWxsIHN0ZXAgbm9pc2VcclxuICBjb25zdCBncm93dGhVID0gdGFuaChiZXRhX2cgKiAoTWF0aC5hYnMobXUpIC8gKHNwcmVhZEQgKyAxZS05KSkpO1xyXG5cclxuICBjb25zdCBzID0gMTAwICogY2xhbXAoc3RhdGljVSwgMCwgMSk7XHJcbiAgY29uc3QgZyA9IDEwMCAqIGNsYW1wKGdyb3d0aFUsIDAsIDEpO1xyXG4gIGNvbnN0IGZhY2UgPSBnID4gcyA/IFwiZ3Jvd3RoXCIgOiBcInN0YXRpY1wiO1xyXG4gIHJldHVybiB7IHN0YXRpYzogcywgZ3Jvd3RoOiBnLCB0b3RhbDogTWF0aC5tYXgocywgZyksIGZhY2UgfTtcclxufVxyXG5cclxuLyog4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIERpc3J1cHRpb24g4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXHJcbiAgIFlvdXIgbWVhbmluZzogaW5zdGFudCBtb3ZlIG91dCBvZiBpbmVydGlhOyBzeXN0ZW1pYyA9IHByb3BvcnRpb24gb2YgY29pbnMuXHJcbuKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc3J1cHRpb25JbnN0YW50KFxyXG4gIHJOb3c6IG51bWJlcixcclxuICByZWZXaW5kb3c6IG51bWJlcltdIC8vIHJlY2VudCByZXR1cm5zICh3aW5kb3cgVykgZm9yIHRoZSBTQU1FIGNvaW5cclxuLCBnYW1tYSA9IDEuMCk6IG51bWJlciB7XHJcbiAgY29uc3QgbXUgPSBtZWRpYW4ocmVmV2luZG93KTtcclxuICBjb25zdCBzcHJlYWREID0gbWFkKHJlZldpbmRvdy5sZW5ndGggPiAxID8gcmVmV2luZG93Lm1hcCgodiwgaSwgYSkgPT4gKGkgPyB2IC0gYVtpIC0gMV0gOiAwKSkuc2xpY2UoMSkgOiBbMF0pO1xyXG4gIGNvbnN0IHUgPSB0YW5oKGdhbW1hICogKE1hdGguYWJzKHJOb3cgLSBtdSkgLyAoc3ByZWFkRCArIDFlLTkpKSk7XHJcbiAgcmV0dXJuIDEwMCAqIGNsYW1wKHUsIDAsIDEpO1xyXG59XHJcblxyXG4vKiogc3lzdGVtaWMgZGlzcnVwdGlvbiA9IHNoYXJlIG9mIGNvaW5zIHdob3NlIGluc3RhbnQgZGlzcnVwdGlvbiA+PSB0aHJlc2hvbGQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc3J1cHRpb25TeXN0ZW1pYyhkaXNydXB0aW9uczogbnVtYmVyW10sIHRocmVzaG9sZCA9IDYwKTogbnVtYmVyIHtcclxuICBpZiAoIWRpc3J1cHRpb25zLmxlbmd0aCkgcmV0dXJuIDA7XHJcbiAgY29uc3QgayA9IGRpc3J1cHRpb25zLmZpbHRlcihkID0+IGQgPj0gdGhyZXNob2xkKS5sZW5ndGg7XHJcbiAgcmV0dXJuIChrIC8gZGlzcnVwdGlvbnMubGVuZ3RoKSAqIDEwMDsgLy8gcGVyY2VudCBvZiB1bml2ZXJzZVxyXG59XHJcblxyXG4vKiDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgQW1wIChhbXBlcmFnZSkg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXHJcbiAgIFlvdXIgbWVhbmluZzogdGVuZGVuY3kgdG8gZmxpcCBiZXR3ZWVuIGdyb3d0aC9zaHJpbms7IHN3YXAgZnJlcXVlbmN5IG1hdHRlcnMuXHJcbiAgIEFtcCA9IHN3aW5nIHNpemUgw5cgZmxpcCByYXRlIOKGkiBbMC4uMTAwXS5cclxu4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYW1wRnJvbVNlcmllcyhcclxuICByOiBudW1iZXJbXSxcclxuICBvcHRzOiB7IHdpbmRvdz86IG51bWJlcjsgZXRhQT86IG51bWJlcjsgZXRhRj86IG51bWJlcjsgUz86IFNjYWxlIH0gPSB7fVxyXG4pOiBudW1iZXIge1xyXG4gIGNvbnN0IFcgPSBNYXRoLm1heCg1LCBNYXRoLmZsb29yKG9wdHMud2luZG93ID8/IE1hdGgubWluKDMwLCByLmxlbmd0aCkpKTtcclxuICBpZiAoci5sZW5ndGggPCAzKSByZXR1cm4gMDtcclxuICBjb25zdCB5ID0gci5zbGljZSgtVyk7XHJcbiAgY29uc3QgUyA9IG9wdHMuUyA/PyAxMDA7XHJcbiAgY29uc3Qgc3dpbmcgPSBtYWQoeSk7ICAgICAgICAgICAgICAgICAgICAvLyB0eXBpY2FsIHN3aW5nIHNpemUgKHVuaXRsZXNzKVxyXG4gIGNvbnN0IGZsaXBzID0gZnJhY0ZsaXBzKHkpOyAgICAgICAgICAgICAgLy8gMC4uMVxyXG4gIGNvbnN0IHUgPSB0YW5oKChvcHRzLmV0YUEgPz8gMS4wKSAqIChzd2luZyAvIChTIHx8IDEwMCkpKSAqIHRhbmgoKG9wdHMuZXRhRiA/PyAxLjApICogZmxpcHMpO1xyXG4gIHJldHVybiAxMDAgKiBjbGFtcCh1LCAwLCAxKTtcclxufVxyXG5cclxuLyog4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIFZvbHQgKHZvbHRhZ2UpIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgFxyXG4gICBZb3VyIG1lYW5pbmc6IHBlcnNpc3RlbnQgaW1iYWxhbmNlIChpbnN1bGF0aW9uKSB2cyBlY29zeXN0ZW0uXHJcbiAgIFVzZSBkaXZlcmdlbmNlIM6UX3QgPSByX3QgLSBNX3QuIFZvbHQg4oiIIFswLi4xMDBdLlxyXG7ilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2b2x0RnJvbURpdmVyZ2VuY2UoXHJcbiAgZGVsdGE6IG51bWJlcltdLFxyXG4gIG9wdHM/OiB7IHdpbmRvdz86IG51bWJlcjsgbGFtYmRhPzogbnVtYmVyOyBzcHJlYWQ/OiBudW1iZXIgfVxyXG4pOiBudW1iZXIge1xyXG4gIGNvbnN0IFcgPSBNYXRoLm1heCg1LCBNYXRoLmZsb29yKG9wdHM/LndpbmRvdyA/PyBNYXRoLm1pbigzMCwgZGVsdGEubGVuZ3RoKSkpO1xyXG4gIGlmIChkZWx0YS5sZW5ndGggPCAzKSByZXR1cm4gMDtcclxuICBjb25zdCBkID0gZGVsdGEuc2xpY2UoLVcpO1xyXG5cclxuICAvLyBGSVhFRDogYXZvaWQgbWl4aW5nID8/IGFuZCB8fCwgYWxzbyBndWFyZCBhZ2FpbnN0IDBcclxuICBjb25zdCBzcHJlYWQgPSBNYXRoLm1heCgxZS05LCBvcHRzPy5zcHJlYWQgPz8gbWFkKGQpKTtcclxuXHJcbiAgY29uc3QgYXZnQWJzWiA9IG1lYW4oZC5tYXAoeCA9PiBNYXRoLmFicyh4KSAvIHNwcmVhZCkpO1xyXG4gIGNvbnN0IHUgPSB0YW5oKChvcHRzPy5sYW1iZGEgPz8gMS4wKSAqIGF2Z0Fic1opO1xyXG4gIHJldHVybiAxMDAgKiBjbGFtcCh1LCAwLCAxKTtcclxufVxyXG5cclxuLyoqIGhlbHBlciBpZiB5b3UgaGF2ZSByX3QgYW5kIE1fdCBpbnN0ZWFkIG9mIM6UX3QgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZvbHRGcm9tUmV0dXJucyhyOiBudW1iZXJbXSwgTTogbnVtYmVyW10sIG9wdHM/OiB7IHdpbmRvdz86IG51bWJlcjsgbGFtYmRhPzogbnVtYmVyIH0pIHtcclxuICBjb25zdCBuID0gTWF0aC5taW4oci5sZW5ndGgsIE0ubGVuZ3RoKTtcclxuICBjb25zdCBkZWx0YSA9IFtdOyBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykgZGVsdGEucHVzaChyW2ldIC0gTVtpXSk7XHJcbiAgcmV0dXJuIHZvbHRGcm9tRGl2ZXJnZW5jZShkZWx0YSwgeyB3aW5kb3c6IG9wdHM/LndpbmRvdywgbGFtYmRhOiBvcHRzPy5sYW1iZGEgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2b2x0RnJvbVNlcmllcyh5Om51bWJlcltdLCBvcHRzPzogeyB3aW5kb3c/OiBudW1iZXI7IGxhbWJkYT86IG51bWJlcjsgUz86IFNjYWxlIH0pOiBudW1iZXIge1xyXG4gIGNvbnN0IFcgPSBNYXRoLm1heCg1LCBNYXRoLmZsb29yKG9wdHM/LndpbmRvdyA/PyBNYXRoLm1pbigzMCwgeS5sZW5ndGgpKSk7XHJcbiAgaWYgKHkubGVuZ3RoIDwgMykgcmV0dXJuIDA7XHJcbiAgY29uc3Qgc2xpY2UgPSB5LnNsaWNlKC1XKTtcclxuICBjb25zdCBkaWZmcyA9IFtdOyBmb3IgKGxldCBpPTE7aTxzbGljZS5sZW5ndGg7aSsrKSBkaWZmcy5wdXNoKHNsaWNlW2ldLXNsaWNlW2ktMV0pO1xyXG4gIGNvbnN0IFMgPSBvcHRzPy5TID8/IDEwMDtcclxuICBjb25zdCBsYW1iZGEgPSBvcHRzPy5sYW1iZGEgPz8gMS4wO1xyXG4gIHJldHVybiAxMDAgKiB0YW5oKGxhbWJkYSAqIChtYWQoZGlmZnMpIC8gUykpO1xyXG59XHJcblxyXG4vKiDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgSW5mbGF0aW9uIC8gRGVmbGF0aW9uIChzeXN0ZW1pYykg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXHJcbiAgIFlvdXIgbWVhbmluZzogcG9zaXRpb24gdnMgdGhlIHN5c3RlbSAoZWNvc3lzdGVtaWMgYW5hbHlzaXMpLlxyXG4gICBMZXZlbCB2YXJpYW50OiBMX3QgdnMgc3lzdGVtIGxldmVsIE1fdF7ihJMg4oaSIHNpZ25lZCBpbiBbLTEwMC4uMTAwXS5cclxu4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaW5mbERlZkxldmVsKFxyXG4gIExfbm93OiBudW1iZXIsICAgICAgICAvLyBjb2luIGxldmVsIChpbmRleCkgbm93XHJcbiAgTV9ub3c6IG51bWJlciwgICAgICAgIC8vIHN5c3RlbSBsZXZlbCBub3dcclxuICBvcHRzOiB7IGthcHBhPzogbnVtYmVyOyBTPzogU2NhbGUgfSA9IHt9XHJcbik6IG51bWJlciB7XHJcbiAgY29uc3QgUyA9IG9wdHMuUyA/PyAxMDA7IGNvbnN0IGthcHBhID0gb3B0cy5rYXBwYSA/PyAxLjA7XHJcbiAgY29uc3QgcmF0aW8gPSBNX25vdyA+IDAgPyBMX25vdyAvIE1fbm93IDogMTtcclxuICBjb25zdCBSID0gTWF0aC5sb2coTWF0aC5tYXgoMWUtOSwgcmF0aW8pKTsgICAvLyArIGluZmxhdGlvbiAocmljaGVyKSwgLSBkZWZsYXRpb25cclxuICByZXR1cm4gY2xhbXAoUyAqIHRhbmgoa2FwcGEgKiBSKSwgLVMsIFMpO1xyXG59XHJcblxyXG4vKiogcmF0ZSB2YXJpYW50IChjaGFuZ2UgdnMgcHJldmlvdXMgc3RlcCkgaWYgeW91IHdhbnQgYW4g4oCcaW5mbC9kZWYgcmF0ZeKAnSBsYXRlciAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaW5mbERlZlJhdGUoUl9ub3c6IG51bWJlciwgUl9wcmV2OiBudW1iZXIsIG9wdHM6IHsga2FwcGE/OiBudW1iZXI7IFM/OiBTY2FsZSB9ID0ge30pIHtcclxuICBjb25zdCBTID0gb3B0cy5TID8/IDEwMDsgY29uc3Qga2FwcGEgPSBvcHRzLmthcHBhID8/IDEuMDtcclxuICBjb25zdCBkUiA9IFJfbm93IC0gUl9wcmV2OyAvLyBhbHJlYWR5IHVuaXRsZXNzXHJcbiAgcmV0dXJuIGNsYW1wKFMgKiB0YW5oKGthcHBhICogZFIpLCAtUywgUyk7XHJcbn1cclxuXHJcbi8qIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBBcnRpZmljaWFsaXR5ICYgRWZmaWNpZW5jeSDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcclxuICAgWW91ciBtZWFuaW5nOlxyXG4gICAtIEFydGlmaWNpYWxpdHkgPSBtaXNtYXRjaCBiZXR3ZWVuIOKAnGJ1bGsgb3JkZXJz4oCdIGFuZCByZXN1bHRpbmcgYmVuY2htYXJrIG1vdmUsXHJcbiAgICAgcGx1cyBleGVjdXRpb24gY2h1cm4gLyBiaW4gY29uY2VudHJhdGlvbiAoc3BlY3VsYXRpdmUvY29udHJpdmVkKS5cclxuICAgLSBFZmZpY2llbmN5ICA9IGNvbnNvbGlkYXRlZCBvcmdhbmljIGdyb3d0aCAodHJlbmQgw5cgc3RyZW5ndGgpIHBlbmFsaXplZCBieVxyXG4gICAgIHZvbGF0aWxpdHkgYW5kIGFydGlmaWNpYWxpdHkg4oaSIFstMTAwLi4xMDBdLlxyXG7ilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgKi9cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQXJ0aWZpY2lhbGl0eUlucHV0cyB7XHJcbiAgLy8gRXhwZWN0ZWQgdnMgb2JzZXJ2ZWQgaW1wYWN0IChzYW1lIHVuaXRzLCBlLmcuLCByZXR1cm4gb3IgzpRiZW5jaG1hcmsgb3ZlciB0aWNrKVxyXG4gIGV4cGVjdGVkSW1wYWN0OiBudW1iZXI7ICAgLy8gZnJvbSBvcmRlcmJvb2sgbWljcm9zdHJ1Y3R1cmUgbW9kZWxcclxuICBvYnNlcnZlZENoYW5nZTogbnVtYmVyOyAgIC8vIGFjdHVhbCBiZW5jaG1hcmsgY2hhbmdlXHJcbiAgLy8gRXhlY3V0aW9uIHN0YXRzIG92ZXIgd2luZG93IEg6XHJcbiAgcGxhY2VkPzogbnVtYmVyOyBjYW5jZWxlZD86IG51bWJlcjsgZXhlY3V0ZWQ/OiBudW1iZXI7IC8vIGNvdW50cyBvciBub3Rpb25hbFxyXG4gIC8vIENvbmNlbnRyYXRpb246IHBlci1iaW4gY29udHJpYnV0aW9ucyAoYWJzIGlubmVyICogc2hhcmUpIGZvciBjdXJyZW50IHRpY2sgb3IgbWVhbiBvdmVyIHdpbmRvd1xyXG4gIGNvbnRyaWJTaGFyZXM/OiBudW1iZXJbXTsgLy8gZG9lcyBub3QgbmVlZCB0byBzdW0gdG8gMTsgd2Ugbm9ybWFsaXplXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhcnRpZmljaWFsaXR5U2NvcmUoXHJcbiAgaW5wOiBBcnRpZmljaWFsaXR5SW5wdXRzLFxyXG4gIHdlaWdodHM6IHsgd01pc21hdGNoPzogbnVtYmVyOyB3RXhlYz86IG51bWJlcjsgd0hIST86IG51bWJlciB9ID0ge31cclxuKTogbnVtYmVyIHtcclxuICBjb25zdCB3TSA9IHdlaWdodHMud01pc21hdGNoID8/IDAuNTtcclxuICBjb25zdCB3RSA9IHdlaWdodHMud0V4ZWMgPz8gMC4zO1xyXG4gIGNvbnN0IHdIID0gd2VpZ2h0cy53SEhJID8/IDAuMjtcclxuXHJcbiAgLy8gKDEpIEltcGFjdCBtaXNtYXRjaCAoMC4uMSk6IGxhcmdlIGlmIGJvb2sgc3VnZ2VzdHMgYmlnIG1vdmUgYnV0IHByaWNlIGJhcmVseSBtb3ZlcyAob3IgdmljZS12ZXJzYSlcclxuICBjb25zdCBtaXNtYXRjaCA9IE1hdGguYWJzKGlucC5leHBlY3RlZEltcGFjdCkgLyAoTWF0aC5hYnMoaW5wLm9ic2VydmVkQ2hhbmdlKSArIDFlLTkpO1xyXG4gIGNvbnN0IE0gPSBjbGFtcCh0YW5oKDAuNzUgKiBNYXRoLmxvZygxICsgbWlzbWF0Y2gpKSwgMCwgMSk7IC8vIHNvZnQtYm91bmRlZCAwLi4xXHJcblxyXG4gIC8vICgyKSBFeGVjdXRpb24gcmF0aW8gKDAuLjEpOiBjaHVybnkgaWYgKHBsYWNlZCtjYW5jZWwpL2V4ZWN1dGVkIGlzIGxhcmdlXHJcbiAgbGV0IEUgPSAwO1xyXG4gIGlmICgoaW5wLmV4ZWN1dGVkID8/IDApID4gMCkge1xyXG4gICAgY29uc3QgcmF0aW8gPSAoKGlucC5wbGFjZWQgPz8gMCkgKyAoaW5wLmNhbmNlbGVkID8/IDApKSAvIChpbnAuZXhlY3V0ZWQgPz8gMSk7XHJcbiAgICBFID0gY2xhbXAodGFuaCgwLjUgKiBNYXRoLmxvZygxICsgcmF0aW8pKSwgMCwgMSk7XHJcbiAgfVxyXG5cclxuICAvLyAoMykgQ29uY2VudHJhdGlvbiB2aWEgbm9ybWFsaXplZCBISEkgKDAuLjEpXHJcbiAgbGV0IEggPSAwO1xyXG4gIGlmIChpbnAuY29udHJpYlNoYXJlcyAmJiBpbnAuY29udHJpYlNoYXJlcy5sZW5ndGgpIHtcclxuICAgIGNvbnN0IHJhdyA9IGhoaShpbnAuY29udHJpYlNoYXJlcyk7XHJcbiAgICAvLyBub3JtYWxpemU6IG1pbmltYWwgfjAgKGJyb2FkKSDihpIgMCwgbWF4aW1hbCAxIOKGkiAxICh3ZSBza2lwIDEvSyBmbG9vcjsgdW5rbm93biBLKVxyXG4gICAgSCA9IGNsYW1wKChyYXcgLSAwKSAvICgxIC0gMCksIDAsIDEpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgQSA9IGNsYW1wKHdNICogTSArIHdFICogRSArIHdIICogSCwgMCwgMSk7XHJcbiAgcmV0dXJuIDEwMCAqIEE7IC8vIDAuLjEwMCAoaGlnaGVyID0gbW9yZSBhcnRpZmljaWFsKVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEVmZmljaWVuY3lJbnB1dHMge1xyXG4gIHRlbmRlbmN5RGlyZWN0aW9uOiBudW1iZXI7IC8vIGZyb20gdlRlbmRlbmN5LmRpcmVjdGlvbiBpbiBbLTEsMV1cclxuICB0ZW5kZW5jeVN0cmVuZ3RoOiBudW1iZXI7ICAvLyBmcm9tIHZUZW5kZW5jeS5zdHJlbmd0aCBpbiBbMCwxXVxyXG4gIHZvbHQwMT86IG51bWJlcjsgICAgICAgICAgIC8vIHZvbHQgaW4gWzAuLjFdICh1c2Ugdm9sdEZyb23igKYvMTAwKVxyXG4gIGFydGlmaWNpYWxpdHkwMT86IG51bWJlcjsgIC8vIGFydGlmaWNpYWxpdHkgaW4gWzAuLjFdIChhcnRpZmljaWFsaXR5U2NvcmUvMTAwKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZWZmaWNpZW5jeVNjb3JlKFxyXG4gIGlucDogRWZmaWNpZW5jeUlucHV0cyxcclxuICB3ZWlnaHRzOiB7IHdUcmVuZD86IG51bWJlcjsgd1ZvbHQ/OiBudW1iZXI7IHdBcnQ/OiBudW1iZXI7IGFscGhhPzogbnVtYmVyOyBTPzogU2NhbGUgfSA9IHt9XHJcbik6IG51bWJlciB7XHJcbiAgY29uc3Qgd1QgPSB3ZWlnaHRzLndUcmVuZCA/PyAwLjY7XHJcbiAgY29uc3Qgd1YgPSB3ZWlnaHRzLndWb2x0ID8/IDAuMjtcclxuICBjb25zdCB3QSA9IHdlaWdodHMud0FydCA/PyAwLjI7XHJcbiAgY29uc3QgYWxwaGEgPSB3ZWlnaHRzLmFscGhhID8/IDEuMjtcclxuICBjb25zdCBTID0gd2VpZ2h0cy5TID8/IDEwMDtcclxuXHJcbiAgLy8g4oCcT3JnYW5pYyBncm93dGjigJ06IGRpcmVjdGlvbiDDlyBzdHJlbmd0aCAoWy0xLDFdKVxyXG4gIGNvbnN0IHRyZW5kID0gY2xhbXAoaW5wLnRlbmRlbmN5RGlyZWN0aW9uLCAtMSwgMSkgKiBjbGFtcChpbnAudGVuZGVuY3lTdHJlbmd0aCwgMCwgMSk7XHJcbiAgY29uc3Qgdm9sdCA9IGNsYW1wKGlucC52b2x0MDEgPz8gMCwgMCwgMSk7ICAgICAgICAgICAgIC8vIHBlbmFsdHlcclxuICBjb25zdCBhcnQgID0gY2xhbXAoaW5wLmFydGlmaWNpYWxpdHkwMSA/PyAwLCAwLCAxKTsgICAgLy8gcGVuYWx0eVxyXG5cclxuICBjb25zdCByYXcgPSB3VCAqIHRyZW5kIC0gd1YgKiB2b2x0IC0gd0EgKiBhcnQ7XHJcbiAgcmV0dXJuIGNsYW1wKFMgKiB0YW5oKGFscGhhICogcmF3KSwgLVMsIFMpOyAgICAgICAgICAgIC8vIFstUyxTXVxyXG59XHJcbiJdLCJuYW1lcyI6WyJjbGFtcCIsIngiLCJsbyIsImhpIiwiTWF0aCIsIm1heCIsIm1pbiIsInRhbmgiLCJlIiwiZXhwIiwic3VtIiwieHMiLCJyZWR1Y2UiLCJhIiwiYiIsIm1lYW4iLCJsZW5ndGgiLCJzaWduIiwibWVkaWFuIiwicyIsInNsaWNlIiwic29ydCIsIm0iLCJmbG9vciIsIm1hZCIsImRldiIsIm1hcCIsImFicyIsImlxciIsInEiLCJwIiwiaWR4IiwiY2VpbCIsImZyYWNGbGlwcyIsImZsaXBzIiwidmFsaWQiLCJwcmV2IiwidiIsImhoaSIsInNoYXJlcyIsIloiLCJwb3ciLCJpbmVydGlhRnJvbVJldHVybnMiLCJyIiwib3B0cyIsIlciLCJ3aW5kb3ciLCJzdGF0aWMiLCJncm93dGgiLCJ0b3RhbCIsImZhY2UiLCJ5IiwiZGlmZnMiLCJpIiwicHVzaCIsIm11Iiwic3ByZWFkRCIsImJldGFfcyIsImJldGFfbSIsImJldGFfZyIsInRhdTAiLCJzdGF0aWNVIiwiZ3Jvd3RoVSIsImciLCJkaXNydXB0aW9uSW5zdGFudCIsInJOb3ciLCJyZWZXaW5kb3ciLCJnYW1tYSIsInUiLCJkaXNydXB0aW9uU3lzdGVtaWMiLCJkaXNydXB0aW9ucyIsInRocmVzaG9sZCIsImsiLCJmaWx0ZXIiLCJkIiwiYW1wRnJvbVNlcmllcyIsIlMiLCJzd2luZyIsImV0YUEiLCJldGFGIiwidm9sdEZyb21EaXZlcmdlbmNlIiwiZGVsdGEiLCJzcHJlYWQiLCJhdmdBYnNaIiwibGFtYmRhIiwidm9sdEZyb21SZXR1cm5zIiwiTSIsIm4iLCJ2b2x0RnJvbVNlcmllcyIsImluZmxEZWZMZXZlbCIsIkxfbm93IiwiTV9ub3ciLCJrYXBwYSIsInJhdGlvIiwiUiIsImxvZyIsImluZmxEZWZSYXRlIiwiUl9ub3ciLCJSX3ByZXYiLCJkUiIsImFydGlmaWNpYWxpdHlTY29yZSIsImlucCIsIndlaWdodHMiLCJ3TSIsIndNaXNtYXRjaCIsIndFIiwid0V4ZWMiLCJ3SCIsIndISEkiLCJtaXNtYXRjaCIsImV4cGVjdGVkSW1wYWN0Iiwib2JzZXJ2ZWRDaGFuZ2UiLCJFIiwiZXhlY3V0ZWQiLCJwbGFjZWQiLCJjYW5jZWxlZCIsIkgiLCJjb250cmliU2hhcmVzIiwicmF3IiwiQSIsImVmZmljaWVuY3lTY29yZSIsIndUIiwid1RyZW5kIiwid1YiLCJ3Vm9sdCIsIndBIiwid0FydCIsImFscGhhIiwidHJlbmQiLCJ0ZW5kZW5jeURpcmVjdGlvbiIsInRlbmRlbmN5U3RyZW5ndGgiLCJ2b2x0Iiwidm9sdDAxIiwiYXJ0IiwiYXJ0aWZpY2lhbGl0eTAxIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/calc/metrics.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/calc/panel.ts":
/*!*************************************************!*\
  !*** ./src/core/features/str-aux/calc/panel.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildSymbolStatsPanel: () => (/* binding */ buildSymbolStatsPanel),\n/* harmony export */   buildSymbolsStatsPanel: () => (/* binding */ buildSymbolsStatsPanel),\n/* harmony export */   computeSampledMetrics: () => (/* reexport safe */ _core_features_str_aux_calc_executive__WEBPACK_IMPORTED_MODULE_0__.computeSampledMetrics),\n/* harmony export */   computeSampledMetricsForSymbol: () => (/* reexport safe */ _core_features_str_aux_calc_executive__WEBPACK_IMPORTED_MODULE_0__.computeSampledMetricsForSymbol),\n/* harmony export */   toSymbolStatsPanel: () => (/* binding */ toSymbolStatsPanel)\n/* harmony export */ });\n/* harmony import */ var _core_features_str_aux_calc_executive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/features/str-aux/calc/executive */ \"(rsc)/./src/core/features/str-aux/calc/executive.ts\");\n// src/core/features/str-aux/calc/panel.ts\n// Helpers that transform sampled metrics into the shape consumed by the stats endpoint / UI.\n\nfunction toSymbolStatsPanel(symbol, result, ticker) {\n    if (!result.ok) {\n        return {\n            ok: false,\n            symbol,\n            error: result.error,\n            sampling: result.sampling\n        };\n    }\n    return sampledSuccessToPanel(symbol, result, ticker);\n}\nasync function buildSymbolStatsPanel(symbol, opts, ticker) {\n    const result = await (0,_core_features_str_aux_calc_executive__WEBPACK_IMPORTED_MODULE_0__.computeSampledMetricsForSymbol)(symbol, opts);\n    return toSymbolStatsPanel(symbol, result, ticker);\n}\nasync function buildSymbolsStatsPanel(symbols, opts, tickers) {\n    const entries = await Promise.all(symbols.map(async (symbol)=>{\n        const panel = await buildSymbolStatsPanel(symbol, opts, tickers?.[symbol]);\n        return [\n            symbol,\n            panel\n        ];\n    }));\n    return Object.fromEntries(entries);\n}\n\nfunction sampledSuccessToPanel(symbol, success, ticker) {\n    const pct24h = Number.isFinite(Number(ticker?.pct24h)) ? Number(ticker?.pct24h) : undefined;\n    const cards = buildCards(success.meta, pct24h);\n    const meta = {\n        opening: success.meta.opening,\n        last: success.meta.last,\n        prev: success.meta.prev,\n        lastUpdateTs: success.meta.lastUpdateTs,\n        n: success.meta.n\n    };\n    return {\n        ok: true,\n        symbol,\n        stats: success.stats,\n        hist: success.hist,\n        extrema: success.extrema,\n        sampling: success.sampling,\n        meta,\n        cards\n    };\n}\nfunction buildCards(meta, pct24h) {\n    return {\n        opening: {\n            benchmark: meta.opening,\n            pct24h\n        },\n        live: {\n            benchmark: meta.last,\n            pct_drv: pctDrv(meta.prev, meta.last, meta.n),\n            pct24h\n        }\n    };\n}\nfunction pctDrv(prev, cur, n) {\n    if (!(n > 1) || !Number.isFinite(prev) || !Number.isFinite(cur) || prev === 0) {\n        return 0;\n    }\n    return 100 * (cur / prev - 1);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L2NhbGMvcGFuZWwudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsMENBQTBDO0FBQzFDLDZGQUE2RjtBQVE3QztBQTBDekMsU0FBU0UsbUJBQ2RDLE1BQWMsRUFDZEMsTUFBNEIsRUFDNUJDLE1BQXVCO0lBRXZCLElBQUksQ0FBQ0QsT0FBT0UsRUFBRSxFQUFFO1FBQ2QsT0FBTztZQUNMQSxJQUFJO1lBQ0pIO1lBQ0FJLE9BQU9ILE9BQU9HLEtBQUs7WUFDbkJDLFVBQVVKLE9BQU9JLFFBQVE7UUFDM0I7SUFDRjtJQUVBLE9BQU9DLHNCQUFzQk4sUUFBUUMsUUFBUUM7QUFDL0M7QUFFTyxlQUFlSyxzQkFDcEJQLE1BQWMsRUFDZFEsSUFBMkIsRUFDM0JOLE1BQXVCO0lBRXZCLE1BQU1ELFNBQVMsTUFBTUoscUdBQThCQSxDQUFDRyxRQUFRUTtJQUM1RCxPQUFPVCxtQkFBbUJDLFFBQVFDLFFBQVFDO0FBQzVDO0FBRU8sZUFBZU8sdUJBQ3BCQyxPQUFpQixFQUNqQkYsSUFBMkIsRUFDM0JHLE9BQXdDO0lBRXhDLE1BQU1DLFVBQVUsTUFBTUMsUUFBUUMsR0FBRyxDQUMvQkosUUFBUUssR0FBRyxDQUFDLE9BQU9mO1FBQ2pCLE1BQU1nQixRQUFRLE1BQU1ULHNCQUFzQlAsUUFBUVEsTUFBTUcsU0FBUyxDQUFDWCxPQUFPO1FBQ3pFLE9BQU87WUFBQ0E7WUFBUWdCO1NBQU07SUFDeEI7SUFFRixPQUFPQyxPQUFPQyxXQUFXLENBQUNOO0FBQzVCO0FBRWlFO0FBR2pFLFNBQVNOLHNCQUNQTixNQUFjLEVBQ2RtQixPQUE4QixFQUM5QmpCLE1BQXVCO0lBRXZCLE1BQU1rQixTQUFTQyxPQUFPQyxRQUFRLENBQUNELE9BQU9uQixRQUFRa0IsV0FDMUNDLE9BQU9uQixRQUFRa0IsVUFDZkc7SUFDSixNQUFNQyxRQUFRQyxXQUFXTixRQUFRTyxJQUFJLEVBQUVOO0lBQ3ZDLE1BQU1NLE9BQXdCO1FBQzVCQyxTQUFTUixRQUFRTyxJQUFJLENBQUNDLE9BQU87UUFDN0JDLE1BQU1ULFFBQVFPLElBQUksQ0FBQ0UsSUFBSTtRQUN2QkMsTUFBTVYsUUFBUU8sSUFBSSxDQUFDRyxJQUFJO1FBQ3ZCQyxjQUFjWCxRQUFRTyxJQUFJLENBQUNJLFlBQVk7UUFDdkNDLEdBQUdaLFFBQVFPLElBQUksQ0FBQ0ssQ0FBQztJQUNuQjtJQUVBLE9BQU87UUFDTDVCLElBQUk7UUFDSkg7UUFDQWdDLE9BQU9iLFFBQVFhLEtBQUs7UUFDcEJDLE1BQU1kLFFBQVFjLElBQUk7UUFDbEJDLFNBQVNmLFFBQVFlLE9BQU87UUFDeEI3QixVQUFVYyxRQUFRZCxRQUFRO1FBQzFCcUI7UUFDQUY7SUFDRjtBQUNGO0FBRUEsU0FBU0MsV0FBV0MsSUFBbUMsRUFBRU4sTUFBZTtJQUN0RSxPQUFPO1FBQ0xPLFNBQVM7WUFBRVEsV0FBV1QsS0FBS0MsT0FBTztZQUFFUDtRQUFPO1FBQzNDZ0IsTUFBTTtZQUNKRCxXQUFXVCxLQUFLRSxJQUFJO1lBQ3BCUyxTQUFTQyxPQUFPWixLQUFLRyxJQUFJLEVBQUVILEtBQUtFLElBQUksRUFBRUYsS0FBS0ssQ0FBQztZQUM1Q1g7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTa0IsT0FBT1QsSUFBWSxFQUFFVSxHQUFXLEVBQUVSLENBQVM7SUFDbEQsSUFBSSxDQUFFQSxDQUFBQSxJQUFJLE1BQU0sQ0FBQ1YsT0FBT0MsUUFBUSxDQUFDTyxTQUFTLENBQUNSLE9BQU9DLFFBQVEsQ0FBQ2lCLFFBQVFWLFNBQVMsR0FBRztRQUM3RSxPQUFPO0lBQ1Q7SUFDQSxPQUFPLE1BQU8sT0FBT0EsT0FBUTtBQUMvQiIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGNvcmVcXGZlYXR1cmVzXFxzdHItYXV4XFxjYWxjXFxwYW5lbC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L2NhbGMvcGFuZWwudHNcbi8vIEhlbHBlcnMgdGhhdCB0cmFuc2Zvcm0gc2FtcGxlZCBtZXRyaWNzIGludG8gdGhlIHNoYXBlIGNvbnN1bWVkIGJ5IHRoZSBzdGF0cyBlbmRwb2ludCAvIFVJLlxuXG5pbXBvcnQge1xuICBjb21wdXRlU2FtcGxlZE1ldHJpY3NGb3JTeW1ib2wsXG4gIGNvbXB1dGVTYW1wbGVkTWV0cmljcyxcbiAgdHlwZSBTYW1wbGVkTWV0cmljc09wdGlvbnMsXG4gIHR5cGUgU2FtcGxlZE1ldHJpY3NSZXN1bHQsXG4gIHR5cGUgU2FtcGxlZE1ldHJpY3NTdWNjZXNzLFxufSBmcm9tIFwiQC9jb3JlL2ZlYXR1cmVzL3N0ci1hdXgvY2FsYy9leGVjdXRpdmVcIjtcbmltcG9ydCB0eXBlIHsgU3RhdHMgfSBmcm9tIFwiQC9jb3JlL2ZlYXR1cmVzL3N0ci1hdXgvY2FsYy9zdGF0c1wiO1xuaW1wb3J0IHR5cGUgeyBTYW1wbGluZ1dpbmRvd0RpZ2VzdCB9IGZyb20gXCJAL2NvcmUvZmVhdHVyZXMvc3RyLWF1eC9zYW1wbGluZ1wiO1xuXG5leHBvcnQgdHlwZSBUaWNrZXJTbmFwc2hvdCA9IHtcbiAgcHJpY2U/OiBudW1iZXIgfCBudWxsO1xuICBwY3QyNGg/OiBudW1iZXIgfCBudWxsO1xufTtcblxuZXhwb3J0IHR5cGUgU3ltYm9sU3RhdHNNZXRhID0ge1xuICBvcGVuaW5nOiBudW1iZXI7XG4gIGxhc3Q6IG51bWJlcjtcbiAgcHJldjogbnVtYmVyO1xuICBsYXN0VXBkYXRlVHM6IG51bWJlcjtcbiAgbjogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgU3ltYm9sU3RhdHNDYXJkcyA9IHtcbiAgb3BlbmluZzogeyBiZW5jaG1hcms6IG51bWJlcjsgcGN0MjRoPzogbnVtYmVyIHwgbnVsbCB9O1xuICBsaXZlOiB7IGJlbmNobWFyazogbnVtYmVyOyBwY3RfZHJ2OiBudW1iZXI7IHBjdDI0aD86IG51bWJlciB8IG51bGwgfTtcbn07XG5cbmV4cG9ydCB0eXBlIFN5bWJvbFN0YXRzUGFuZWxTdWNjZXNzID0ge1xuICBvazogdHJ1ZTtcbiAgc3ltYm9sOiBzdHJpbmc7XG4gIHN0YXRzOiBTdGF0cztcbiAgaGlzdDogU2FtcGxlZE1ldHJpY3NTdWNjZXNzW1wiaGlzdFwiXTtcbiAgZXh0cmVtYTogeyBwcmljZU1pbjogbnVtYmVyOyBwcmljZU1heDogbnVtYmVyOyBiZW5jaFBjdE1pbjogbnVtYmVyOyBiZW5jaFBjdE1heDogbnVtYmVyIH07XG4gIHNhbXBsaW5nOiBTYW1wbGluZ1dpbmRvd0RpZ2VzdDtcbiAgbWV0YTogU3ltYm9sU3RhdHNNZXRhO1xuICBjYXJkczogU3ltYm9sU3RhdHNDYXJkcztcbn07XG5cbmV4cG9ydCB0eXBlIFN5bWJvbFN0YXRzUGFuZWxFcnJvciA9IHtcbiAgb2s6IGZhbHNlO1xuICBzeW1ib2w6IHN0cmluZztcbiAgZXJyb3I6IHN0cmluZztcbiAgc2FtcGxpbmc/OiBTYW1wbGluZ1dpbmRvd0RpZ2VzdDtcbn07XG5cbmV4cG9ydCB0eXBlIFN5bWJvbFN0YXRzUGFuZWwgPSBTeW1ib2xTdGF0c1BhbmVsU3VjY2VzcyB8IFN5bWJvbFN0YXRzUGFuZWxFcnJvcjtcblxuZXhwb3J0IGZ1bmN0aW9uIHRvU3ltYm9sU3RhdHNQYW5lbChcbiAgc3ltYm9sOiBzdHJpbmcsXG4gIHJlc3VsdDogU2FtcGxlZE1ldHJpY3NSZXN1bHQsXG4gIHRpY2tlcj86IFRpY2tlclNuYXBzaG90XG4pOiBTeW1ib2xTdGF0c1BhbmVsIHtcbiAgaWYgKCFyZXN1bHQub2spIHtcbiAgICByZXR1cm4ge1xuICAgICAgb2s6IGZhbHNlLFxuICAgICAgc3ltYm9sLFxuICAgICAgZXJyb3I6IHJlc3VsdC5lcnJvcixcbiAgICAgIHNhbXBsaW5nOiByZXN1bHQuc2FtcGxpbmcsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzYW1wbGVkU3VjY2Vzc1RvUGFuZWwoc3ltYm9sLCByZXN1bHQsIHRpY2tlcik7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBidWlsZFN5bWJvbFN0YXRzUGFuZWwoXG4gIHN5bWJvbDogc3RyaW5nLFxuICBvcHRzOiBTYW1wbGVkTWV0cmljc09wdGlvbnMsXG4gIHRpY2tlcj86IFRpY2tlclNuYXBzaG90XG4pOiBQcm9taXNlPFN5bWJvbFN0YXRzUGFuZWw+IHtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29tcHV0ZVNhbXBsZWRNZXRyaWNzRm9yU3ltYm9sKHN5bWJvbCwgb3B0cyk7XG4gIHJldHVybiB0b1N5bWJvbFN0YXRzUGFuZWwoc3ltYm9sLCByZXN1bHQsIHRpY2tlcik7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBidWlsZFN5bWJvbHNTdGF0c1BhbmVsKFxuICBzeW1ib2xzOiBzdHJpbmdbXSxcbiAgb3B0czogU2FtcGxlZE1ldHJpY3NPcHRpb25zLFxuICB0aWNrZXJzPzogUmVjb3JkPHN0cmluZywgVGlja2VyU25hcHNob3Q+XG4pOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIFN5bWJvbFN0YXRzUGFuZWw+PiB7XG4gIGNvbnN0IGVudHJpZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBzeW1ib2xzLm1hcChhc3luYyAoc3ltYm9sKSA9PiB7XG4gICAgICBjb25zdCBwYW5lbCA9IGF3YWl0IGJ1aWxkU3ltYm9sU3RhdHNQYW5lbChzeW1ib2wsIG9wdHMsIHRpY2tlcnM/LltzeW1ib2xdKTtcbiAgICAgIHJldHVybiBbc3ltYm9sLCBwYW5lbF0gYXMgY29uc3Q7XG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhlbnRyaWVzKTtcbn1cblxuZXhwb3J0IHsgY29tcHV0ZVNhbXBsZWRNZXRyaWNzRm9yU3ltYm9sLCBjb21wdXRlU2FtcGxlZE1ldHJpY3MgfTtcbmV4cG9ydCB0eXBlIHsgU2FtcGxlZE1ldHJpY3NPcHRpb25zLCBTYW1wbGVkTWV0cmljc1Jlc3VsdCwgU2FtcGxlZE1ldHJpY3NTdWNjZXNzIH07XG5cbmZ1bmN0aW9uIHNhbXBsZWRTdWNjZXNzVG9QYW5lbChcbiAgc3ltYm9sOiBzdHJpbmcsXG4gIHN1Y2Nlc3M6IFNhbXBsZWRNZXRyaWNzU3VjY2VzcyxcbiAgdGlja2VyPzogVGlja2VyU25hcHNob3Rcbik6IFN5bWJvbFN0YXRzUGFuZWxTdWNjZXNzIHtcbiAgY29uc3QgcGN0MjRoID0gTnVtYmVyLmlzRmluaXRlKE51bWJlcih0aWNrZXI/LnBjdDI0aCkpXG4gICAgPyBOdW1iZXIodGlja2VyPy5wY3QyNGgpXG4gICAgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGNhcmRzID0gYnVpbGRDYXJkcyhzdWNjZXNzLm1ldGEsIHBjdDI0aCk7XG4gIGNvbnN0IG1ldGE6IFN5bWJvbFN0YXRzTWV0YSA9IHtcbiAgICBvcGVuaW5nOiBzdWNjZXNzLm1ldGEub3BlbmluZyxcbiAgICBsYXN0OiBzdWNjZXNzLm1ldGEubGFzdCxcbiAgICBwcmV2OiBzdWNjZXNzLm1ldGEucHJldixcbiAgICBsYXN0VXBkYXRlVHM6IHN1Y2Nlc3MubWV0YS5sYXN0VXBkYXRlVHMsXG4gICAgbjogc3VjY2Vzcy5tZXRhLm4sXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBvazogdHJ1ZSxcbiAgICBzeW1ib2wsXG4gICAgc3RhdHM6IHN1Y2Nlc3Muc3RhdHMsXG4gICAgaGlzdDogc3VjY2Vzcy5oaXN0LFxuICAgIGV4dHJlbWE6IHN1Y2Nlc3MuZXh0cmVtYSxcbiAgICBzYW1wbGluZzogc3VjY2Vzcy5zYW1wbGluZyxcbiAgICBtZXRhLFxuICAgIGNhcmRzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZENhcmRzKG1ldGE6IFNhbXBsZWRNZXRyaWNzU3VjY2Vzc1tcIm1ldGFcIl0sIHBjdDI0aD86IG51bWJlcikge1xuICByZXR1cm4ge1xuICAgIG9wZW5pbmc6IHsgYmVuY2htYXJrOiBtZXRhLm9wZW5pbmcsIHBjdDI0aCB9LFxuICAgIGxpdmU6IHtcbiAgICAgIGJlbmNobWFyazogbWV0YS5sYXN0LFxuICAgICAgcGN0X2RydjogcGN0RHJ2KG1ldGEucHJldiwgbWV0YS5sYXN0LCBtZXRhLm4pLFxuICAgICAgcGN0MjRoLFxuICAgIH0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBjdERydihwcmV2OiBudW1iZXIsIGN1cjogbnVtYmVyLCBuOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoIShuID4gMSkgfHwgIU51bWJlci5pc0Zpbml0ZShwcmV2KSB8fCAhTnVtYmVyLmlzRmluaXRlKGN1cikgfHwgcHJldiA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiAxMDAgKiAoKGN1ciAvIHByZXYpIC0gMSk7XG59XG4iXSwibmFtZXMiOlsiY29tcHV0ZVNhbXBsZWRNZXRyaWNzRm9yU3ltYm9sIiwiY29tcHV0ZVNhbXBsZWRNZXRyaWNzIiwidG9TeW1ib2xTdGF0c1BhbmVsIiwic3ltYm9sIiwicmVzdWx0IiwidGlja2VyIiwib2siLCJlcnJvciIsInNhbXBsaW5nIiwic2FtcGxlZFN1Y2Nlc3NUb1BhbmVsIiwiYnVpbGRTeW1ib2xTdGF0c1BhbmVsIiwib3B0cyIsImJ1aWxkU3ltYm9sc1N0YXRzUGFuZWwiLCJzeW1ib2xzIiwidGlja2VycyIsImVudHJpZXMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwicGFuZWwiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsInN1Y2Nlc3MiLCJwY3QyNGgiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInVuZGVmaW5lZCIsImNhcmRzIiwiYnVpbGRDYXJkcyIsIm1ldGEiLCJvcGVuaW5nIiwibGFzdCIsInByZXYiLCJsYXN0VXBkYXRlVHMiLCJuIiwic3RhdHMiLCJoaXN0IiwiZXh0cmVtYSIsImJlbmNobWFyayIsImxpdmUiLCJwY3RfZHJ2IiwicGN0RHJ2IiwiY3VyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/calc/panel.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/calc/stats.ts":
/*!*************************************************!*\
  !*** ./src/core/features/str-aux/calc/stats.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeStats: () => (/* binding */ computeStats)\n/* harmony export */ });\n/* harmony import */ var _frame_idhr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../frame/idhr */ \"(rsc)/./src/core/features/str-aux/frame/idhr.ts\");\n/* harmony import */ var _vectors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../vectors */ \"(rsc)/./src/core/features/str-aux/vectors.ts\");\n/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./metrics */ \"(rsc)/./src/core/features/str-aux/calc/metrics.ts\");\n// core/features/str-aux/calc/stats.ts\n// STR-AUX descriptive stats + Floating Mode + Vectors + Intrinsic metrics.\n// - FloMo (GFM absolute price) from top-K densest IDHR bins (outlier-robust).\n// - BFloM (BFM 0..1) normalized within current IDHR return window.\n// - Vectors: vInner, vOuter, vTendency, optional vSwap (quartiles).\n// - Intrinsic metrics via metrics toolbox: inertia, amp, volt, efficiency.\n // sampler only (no MarketPoint import)\n // vectors\n // toolbox\n//  small utils \nconst EPS = 1e-9;\nconst avg = (a)=>a.length ? a.reduce((x, y)=>x + y, 0) / a.length : 0;\nconst robustSigma = (values)=>{\n    const m = avg(values);\n    const varSum = values.reduce((s, v)=>s + (v - m) * (v - m), 0);\n    return Math.sqrt(varSum / Math.max(1, values.length));\n};\nconst zAbs = (values, sigma)=>{\n    if (!(sigma > 0)) return 0;\n    const m = avg(values);\n    return avg(values.map((v)=>Math.abs((v - m) / sigma)));\n};\n// densest-K (works with idhr exposing edges+counts OR centers+counts)\nfunction takeDensestK(hist, k = 8) {\n    const centers = hist.edges ?? hist.centers ?? [];\n    const counts = hist.counts ?? [];\n    const pairs = centers.map((c, i)=>({\n            idx: i,\n            count: counts[i] ?? 0,\n            centerR: c\n        }));\n    pairs.sort((a, b)=>b.count - a.count);\n    return pairs.slice(0, Math.max(1, Math.min(k, pairs.length)));\n}\nfunction weightedCenterR(_hist, top) {\n    const mass = top.reduce((s, x)=>s + x.count, 0) || 1;\n    return top.reduce((s, x)=>s + x.centerR * (x.count / mass), 0);\n}\n// compute simple log-returns for metrics\nfunction logReturns(prices) {\n    const r = [];\n    for(let i = 1; i < prices.length; i++){\n        const a = prices[i - 1], b = prices[i];\n        if (a > 0 && b > 0) r.push(Math.log(b / a));\n        else r.push(0);\n    }\n    return r;\n}\n//  main \nfunction computeStats(points, opening, opts = {}) {\n    const epsGfmPct = opts.epsGfmPct ?? 0.35;\n    const epsBfmPct = opts.epsBfmPct ?? 0.35;\n    const vScale = opts.vScale ?? 100;\n    const Wm = Math.max(5, Math.floor(opts.metricsWin ?? 30));\n    const topK = Math.max(1, Math.floor(opts.idhr?.topK ?? 8));\n    // price dispersion\n    const prices = points.map((p)=>Number(p.price)).filter(Number.isFinite);\n    const openingPx = Number(opening?.benchmark ?? NaN);\n    const openingVal = prices[0] ?? openingPx;\n    const last = prices[prices.length - 1] ?? openingPx;\n    const prev = prices.length >= 2 ? prices[prices.length - 2] : last;\n    const sigma = robustSigma(prices);\n    const z = zAbs(prices, sigma);\n    // IDHR histogram (return-space)  map to CompatMarketPoint[] (volume required by sampler)\n    const idhrPoints = points.map((p)=>({\n            ts: Number(p.ts),\n            price: Number(p.price),\n            volume: Number.isFinite(p?.volume) ? Number(p.volume) : 0\n        }));\n    const hist = (0,_frame_idhr__WEBPACK_IMPORTED_MODULE_0__.computeIdhrBins)(idhrPoints, {\n        benchmark: openingPx,\n        pct24h: 0,\n        id_pct: 0,\n        ts: points[0]?.ts ?? 0,\n        layoutHash: '0'\n    }, {\n        bins: opts.idhr?.bins,\n        alpha: opts.idhr?.alpha,\n        sMin: opts.idhr?.sMin,\n        smooth: opts.idhr?.smooth\n    });\n    const binsCount = (hist.edges ?? hist.centers ?? []).length || hist.bins || 0;\n    // densest-K  weighted center in RETURN space\n    const top = takeDensestK(hist, topK);\n    const rCenter = weightedCenterR(hist, top); // ln(px/p0)\n    // FloMo (absolute price)\n    const gfmAbs = Number.isFinite(openingPx) && openingPx > 0 ? openingPx * Math.exp(rCenter) : NaN;\n    const refGfmAbs = Number.isFinite(opts.refGfmAbs) ? opts.refGfmAbs : openingPx;\n    const deltaGfmAbs = Number.isFinite(gfmAbs) && Number.isFinite(refGfmAbs) ? gfmAbs - refGfmAbs : NaN;\n    const deltaGfmPct = Number.isFinite(gfmAbs) && refGfmAbs > 0 ? (gfmAbs / refGfmAbs - 1) * 100 : NaN;\n    const shiftedGfm = Number.isFinite(deltaGfmPct) ? Math.abs(deltaGfmPct) >= epsGfmPct : false;\n    // BFloM (0..1) within current return window\n    const edges = hist.edges ?? hist.centers ?? [];\n    const rMin = edges[0] ?? 0, rMax = edges[edges.length - 1] ?? 1;\n    const bfm01 = (rCenter - rMin) / Math.max(EPS, rMax - rMin);\n    const refBfm01 = Number.isFinite(opts.refBfm01) ? opts.refBfm01 : bfm01;\n    const deltaBfm01 = bfm01 - refBfm01;\n    const deltaBfmPct = deltaBfm01 * 100;\n    const shiftedBfm = Math.abs(deltaBfmPct) >= epsBfmPct;\n    // vectors\n    const vectorSummary = (0,_vectors__WEBPACK_IMPORTED_MODULE_1__.computeVectorSummary)(points, {\n        bins: binsCount,\n        scale: vScale,\n        history: {\n            inner: opts.innerHistScaled,\n            tendency: opts.tendencyHistScaled\n        },\n        tendencyWindow: opts.tendencyWin,\n        tendencyNorm: opts.tendencyNorm\n    });\n    const vInnerAgg = vectorSummary.inner.scaled;\n    const vOuterAgg = vectorSummary.outer.scaled;\n    const tendency = vectorSummary.tendency.metrics;\n    const vSwap = vectorSummary.swap;\n    // intrinsic metrics (toolbox) using log-returns\n    const r = logReturns(prices);\n    const rW = r.slice(-Wm);\n    let inertia, amp, volt, efficiency;\n    if (rW.length >= 3) {\n        inertia = (0,_metrics__WEBPACK_IMPORTED_MODULE_2__.inertiaFromReturns)(rW, {\n            window: Wm\n        });\n        amp = (0,_metrics__WEBPACK_IMPORTED_MODULE_2__.ampFromSeries)(rW, {\n            window: Wm,\n            S: 100\n        });\n        volt = (0,_metrics__WEBPACK_IMPORTED_MODULE_2__.voltFromSeries)(rW, {\n            window: Wm,\n            lambda: 1.0,\n            S: 100\n        });\n        efficiency = (0,_metrics__WEBPACK_IMPORTED_MODULE_2__.efficiencyScore)({\n            tendencyDirection: tendency.direction,\n            tendencyStrength: tendency.strength,\n            volt01: (volt ?? 0) / 100,\n            artificiality01: 0\n        }, opts.efficiency);\n    }\n    return {\n        // dispersion\n        sigma,\n        zAbs: z,\n        // modes\n        gfmAbs,\n        refGfmAbs,\n        deltaGfmAbs,\n        deltaGfmPct,\n        shiftedGfm,\n        bfm01,\n        refBfm01,\n        deltaBfm01,\n        deltaBfmPct,\n        shiftedBfm,\n        // vectors\n        vInner: vInnerAgg,\n        vOuter: vOuterAgg,\n        tendency,\n        vSwap,\n        vectors: vectorSummary,\n        // metrics\n        inertia,\n        amp,\n        volt,\n        efficiency,\n        // raw\n        opening: Number(openingVal),\n        last: Number(last),\n        prev: Number(prev)\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L2NhbGMvc3RhdHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLHNDQUFzQztBQUN0QywyRUFBMkU7QUFDM0UsOEVBQThFO0FBQzlFLG1FQUFtRTtBQUNuRSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBS3BELENBQUMsdUNBQXVDO0FBSzNDLENBQUMsVUFBVTtBQU9aLENBQUMsVUFBVTtBQWtGOUIsa0VBQWtFO0FBQ2xFLE1BQU1NLE1BQU07QUFDWixNQUFNQyxNQUFNLENBQUNDLElBQWlCQSxFQUFFQyxNQUFNLEdBQUdELEVBQUVFLE1BQU0sQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxJQUFJQyxHQUFHLEtBQUtKLEVBQUVDLE1BQU0sR0FBRztBQUNuRixNQUFNSSxjQUFjLENBQUNDO0lBQ25CLE1BQU1DLElBQUlSLElBQUlPO0lBQ2QsTUFBTUUsU0FBU0YsT0FBT0osTUFBTSxDQUFDLENBQUNPLEdBQUdDLElBQU1ELElBQUksQ0FBQ0MsSUFBSUgsQ0FBQUEsSUFBTUcsQ0FBQUEsSUFBSUgsQ0FBQUEsR0FBSTtJQUM5RCxPQUFPSSxLQUFLQyxJQUFJLENBQUNKLFNBQVNHLEtBQUtFLEdBQUcsQ0FBQyxHQUFHUCxPQUFPTCxNQUFNO0FBQ3JEO0FBQ0EsTUFBTWEsT0FBTyxDQUFDUixRQUFrQlM7SUFDOUIsSUFBSSxDQUFFQSxDQUFBQSxRQUFRLElBQUksT0FBTztJQUN6QixNQUFNUixJQUFJUixJQUFJTztJQUNkLE9BQU9QLElBQUlPLE9BQU9VLEdBQUcsQ0FBQyxDQUFDTixJQUFNQyxLQUFLTSxHQUFHLENBQUMsQ0FBQ1AsSUFBSUgsQ0FBQUEsSUFBS1E7QUFDbEQ7QUFFQSxzRUFBc0U7QUFDdEUsU0FBU0csYUFDUEMsSUFBYyxFQUNkQyxJQUFJLENBQUM7SUFFTCxNQUFNQyxVQUFvQixLQUFjQyxLQUFLLElBQUksS0FBY0QsT0FBTyxJQUFJLEVBQUU7SUFDNUUsTUFBTUUsU0FBbUIsS0FBY0EsTUFBTSxJ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UUFBUWhFO1lBQUlpRSxHQUFHO1FBQUk7UUFDN0NILE9BQU9wSCx3REFBY0EsQ0FBQ2lILElBQUk7WUFBRUssUUFBUWhFO1lBQUlrRSxRQUFRO1lBQUtELEdBQUc7UUFBSTtRQUM1REYsYUFBYXBILHlEQUFlQSxDQUMxQjtZQUNFd0gsbUJBQW1CcEIsU0FBU3FCLFNBQVM7WUFDckNDLGtCQUFrQnRCLFNBQVN1QixRQUFRO1lBQ25DQyxRQUFRLENBQUNULFFBQVEsS0FBSztZQUN0QlUsaUJBQWlCO1FBQ25CLEdBQ0E1RSxLQUFLbUUsVUFBVTtJQUVuQjtJQUVBLE9BQU87UUFDTCxhQUFhO1FBQ2JsRztRQUNBRCxNQUFNb0Q7UUFFTixRQUFRO1FBQ1JhO1FBQ0FFO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FHO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBRUEsVUFBVTtRQUNWZ0MsUUFBUXJCO1FBQ1JzQixRQUFRcEI7UUFDUlA7UUFDQVU7UUFDQWtCLFNBQVNqQztRQUVULFVBQVU7UUFDVmtCO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBRUEsTUFBTTtRQUNOcEUsU0FBU1csT0FBT087UUFDaEJDLE1BQU1SLE9BQU9RO1FBQ2JDLE1BQU1ULE9BQU9TO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGNvcmVcXGZlYXR1cmVzXFxzdHItYXV4XFxjYWxjXFxzdGF0cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb3JlL2ZlYXR1cmVzL3N0ci1hdXgvY2FsYy9zdGF0cy50c1xuLy8gU1RSLUFVWCBkZXNjcmlwdGl2ZSBzdGF0cyArIEZsb2F0aW5nIE1vZGUgKyBWZWN0b3JzICsgSW50cmluc2ljIG1ldHJpY3MuXG4vLyAtIEZsb01vIChHRk0gYWJzb2x1dGUgcHJpY2UpIGZyb20gdG9wLUsgZGVuc2VzdCBJREhSIGJpbnMgKG91dGxpZXItcm9idXN0KS5cbi8vIC0gQkZsb00gKEJGTSAwLi4xKSBub3JtYWxpemVkIHdpdGhpbiBjdXJyZW50IElESFIgcmV0dXJuIHdpbmRvdy5cbi8vIC0gVmVjdG9yczogdklubmVyLCB2T3V0ZXIsIHZUZW5kZW5jeSwgb3B0aW9uYWwgdlN3YXAgKHF1YXJ0aWxlcykuXG4vLyAtIEludHJpbnNpYyBtZXRyaWNzIHZpYSBtZXRyaWNzIHRvb2xib3g6IGluZXJ0aWEsIGFtcCwgdm9sdCwgZWZmaWNpZW5jeS5cblxuaW1wb3J0IHtcbiAgY29tcHV0ZUlkaHJCaW5zLFxuICB0eXBlIElkaHJCaW5zLFxufSBmcm9tICcuLi9mcmFtZS9pZGhyJzsgLy8gc2FtcGxlciBvbmx5IChubyBNYXJrZXRQb2ludCBpbXBvcnQpXG5cbmltcG9ydCB7XG4gIGNvbXB1dGVWZWN0b3JTdW1tYXJ5LFxuICB0eXBlIFZlY3RvclN1bW1hcnksXG59IGZyb20gJy4uL3ZlY3RvcnMnOyAvLyB2ZWN0b3JzXG5cbmltcG9ydCB7XG4gIGluZXJ0aWFGcm9tUmV0dXJucyxcbiAgYW1wRnJvbVNlcmllcyxcbiAgdm9sdEZyb21TZXJpZXMsXG4gIGVmZmljaWVuY3lTY29yZSxcbn0gZnJvbSAnLi9tZXRyaWNzJzsgLy8gdG9vbGJveFxuXG4vLyBMb2NhbCBzdHJ1Y3R1cmFsIHR5cGUgY29tcGF0aWJsZSB3aXRoIHRoZSBzYW1wbGVyJ3MgZXhwZWN0YXRpb24uXG50eXBlIENvbXBhdE1hcmtldFBvaW50ID0geyB0czogbnVtYmVyOyBwcmljZTogbnVtYmVyOyB2b2x1bWU6IG51bWJlciB9O1xuXG5leHBvcnQgdHlwZSBQb2ludCA9IHsgdHM6IG51bWJlcjsgcHJpY2U6IG51bWJlcjsgdz86IG51bWJlcjsgdm9sdW1lPzogbnVtYmVyIH07XG5cbmV4cG9ydCB0eXBlIFN0YXRzID0ge1xuICAvLyBkaXNwZXJzaW9uIChwcmljZSBzZXJpZXMpXG4gIHNpZ21hOiBudW1iZXI7XG4gIHpBYnM6IG51bWJlcjtcblxuICAvLyBGbG9NbyDigJQgYWJzb2x1dGUgR2VuZXJhbCBGbG9hdGluZyBNb2RlIChwcmljZSBzcGFjZSlcbiAgZ2ZtQWJzOiBudW1iZXI7XG4gIHJlZkdmbUFiczogbnVtYmVyO1xuICBkZWx0YUdmbUFiczogbnVtYmVyO1xuICBkZWx0YUdmbVBjdDogbnVtYmVyO1xuICBzaGlmdGVkR2ZtOiBib29sZWFuO1xuXG4gIC8vIEJGbG9NIOKAlCBub3JtYWxpemVkICgwLi4xKSB3aXRoaW4gY3VycmVudCBJREhSIHJldHVybiBzcGFuXG4gIGJmbTAxOiBudW1iZXI7XG4gIHJlZkJmbTAxOiBudW1iZXI7XG4gIGRlbHRhQmZtMDE6IG51bWJlcjtcbiAgZGVsdGFCZm1QY3Q6IG51bWJlcjtcbiAgc2hpZnRlZEJmbTogYm9vbGVhbjtcblxuICAvLyB2ZWN0b3JzXG4gIHZJbm5lcjogbnVtYmVyO1xuICB2T3V0ZXI6IG51bWJlcjtcbiAgdGVuZGVuY3k6IHsgZGlyZWN0aW9uOiBudW1iZXI7IHN0cmVuZ3RoOiBudW1iZXI7IHNsb3BlOiBudW1iZXI7IHI6IG51bWJlcjsgc2NvcmU6IG51bWJlciB9O1xuICB2U3dhcD86IHsgUTogbnVtYmVyOyBzY29yZTogbnVtYmVyOyBxMTogbnVtYmVyOyBxMzogbnVtYmVyIH07XG4gIHZlY3RvcnM6IFZlY3RvclN1bW1hcnk7XG5cbiAgLy8gaW50cmluc2ljIG1ldHJpY3MgKHRvb2xib3gpXG4gIGluZXJ0aWE/OiB7IHN0YXRpYzogbnVtYmVyOyBncm93dGg6IG51bWJlcjsgdG90YWw6IG51bWJlcjsgZmFjZTogJ3N0YXRpYycgfCAnZ3Jvd3RoJyB9O1xuICBhbXA/OiBudW1iZXI7XG4gIHZvbHQ/OiBudW1iZXI7XG4gIGVmZmljaWVuY3k/OiBudW1iZXI7XG5cbiAgLy8gb3B0aW9uYWwgaGlzdG9ncmFtIHNuYXBzaG90IChwcmVzZW50IHdoZW4gaW52b2tlZCBmcm9tIHNhbXBsaW5nIHBpcGVsaW5lcylcbiAgaGlzdG9ncmFtPzoge1xuICAgIGNvdW50czogbnVtYmVyW107XG4gICAgZWRnZXM6IG51bWJlcltdO1xuICAgIHByb2JzOiBudW1iZXJbXTtcbiAgICBkZW5zZXN0OiBudW1iZXJbXTtcbiAgICBtdVI6IG51bWJlcjtcbiAgICBzaWdtYVI6IG51bWJlcjtcbiAgICB0b3RhbDogbnVtYmVyO1xuICB9O1xuXG4gIC8vIHJhdyBoZWxwZXJzXG4gIG9wZW5pbmc6IG51bWJlcjtcbiAgbGFzdDogbnVtYmVyO1xuICBwcmV2OiBudW1iZXI7XG59O1xuXG50eXBlIE9wdGlvbnMgPSB7XG4gIC8vIElESFIgY29udHJvbHMgKG1lcmdlZCBpbnNpZGUgaWRoci50cyBpZiBzdXBwb3J0ZWQpXG4gIGlkaHI/OiB7IGJpbnM/OiBudW1iZXI7IGFscGhhPzogbnVtYmVyOyBzTWluPzogbnVtYmVyOyBzbW9vdGg/OiBudW1iZXI7IHRvcEs/OiBudW1iZXIgfTtcblxuICAvLyBhbmNob3JzICYgdGhyZXNob2xkc1xuICBlcHNHZm1QY3Q/OiBudW1iZXI7IC8vIGRlZmF1bHQgMC4zNVxuICBlcHNCZm1QY3Q/OiBudW1iZXI7IC8vIGRlZmF1bHQgMC4zNVxuICByZWZHZm1BYnM/OiBudW1iZXI7IC8vIGRlZmF1bHQgPSBvcGVuaW5nUHhcbiAgcmVmQmZtMDE/OiBudW1iZXI7ICAvLyBkZWZhdWx0ID0gYmZtMDEgb2YgdGhpcyBjYWxsXG5cbiAgLy8gdmVjdG9yc1xuICB2U2NhbGU/OiBudW1iZXI7IC8vIGRlZmF1bHQgMTAwXG4gIHRlbmRlbmN5V2luPzogbnVtYmVyOyAvLyBkZWZhdWx0IDMwXG4gIHRlbmRlbmN5Tm9ybT86ICdtYWQnIHwgJ3N0ZGV2JzsgLy8gZGVmYXVsdCAnbWFkJ1xuICBpbm5lckhpc3RTY2FsZWQ/OiBudW1iZXJbXTtcbiAgdGVuZGVuY3lIaXN0U2NhbGVkPzogbnVtYmVyW107XG5cbiAgLy8gbWV0cmljcyB3aW5kb3dzXG4gIG1ldHJpY3NXaW4/OiBudW1iZXI7IC8vIGRlZmF1bHQgMzAgZm9yIGluZXJ0aWEvYW1wL3ZvbHQgY2FsY3VsYXRpb25zXG5cbiAgLy8gZWZmaWNpZW5jeSB3ZWlnaHRzIChvcHRpb25hbClcbiAgZWZmaWNpZW5jeT86IHsgd1RyZW5kPzogbnVtYmVyOyB3Vm9sdD86IG51bWJlcjsgd0FydD86IG51bWJlcjsgYWxwaGE/OiBudW1iZXI7IFM/OiBudW1iZXIgfTtcbn07XG5cbmV4cG9ydCB0eXBlIFN0YXRzT3B0aW9ucyA9IE9wdGlvbnM7XG5cbi8vIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCBzbWFsbCB1dGlscyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcbmNvbnN0IEVQUyA9IDFlLTk7XG5jb25zdCBhdmcgPSAoYTogbnVtYmVyW10pID0+IChhLmxlbmd0aCA/IGEucmVkdWNlKCh4LCB5KSA9PiB4ICsgeSwgMCkgLyBhLmxlbmd0aCA6IDApO1xuY29uc3Qgcm9idXN0U2lnbWEgPSAodmFsdWVzOiBudW1iZXJbXSkgPT4ge1xuICBjb25zdCBtID0gYXZnKHZhbHVlcyk7XG4gIGNvbnN0IHZhclN1bSA9IHZhbHVlcy5yZWR1Y2UoKHMsIHYpID0+IHMgKyAodiAtIG0pICogKHYgLSBtKSwgMCk7XG4gIHJldHVybiBNYXRoLnNxcnQodmFyU3VtIC8gTWF0aC5tYXgoMSwgdmFsdWVzLmxlbmd0aCkpO1xufTtcbmNvbnN0IHpBYnMgPSAodmFsdWVzOiBudW1iZXJbXSwgc2lnbWE6IG51bWJlcikgPT4ge1xuICBpZiAoIShzaWdtYSA+IDApKSByZXR1cm4gMDtcbiAgY29uc3QgbSA9IGF2Zyh2YWx1ZXMpO1xuICByZXR1cm4gYXZnKHZhbHVlcy5tYXAoKHYpID0+IE1hdGguYWJzKCh2IC0gbSkgLyBzaWdtYSkpKTtcbn07XG5cbi8vIGRlbnNlc3QtSyAod29ya3Mgd2l0aCBpZGhyIGV4cG9zaW5nIGVkZ2VzK2NvdW50cyBPUiBjZW50ZXJzK2NvdW50cylcbmZ1bmN0aW9uIHRha2VEZW5zZXN0SyhcbiAgaGlzdDogSWRockJpbnMsXG4gIGsgPSA4XG4pOiBBcnJheTx7IGlkeDogbnVtYmVyOyBjb3VudDogbnVtYmVyOyBjZW50ZXJSOiBudW1iZXIgfT4ge1xuICBjb25zdCBjZW50ZXJzOiBudW1iZXJbXSA9IChoaXN0IGFzIGFueSkuZWRnZXMgPz8gKGhpc3QgYXMgYW55KS5jZW50ZXJzID8/IFtdO1xuICBjb25zdCBjb3VudHM6IG51bWJlcltdID0gKGhpc3QgYXMgYW55KS5jb3VudHMgPz8gW107XG4gIGNvbnN0IHBhaXJzID0gY2VudGVycy5tYXAoKGMsIGkpID0+ICh7IGlkeDogaSwgY291bnQ6IGNvdW50c1tpXSA/PyAwLCBjZW50ZXJSOiBjIH0pKTtcbiAgcGFpcnMuc29ydCgoYSwgYikgPT4gYi5jb3VudCAtIGEuY291bnQpO1xuICByZXR1cm4gcGFpcnMuc2xpY2UoMCwgTWF0aC5tYXgoMSwgTWF0aC5taW4oaywgcGFpcnMubGVuZ3RoKSkpO1xufVxuZnVuY3Rpb24gd2VpZ2h0ZWRDZW50ZXJSKFxuICBfaGlzdDogSWRockJpbnMsXG4gIHRvcDogQXJyYXk8eyBpZHg6IG51bWJlcjsgY291bnQ6IG51bWJlcjsgY2VudGVyUjogbnVtYmVyIH0+XG4pOiBudW1iZXIge1xuICBjb25zdCBtYXNzID0gdG9wLnJlZHVjZSgocywgeCkgPT4gcyArIHguY291bnQsIDApIHx8IDE7XG4gIHJldHVybiB0b3AucmVkdWNlKChzLCB4KSA9PiBzICsgeC5jZW50ZXJSICogKHguY291bnQgLyBtYXNzKSwgMCk7XG59XG5cbi8vIGNvbXB1dGUgc2ltcGxlIGxvZy1yZXR1cm5zIGZvciBtZXRyaWNzXG5mdW5jdGlvbiBsb2dSZXR1cm5zKHByaWNlczogbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gIGNvbnN0IHI6IG51bWJlcltdID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgcHJpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYSA9IHByaWNlc1tpIC0gMV0sIGIgPSBwcmljZXNbaV07XG4gICAgaWYgKGEgPiAwICYmIGIgPiAwKSByLnB1c2goTWF0aC5sb2coYiAvIGEpKTtcbiAgICBlbHNlIHIucHVzaCgwKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuLy8g4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIG1haW4g4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVN0YXRzKFxuICBwb2ludHM6IFBvaW50W10sXG4gIG9wZW5pbmc6IHsgYmVuY2htYXJrOiBudW1iZXIgfSxcbiAgb3B0czogT3B0aW9ucyA9IHt9XG4pOiBTdGF0cyB7XG4gIGNvbnN0IGVwc0dmbVBjdCA9IG9wdHMuZXBzR2ZtUGN0ID8/IDAuMzU7XG4gIGNvbnN0IGVwc0JmbVBjdCA9IG9wdHMuZXBzQmZtUGN0ID8/IDAuMzU7XG4gIGNvbnN0IHZTY2FsZSAgICA9IG9wdHMudlNjYWxlICAgID8/IDEwMDtcbiAgY29uc3QgV20gICAgICAgID0gTWF0aC5tYXgoNSwgTWF0aC5mbG9vcihvcHRzLm1ldHJpY3NXaW4gPz8gMzApKTtcbiAgY29uc3QgdG9wSyAgICAgID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihvcHRzLmlkaHI/LnRvcEsgPz8gOCkpO1xuXG4gIC8vIHByaWNlIGRpc3BlcnNpb25cbiAgY29uc3QgcHJpY2VzID0gcG9pbnRzLm1hcCgocCkgPT4gTnVtYmVyKHAucHJpY2UpKS5maWx0ZXIoTnVtYmVyLmlzRmluaXRlKTtcbiAgY29uc3Qgb3BlbmluZ1B4ID0gTnVtYmVyKG9wZW5pbmc/LmJlbmNobWFyayA/PyBOYU4pO1xuICBjb25zdCBvcGVuaW5nVmFsID0gcHJpY2VzWzBdID8/IG9wZW5pbmdQeDtcbiAgY29uc3QgbGFzdCA9IHByaWNlc1twcmljZXMubGVuZ3RoIC0gMV0gPz8gb3BlbmluZ1B4O1xuICBjb25zdCBwcmV2ID0gcHJpY2VzLmxlbmd0aCA+PSAyID8gcHJpY2VzW3ByaWNlcy5sZW5ndGggLSAyXSA6IGxhc3Q7XG5cbiAgY29uc3Qgc2lnbWEgPSByb2J1c3RTaWdtYShwcmljZXMpO1xuICBjb25zdCB6ID0gekFicyhwcmljZXMsIHNpZ21hKTtcblxuICAvLyBJREhSIGhpc3RvZ3JhbSAocmV0dXJuLXNwYWNlKSDigJQgbWFwIHRvIENvbXBhdE1hcmtldFBvaW50W10gKHZvbHVtZSByZXF1aXJlZCBieSBzYW1wbGVyKVxuICBjb25zdCBpZGhyUG9pbnRzOiBDb21wYXRNYXJrZXRQb2ludFtdID0gcG9pbnRzLm1hcCgocCkgPT4gKHtcbiAgICB0czogTnVtYmVyKHAudHMpLFxuICAgIHByaWNlOiBOdW1iZXIocC5wcmljZSksXG4gICAgdm9sdW1lOiBOdW1iZXIuaXNGaW5pdGUoKHAgYXMgYW55KT8udm9sdW1lKSA/IE51bWJlcigocCBhcyBhbnkpLnZvbHVtZSkgOiAwLFxuICB9KSk7XG5cbiAgY29uc3QgaGlzdCA9IGNvbXB1dGVJZGhyQmlucyhcbiAgICBpZGhyUG9pbnRzLFxuICAgIHtcbiAgICAgIGJlbmNobWFyazogb3BlbmluZ1B4LFxuICAgICAgcGN0MjRoOiAwLFxuICAgICAgaWRfcGN0OiAwLFxuICAgICAgdHM6IHBvaW50c1swXT8udHMgPz8gMCxcbiAgICAgIGxheW91dEhhc2g6ICcwJyxcbiAgICB9LFxuICAgIHsgYmluczogb3B0cy5pZGhyPy5iaW5zLCBhbHBoYTogb3B0cy5pZGhyPy5hbHBoYSwgc01pbjogb3B0cy5pZGhyPy5zTWluLCBzbW9vdGg6IG9wdHMuaWRocj8uc21vb3RoIH0gYXMgYW55XG4gICk7XG4gIGNvbnN0IGJpbnNDb3VudCA9XG4gICAgKChoaXN0IGFzIGFueSkuZWRnZXMgPz8gKGhpc3QgYXMgYW55KS5jZW50ZXJzID8/IFtdKS5sZW5ndGggfHxcbiAgICAoaGlzdCBhcyBhbnkpLmJpbnMgfHxcbiAgICAwO1xuXG4gIC8vIGRlbnNlc3QtSyDihpIgd2VpZ2h0ZWQgY2VudGVyIGluIFJFVFVSTiBzcGFjZVxuICBjb25zdCB0b3AgPSB0YWtlRGVuc2VzdEsoaGlzdCwgdG9wSyk7XG4gIGNvbnN0IHJDZW50ZXIgPSB3ZWlnaHRlZENlbnRlclIoaGlzdCwgdG9wKTsgLy8gbG4ocHgvcDApXG5cbiAgLy8gRmxvTW8gKGFic29sdXRlIHByaWNlKVxuICBjb25zdCBnZm1BYnMgPVxuICAgIE51bWJlci5pc0Zpbml0ZShvcGVuaW5nUHgpICYmIG9wZW5pbmdQeCA+IDAgPyBvcGVuaW5nUHggKiBNYXRoLmV4cChyQ2VudGVyKSA6IE5hTjtcbiAgY29uc3QgcmVmR2ZtQWJzID0gTnVtYmVyLmlzRmluaXRlKG9wdHMucmVmR2ZtQWJzIGFzIG51bWJlcilcbiAgICA/IChvcHRzLnJlZkdmbUFicyBhcyBudW1iZXIpXG4gICAgOiBvcGVuaW5nUHg7XG4gIGNvbnN0IGRlbHRhR2ZtQWJzID1cbiAgICBOdW1iZXIuaXNGaW5pdGUoZ2ZtQWJzKSAmJiBOdW1iZXIuaXNGaW5pdGUocmVmR2ZtQWJzKVxuICAgICAgPyBnZm1BYnMgLSByZWZHZm1BYnNcbiAgICAgIDogTmFOO1xuICBjb25zdCBkZWx0YUdmbVBjdCA9XG4gICAgTnVtYmVyLmlzRmluaXRlKGdmbUFicykgJiYgcmVmR2ZtQWJzID4gMCA/IChnZm1BYnMgLyByZWZHZm1BYnMgLSAxKSAqIDEwMCA6IE5hTjtcbiAgY29uc3Qgc2hpZnRlZEdmbSA9IE51bWJlci5pc0Zpbml0ZShkZWx0YUdmbVBjdClcbiAgICA/IE1hdGguYWJzKGRlbHRhR2ZtUGN0KSA+PSBlcHNHZm1QY3RcbiAgICA6IGZhbHNlO1xuXG4gIC8vIEJGbG9NICgwLi4xKSB3aXRoaW4gY3VycmVudCByZXR1cm4gd2luZG93XG4gIGNvbnN0IGVkZ2VzID0gKGhpc3QgYXMgYW55KS5lZGdlcyA/PyAoaGlzdCBhcyBhbnkpLmNlbnRlcnMgPz8gW107XG4gIGNvbnN0IHJNaW4gPSBlZGdlc1swXSA/PyAwLCByTWF4ID0gZWRnZXNbZWRnZXMubGVuZ3RoIC0gMV0gPz8gMTtcbiAgY29uc3QgYmZtMDEgPSAockNlbnRlciAtIHJNaW4pIC8gTWF0aC5tYXgoRVBTLCByTWF4IC0gck1pbik7XG4gIGNvbnN0IHJlZkJmbTAxID0gTnVtYmVyLmlzRmluaXRlKG9wdHMucmVmQmZtMDEgYXMgbnVtYmVyKVxuICAgID8gKG9wdHMucmVmQmZtMDEgYXMgbnVtYmVyKVxuICAgIDogYmZtMDE7XG4gIGNvbnN0IGRlbHRhQmZtMDEgPSBiZm0wMSAtIHJlZkJmbTAxO1xuICBjb25zdCBkZWx0YUJmbVBjdCA9IGRlbHRhQmZtMDEgKiAxMDA7XG4gIGNvbnN0IHNoaWZ0ZWRCZm0gPSBNYXRoLmFicyhkZWx0YUJmbVBjdCkgPj0gZXBzQmZtUGN0O1xuXG4gIC8vIHZlY3RvcnNcbiAgY29uc3QgdmVjdG9yU3VtbWFyeSA9IGNvbXB1dGVWZWN0b3JTdW1tYXJ5KHBvaW50cywge1xuICAgIGJpbnM6IGJpbnNDb3VudCxcbiAgICBzY2FsZTogdlNjYWxlLFxuICAgIGhpc3Rvcnk6IHtcbiAgICAgIGlubmVyOiBvcHRzLmlubmVySGlzdFNjYWxlZCxcbiAgICAgIHRlbmRlbmN5OiBvcHRzLnRlbmRlbmN5SGlzdFNjYWxlZCxcbiAgICB9LFxuICAgIHRlbmRlbmN5V2luZG93OiBvcHRzLnRlbmRlbmN5V2luLFxuICAgIHRlbmRlbmN5Tm9ybTogb3B0cy50ZW5kZW5jeU5vcm0sXG4gIH0pO1xuICBjb25zdCB2SW5uZXJBZ2cgPSB2ZWN0b3JTdW1tYXJ5LmlubmVyLnNjYWxlZDtcbiAgY29uc3Qgdk91dGVyQWdnID0gdmVjdG9yU3VtbWFyeS5vdXRlci5zY2FsZWQ7XG4gIGNvbnN0IHRlbmRlbmN5ID0gdmVjdG9yU3VtbWFyeS50ZW5kZW5jeS5tZXRyaWNzO1xuICBjb25zdCB2U3dhcCA9IHZlY3RvclN1bW1hcnkuc3dhcDtcblxuICAvLyBpbnRyaW5zaWMgbWV0cmljcyAodG9vbGJveCkgdXNpbmcgbG9nLXJldHVybnNcbiAgY29uc3QgciA9IGxvZ1JldHVybnMocHJpY2VzKTtcbiAgY29uc3QgclcgPSByLnNsaWNlKC1XbSk7XG4gIGxldCBpbmVydGlhLCBhbXAsIHZvbHQsIGVmZmljaWVuY3k7XG4gIGlmIChyVy5sZW5ndGggPj0gMykge1xuICAgIGluZXJ0aWEgPSBpbmVydGlhRnJvbVJldHVybnMoclcsIHsgd2luZG93OiBXbSB9KTtcbiAgICBhbXAgPSBhbXBGcm9tU2VyaWVzKHJXLCB7IHdpbmRvdzogV20sIFM6IDEwMCB9KTtcbiAgICB2b2x0ID0gdm9sdEZyb21TZXJpZXMoclcsIHsgd2luZG93OiBXbSwgbGFtYmRhOiAxLjAsIFM6IDEwMCB9KTtcbiAgICBlZmZpY2llbmN5ID0gZWZmaWNpZW5jeVNjb3JlKFxuICAgICAge1xuICAgICAgICB0ZW5kZW5jeURpcmVjdGlvbjogdGVuZGVuY3kuZGlyZWN0aW9uLFxuICAgICAgICB0ZW5kZW5jeVN0cmVuZ3RoOiB0ZW5kZW5jeS5zdHJlbmd0aCxcbiAgICAgICAgdm9sdDAxOiAodm9sdCA/PyAwKSAvIDEwMCxcbiAgICAgICAgYXJ0aWZpY2lhbGl0eTAxOiAwLFxuICAgICAgfSxcbiAgICAgIG9wdHMuZWZmaWNpZW5jeVxuICAgICk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIGRpc3BlcnNpb25cbiAgICBzaWdtYSxcbiAgICB6QWJzOiB6LFxuXG4gICAgLy8gbW9kZXNcbiAgICBnZm1BYnMsXG4gICAgcmVmR2ZtQWJzLFxuICAgIGRlbHRhR2ZtQWJzLFxuICAgIGRlbHRhR2ZtUGN0LFxuICAgIHNoaWZ0ZWRHZm0sXG4gICAgYmZtMDEsXG4gICAgcmVmQmZtMDEsXG4gICAgZGVsdGFCZm0wMSxcbiAgICBkZWx0YUJmbVBjdCxcbiAgICBzaGlmdGVkQmZtLFxuXG4gICAgLy8gdmVjdG9yc1xuICAgIHZJbm5lcjogdklubmVyQWdnLFxuICAgIHZPdXRlcjogdk91dGVyQWdnLFxuICAgIHRlbmRlbmN5LFxuICAgIHZTd2FwLFxuICAgIHZlY3RvcnM6IHZlY3RvclN1bW1hcnksXG5cbiAgICAvLyBtZXRyaWNzXG4gICAgaW5lcnRpYSxcbiAgICBhbXAsXG4gICAgdm9sdCxcbiAgICBlZmZpY2llbmN5LFxuXG4gICAgLy8gcmF3XG4gICAgb3BlbmluZzogTnVtYmVyKG9wZW5pbmdWYWwpLFxuICAgIGxhc3Q6IE51bWJlcihsYXN0KSxcbiAgICBwcmV2OiBOdW1iZXIocHJldiksXG4gIH07XG59XG4iXSwibmFtZXMiOlsiY29tcHV0ZUlkaHJCaW5zIiwiY29tcHV0ZVZlY3RvclN1bW1hcnkiLCJpbmVydGlhRnJvbVJldHVybnMiLCJhbXBGcm9tU2VyaWVzIiwidm9sdEZyb21TZXJpZXMiLCJlZmZpY2llbmN5U2NvcmUiLCJFUFMiLCJhdmciLCJhIiwibGVuZ3RoIiwicmVkdWNlIiwieCIsInkiLCJyb2J1c3RTaWdtYSIsInZhbHVlcyIsIm0iLCJ2YXJTdW0iLCJzIiwidiIsIk1hdGgiLCJzcXJ0IiwibWF4IiwiekFicyIsInNpZ21hIiwibWFwIiwiYWJzIiwidGFrZURlbnNlc3RLIiwiaGlzdCIsImsiLCJjZW50ZXJzIiwiZWRnZXMiLCJjb3VudHMiLCJwYWlycyIsImMiLCJpIiwiaWR4IiwiY291bnQiLCJjZW50ZXJSIiwic29ydCIsImIiLCJzbGljZSIsIm1pbiIsIndlaWdodGVkQ2VudGVyUiIsIl9oaXN0IiwidG9wIiwibWFzcyIsImxvZ1JldHVybnMiLCJwcmljZXMiLCJyIiwicHVzaCIsImxvZyIsImNvbXB1dGVTdGF0cyIsInBvaW50cyIsIm9wZW5pbmciLCJvcHRzIiwiZXBzR2ZtUGN0IiwiZXBzQmZtUGN0IiwidlNjYWxlIiwiV20iLCJmbG9vciIsIm1ldHJpY3NXaW4iLCJ0b3BLIiwiaWRociIsInAiLCJOdW1iZXIiLCJwcmljZSIsImZpbHRlciIsImlzRmluaXRlIiwib3BlbmluZ1B4IiwiYmVuY2htYXJrIiwiTmFOIiwib3BlbmluZ1ZhbCIsImxhc3QiLCJwcmV2IiwieiIsImlkaHJQb2ludHMiLCJ0cyIsInZvbHVtZSIsInBjdDI0aCIsImlkX3BjdCIsImxheW91dEhhc2giLCJiaW5zIiwiYWxwaGEiLCJzTWluIiwic21vb3RoIiwiYmluc0NvdW50IiwickNlbnRlciIsImdmbUFicyIsImV4cCIsInJlZkdmbUFicyIsImRlbHRhR2ZtQWJzIiwiZGVsdGFHZm1QY3QiLCJzaGlmdGVkR2ZtIiwick1pbiIsInJNYXgiLCJiZm0wMSIsInJlZkJmbTAxIiwiZGVsdGFCZm0wMSIsImRlbHRhQmZtUGN0Iiwic2hpZnRlZEJmbSIsInZlY3RvclN1bW1hcnkiLCJzY2FsZSIsImhpc3RvcnkiLCJpbm5lciIsImlubmVySGlzdFNjYWxlZCIsInRlbmRlbmN5IiwidGVuZGVuY3lIaXN0U2NhbGVkIiwidGVuZGVuY3lXaW5kb3ciLCJ0ZW5kZW5jeVdpbiIsInRlbmRlbmN5Tm9ybSIsInZJbm5lckFnZyIsInNjYWxlZCIsInZPdXRlckFnZyIsIm91dGVyIiwibWV0cmljcyIsInZTd2FwIiwic3dhcCIsInJXIiwiaW5lcnRpYSIsImFtcCIsInZvbHQiLCJlZmZpY2llbmN5Iiwid2luZG93IiwiUyIsImxhbWJkYSIsInRlbmRlbmN5RGlyZWN0aW9uIiwiZGlyZWN0aW9uIiwidGVuZGVuY3lTdHJlbmd0aCIsInN0cmVuZ3RoIiwidm9sdDAxIiwiYXJ0aWZpY2lhbGl0eTAxIiwidklubmVyIiwidk91dGVyIiwidmVjdG9ycyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/calc/stats.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/calc/tendency.ts":
/*!****************************************************!*\
  !*** ./src/core/features/str-aux/calc/tendency.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aggregateInnerNow: () => (/* binding */ aggregateInnerNow),\n/* harmony export */   vInner: () => (/* binding */ vInner),\n/* harmony export */   vInnerScaled: () => (/* binding */ vInnerScaled),\n/* harmony export */   vOuter: () => (/* binding */ vOuter),\n/* harmony export */   vOuterScaled: () => (/* binding */ vOuterScaled),\n/* harmony export */   vSwapFromNuclei: () => (/* binding */ vSwapFromNuclei),\n/* harmony export */   vSwapQuartiles: () => (/* binding */ vSwapQuartiles),\n/* harmony export */   vTendencyFromSeries: () => (/* binding */ vTendencyFromSeries)\n/* harmony export */ });\n// tendency.ts\n// IDHR/binning tendency vectors: vInner, vOuter, vTendency, vSwap (quartiles).\n// Scale convention: default S = 100; all public scores in [-S, +S]. No external deps.\n/* ----------------------------- Types & Helpers ---------------------------- */ const clamp = (x, lo, hi)=>Math.max(lo, Math.min(hi, x));\nconst tanh = (x)=>{\n    const e = Math.exp(2 * x);\n    return (e - 1) / (e + 1);\n};\nconst sum = (xs)=>xs.reduce((a, b)=>a + b, 0);\nconst mean = (xs)=>xs.length ? sum(xs) / xs.length : 0;\nfunction sortBy(arr, key) {\n    return arr.slice().sort((a, b)=>key(a) - key(b));\n}\n/** Weighted median of x with weights w (positive). Falls back to plain median if no weights. */ function wMedian(x, w) {\n    const n = x.length;\n    if (!n) return 0;\n    if (!w || w.length !== n) {\n        const xs = x.slice().sort((a, b)=>a - b);\n        const m = Math.floor(n / 2);\n        return n % 2 ? xs[m] : (xs[m - 1] + xs[m]) / 2;\n    }\n    const pairs = sortBy(x.map((xi, i)=>({\n            xi,\n            wi: Math.max(0, Number.isFinite(w[i]) ? w[i] : 0)\n        })), (p)=>p.xi);\n    const total = pairs.reduce((a, p)=>a + p.wi, 0);\n    if (total <= 0) return wMedian(x); // fallback to unweighted\n    let c = 0;\n    for(let i = 0; i < pairs.length; i++){\n        c += pairs[i].wi;\n        if (c >= total / 2) return pairs[i].xi;\n    }\n    return pairs[pairs.length - 1].xi;\n}\n/** Weighted MAD: median of |x - center|, with same weights. */ function wMAD(x, w, center) {\n    if (!x.length) return 0;\n    const c = center ?? wMedian(x, w);\n    const dev = x.map((xi)=>Math.abs(xi - c));\n    return wMedian(dev, w);\n}\nfunction quantile(sorted, p) {\n    if (!sorted.length) return 0;\n    const idx = (sorted.length - 1) * p;\n    const lo = Math.floor(idx);\n    const hi = Math.ceil(idx);\n    if (lo === hi) return sorted[lo];\n    const a = sorted[lo], b = sorted[hi];\n    return a + (b - a) * (idx - lo);\n}\n/**\r\n * vInner_k: per-bin skew of distribution.\r\n * 1) Normalize residuals by robust dispersion (MAD).\r\n * 2) Weighted mean residual -> tanh -> scaled to [-S, S].\r\n */ function vInner(nucleus, opts = {}) {\n    const S = opts.scale ?? 100;\n    const g = opts.gain ?? 1.0;\n    const x = nucleus.values ?? [];\n    const w = nucleus.weights && nucleus.weights.length === x.length ? nucleus.weights : undefined;\n    if (!x.length) return 0;\n    const c = opts.centerOverride ?? nucleus.center ?? wMedian(x, w);\n    const sigma = opts.sigmaOverride ?? wMAD(x, w, c);\n    const denom = sigma > 0 ? sigma : 1e-9;\n    // weighted mean of standardized residuals\n    let num = 0, den = 0;\n    for(let i = 0; i < x.length; i++){\n        const wi = w ? Math.max(0, w[i] || 0) : 1;\n        num += wi * ((x[i] - c) / denom);\n        den += wi;\n    }\n    const rbar = den > 0 ? num / den : 0;\n    return clamp(S * tanh(g * rbar), -S, S);\n}\n/**\r\n * vOuter: liquidity-weighted aggregation across bins.\r\n * If weights sum to 1 (shares), set normalize=false to respect them.\r\n */ function vOuter(nuclei, weights, opts = {}) {\n    const S = opts.scale ?? 100;\n    const g = opts.gain ?? 1.0;\n    const inners = nuclei.map((nu)=>vInner(nu, {\n            ...opts.inner,\n            scale: S\n        }));\n    const gammas = weights?.map((w)=>Number.isFinite(w?.gamma) ? w.gamma : 1) ?? Array(nuclei.length).fill(1);\n    if (!inners.length) return 0;\n    const sumG = sum(gammas);\n    const denom = opts.normalize === false ? 1 : sumG || inners.length;\n    let agg = 0;\n    for(let i = 0; i < inners.length; i++)agg += gammas[i] * (inners[i] / S);\n    const unitless = denom ? agg / denom : 0; // ~[-1..1]\n    return clamp(S * tanh(g * unitless), -S, S);\n}\n/* ---- optional scaled convenience (maps sign-preserving to ~[-1..1]) ---- */ function vInnerScaled(nucleus, opts = {}) {\n    const S = opts.scale ?? 100;\n    const v = vInner(nucleus, opts);\n    return clamp(v / S, -1, 1);\n}\nfunction vOuterScaled(nuclei, weights, opts = {}) {\n    const S = opts.scale ?? 100;\n    const v = vOuter(nuclei, weights, opts);\n    return clamp(v / S, -1, 1);\n}\n/**\r\n * vTendency over a stable series (typically vOuter_t).\r\n * Regress over last W points; normalize slope by MAD|y|.\r\n * Returns direction/strength/score in your envelope.\r\n */ function vTendencyFromSeries(series, opts = {}) {\n    const W = Math.max(3, Math.floor(opts.window ?? 30));\n    const S = opts.scale ?? 100;\n    const k = opts.k ?? 1.1;\n    const norm = opts.normalizer ?? \"mad\";\n    if (!series?.length || series.length < 2) {\n        return {\n            direction: 0,\n            strength: 0,\n            slope: 0,\n            r: 0,\n            score: 0\n        };\n    }\n    const start = Math.max(0, series.length - W);\n    const y = series.slice(start); // length m\n    // linreg on index 0..m-1\n    const m = y.length;\n    let sx = 0, sy = 0, sxx = 0, sxy = 0, syy = 0;\n    for(let i = 0; i < m; i++){\n        const xi = i, yi = y[i];\n        sx += xi;\n        sy += yi;\n        sxx += xi * xi;\n        sxy += xi * yi;\n        syy += yi * yi;\n    }\n    const num = m * sxy - sx * sy;\n    const den = m * sxx - sx * sx;\n    const slope = den === 0 ? 0 : num / den;\n    const rden = Math.sqrt((m * sxx - sx * sx) * (m * syy - sy * sy));\n    const r = rden === 0 ? 0 : num / rden;\n    // dispersion of first differences\n    const diffs = [];\n    for(let i = 1; i < y.length; i++)diffs.push(y[i] - y[i - 1]);\n    let D = 0;\n    if (norm === \"mad\") {\n        const med = wMedian(diffs);\n        const absdev = diffs.map((d)=>Math.abs(d - med));\n        D = wMedian(absdev);\n    } else {\n        const mu = mean(diffs);\n        const varsum = diffs.reduce((a, d)=>a + (d - mu) * (d - mu), 0);\n        D = diffs.length > 1 ? Math.sqrt(varsum / (diffs.length - 1)) : 0;\n    }\n    const z = D > 0 ? slope / D : 0;\n    const direction = tanh(k * z); // [-1..1]\n    const strength = Math.min(1, Math.max(0, Math.abs(r)));\n    const score = clamp(direction * S, -S, S);\n    return {\n        direction,\n        strength,\n        slope,\n        r,\n        score\n    };\n}\n/* --------------------------------- vSwap ---------------------------------- */ /**\r\n * vSwap (quartile-conditioned, non-parametric):\r\n * Compare average inner in top vs bottom quartile of tendency over a window.\r\n *\r\n * Inputs:\r\n *  - innerHistScaled: history of aggregate inner (scaled in [-S,S]) for last H ticks\r\n *  - tendencyHistScaled: matching history of vTendency (scaled in [-S,S]) for last H ticks\r\n *  - scale S and softness alpha for final tanh\r\n *\r\n * Steps:\r\n *  1) Convert both to unitless [-1..1] by dividing by S.\r\n *  2) Find Q1/Q3 of tendency; compute mean(inner) where T<=Q1 and where T>=Q3.\r\n *  3) Q = (mean_top - mean_bottom)/2 in [-1,1].\r\n *  4) vSwap = S * tanh(alpha * Q).\r\n */ function vSwapQuartiles(innerHistScaled, tendencyHistScaled, opts = {}) {\n    const S = opts.scale ?? 100;\n    const alpha = opts.alpha ?? 1.2;\n    const n = Math.min(innerHistScaled.length, tendencyHistScaled.length);\n    if (n < 4) return {\n        Q: 0,\n        score: 0,\n        q1: 0,\n        q3: 0\n    };\n    // unitless series in [-1..1]\n    const I = innerHistScaled.slice(-n).map((v)=>S ? v / S : v);\n    const T = tendencyHistScaled.slice(-n).map((v)=>S ? v / S : v);\n    // compute Q1, Q3 of T\n    const sortedT = T.slice().sort((a, b)=>a - b);\n    const q1 = quantile(sortedT, 0.25);\n    const q3 = quantile(sortedT, 0.75);\n    // means in tails\n    const bot = [];\n    const top = [];\n    for(let i = 0; i < n; i++){\n        if (T[i] <= q1) bot.push(I[i]);\n        else if (T[i] >= q3) top.push(I[i]);\n    }\n    const meanTop = top.length ? mean(top) : 0;\n    const meanBot = bot.length ? mean(bot) : 0;\n    const Q = clamp((meanTop - meanBot) / 2, -1, 1); // [-1,1]\n    const score = clamp(S * tanh(alpha * Q), -S, S);\n    return {\n        Q,\n        score,\n        q1,\n        q3\n    };\n}\n/**\r\n * vSwapFromNuclei (optional side-of-mass view):\r\n * Compare total mass right-vs-left of center across nuclei (bins).\r\n * Returns score in [-S, S].\r\n */ function vSwapFromNuclei(nuclei, bins, opts = {}) {\n    const S = opts.scale ?? 100;\n    const alpha = opts.alpha ?? 1.0;\n    if (!nuclei?.length || bins <= 0) return 0;\n    const mid = (bins - 1) / 2;\n    let left = 0, right = 0;\n    for(let b = 0; b < nuclei.length; b++){\n        const nu = nuclei[b];\n        const w = nu.weights && nu.weights.length === nu.values.length ? nu.weights : undefined;\n        // treat each sample in this nucleus as unit mass (or weighted)\n        for(let i = 0; i < nu.values.length; i++){\n            // map index within the nucleus to its global bin index b\n            // if you keep per-sample bin index, adapt as needed; for now use bin b\n            const wi = w ? Math.max(0, w[i] || 0) : 1;\n            if (b < mid) left += wi;\n            else if (b > mid) right += wi;\n            else {\n                left += wi / 2;\n                right += wi / 2;\n            }\n        }\n    }\n    const s = Math.abs(left) + Math.abs(right);\n    if (!s) return 0;\n    const unitless = (right - left) / s; // [-1,1]\n    return clamp(S * tanh(alpha * unitless), -S, S);\n}\n/* --------------------------- Aggregate inner now -------------------------- */ /**\r\n * Helper to get the aggregate inner (unitless & scaled) at a single tick,\r\n * from the current nuclei & optional bin shares.\r\n */ function aggregateInnerNow(nuclei, weights, innerOpts, scale = 100) {\n    const S = scale;\n    const inners = nuclei.map((nu)=>vInner(nu, {\n            ...innerOpts,\n            scale: S\n        }));\n    const gammas = weights?.map((w)=>Number.isFinite(w?.gamma) ? w.gamma : 1) ?? Array(nuclei.length).fill(1);\n    const sumG = sum(gammas) || inners.length || 1;\n    const u = inners.reduce((a, v, i)=>a + gammas[i] * (v / S), 0) / sumG;\n    return {\n        unitless: u,\n        scaled: clamp(S * u, -S, S)\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L2NhbGMvdGVuZGVuY3kudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxjQUFjO0FBQ2QsK0VBQStFO0FBQy9FLHNGQUFzRjtBQUV0Riw4RUFBOEUsR0FrQjlFLE1BQU1BLFFBQVEsQ0FBQ0MsR0FBV0MsSUFBWUMsS0FBZUMsS0FBS0MsR0FBRyxDQUFDSCxJQUFJRSxLQUFLRSxHQUFHLENBQUNILElBQUlGO0FBRS9FLE1BQU1NLE9BQU8sQ0FBQ047SUFDWixNQUFNTyxJQUFJSixLQUFLSyxHQUFHLENBQUMsSUFBSVI7SUFDdkIsT0FBTyxDQUFDTyxJQUFJLEtBQU1BLENBQUFBLElBQUk7QUFDeEI7QUFFQSxNQUFNRSxNQUFPLENBQUNDLEtBQWlCQSxHQUFHQyxNQUFNLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsSUFBSUMsR0FBRztBQUMxRCxNQUFNQyxPQUFPLENBQUNKLEtBQWtCQSxHQUFHSyxNQUFNLEdBQUdOLElBQUlDLE1BQU1BLEdBQUdLLE1BQU0sR0FBRztBQUVsRSxTQUFTQyxPQUFVQyxHQUFRLEVBQUVDLEdBQXFCO0lBQ2hELE9BQU9ELElBQUlFLEtBQUssR0FBR0MsSUFBSSxDQUFDLENBQUNSLEdBQUdDLElBQU1LLElBQUlOLEtBQUtNLElBQUlMO0FBQ2pEO0FBRUEsOEZBQThGLEdBQzlGLFNBQVNRLFFBQVFyQixDQUFXLEVBQUVzQixDQUFZO0lBQ3hDLE1BQU1DLElBQUl2QixFQUFFZSxNQUFNO0lBQ2xCLElBQUksQ0FBQ1EsR0FBRyxPQUFPO0lBQ2YsSUFBSSxDQUFDRCxLQUFLQSxFQUFFUCxNQUFNLEtBQUtRLEdBQUc7UUFDeEIsTUFBTWIsS0FBS1YsRUFBRW1CLEtBQUssR0FBR0MsSUFBSSxDQUFDLENBQUNSLEdBQUdDLElBQU1ELElBQUlDO1FBQ3hDLE1BQU1XLElBQUlyQixLQUFLc0IsS0FBSyxDQUFDRixJQUFJO1FBQ3pCLE9BQU9BLElBQUksSUFBSWIsRUFBRSxDQUFDYyxF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OUMsT0FBT2hJLE1BQU1nRCxJQUFJekMsS0FBS3lHLFFBQVF0QyxXQUFXLENBQUMxQixHQUFHQTtBQUMvQztBQUVBLDhFQUE4RSxHQUM5RTs7O0NBR0MsR0FDTSxTQUFTaUYsa0JBQ2RsRSxNQUFpQixFQUNqQlYsT0FBMEIsRUFDMUI2RSxTQUFzQixFQUN0QmpGLFFBQWdCLEdBQUc7SUFFbkIsTUFBTUQsSUFBWUM7SUFDbEIsTUFBTWUsU0FBU0QsT0FBT25DLEdBQUcsQ0FBQyxDQUFDcUMsS0FBT3BCLE9BQU9vQixJQUFJO1lBQUUsR0FBR2lFLFNBQVM7WUFBRWpGLE9BQU9EO1FBQUU7SUFDdEUsTUFBTW1CLFNBQVNkLFNBQVN6QixJQUFJLENBQUNMLElBQU9TLE9BQU9DLFFBQVEsQ0FBQ1YsR0FBRzZDLFNBQW9CN0MsRUFBRzZDLEtBQUssR0FBYyxNQUM1RkMsTUFBTU4sT0FBTy9DLE1BQU0sRUFBRXNELElBQUksQ0FBQztJQUMvQixNQUFNQyxPQUFPN0QsSUFBSXlELFdBQVdILE9BQU9oRCxNQUFNLElBQUk7SUFDN0MsTUFBTW1ILElBQUluRSxPQUFPcEQsTUFBTSxDQUFDLENBQUNDLEdBQUcrRCxHQUFHOUMsSUFBTWpCLElBQUtzRCxNQUFNLENBQUNyQyxFQUFFLEdBQUk4QyxDQUFBQSxJQUFJNUIsQ0FBQUEsR0FBSyxLQUFLdUI7SUFDckUsT0FBTztRQUFFRyxVQUFVeUQ7UUFBR0MsUUFBUXBJLE1BQU1nRCxJQUFJbUYsR0FBRyxDQUFDbkYsR0FBR0E7SUFBRztBQUNwRCIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGNvcmVcXGZlYXR1cmVzXFxzdHItYXV4XFxjYWxjXFx0ZW5kZW5jeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0ZW5kZW5jeS50c1xyXG4vLyBJREhSL2Jpbm5pbmcgdGVuZGVuY3kgdmVjdG9yczogdklubmVyLCB2T3V0ZXIsIHZUZW5kZW5jeSwgdlN3YXAgKHF1YXJ0aWxlcykuXHJcbi8vIFNjYWxlIGNvbnZlbnRpb246IGRlZmF1bHQgUyA9IDEwMDsgYWxsIHB1YmxpYyBzY29yZXMgaW4gWy1TLCArU10uIE5vIGV4dGVybmFsIGRlcHMuXHJcblxyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBUeXBlcyAmIEhlbHBlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuZXhwb3J0IHR5cGUgU2NhbGUgPSBudW1iZXI7IC8vIGFjY2VwdCBhbnkgbnVtZXJpYyBzY2FsZTsgZGVmYXVsdCAxMDBcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTnVjbGV1cyB7XHJcbiAgLy8gQmluIHNhbXBsZXMgKGUuZy4sIG5vcm1hbGl6ZWQgcHJpY2Ugb2Zmc2V0cykuXHJcbiAgdmFsdWVzOiBudW1iZXJbXTtcclxuICAvLyBPcHRpb25hbCBwZXItc2FtcGxlIHdlaWdodHMgKGxpcXVpZGl0eS92b2x1bWUvdGltZSkuIE11c3QgbWF0Y2ggdmFsdWVzLmxlbmd0aCBpZiBwcm92aWRlZC5cclxuICB3ZWlnaHRzPzogbnVtYmVyW107XHJcbiAgLy8gT3B0aW9uYWwgcHJlY29tcHV0ZWQgY2VudGVyIG9mIHRoZSBiaW4gKGVsc2UgY29tcHV0ZWQgYXMgd2VpZ2h0ZWQgbWVkaWFuKS5cclxuICBjZW50ZXI/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29tcG9zZVdlaWdodHMge1xyXG4gIC8vIEJpbi1sZXZlbCB3ZWlnaHQgKGUuZy4sIGxpcXVpZGl0eSBzaGFyZSkuIElmIG5vdCBwcm92aWRlZCwgdHJlYXRlZCBhcyAxLlxyXG4gIGdhbW1hPzogbnVtYmVyO1xyXG59XHJcblxyXG5jb25zdCBjbGFtcCA9ICh4OiBudW1iZXIsIGxvOiBudW1iZXIsIGhpOiBudW1iZXIpID0+IE1hdGgubWF4KGxvLCBNYXRoLm1pbihoaSwgeCkpO1xyXG5cclxuY29uc3QgdGFuaCA9ICh4OiBudW1iZXIpID0+IHtcclxuICBjb25zdCBlID0gTWF0aC5leHAoMiAqIHgpO1xyXG4gIHJldHVybiAoZSAtIDEpIC8gKGUgKyAxKTtcclxufTtcclxuXHJcbmNvbnN0IHN1bSAgPSAoeHM6IG51bWJlcltdKSA9PiB4cy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcclxuY29uc3QgbWVhbiA9ICh4czogbnVtYmVyW10pID0+ICh4cy5sZW5ndGggPyBzdW0oeHMpIC8geHMubGVuZ3RoIDogMCk7XHJcblxyXG5mdW5jdGlvbiBzb3J0Qnk8VD4oYXJyOiBUW10sIGtleTogKHQ6IFQpID0+IG51bWJlcik6IFRbXSB7XHJcbiAgcmV0dXJuIGFyci5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGtleShhKSAtIGtleShiKSk7XHJcbn1cclxuXHJcbi8qKiBXZWlnaHRlZCBtZWRpYW4gb2YgeCB3aXRoIHdlaWdodHMgdyAocG9zaXRpdmUpLiBGYWxscyBiYWNrIHRvIHBsYWluIG1lZGlhbiBpZiBubyB3ZWlnaHRzLiAqL1xyXG5mdW5jdGlvbiB3TWVkaWFuKHg6IG51bWJlcltdLCB3PzogbnVtYmVyW10pOiBudW1iZXIge1xyXG4gIGNvbnN0IG4gPSB4Lmxlbmd0aDtcclxuICBpZiAoIW4pIHJldHVybiAwO1xyXG4gIGlmICghdyB8fCB3Lmxlbmd0aCAhPT0gbikge1xyXG4gICAgY29uc3QgeHMgPSB4LnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG4gICAgY29uc3QgbSA9IE1hdGguZmxvb3IobiAvIDIpO1xyXG4gICAgcmV0dXJuIG4gJSAyID8geHNbbV0gOiAoeHNbbSAtIDFdICsgeHNbbV0pIC8gMjtcclxuICB9XHJcbiAgY29uc3QgcGFpcnMgPSBzb3J0QnkoXHJcbiAgICB4Lm1hcCgoeGksIGkpID0+ICh7IHhpLCB3aTogTWF0aC5tYXgoMCwgTnVtYmVyLmlzRmluaXRlKHdbaV0hKSA/IHdbaV0hIDogMCkgfSkpLFxyXG4gICAgKHApID0+IHAueGlcclxuICApO1xyXG4gIGNvbnN0IHRvdGFsID0gcGFpcnMucmVkdWNlKChhLCBwKSA9PiBhICsgcC53aSwgMCk7XHJcbiAgaWYgKHRvdGFsIDw9IDApIHJldHVybiB3TWVkaWFuKHgpOyAvLyBmYWxsYmFjayB0byB1bndlaWdodGVkXHJcbiAgbGV0IGMgPSAwO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcclxuICAgIGMgKz0gcGFpcnNbaV0ud2k7XHJcbiAgICBpZiAoYyA+PSB0b3RhbCAvIDIpIHJldHVybiBwYWlyc1tpXS54aTtcclxuICB9XHJcbiAgcmV0dXJuIHBhaXJzW3BhaXJzLmxlbmd0aCAtIDFdLnhpO1xyXG59XHJcblxyXG4vKiogV2VpZ2h0ZWQgTUFEOiBtZWRpYW4gb2YgfHggLSBjZW50ZXJ8LCB3aXRoIHNhbWUgd2VpZ2h0cy4gKi9cclxuZnVuY3Rpb24gd01BRCh4OiBudW1iZXJbXSwgdz86IG51bWJlcltdLCBjZW50ZXI/OiBudW1iZXIpOiBudW1iZXIge1xyXG4gIGlmICgheC5sZW5ndGgpIHJldHVybiAwO1xyXG4gIGNvbnN0IGMgPSBjZW50ZXIgPz8gd01lZGlhbih4LCB3KTtcclxuICBjb25zdCBkZXYgPSB4Lm1hcCgoeGkpID0+IE1hdGguYWJzKHhpIC0gYykpO1xyXG4gIHJldHVybiB3TWVkaWFuKGRldiwgdyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHF1YW50aWxlKHNvcnRlZDogbnVtYmVyW10sIHA6IG51bWJlcik6IG51bWJlciB7XHJcbiAgaWYgKCFzb3J0ZWQubGVuZ3RoKSByZXR1cm4gMDtcclxuICBjb25zdCBpZHggPSAoc29ydGVkLmxlbmd0aCAtIDEpICogcDtcclxuICBjb25zdCBsbyA9IE1hdGguZmxvb3IoaWR4KTtcclxuICBjb25zdCBoaSA9IE1hdGguY2VpbChpZHgpO1xyXG4gIGlmIChsbyA9PT0gaGkpIHJldHVybiBzb3J0ZWRbbG9dO1xyXG4gIGNvbnN0IGEgPSBzb3J0ZWRbbG9dLCBiID0gc29ydGVkW2hpXTtcclxuICByZXR1cm4gYSArIChiIC0gYSkgKiAoaWR4IC0gbG8pO1xyXG59XHJcblxyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB2SW5uZXIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBWSW5uZXJPcHRzIHtcclxuICAvLyBHYWluIGJlZm9yZSB0YW5oIChzZW5zaXRpdml0eSkuXHJcbiAgZ2Fpbj86IG51bWJlcjsgLy8gZGVmYXVsdCAxLjBcclxuICAvLyBPdXRwdXQgc2NhbGUgZW52ZWxvcGUuXHJcbiAgc2NhbGU/OiBudW1iZXI7IC8vIGRlZmF1bHQgMTAwXHJcbiAgLy8gSWYgcHJvdmlkZWQsIHVzZSB0aGlzIGRpc3BlcnNpb24gaW5zdGVhZCBvZiBNQUQuXHJcbiAgc2lnbWFPdmVycmlkZT86IG51bWJlcjtcclxuICAvLyBJZiBwcm92aWRlZCwgdXNlIHRoaXMgY2VudGVyIGluc3RlYWQgb2Ygd2VpZ2h0ZWQgbWVkaWFuLlxyXG4gIGNlbnRlck92ZXJyaWRlPzogbnVtYmVyO1xyXG59XHJcblxyXG4vKipcclxuICogdklubmVyX2s6IHBlci1iaW4gc2tldyBvZiBkaXN0cmlidXRpb24uXHJcbiAqIDEpIE5vcm1hbGl6ZSByZXNpZHVhbHMgYnkgcm9idXN0IGRpc3BlcnNpb24gKE1BRCkuXHJcbiAqIDIpIFdlaWdodGVkIG1lYW4gcmVzaWR1YWwgLT4gdGFuaCAtPiBzY2FsZWQgdG8gWy1TLCBTXS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB2SW5uZXIobnVjbGV1czogTnVjbGV1cywgb3B0czogVklubmVyT3B0cyA9IHt9KTogbnVtYmVyIHtcclxuICBjb25zdCBTOiBudW1iZXIgPSBvcHRzLnNjYWxlID8/IDEwMDtcclxuICBjb25zdCBnOiBudW1iZXIgPSBvcHRzLmdhaW4gPz8gMS4wO1xyXG4gIGNvbnN0IHggPSBudWNsZXVzLnZhbHVlcyA/PyBbXTtcclxuICBjb25zdCB3ID0gbnVjbGV1cy53ZWlnaHRzICYmIG51Y2xldXMud2VpZ2h0cy5sZW5ndGggPT09IHgubGVuZ3RoID8gbnVjbGV1cy53ZWlnaHRzIDogdW5kZWZpbmVkO1xyXG4gIGlmICgheC5sZW5ndGgpIHJldHVybiAwO1xyXG5cclxuICBjb25zdCBjID0gb3B0cy5jZW50ZXJPdmVycmlkZSA/PyBudWNsZXVzLmNlbnRlciA/PyB3TWVkaWFuKHgsIHcpO1xyXG4gIGNvbnN0IHNpZ21hID0gb3B0cy5zaWdtYU92ZXJyaWRlID8/IHdNQUQoeCwgdywgYyk7XHJcbiAgY29uc3QgZGVub20gPSBzaWdtYSA+IDAgPyBzaWdtYSA6IDFlLTk7XHJcblxyXG4gIC8vIHdlaWdodGVkIG1lYW4gb2Ygc3RhbmRhcmRpemVkIHJlc2lkdWFsc1xyXG4gIGxldCBudW0gPSAwLCBkZW4gPSAwO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3Qgd2kgPSB3ID8gTWF0aC5tYXgoMCwgd1tpXSB8fCAwKSA6IDE7XHJcbiAgICBudW0gKz0gd2kgKiAoKHhbaV0gLSBjKSAvIGRlbm9tKTtcclxuICAgIGRlbiArPSB3aTtcclxuICB9XHJcbiAgY29uc3QgcmJhciA9IGRlbiA+IDAgPyBudW0gLyBkZW4gOiAwO1xyXG4gIHJldHVybiBjbGFtcChTICogdGFuaChnICogcmJhciksIC1TLCBTKTtcclxufVxyXG5cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gdk91dGVyIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVk91dGVyT3B0cyB7XHJcbiAgLy8gU2NhbGUgZW52ZWxvcGUgZm9yIG91dHB1dCAowrEpLlxyXG4gIHNjYWxlPzogbnVtYmVyOyAvLyBkZWZhdWx0IDEwMFxyXG4gIC8vIE5vbmxpbmVhcml0eSBnYWluIGJlZm9yZSB0YW5oLlxyXG4gIGdhaW4/OiBudW1iZXI7IC8vIGRlZmF1bHQgMS4wXHJcbiAgLy8gSWYgdHJ1ZSAoZGVmYXVsdCksIG5vcm1hbGl6ZSBvdXRlciBieSBzdW0gb2YgZ2FtbWFzIG9yIE4gaWYgbm9uZSBwcm92aWRlZC5cclxuICBub3JtYWxpemU/OiBib29sZWFuOyAvLyBkZWZhdWx0IHRydWVcclxuICAvLyBSZXVzZSB2SW5uZXIgb3B0aW9ucyBmb3IgZWFjaCBiaW4gKGUuZy4sIHNhbWUgZ2Fpbi9zY2FsZSkuXHJcbiAgaW5uZXI/OiBWSW5uZXJPcHRzO1xyXG59XHJcblxyXG4vKipcclxuICogdk91dGVyOiBsaXF1aWRpdHktd2VpZ2h0ZWQgYWdncmVnYXRpb24gYWNyb3NzIGJpbnMuXHJcbiAqIElmIHdlaWdodHMgc3VtIHRvIDEgKHNoYXJlcyksIHNldCBub3JtYWxpemU9ZmFsc2UgdG8gcmVzcGVjdCB0aGVtLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZPdXRlcihudWNsZWk6IE51Y2xldXNbXSwgd2VpZ2h0cz86IENvbXBvc2VXZWlnaHRzW10sIG9wdHM6IFZPdXRlck9wdHMgPSB7fSk6IG51bWJlciB7XHJcbiAgY29uc3QgUzogbnVtYmVyID0gb3B0cy5zY2FsZSA/PyAxMDA7XHJcbiAgY29uc3QgZzogbnVtYmVyID0gb3B0cy5nYWluID8/IDEuMDtcclxuICBjb25zdCBpbm5lcnMgPSBudWNsZWkubWFwKChudSkgPT4gdklubmVyKG51LCB7IC4uLm9wdHMuaW5uZXIsIHNjYWxlOiBTIH0pKTtcclxuICBjb25zdCBnYW1tYXMgPSB3ZWlnaHRzPy5tYXAoKHcpID0+IChOdW1iZXIuaXNGaW5pdGUodz8uZ2FtbWEgYXMgbnVtYmVyKSA/ICh3IS5nYW1tYSBhcyBudW1iZXIpIDogMSkpXHJcbiAgICA/PyBBcnJheShudWNsZWkubGVuZ3RoKS5maWxsKDEpO1xyXG4gIGlmICghaW5uZXJzLmxlbmd0aCkgcmV0dXJuIDA7XHJcblxyXG4gIGNvbnN0IHN1bUcgPSBzdW0oZ2FtbWFzKTtcclxuICBjb25zdCBkZW5vbSA9IG9wdHMubm9ybWFsaXplID09PSBmYWxzZSA/IDEgOiAoc3VtRyB8fCBpbm5lcnMubGVuZ3RoKTtcclxuICBsZXQgYWdnID0gMDtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlubmVycy5sZW5ndGg7IGkrKykgYWdnICs9IGdhbW1hc1tpXSAqIChpbm5lcnNbaV0gLyBTKTtcclxuICBjb25zdCB1bml0bGVzcyA9IGRlbm9tID8gYWdnIC8gZGVub20gOiAwOyAvLyB+Wy0xLi4xXVxyXG4gIHJldHVybiBjbGFtcChTICogdGFuaChnICogdW5pdGxlc3MpLCAtUywgUyk7XHJcbn1cclxuXHJcbi8qIC0tLS0gb3B0aW9uYWwg4oCcc2NhbGVk4oCdIGNvbnZlbmllbmNlIChtYXBzIHNpZ24tcHJlc2VydmluZyB0byB+Wy0xLi4xXSkgLS0tLSAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHZJbm5lclNjYWxlZChudWNsZXVzOiBOdWNsZXVzLCBvcHRzOiBWSW5uZXJPcHRzID0ge30pOiBudW1iZXIge1xyXG4gIGNvbnN0IFMgPSBvcHRzLnNjYWxlID8/IDEwMDtcclxuICBjb25zdCB2ID0gdklubmVyKG51Y2xldXMsIG9wdHMpO1xyXG4gIHJldHVybiBjbGFtcCh2IC8gUywgLTEsIDEpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB2T3V0ZXJTY2FsZWQobnVjbGVpOiBOdWNsZXVzW10sIHdlaWdodHM/OiBDb21wb3NlV2VpZ2h0c1tdLCBvcHRzOiBWT3V0ZXJPcHRzID0ge30pOiBudW1iZXIge1xyXG4gIGNvbnN0IFMgPSBvcHRzLnNjYWxlID8/IDEwMDtcclxuICBjb25zdCB2ID0gdk91dGVyKG51Y2xlaSwgd2VpZ2h0cywgb3B0cyk7XHJcbiAgcmV0dXJuIGNsYW1wKHYgLyBTLCAtMSwgMSk7XHJcbn1cclxuXHJcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gdlRlbmRlbmN5IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFZUZW5kZW5jeU9wdHMge1xyXG4gIC8vIFdpbmRvdyBsZW5ndGggaW4gdGlja3Mvc3RlcHMgKGUuZy4sIDIw4oCTNjApLlxyXG4gIHdpbmRvdz86IG51bWJlcjsgLy8gZGVmYXVsdCAzMFxyXG4gIC8vIFNjYWxlIGVudmVsb3BlICjCsSkuXHJcbiAgc2NhbGU/OiBudW1iZXI7IC8vIGRlZmF1bHQgMTAwXHJcbiAgLy8gU2xvcGUgZ2FpbiBpbnNpZGUgdGFuaC5cclxuICBrPzogbnVtYmVyOyAvLyBkZWZhdWx0IDEuMVxyXG4gIC8vIE5vcm1hbGl6ZXIgZm9yIHNsb3BlIGRpc3BlcnNpb24gKE1BRCBvZiBmaXJzdCBkaWZmZXJlbmNlcyBvciBzdGRldikuXHJcbiAgbm9ybWFsaXplcj86IFwibWFkXCIgfCBcInN0ZGV2XCI7IC8vIGRlZmF1bHQgXCJtYWRcIlxyXG59XHJcblxyXG4vKipcclxuICogdlRlbmRlbmN5IG92ZXIgYSBzdGFibGUgc2VyaWVzICh0eXBpY2FsbHkgdk91dGVyX3QpLlxyXG4gKiBSZWdyZXNzIG92ZXIgbGFzdCBXIHBvaW50czsgbm9ybWFsaXplIHNsb3BlIGJ5IE1BRHzOlHl8LlxyXG4gKiBSZXR1cm5zIGRpcmVjdGlvbi9zdHJlbmd0aC9zY29yZSBpbiB5b3VyIGVudmVsb3BlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZUZW5kZW5jeUZyb21TZXJpZXMoXHJcbiAgc2VyaWVzOiBudW1iZXJbXSxcclxuICBvcHRzOiBWVGVuZGVuY3lPcHRzID0ge31cclxuKTogeyBkaXJlY3Rpb246IG51bWJlcjsgc3RyZW5ndGg6IG51bWJlcjsgc2xvcGU6IG51bWJlcjsgcjogbnVtYmVyOyBzY29yZTogbnVtYmVyIH0ge1xyXG4gIGNvbnN0IFc6IG51bWJlciA9IE1hdGgubWF4KDMsIE1hdGguZmxvb3Iob3B0cy53aW5kb3cgPz8gMzApKTtcclxuICBjb25zdCBTOiBudW1iZXIgPSBvcHRzLnNjYWxlID8/IDEwMDtcclxuICBjb25zdCBrOiBudW1iZXIgPSBvcHRzLmsgPz8gMS4xO1xyXG4gIGNvbnN0IG5vcm0gPSBvcHRzLm5vcm1hbGl6ZXIgPz8gXCJtYWRcIjtcclxuXHJcbiAgaWYgKCFzZXJpZXM/Lmxlbmd0aCB8fCBzZXJpZXMubGVuZ3RoIDwgMikge1xyXG4gICAgcmV0dXJuIHsgZGlyZWN0aW9uOiAwLCBzdHJlbmd0aDogMCwgc2xvcGU6IDAsIHI6IDAsIHNjb3JlOiAwIH07XHJcbiAgfVxyXG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgc2VyaWVzLmxlbmd0aCAtIFcpO1xyXG4gIGNvbnN0IHkgPSBzZXJpZXMuc2xpY2Uoc3RhcnQpOyAvLyBsZW5ndGggbVxyXG5cclxuICAvLyBsaW5yZWcgb24gaW5kZXggMC4ubS0xXHJcbiAgY29uc3QgbSA9IHkubGVuZ3RoO1xyXG4gIGxldCBzeCA9IDAsIHN5ID0gMCwgc3h4ID0gMCwgc3h5ID0gMCwgc3l5ID0gMDtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xyXG4gICAgY29uc3QgeGkgPSBpLCB5aSA9IHlbaV07XHJcbiAgICBzeCArPSB4aTsgc3kgKz0geWk7IHN4eCArPSB4aSAqIHhpOyBzeHkgKz0geGkgKiB5aTsgc3l5ICs9IHlpICogeWk7XHJcbiAgfVxyXG4gIGNvbnN0IG51bSA9IG0gKiBzeHkgLSBzeCAqIHN5O1xyXG4gIGNvbnN0IGRlbiA9IG0gKiBzeHggLSBzeCAqIHN4O1xyXG4gIGNvbnN0IHNsb3BlID0gZGVuID09PSAwID8gMCA6IG51bSAvIGRlbjtcclxuICBjb25zdCByZGVuID0gTWF0aC5zcXJ0KChtICogc3h4IC0gc3ggKiBzeCkgKiAobSAqIHN5eSAtIHN5ICogc3kpKTtcclxuICBjb25zdCByID0gcmRlbiA9PT0gMCA/IDAgOiBudW0gLyByZGVuO1xyXG5cclxuICAvLyBkaXNwZXJzaW9uIG9mIGZpcnN0IGRpZmZlcmVuY2VzXHJcbiAgY29uc3QgZGlmZnM6IG51bWJlcltdID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCB5Lmxlbmd0aDsgaSsrKSBkaWZmcy5wdXNoKHlbaV0gLSB5W2kgLSAxXSk7XHJcblxyXG4gIGxldCBEID0gMDtcclxuICBpZiAobm9ybSA9PT0gXCJtYWRcIikge1xyXG4gICAgY29uc3QgbWVkID0gd01lZGlhbihkaWZmcyk7XHJcbiAgICBjb25zdCBhYnNkZXYgPSBkaWZmcy5tYXAoKGQpID0+IE1hdGguYWJzKGQgLSBtZWQpKTtcclxuICAgIEQgPSB3TWVkaWFuKGFic2Rldik7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IG11ID0gbWVhbihkaWZmcyk7XHJcbiAgICBjb25zdCB2YXJzdW0gPSBkaWZmcy5yZWR1Y2UoKGEsIGQpID0+IGEgKyAoZCAtIG11KSAqIChkIC0gbXUpLCAwKTtcclxuICAgIEQgPSBkaWZmcy5sZW5ndGggPiAxID8gTWF0aC5zcXJ0KHZhcnN1bSAvIChkaWZmcy5sZW5ndGggLSAxKSkgOiAwO1xyXG4gIH1cclxuICBjb25zdCB6ID0gRCA+IDAgPyBzbG9wZSAvIEQgOiAwO1xyXG5cclxuICBjb25zdCBkaXJlY3Rpb24gPSB0YW5oKGsgKiB6KTsgLy8gWy0xLi4xXVxyXG4gIGNvbnN0IHN0cmVuZ3RoID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgTWF0aC5hYnMocikpKTtcclxuICBjb25zdCBzY29yZSA9IGNsYW1wKGRpcmVjdGlvbiAqIFMsIC1TLCBTKTtcclxuICByZXR1cm4geyBkaXJlY3Rpb24sIHN0cmVuZ3RoLCBzbG9wZSwgciwgc2NvcmUgfTtcclxufVxyXG5cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHZTd2FwIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuLyoqXHJcbiAqIHZTd2FwIChxdWFydGlsZS1jb25kaXRpb25lZCwgbm9uLXBhcmFtZXRyaWMpOlxyXG4gKiBDb21wYXJlIGF2ZXJhZ2UgaW5uZXIgaW4gdG9wIHZzIGJvdHRvbSBxdWFydGlsZSBvZiB0ZW5kZW5jeSBvdmVyIGEgd2luZG93LlxyXG4gKlxyXG4gKiBJbnB1dHM6XHJcbiAqICAtIGlubmVySGlzdFNjYWxlZDogaGlzdG9yeSBvZiBhZ2dyZWdhdGUgaW5uZXIgKHNjYWxlZCBpbiBbLVMsU10pIGZvciBsYXN0IEggdGlja3NcclxuICogIC0gdGVuZGVuY3lIaXN0U2NhbGVkOiBtYXRjaGluZyBoaXN0b3J5IG9mIHZUZW5kZW5jeSAoc2NhbGVkIGluIFstUyxTXSkgZm9yIGxhc3QgSCB0aWNrc1xyXG4gKiAgLSBzY2FsZSBTIGFuZCBzb2Z0bmVzcyBhbHBoYSBmb3IgZmluYWwgdGFuaFxyXG4gKlxyXG4gKiBTdGVwczpcclxuICogIDEpIENvbnZlcnQgYm90aCB0byB1bml0bGVzcyBbLTEuLjFdIGJ5IGRpdmlkaW5nIGJ5IFMuXHJcbiAqICAyKSBGaW5kIFExL1EzIG9mIHRlbmRlbmN5OyBjb21wdXRlIG1lYW4oaW5uZXIpIHdoZXJlIFQ8PVExIGFuZCB3aGVyZSBUPj1RMy5cclxuICogIDMpIFEgPSAobWVhbl90b3AgLSBtZWFuX2JvdHRvbSkvMiBpbiBbLTEsMV0uXHJcbiAqICA0KSB2U3dhcCA9IFMgKiB0YW5oKGFscGhhICogUSkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdlN3YXBRdWFydGlsZXMoXHJcbiAgaW5uZXJIaXN0U2NhbGVkOiBudW1iZXJbXSxcclxuICB0ZW5kZW5jeUhpc3RTY2FsZWQ6IG51bWJlcltdLFxyXG4gIG9wdHM6IHsgc2NhbGU/OiBudW1iZXI7IGFscGhhPzogbnVtYmVyIH0gPSB7fVxyXG4pOiB7IFE6IG51bWJlcjsgc2NvcmU6IG51bWJlcjsgcTE6IG51bWJlcjsgcTM6IG51bWJlciB9IHtcclxuICBjb25zdCBTOiBudW1iZXIgPSBvcHRzLnNjYWxlID8/IDEwMDtcclxuICBjb25zdCBhbHBoYTogbnVtYmVyID0gb3B0cy5hbHBoYSA/PyAxLjI7XHJcblxyXG4gIGNvbnN0IG4gPSBNYXRoLm1pbihpbm5lckhpc3RTY2FsZWQubGVuZ3RoLCB0ZW5kZW5jeUhpc3RTY2FsZWQubGVuZ3RoKTtcclxuICBpZiAobiA8IDQpIHJldHVybiB7IFE6IDAsIHNjb3JlOiAwLCBxMTogMCwgcTM6IDAgfTtcclxuXHJcbiAgLy8gdW5pdGxlc3Mgc2VyaWVzIGluIFstMS4uMV1cclxuICBjb25zdCBJID0gaW5uZXJIaXN0U2NhbGVkLnNsaWNlKC1uKS5tYXAoKHYpID0+IChTID8gdiAvIFMgOiB2KSk7XHJcbiAgY29uc3QgVCA9IHRlbmRlbmN5SGlzdFNjYWxlZC5zbGljZSgtbikubWFwKCh2KSA9PiAoUyA/IHYgLyBTIDogdikpO1xyXG5cclxuICAvLyBjb21wdXRlIFExLCBRMyBvZiBUXHJcbiAgY29uc3Qgc29ydGVkVCA9IFQuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcbiAgY29uc3QgcTEgPSBxdWFudGlsZShzb3J0ZWRULCAwLjI1KTtcclxuICBjb25zdCBxMyA9IHF1YW50aWxlKHNvcnRlZFQsIDAuNzUpO1xyXG5cclxuICAvLyBtZWFucyBpbiB0YWlsc1xyXG4gIGNvbnN0IGJvdDogbnVtYmVyW10gPSBbXTtcclxuICBjb25zdCB0b3A6IG51bWJlcltdID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgIGlmIChUW2ldIDw9IHExKSBib3QucHVzaChJW2ldKTtcclxuICAgIGVsc2UgaWYgKFRbaV0gPj0gcTMpIHRvcC5wdXNoKElbaV0pO1xyXG4gIH1cclxuICBjb25zdCBtZWFuVG9wID0gdG9wLmxlbmd0aCA/IG1lYW4odG9wKSA6IDA7XHJcbiAgY29uc3QgbWVhbkJvdCA9IGJvdC5sZW5ndGggPyBtZWFuKGJvdCkgOiAwO1xyXG5cclxuICBjb25zdCBRID0gY2xhbXAoKG1lYW5Ub3AgLSBtZWFuQm90KSAvIDIsIC0xLCAxKTsgLy8gWy0xLDFdXHJcbiAgY29uc3Qgc2NvcmUgPSBjbGFtcChTICogdGFuaChhbHBoYSAqIFEpLCAtUywgUyk7XHJcbiAgcmV0dXJuIHsgUSwgc2NvcmUsIHExLCBxMyB9O1xyXG59XHJcblxyXG4vKipcclxuICogdlN3YXBGcm9tTnVjbGVpIChvcHRpb25hbCBzaWRlLW9mLW1hc3Mgdmlldyk6XHJcbiAqIENvbXBhcmUgdG90YWwgbWFzcyByaWdodC12cy1sZWZ0IG9mIGNlbnRlciBhY3Jvc3MgbnVjbGVpIChiaW5zKS5cclxuICogUmV0dXJucyBzY29yZSBpbiBbLVMsIFNdLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZTd2FwRnJvbU51Y2xlaShcclxuICBudWNsZWk6IE51Y2xldXNbXSxcclxuICBiaW5zOiBudW1iZXIsXHJcbiAgb3B0czogeyBzY2FsZT86IG51bWJlcjsgYWxwaGE/OiBudW1iZXIgfSA9IHt9XHJcbik6IG51bWJlciB7XHJcbiAgY29uc3QgUzogbnVtYmVyID0gb3B0cy5zY2FsZSA/PyAxMDA7XHJcbiAgY29uc3QgYWxwaGE6IG51bWJlciA9IG9wdHMuYWxwaGEgPz8gMS4wO1xyXG4gIGlmICghbnVjbGVpPy5sZW5ndGggfHwgYmlucyA8PSAwKSByZXR1cm4gMDtcclxuXHJcbiAgY29uc3QgbWlkID0gKGJpbnMgLSAxKSAvIDI7XHJcbiAgbGV0IGxlZnQgPSAwLCByaWdodCA9IDA7XHJcblxyXG4gIGZvciAobGV0IGIgPSAwOyBiIDwgbnVjbGVpLmxlbmd0aDsgYisrKSB7XHJcbiAgICBjb25zdCBudSA9IG51Y2xlaVtiXTtcclxuICAgIGNvbnN0IHcgPSBudS53ZWlnaHRzICYmIG51LndlaWdodHMubGVuZ3RoID09PSBudS52YWx1ZXMubGVuZ3RoID8gbnUud2VpZ2h0cyA6IHVuZGVmaW5lZDtcclxuICAgIC8vIHRyZWF0IGVhY2ggc2FtcGxlIGluIHRoaXMgbnVjbGV1cyBhcyB1bml0IG1hc3MgKG9yIHdlaWdodGVkKVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudS52YWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgLy8gbWFwIGluZGV4IHdpdGhpbiB0aGUgbnVjbGV1cyB0byBpdHMgZ2xvYmFsIGJpbiBpbmRleCBiXHJcbiAgICAgIC8vIGlmIHlvdSBrZWVwIHBlci1zYW1wbGUgYmluIGluZGV4LCBhZGFwdCBhcyBuZWVkZWQ7IGZvciBub3cgdXNlIGJpbiBiXHJcbiAgICAgIGNvbnN0IHdpID0gdyA/IE1hdGgubWF4KDAsIHdbaV0gfHwgMCkgOiAxO1xyXG4gICAgICBpZiAoYiA8IG1pZCkgbGVmdCArPSB3aTtcclxuICAgICAgZWxzZSBpZiAoYiA+IG1pZCkgcmlnaHQgKz0gd2k7XHJcbiAgICAgIGVsc2UgeyBsZWZ0ICs9IHdpIC8gMjsgcmlnaHQgKz0gd2kgLyAyOyB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBzID0gTWF0aC5hYnMobGVmdCkgKyBNYXRoLmFicyhyaWdodCk7XHJcbiAgaWYgKCFzKSByZXR1cm4gMDtcclxuXHJcbiAgY29uc3QgdW5pdGxlc3MgPSAocmlnaHQgLSBsZWZ0KSAvIHM7IC8vIFstMSwxXVxyXG4gIHJldHVybiBjbGFtcChTICogdGFuaChhbHBoYSAqIHVuaXRsZXNzKSwgLVMsIFMpO1xyXG59XHJcblxyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQWdncmVnYXRlIGlubmVyIG5vdyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4vKipcclxuICogSGVscGVyIHRvIGdldCB0aGUgYWdncmVnYXRlIGlubmVyICh1bml0bGVzcyAmIHNjYWxlZCkgYXQgYSBzaW5nbGUgdGljayxcclxuICogZnJvbSB0aGUgY3VycmVudCBudWNsZWkgJiBvcHRpb25hbCBiaW4gc2hhcmVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFnZ3JlZ2F0ZUlubmVyTm93KFxyXG4gIG51Y2xlaTogTnVjbGV1c1tdLFxyXG4gIHdlaWdodHM/OiBDb21wb3NlV2VpZ2h0c1tdLFxyXG4gIGlubmVyT3B0cz86IFZJbm5lck9wdHMsXHJcbiAgc2NhbGU6IG51bWJlciA9IDEwMFxyXG4pOiB7IHVuaXRsZXNzOiBudW1iZXI7IHNjYWxlZDogbnVtYmVyIH0ge1xyXG4gIGNvbnN0IFM6IG51bWJlciA9IHNjYWxlO1xyXG4gIGNvbnN0IGlubmVycyA9IG51Y2xlaS5tYXAoKG51KSA9PiB2SW5uZXIobnUsIHsgLi4uaW5uZXJPcHRzLCBzY2FsZTogUyB9KSk7XHJcbiAgY29uc3QgZ2FtbWFzID0gd2VpZ2h0cz8ubWFwKCh3KSA9PiAoTnVtYmVyLmlzRmluaXRlKHc/LmdhbW1hIGFzIG51bWJlcikgPyAodyEuZ2FtbWEgYXMgbnVtYmVyKSA6IDEpKVxyXG4gICAgPz8gQXJyYXkobnVjbGVpLmxlbmd0aCkuZmlsbCgxKTtcclxuICBjb25zdCBzdW1HID0gc3VtKGdhbW1hcykgfHwgaW5uZXJzLmxlbmd0aCB8fCAxO1xyXG4gIGNvbnN0IHUgPSBpbm5lcnMucmVkdWNlKChhLCB2LCBpKSA9PiBhICsgKGdhbW1hc1tpXSAqICh2IC8gUykpLCAwKSAvIHN1bUc7XHJcbiAgcmV0dXJuIHsgdW5pdGxlc3M6IHUsIHNjYWxlZDogY2xhbXAoUyAqIHUsIC1TLCBTKSB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJjbGFtcCIsIngiLCJsbyIsImhpIiwiTWF0aCIsIm1heCIsIm1pbiIsInRhbmgiLCJlIiwiZXhwIiwic3VtIiwieHMiLCJyZWR1Y2UiLCJhIiwiYiIsIm1lYW4iLCJsZW5ndGgiLCJzb3J0QnkiLCJhcnIiLCJrZXkiLCJzbGljZSIsInNvcnQiLCJ3TWVkaWFuIiwidyIsIm4iLCJtIiwiZmxvb3IiLCJwYWlycyIsIm1hcCIsInhpIiwiaSIsIndpIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJwIiwidG90YWwiLCJjIiwid01BRCIsImNlbnRlciIsImRldiIsImFicyIsInF1YW50aWxlIiwic29ydGVkIiwiaWR4IiwiY2VpbCIsInZJbm5lciIsIm51Y2xldXMiLCJvcHRzIiwiUyIsInNjYWxlIiwiZyIsImdhaW4iLCJ2YWx1ZXMiLCJ3ZWlnaHRzIiwidW5kZWZpbmVkIiwiY2VudGVyT3ZlcnJpZGUiLCJzaWdtYSIsInNpZ21hT3ZlcnJpZGUiLCJkZW5vbSIsIm51bSIsImRlbiIsInJiYXIiLCJ2T3V0ZXIiLCJudWNsZWkiLCJpbm5lcnMiLCJudSIsImlubmVyIiwiZ2FtbWFzIiwiZ2FtbWEiLCJBcnJheSIsImZpbGwiLCJzdW1HIiwibm9ybWFsaXplIiwiYWdnIiwidW5pdGxlc3MiLCJ2SW5uZXJTY2FsZWQiLCJ2Iiwidk91dGVyU2NhbGVkIiwidlRlbmRlbmN5RnJvbVNlcmllcyIsInNlcmllcyIsIlciLCJ3aW5kb3ciLCJrIiwibm9ybSIsIm5vcm1hbGl6ZXIiLCJkaXJlY3Rpb24iLCJzdHJlbmd0aCIsInNsb3BlIiwiciIsInNjb3JlIiwic3RhcnQiLCJ5Iiwic3giLCJzeSIsInN4eCIsInN4eSIsInN5eSIsInlpIiwicmRlbiIsInNxcnQiLCJkaWZmcyIsInB1c2giLCJEIiwibWVkIiwiYWJzZGV2IiwiZCIsIm11IiwidmFyc3VtIiwieiIsInZTd2FwUXVhcnRpbGVzIiwiaW5uZXJIaXN0U2NhbGVkIiwidGVuZGVuY3lIaXN0U2NhbGVkIiwiYWxwaGEiLCJRIiwicTEiLCJxMyIsIkkiLCJUIiwic29ydGVkVCIsImJvdCIsInRvcCIsIm1lYW5Ub3AiLCJtZWFuQm90IiwidlN3YXBGcm9tTnVjbGVpIiwiYmlucyIsIm1pZCIsImxlZnQiLCJyaWdodCIsInMiLCJhZ2dyZWdhdGVJbm5lck5vdyIsImlubmVyT3B0cyIsInUiLCJzY2FsZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/calc/tendency.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/frame/analytics.ts":
/*!******************************************************!*\
  !*** ./src/core/features/str-aux/frame/analytics.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyGfmShiftAndStreams: () => (/* binding */ applyGfmShiftAndStreams)\n/* harmony export */ });\n// src/str-aux/frame/analytics.ts\n// STR-AUX frame-level analytics: apply GFM shift logic + streams stamping\n// Rule: if |GFM %| > epsilonPct for 5 consecutive cycles  mark shift & update streams.\n//\n// This module is intentionally small and framework-free so it can be reused\n// from API routes or jobs. No DB access here  just pure session/state mutation.\n/**\r\n * Update shift window & streams given current GFM vs reference.\r\n * Returns flags telling the caller whether this cycle stamped a new shift.\r\n */ function applyGfmShiftAndStreams(gfm, refGfm, state, streams, opts = {}) {\n    const epsilonPct = opts.epsilonPct ?? 0.35; // %\n    const windowSize = Math.max(1, Math.floor(opts.windowSize ?? 5));\n    const now = opts.nowTs ?? Date.now();\n    const validRef = Number.isFinite(refGfm) && refGfm > 0;\n    const validCur = Number.isFinite(gfm) && gfm >= 0;\n    // convert delta to percent of full scale (0..1  0..100%)\n    const deltaPct = validRef && validCur ? (gfm / refGfm - 1) * 100 : NaN;\n    // slide window\n    const exceeded = Number.isFinite(deltaPct) && deltaPct >= epsilonPct;\n    const nextExceed = (state.exceed ?? []).slice(-windowSize + 1).concat([\n        exceeded\n    ]);\n    const prevCounts = state.counts ?? [];\n    const nextCounts = prevCounts.slice(-windowSize + 1);\n    const lastCount = prevCounts.length ? prevCounts[prevCounts.length - 1] : 0;\n    nextCounts.push(lastCount + 1);\n    const prevStreak = state.streak ?? 0;\n    const streak = exceeded ? prevStreak + 1 : 0;\n    const totalCycles = (state.totalCycles ?? 0) + 1;\n    // condition: streak reached required window size\n    const reached = streak >= windowSize;\n    let isShift = false;\n    const outStreams = {\n        ...streams\n    };\n    const outState = {\n        exceed: nextExceed,\n        counts: nextCounts,\n        lastDeltaPct: Number.isFinite(deltaPct) ? deltaPct : state.lastDeltaPct,\n        shifts: state.shifts ?? 0,\n        streak: reached ? 0 : streak,\n        totalCycles\n    };\n    if (reached) {\n        isShift = true;\n        outState.shifts = (outState.shifts ?? 0) + 1;\n        const stamp = {\n            ts: now,\n            price: Number.isFinite(opts.price) ? opts.price : NaN,\n            gfm,\n            deltaPct\n        };\n        const maxStamps = outStreams.maxStamps ?? 64;\n        const stamps = (outStreams.stamps ?? []).slice(-(maxStamps - 1)).concat([\n            stamp\n        ]);\n        outStreams.lastShiftTs = now;\n        outStreams.lastShiftPrice = stamp.price;\n        outStreams.lastShiftGfm = gfm;\n        outStreams.stamps = stamps;\n        outStreams.maxStamps = maxStamps;\n    }\n    return {\n        isShift,\n        deltaPct,\n        window: outState,\n        streams: outStreams\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L2ZyYW1lL2FuYWx5dGljcy50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUNBQWlDO0FBQ2pDLDBFQUEwRTtBQUMxRSx5RkFBeUY7QUFDekYsRUFBRTtBQUNGLDRFQUE0RTtBQUM1RSxpRkFBaUY7QUE2Q2pGOzs7Q0FHQyxHQUNNLFNBQVNBLHdCQUNkQyxHQUFXLEVBQ1hDLE1BQWMsRUFDZEMsS0FBdUIsRUFDdkJDLE9BQXFCLEVBQ3JCQyxPQUEwQixDQUFDLENBQUM7SUFFNUIsTUFBTUMsYUFBYUQsS0FBS0MsVUFBVSxJQUFJLE1BQU0sSUFBSTtJQUNoRCxNQUFNQyxhQUFhQyxLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0UsS0FBSyxDQUFDTCxLQUFLRSxVQUFVLElBQUk7SUFDN0QsTUFBTUksTUFBTU4sS0FBS08sS0FBSyxJQUFJQyxLQUFLRixHQUFHO0lBQ2xDLE1BQU1HLFdBQVdDLE9BQU9DLFFBQVEsQ0FBQ2QsV0FBV0EsU0FBUztJQUNyRCxNQUFNZSxXQUFXRixPQUFPQyxRQUFRLENBQUNmLFFBQVFBLE9BQU87SUFFaEQsMERBQTBEO0lBQzFELE1BQU1pQixXQUFXSixZQUFZRyxXQUFXLENBQUMsTUFBT2YsU0FBVSxLQUFLLE1BQU1pQjtJQUVyRSxlQUFlO0lBQ2YsTUFBTUMsV0FBV0wsT0FBT0MsUUFBUSxDQUFDRSxhQUFhQSxZQUFZWjtJQUMxRCxNQUFNZSxhQUFhLENBQUNsQixNQUFNbUIsTUFBTSxJQUFJLEVBQUUsRUFBRUMsS0FBSyxDQUFDLENBQUNoQixhQUFhLEdBQUdpQixNQUFNLENBQUM7UUFBQ0o7S0FBUztJQUNoRixNQUFNSyxhQUFhdEIsTUFBTXVCLE1BQU0sSUFBSSxFQUFFO0lBQ3JDLE1BQU1DLGFBQWFGLFdBQVdGLEtBQUssQ0FBQyxDQUFDaEIsYUFBYTtJQUNsRCxNQUFNcUIsWUFBWUgsV0FBV0ksTUFBTSxHQUFHSixVQUFVLENBQUNBLFdBQVdJLE1BQU0sR0FBRyxFQUFFLEdBQUc7SUFDMUVGLFdBQVdHLElBQUksQ0FBQ0YsWUFBWTtJQUU1QixNQUFNRyxhQUFhNUIsTUFBTTZCLE1BQU0sSUFBSTtJQUNuQyxNQUFNQSxTQUFTWixXQUFXVyxhQUFhLElBQUk7SUFDM0MsTUFBTUUsY0FBYyxDQUFDOUIsTUFBTThCLFdBQVcsSUFBSSxLQUFLO0lBRS9DLGlEQUFpRDtJQUNqRCxNQUFNQyxVQUFVRixVQUFVekI7SUFFMUIsSUFBSTRCLFVBQVU7SUFDZCxNQUFNQyxhQUEyQjtRQUFFLEdBQUdoQyxPQUFPO0lBQUM7SUFDOUMsTUFBTWlDLFdBQTZCO1FBQ2pDZixRQUFRRDtRQUNSSyxRQUFRQztRQUNSVyxjQUFjdkIsT0FBT0MsUUFBUSxDQUFDRSxZQUFZQSxXQUFXZixNQUFNbUMsWUFBWTtRQUN2RUMsUUFBUXBDLE1BQU1vQyxNQUFNLElBQUk7UUFDeEJQLFFBQVFFLFVBQVUsSUFBSUY7UUFDdEJDO0lBQ0Y7SUFFQSxJQUFJQyxTQUFTO1FBQ1hDLFVBQVU7UUFDVkUsU0FBU0UsTUFBTSxHQUFHLENBQUNGLFNBQVNFLE1BQU0sSUFBSSxLQUFLO1FBRTNDLE1BQU1DLFFBQVE7WUFDWkMsSUFBSTlCO1lBQ0orQixPQUFPM0IsT0FBT0MsUUFBUSxDQUFDWCxLQUFLcUMsS0FBSyxJQUFlckMsS0FBS3FDLEtBQUssR0FBY3ZCO1lBQ3hFbEI7WUFDQWlCO1FBQ0Y7UUFFQSxNQUFNeUIsWUFBWVAsV0FBV08sU0FBUyxJQUFJO1FBQzFDLE1BQU1DLFNBQVMsQ0FBQ1IsV0FBV1EsTUFBTSxJQUFJLEVBQUUsRUFBRXJCLEtBQUssQ0FBQyxDQUFFb0IsQ0FBQUEsWUFBWSxJQUFJbkIsTUFBTSxDQUFDO1lBQUNnQjtTQUFNO1FBRS9FSixXQUFXUyxXQUFXLEdBQUdsQztRQUN6QnlCLFdBQVdVLGNBQWMsR0FBR04sTUFBTUUsS0FBSztRQUN2Q04sV0FBV1csWUFBWSxHQUFHOUM7UUFDMUJtQyxXQUFXUSxNQUFNLEdBQUdBO1FBQ3BCUixXQUFXTyxTQUFTLEdBQUdBO0lBQ3pCO0lBRUEsT0FBTztRQUFFUjtRQUFTakI7UUFBVThCLFFBQVFYO1FBQVVqQyxTQUFTZ0M7SUFBVztBQUNwRSIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGNvcmVcXGZlYXR1cmVzXFxzdHItYXV4XFxmcmFtZVxcYW5hbHl0aWNzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9zdHItYXV4L2ZyYW1lL2FuYWx5dGljcy50c1xyXG4vLyBTVFItQVVYIGZyYW1lLWxldmVsIGFuYWx5dGljczogYXBwbHkgR0ZNIHNoaWZ0IGxvZ2ljICsgc3RyZWFtcyBzdGFtcGluZ1xyXG4vLyBSdWxlOiBpZiB8zpRHRk0gJXwgPiBlcHNpbG9uUGN0IGZvciA1IGNvbnNlY3V0aXZlIGN5Y2xlcyDih5IgbWFyayBzaGlmdCAmIHVwZGF0ZSBzdHJlYW1zLlxyXG4vL1xyXG4vLyBUaGlzIG1vZHVsZSBpcyBpbnRlbnRpb25hbGx5IHNtYWxsIGFuZCBmcmFtZXdvcmstZnJlZSBzbyBpdCBjYW4gYmUgcmV1c2VkXHJcbi8vIGZyb20gQVBJIHJvdXRlcyBvciBqb2JzLiBObyBEQiBhY2Nlc3MgaGVyZSDigJQganVzdCBwdXJlIHNlc3Npb24vc3RhdGUgbXV0YXRpb24uXHJcblxyXG5leHBvcnQgdHlwZSBTaGlmdFdpbmRvd1N0YXRlID0ge1xuICAvLyByb2xsaW5nIHdpbmRvdyBvZiBib29sZWFuIGZsYWdzIGZvciBcImRlbHRhIGV4Y2VlZGVkIGVwc2lsb25QY3RcIiBwZXIgY3ljbGVcbiAgZXhjZWVkOiBib29sZWFuW107XG4gIC8vIHJvbGxpbmcgY291bnRlcnMgZm9yIGVhY2ggc2FtcGxlIHByb2Nlc3NlZFxuICBjb3VudHM/OiBudW1iZXJbXTtcbiAgLy8gbGFzdCBjb21wdXRlZCBkZWx0YSBpbiBwZXJjZW50IHBvaW50c1xuICBsYXN0RGVsdGFQY3Q/OiBudW1iZXI7XG4gIC8vIHRvdGFsIHNoaWZ0cyBkZXRlY3RlZCAobGlmZXRpbWUsIG1haW50YWluZWQgYnkgY2FsbGVyIGlmIHBlcnNpc3RlZClcbiAgc2hpZnRzPzogbnVtYmVyO1xuICAvLyBjdXJyZW50IHN0cmVhayBvZiBjb25zZWN1dGl2ZSBxdWFsaWZ5aW5nIGN5Y2xlc1xuICBzdHJlYWs/OiBudW1iZXI7XG4gIC8vIHRvdGFsIGN5Y2xlcyBwcm9jZXNzZWRcbiAgdG90YWxDeWNsZXM/OiBudW1iZXI7XG59O1xuXHJcbmV4cG9ydCB0eXBlIFN0cmVhbXNTdGF0ZSA9IHtcbiAgLy8gbWluaW1hbCBza2V0Y2ggLSBjYWxsZXIgY2FuIGV4dGVuZFxuICBsYXN0U2hpZnRUcz86IG51bWJlcjtcbiAgbGFzdFNoaWZ0UHJpY2U/OiBudW1iZXI7XG4gIGxhc3RTaGlmdEdmbT86IG51bWJlcjtcbiAgLy8gcmVjZW50IHN0YW1wcyAoZml4ZWQgc2l6ZSBmb3IgVUkpXG4gIHN0YW1wcz86IEFycmF5PHsgdHM6IG51bWJlcjsgcHJpY2U6IG51bWJlcjsgZ2ZtOiBudW1iZXI7IGRlbHRhUGN0OiBudW1iZXIgfT47XG4gIG1heFN0YW1wcz86IG51bWJlcjsgLy8gZGVmYXVsdCA2NFxuICBiZW5jaG1hcms/OiB7IHByZXY6IG51bWJlciB8IG51bGw7IGN1cjogbnVtYmVyIHwgbnVsbDsgZ3JlYXRlc3Q6IG51bWJlciB8IG51bGwgfTtcbiAgcGN0MjRoPzogeyBwcmV2OiBudW1iZXIgfCBudWxsOyBjdXI6IG51bWJlciB8IG51bGw7IGdyZWF0ZXN0OiBudW1iZXIgfCBudWxsIH07XG4gIHBjdF9kcnY/OiB7IHByZXY6IG51bWJlciB8IG51bGw7IGN1cjogbnVtYmVyIHwgbnVsbDsgZ3JlYXRlc3Q6IG51bWJlciB8IG51bGwgfTtcbiAgdlN3YXA/OiB7IHByZXY6IG51bWJlciB8IG51bGw7IGN1cjogbnVtYmVyIHwgbnVsbDsgZ3JlYXRlc3Q6IG51bWJlciB8IG51bGwgfTtcbiAgdlRlbmRlbmN5PzogeyBwcmV2OiBudW1iZXIgfCBudWxsOyBjdXI6IG51bWJlciB8IG51bGw7IGdyZWF0ZXN0OiBudW1iZXIgfCBudWxsIH07XG4gIHZJbm5lcj86IHsgcHJldjogbnVtYmVyIHwgbnVsbDsgY3VyOiBudW1iZXIgfCBudWxsOyBncmVhdGVzdDogbnVtYmVyIHwgbnVsbCB9O1xuICB2T3V0ZXI/OiB7IHByZXY6IG51bWJlciB8IG51bGw7IGN1cjogbnVtYmVyIHwgbnVsbDsgZ3JlYXRlc3Q6IG51bWJlciB8IG51bGwgfTtcbiAgaW5lcnRpYT86IHsgcHJldjogbnVtYmVyIHwgbnVsbDsgY3VyOiBudW1iZXIgfCBudWxsOyBncmVhdGVzdDogbnVtYmVyIHwgbnVsbCB9O1xuICBhbXA/OiB7IHByZXY6IG51bWJlciB8IG51bGw7IGN1cjogbnVtYmVyIHwgbnVsbDsgZ3JlYXRlc3Q6IG51bWJlciB8IG51bGwgfTtcbiAgdm9sdD86IHsgcHJldjogbnVtYmVyIHwgbnVsbDsgY3VyOiBudW1iZXIgfCBudWxsOyBncmVhdGVzdDogbnVtYmVyIHwgbnVsbCB9O1xuICBlZmZpY2llbmN5PzogeyBwcmV2OiBudW1iZXIgfCBudWxsOyBjdXI6IG51bWJlciB8IG51bGw7IGdyZWF0ZXN0OiBudW1iZXIgfCBudWxsIH07XG59O1xuXHJcbmV4cG9ydCB0eXBlIEFwcGx5R2ZtU2hpZnRPcHRzID0ge1xyXG4gIGVwc2lsb25QY3Q/OiBudW1iZXI7IC8vIHRocmVzaG9sZCBpbiBwZXJjZW50YWdlIHBvaW50cyAoZGVmYXVsdCAwLjM1JSlcclxuICB3aW5kb3dTaXplPzogbnVtYmVyOyAvLyBjb25zZWN1dGl2ZSBjeWNsZXMgbmVlZGVkIChkZWZhdWx0IDUpXHJcbiAgbm93VHM/OiBudW1iZXI7ICAgICAgLy8gb3ZlcnJpZGUgY2xvY2sgaWYgbmVlZGVkXHJcbiAgcHJpY2U/OiBudW1iZXI7ICAgICAgLy8gbGFzdCBwcmljZSBhdCB0aGlzIGN5Y2xlIChmb3Igc3RhbXBpbmcpXHJcbn07XHJcblxyXG4vKipcclxuICogVXBkYXRlIHNoaWZ0IHdpbmRvdyAmIHN0cmVhbXMgZ2l2ZW4gY3VycmVudCBHRk0gdnMgcmVmZXJlbmNlLlxyXG4gKiBSZXR1cm5zIGZsYWdzIHRlbGxpbmcgdGhlIGNhbGxlciB3aGV0aGVyIHRoaXMgY3ljbGUgc3RhbXBlZCBhIG5ldyBzaGlmdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBseUdmbVNoaWZ0QW5kU3RyZWFtcyhcbiAgZ2ZtOiBudW1iZXIsICAgICAgICAgIC8vIGN1cnJlbnQgR0ZNIChhYnNvbHV0ZSlcbiAgcmVmR2ZtOiBudW1iZXIsICAgICAgIC8vIHJlZmVyZW5jZSBHRk0gKGFic29sdXRlKVxuICBzdGF0ZTogU2hpZnRXaW5kb3dTdGF0ZSxcclxuICBzdHJlYW1zOiBTdHJlYW1zU3RhdGUsXHJcbiAgb3B0czogQXBwbHlHZm1TaGlmdE9wdHMgPSB7fVxyXG4pOiB7IGlzU2hpZnQ6IGJvb2xlYW47IGRlbHRhUGN0OiBudW1iZXI7IHdpbmRvdzogU2hpZnRXaW5kb3dTdGF0ZTsgc3RyZWFtczogU3RyZWFtc1N0YXRlIH0ge1xyXG4gIGNvbnN0IGVwc2lsb25QY3QgPSBvcHRzLmVwc2lsb25QY3QgPz8gMC4zNTsgLy8gJVxuICBjb25zdCB3aW5kb3dTaXplID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihvcHRzLndpbmRvd1NpemUgPz8gNSkpO1xuICBjb25zdCBub3cgPSBvcHRzLm5vd1RzID8/IERhdGUubm93KCk7XG4gIGNvbnN0IHZhbGlkUmVmID0gTnVtYmVyLmlzRmluaXRlKHJlZkdmbSkgJiYgcmVmR2ZtID4gMDtcbiAgY29uc3QgdmFsaWRDdXIgPSBOdW1iZXIuaXNGaW5pdGUoZ2ZtKSAmJiBnZm0gPj0gMDtcblxyXG4gIC8vIGNvbnZlcnQgZGVsdGEgdG8gcGVyY2VudCBvZiBmdWxsIHNjYWxlICgwLi4xIOKHkiAwLi4xMDAlKVxyXG4gIGNvbnN0IGRlbHRhUGN0ID0gdmFsaWRSZWYgJiYgdmFsaWRDdXIgPyAoKGdmbSAvIHJlZkdmbSkgLSAxKSAqIDEwMCA6IE5hTjtcblxyXG4gIC8vIHNsaWRlIHdpbmRvd1xyXG4gIGNvbnN0IGV4Y2VlZGVkID0gTnVtYmVyLmlzRmluaXRlKGRlbHRhUGN0KSAmJiBkZWx0YVBjdCA+PSBlcHNpbG9uUGN0O1xuICBjb25zdCBuZXh0RXhjZWVkID0gKHN0YXRlLmV4Y2VlZCA/PyBbXSkuc2xpY2UoLXdpbmRvd1NpemUgKyAxKS5jb25jYXQoW2V4Y2VlZGVkXSk7XG4gIGNvbnN0IHByZXZDb3VudHMgPSBzdGF0ZS5jb3VudHMgPz8gW107XG4gIGNvbnN0IG5leHRDb3VudHMgPSBwcmV2Q291bnRzLnNsaWNlKC13aW5kb3dTaXplICsgMSk7XG4gIGNvbnN0IGxhc3RDb3VudCA9IHByZXZDb3VudHMubGVuZ3RoID8gcHJldkNvdW50c1twcmV2Q291bnRzLmxlbmd0aCAtIDFdIDogMDtcbiAgbmV4dENvdW50cy5wdXNoKGxhc3RDb3VudCArIDEpO1xuXG4gIGNvbnN0IHByZXZTdHJlYWsgPSBzdGF0ZS5zdHJlYWsgPz8gMDtcbiAgY29uc3Qgc3RyZWFrID0gZXhjZWVkZWQgPyBwcmV2U3RyZWFrICsgMSA6IDA7XG4gIGNvbnN0IHRvdGFsQ3ljbGVzID0gKHN0YXRlLnRvdGFsQ3ljbGVzID8/IDApICsgMTtcblxyXG4gIC8vIGNvbmRpdGlvbjogc3RyZWFrIHJlYWNoZWQgcmVxdWlyZWQgd2luZG93IHNpemVcbiAgY29uc3QgcmVhY2hlZCA9IHN0cmVhayA+PSB3aW5kb3dTaXplO1xuXHJcbiAgbGV0IGlzU2hpZnQgPSBmYWxzZTtcclxuICBjb25zdCBvdXRTdHJlYW1zOiBTdHJlYW1zU3RhdGUgPSB7IC4uLnN0cmVhbXMgfTtcbiAgY29uc3Qgb3V0U3RhdGU6IFNoaWZ0V2luZG93U3RhdGUgPSB7XG4gICAgZXhjZWVkOiBuZXh0RXhjZWVkLFxuICAgIGNvdW50czogbmV4dENvdW50cyxcbiAgICBsYXN0RGVsdGFQY3Q6IE51bWJlci5pc0Zpbml0ZShkZWx0YVBjdCkgPyBkZWx0YVBjdCA6IHN0YXRlLmxhc3REZWx0YVBjdCxcbiAgICBzaGlmdHM6IHN0YXRlLnNoaWZ0cyA/PyAwLFxuICAgIHN0cmVhazogcmVhY2hlZCA/IDAgOiBzdHJlYWssXG4gICAgdG90YWxDeWNsZXMsXG4gIH07XG5cclxuICBpZiAocmVhY2hlZCkge1xuICAgIGlzU2hpZnQgPSB0cnVlO1xyXG4gICAgb3V0U3RhdGUuc2hpZnRzID0gKG91dFN0YXRlLnNoaWZ0cyA/PyAwKSArIDE7XHJcblxyXG4gICAgY29uc3Qgc3RhbXAgPSB7XHJcbiAgICAgIHRzOiBub3csXHJcbiAgICAgIHByaWNlOiBOdW1iZXIuaXNGaW5pdGUob3B0cy5wcmljZSBhcyBudW1iZXIpID8gKG9wdHMucHJpY2UgYXMgbnVtYmVyKSA6IE5hTixcclxuICAgICAgZ2ZtLFxyXG4gICAgICBkZWx0YVBjdCxcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgbWF4U3RhbXBzID0gb3V0U3RyZWFtcy5tYXhTdGFtcHMgPz8gNjQ7XHJcbiAgICBjb25zdCBzdGFtcHMgPSAob3V0U3RyZWFtcy5zdGFtcHMgPz8gW10pLnNsaWNlKC0obWF4U3RhbXBzIC0gMSkpLmNvbmNhdChbc3RhbXBdKTtcclxuXHJcbiAgICBvdXRTdHJlYW1zLmxhc3RTaGlmdFRzID0gbm93O1xyXG4gICAgb3V0U3RyZWFtcy5sYXN0U2hpZnRQcmljZSA9IHN0YW1wLnByaWNlO1xyXG4gICAgb3V0U3RyZWFtcy5sYXN0U2hpZnRHZm0gPSBnZm07XHJcbiAgICBvdXRTdHJlYW1zLnN0YW1wcyA9IHN0YW1wcztcclxuICAgIG91dFN0cmVhbXMubWF4U3RhbXBzID0gbWF4U3RhbXBzO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHsgaXNTaGlmdCwgZGVsdGFQY3QsIHdpbmRvdzogb3V0U3RhdGUsIHN0cmVhbXM6IG91dFN0cmVhbXMgfTtcclxufVxyXG4iXSwibmFtZXMiOlsiYXBwbHlHZm1TaGlmdEFuZFN0cmVhbXMiLCJnZm0iLCJyZWZHZm0iLCJzdGF0ZSIsInN0cmVhbXMiLCJvcHRzIiwiZXBzaWxvblBjdCIsIndpbmRvd1NpemUiLCJNYXRoIiwibWF4IiwiZmxvb3IiLCJub3ciLCJub3dUcyIsIkRhdGUiLCJ2YWxpZFJlZiIsIk51bWJlciIsImlzRmluaXRlIiwidmFsaWRDdXIiLCJkZWx0YVBjdCIsIk5hTiIsImV4Y2VlZGVkIiwibmV4dEV4Y2VlZCIsImV4Y2VlZCIsInNsaWNlIiwiY29uY2F0IiwicHJldkNvdW50cyIsImNvdW50cyIsIm5leHRDb3VudHMiLCJsYXN0Q291bnQiLCJsZW5ndGgiLCJwdXNoIiwicHJldlN0cmVhayIsInN0cmVhayIsInRvdGFsQ3ljbGVzIiwicmVhY2hlZCIsImlzU2hpZnQiLCJvdXRTdHJlYW1zIiwib3V0U3RhdGUiLCJsYXN0RGVsdGFQY3QiLCJzaGlmdHMiLCJzdGFtcCIsInRzIiwicHJpY2UiLCJtYXhTdGFtcHMiLCJzdGFtcHMiLCJsYXN0U2hpZnRUcyIsImxhc3RTaGlmdFByaWNlIiwibGFzdFNoaWZ0R2ZtIiwid2luZG93Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/frame/analytics.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/frame/idhr.ts":
/*!*************************************************!*\
  !*** ./src/core/features/str-aux/frame/idhr.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_IDHR: () => (/* binding */ DEFAULT_IDHR),\n/* harmony export */   computeFM: () => (/* binding */ computeFM),\n/* harmony export */   computeIdhrBins: () => (/* binding */ computeIdhrBins),\n/* harmony export */   computeIdhrBinsN: () => (/* binding */ computeIdhrBinsN),\n/* harmony export */   extractNuclei: () => (/* binding */ extractNuclei),\n/* harmony export */   idhr: () => (/* binding */ idhr),\n/* harmony export */   serializeIdhr: () => (/* binding */ serializeIdhr)\n/* harmony export */ });\n// src/lab/str-aux/idhr.ts\n// Deterministic IDHR histogram (with exact bin control) + Floating Mode metrics.\n// - Each function merges config locally into `C` (fixes C is not defined).\n// - `totalBins` enables exact-bin sizing (e.g., 128).\n// - Returns Floating Mode (gfm) + basic shape stats.\n// - Nuclei now match your repos Nucleus type: { binIndex, density, firstDegree, secondDegree }.\nconst DEFAULT_IDHR = {\n    innerBins: 5,\n    outerBins: 4,\n    alpha: 2.5,\n    sMin: 1e-6,\n    topN: 3\n};\n// ---------- Utils ----------\nfunction clamp(n, lo, hi) {\n    return n < lo ? lo : n > hi ? hi : n;\n}\nfunction mean(xs) {\n    return xs.length ? xs.reduce((a, b)=>a + b, 0) / xs.length : 0;\n}\nfunction stdev(xs) {\n    if (xs.length < 2) return 0;\n    const m = mean(xs);\n    const v = xs.reduce((acc, x)=>acc + (x - m) ** 2, 0) / (xs.length - 1);\n    return Math.sqrt(Math.max(0, v));\n}\nfunction linspace(min, max, n) {\n    if (n <= 1) return [\n        min\n    ];\n    const step = (max - min) / (n - 1);\n    return Array.from({\n        length: n\n    }, (_, i)=>min + i * step);\n}\nfunction argMax(xs) {\n    let idx = 0, best = -Infinity;\n    for(let i = 0; i < xs.length; i++)if (xs[i] > best) {\n        best = xs[i];\n        idx = i;\n    }\n    return idx;\n}\nfunction smooth1d(xs, k = 3) {\n    const n = xs.length;\n    if (n === 0 || k <= 1) return xs.slice();\n    const half = Math.floor(k / 2);\n    const out = new Array(n).fill(0);\n    for(let i = 0; i < n; i++){\n        let s = 0, c = 0;\n        for(let j = i - half; j <= i + half; j++)if (j >= 0 && j < n) {\n            s += xs[j];\n            c++;\n        }\n        out[i] = s / (c || 1);\n    }\n    return out;\n}\n// ---------- Core: computeIdhrBins ----------\nfunction computeIdhrBins(points, opening, cfg = {}) {\n    // local config (fixes C is not defined)\n    const C = {\n        ...DEFAULT_IDHR,\n        ...cfg\n    };\n    // returns as log(px / p0)\n    const p0 = Number(opening?.benchmark ?? 0);\n    const returns = [];\n    for (const p of points){\n        const px = Number(p?.price ?? 0);\n        if (Number.isFinite(px) && px > 0 && Number.isFinite(p0) && p0 > 0) {\n            returns.push(Math.log(px / p0));\n        }\n    }\n    // robust stats\n    const mu0 = mean(returns);\n    const sd0 = Math.max(stdev(returns), C.sMin);\n    // range and bins\n    const span = C.alpha * sd0;\n    const rMin = mu0 - span;\n    const rMax = mu0 + span;\n    const binsFromParts = C.innerBins + 2 * C.outerBins + 1;\n    const bins = Math.max(8, Math.floor(C.totalBins ?? binsFromParts));\n    const edges = linspace(rMin, rMax, bins);\n    // counts (nearest-edge)\n    const counts = new Array(bins).fill(0);\n    const step = bins > 1 ? (rMax - rMin) / (bins - 1) : 1;\n    if (step > 0) {\n        for (const r of returns){\n            const ii = clamp(Math.round((r - rMin) / step), 0, bins - 1);\n            counts[ii] += 1;\n        }\n    }\n    const total = counts.reduce((a, b)=>a + b, 0);\n    const probs = counts.map((c)=>total > 0 ? c / total : 0);\n    const inWin = [];\n    for (const r of returns)if (r >= rMin && r <= rMax) inWin.push(r);\n    const muR = mean(inWin);\n    const stdR = Math.max(stdev(inWin), C.sMin);\n    return {\n        edges,\n        counts,\n        probs,\n        muR,\n        stdR,\n        sigmaGlobal: stdR\n    };\n}\n// ---------- Nuclei (peak extraction) ----------\nfunction extractNuclei(bins, k) {\n    const sm = smooth1d(bins.counts, 5);\n    const n = sm.length;\n    // central differences for 1st/2nd derivatives\n    const first = new Array(n).fill(0);\n    const second = new Array(n).fill(0);\n    for(let i = 1; i < n - 1; i++){\n        first[i] = (sm[i + 1] - sm[i - 1]) / 2;\n        second[i] = sm[i + 1] - 2 * sm[i] + sm[i - 1];\n    }\n    // simple local maxima\n    const peaks = [];\n    for(let i = 1; i < n - 1; i++){\n        if (sm[i] > sm[i - 1] && sm[i] > sm[i + 1]) peaks.push({\n            i,\n            v: sm[i]\n        });\n    }\n    peaks.sort((a, b)=>b.v - a.v);\n    const top = peaks.slice(0, Math.max(1, k));\n    const total = bins.counts.reduce((a, b)=>a + b, 0) || 1;\n    // match your Nucleus type exactly\n    const nuclei = top.map(({ i, v })=>({\n            binIndex: i,\n            density: v / total,\n            firstDegree: first[i] ?? 0,\n            secondDegree: second[i] ?? 0\n        }));\n    return nuclei;\n}\n// ---------- Floating Mode (metrics) ----------\nfunction computeFM(points, opening, cfg = {}) {\n    const C = {\n        ...DEFAULT_IDHR,\n        ...cfg\n    };\n    const hist = computeIdhrBins(points, opening, C);\n    const modeIdx = argMax(hist.counts);\n    const gfm = hist.edges[modeIdx] ?? 0;\n    const p0 = Number(opening?.benchmark ?? 0);\n    const rets = [];\n    for (const p of points){\n        const px = Number(p?.price ?? 0);\n        if (Number.isFinite(px) && px > 0 && Number.isFinite(p0) && p0 > 0) {\n            rets.push(Math.log(px / p0));\n        }\n    }\n    const sigma = hist.sigmaGlobal;\n    const zAbs = rets.length ? rets.reduce((a, r)=>a + Math.abs((r - hist.muR) / (sigma || 1)), 0) / rets.length : 0;\n    // crude inner/outer mass around the mode\n    const leftCount = hist.counts.slice(0, modeIdx).reduce((a, b)=>a + b, 0);\n    const rightCount = hist.counts.slice(modeIdx + 1).reduce((a, b)=>a + b, 0);\n    const vInner = Math.max(0, Math.min(leftCount, rightCount));\n    const vOuter = Math.max(0, leftCount + rightCount - vInner);\n    // histogram roughness indicators\n    const center = hist.muR;\n    const inertia = rets.reduce((acc, r)=>acc + (r - center) ** 2, 0) / (rets.length || 1);\n    const sm = smooth1d(hist.counts, 3);\n    let disruption = 0;\n    for(let i = 1; i < sm.length; i++)disruption += Math.abs(sm[i] - sm[i - 1]);\n    disruption /= sm.length || 1;\n    const nuclei = extractNuclei(hist, C.topN);\n    return {\n        gfm,\n        confidence: 1 / (1 + zAbs),\n        inertia,\n        disruption,\n        zMeanAbs: zAbs,\n        sigmaGlobal: sigma,\n        vInner,\n        vOuter,\n        nuclei\n    };\n}\n// ---------- Helpers ----------\nfunction computeIdhrBinsN(points, opening, cfg = {}, N = 128) {\n    return computeIdhrBins(points, opening, {\n        ...cfg,\n        totalBins: N\n    });\n}\nfunction serializeIdhr(idhr) {\n    return {\n        edges: idhr.edges,\n        counts: idhr.counts,\n        probs: idhr.probs,\n        muR: idhr.muR,\n        stdR: idhr.stdR,\n        sigmaGlobal: idhr.sigmaGlobal\n    };\n}\n// Keep buildStrAux compatibility if it imports { idhr }\nfunction idhr(points, opening, cfg = {}) {\n    const bins = computeIdhrBins(points, opening, cfg);\n    const nuclei = extractNuclei(bins, cfg.topN ?? DEFAULT_IDHR.topN);\n    return {\n        nuclei,\n        sampleFirstDegrees: [],\n        outlierCount: 0\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L2ZyYW1lL2lkaHIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLDBCQUEwQjtBQUMxQixpRkFBaUY7QUFDakYsNkVBQTZFO0FBQzdFLHNEQUFzRDtBQUN0RCxxREFBcUQ7QUFDckQsaUdBQWlHO0FBb0IxRixNQUFNQSxlQUEyQjtJQUN0Q0MsV0FBVztJQUNYQyxXQUFXO0lBQ1hDLE9BQU87SUFDUEMsTUFBTTtJQUNOQyxNQUFNO0FBQ1IsRUFBRTtBQVdGLDhCQUE4QjtBQUU5QixTQUFTQyxNQUFNQyxDQUFTLEVBQUVDLEVBQVUsRUFBRUMsRUFBVTtJQUM5QyxPQUFPRixJQUFJQyxLQUFLQSxLQUFLRCxJQUFJRSxLQUFLQSxLQUFLRjtBQUNyQztBQUNBLFNBQVNHLEtBQUtDLEVBQVk7SUFDeEIsT0FBT0EsR0FBR0MsTUFBTSxHQUFHRCxHQUFHRSxNQUFNLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsSUFBSUMsR0FBRyxLQUFLSixHQUFHQyxNQUFNLEdBQUc7QUFDakU7QUFDQSxTQUFTSSxNQUFNTCxFQUFZO0lBQ3pCLElBQUlBLEdBQUdDLE1BQU0sR0FBRyxHQUFHLE9BQU87SUFDMUIsTUFBTUssSUFBSVAsS0FBS0M7SUFDZixNQUFNTyxJQUFJUCxHQUFHRSxNQUFNLENBQUMsQ0FBQ00sS0FBS0MsSUFBTUQsTUFBTSxDQUFDQyxJQUFJSCxDQUFBQSxLQUFNLEdBQUcsS0FBTU4sQ0FBQUEsR0FBR0MsTUFBTSxHQUFHO0lBQ3RFLE9BQU9TLEtBQUtDLElBQUksQ0FBQ0QsS0FBS0UsR0FBRyxDQUFDLEdBQUdMO0FBQy9CO0FBQ0EsU0FBU00sU0FBU0MsR0FBVyxFQUFFRixHQUFXLEVBQUVoQixDQUFTO0lBQ25ELElBQUlBLEtBQUssR0FBRyxPQUFPO1FBQUNrQjtLQUFJO0lBQ3hCLE1BQU1DLE9BQU8sQ0FBQ0gsTUFBTUUsR0FBRSxJQUFNbEIsQ0FBQUEsSUFBSTtJQUNoQyxPQUFPb0IsTUFBTUMsSUFB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S2pDLFdBQVc7SUFDL0I7QUFDRjtBQUVBLHdEQUF3RDtBQUNqRCxTQUFTaUMsS0FDZGxFLE1BQXFCLEVBQ3JCQyxPQUFxQixFQUNyQkMsTUFBMkIsQ0FBQyxDQUFDO0lBRTdCLE1BQU1rQixPQUFPckIsZ0JBQWdCQyxRQUFRQyxTQUFTQztJQUM5QyxNQUFNdUMsU0FBU1AsY0FBY2QsTUFBT2xCLElBQUkzQyxJQUFJLElBQUlMLGFBQWFLLElBQUk7SUFDakUsT0FBTztRQUFFa0Y7UUFBUTBCLG9CQUFvQixFQUFFO1FBQUVDLGNBQWM7SUFBRTtBQUMzRCIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGNvcmVcXGZlYXR1cmVzXFxzdHItYXV4XFxmcmFtZVxcaWRoci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbGFiL3N0ci1hdXgvaWRoci50c1xuLy8gRGV0ZXJtaW5pc3RpYyBJREhSIGhpc3RvZ3JhbSAod2l0aCBleGFjdCBiaW4gY29udHJvbCkgKyBGbG9hdGluZyBNb2RlIG1ldHJpY3MuXG4vLyAtIEVhY2ggZnVuY3Rpb24gbWVyZ2VzIGNvbmZpZyBsb2NhbGx5IGludG8gYENgIChmaXhlcyDigJxDIGlzIG5vdCBkZWZpbmVk4oCdKS5cbi8vIC0gYHRvdGFsQmluc2AgZW5hYmxlcyBleGFjdC1iaW4gc2l6aW5nIChlLmcuLCAxMjgpLlxuLy8gLSBSZXR1cm5zIEZsb2F0aW5nIE1vZGUgKGdmbSkgKyBiYXNpYyBzaGFwZSBzdGF0cy5cbi8vIC0gTnVjbGVpIG5vdyBtYXRjaCB5b3VyIHJlcG/igJlzIE51Y2xldXMgdHlwZTogeyBiaW5JbmRleCwgZGVuc2l0eSwgZmlyc3REZWdyZWUsIHNlY29uZERlZ3JlZSB9LlxuXG5pbXBvcnQgdHlwZSB7XG4gIE1hcmtldFBvaW50LFxuICBPcGVuaW5nRXhhY3QsXG4gIE51Y2xldXMsXG4gIElkaHJSZXN1bHQsXG59IGZyb20gJy4uLy4uLy4uLy4uLy4uL2xhYi9sZWdhY3kvYXV4aWxpYXJ5L3N0ci1hdXgvdHlwZXMnO1xuXG4vLyAtLS0tLS0tLS0tIENvbmZpZyAmIFR5cGVzIC0tLS0tLS0tLS1cblxuZXhwb3J0IHR5cGUgSWRockNvbmZpZyA9IHtcbiAgaW5uZXJCaW5zOiBudW1iZXI7ICAvLyBiaW5zIG5lYXIgMFxuICBvdXRlckJpbnM6IG51bWJlcjsgIC8vIGJpbnMgcGVyIHRhaWxcbiAgYWxwaGE6IG51bWJlcjsgICAgICAvLyBzcGFuIG11bHRpcGxpZXIgYXJvdW5kIG1lYW4gKM68IMKxIM6xwrfPgylcbiAgc01pbjogbnVtYmVyOyAgICAgICAvLyBzaWdtYSBmbG9vciB0byBhdm9pZCBjb2xsYXBzZVxuICB0b3BOOiBudW1iZXI7ICAgICAgIC8vIG51bWJlciBvZiBudWNsZWkgdG8ga2VlcFxuICB0b3RhbEJpbnM/OiBudW1iZXI7IC8vIG9wdGlvbmFsOiBmb3JjZSBmaW5hbCBiaW4gY291bnQgKGUuZy4sIDEyOClcbn07XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0lESFI6IElkaHJDb25maWcgPSB7XG4gIGlubmVyQmluczogNSxcbiAgb3V0ZXJCaW5zOiA0LFxuICBhbHBoYTogMi41LFxuICBzTWluOiAxZS02LFxuICB0b3BOOiAzLFxufTtcblxuZXhwb3J0IHR5cGUgSWRockJpbnMgPSB7XG4gIGVkZ2VzOiBudW1iZXJbXTsgICAgLy8gbGVuZ3RoID0gYmluc1xuICBjb3VudHM6IG51bWJlcltdOyAgIC8vIGxlbmd0aCA9IGJpbnNcbiAgcHJvYnM6IG51bWJlcltdOyAgICAvLyBsZW5ndGggPSBiaW5zXG4gIG11UjogbnVtYmVyO1xuICBzdGRSOiBudW1iZXI7XG4gIHNpZ21hR2xvYmFsOiBudW1iZXI7IC8vIGFsaWFzIHRvIHN0ZFJcbn07XG5cbi8vIC0tLS0tLS0tLS0gVXRpbHMgLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBjbGFtcChuOiBudW1iZXIsIGxvOiBudW1iZXIsIGhpOiBudW1iZXIpIHtcbiAgcmV0dXJuIG4gPCBsbyA/IGxvIDogbiA+IGhpID8gaGkgOiBuO1xufVxuZnVuY3Rpb24gbWVhbih4czogbnVtYmVyW10pIHtcbiAgcmV0dXJuIHhzLmxlbmd0aCA/IHhzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8geHMubGVuZ3RoIDogMDtcbn1cbmZ1bmN0aW9uIHN0ZGV2KHhzOiBudW1iZXJbXSkge1xuICBpZiAoeHMubGVuZ3RoIDwgMikgcmV0dXJuIDA7XG4gIGNvbnN0IG0gPSBtZWFuKHhzKTtcbiAgY29uc3QgdiA9IHhzLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MgKyAoeCAtIG0pICoqIDIsIDApIC8gKHhzLmxlbmd0aCAtIDEpO1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIHYpKTtcbn1cbmZ1bmN0aW9uIGxpbnNwYWNlKG1pbjogbnVtYmVyLCBtYXg6IG51bWJlciwgbjogbnVtYmVyKSB7XG4gIGlmIChuIDw9IDEpIHJldHVybiBbbWluXTtcbiAgY29uc3Qgc3RlcCA9IChtYXggLSBtaW4pIC8gKG4gLSAxKTtcbiAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IG4gfSwgKF8sIGkpID0+IG1pbiArIGkgKiBzdGVwKTtcbn1cbmZ1bmN0aW9uIGFyZ01heCh4czogbnVtYmVyW10pIHtcbiAgbGV0IGlkeCA9IDAsIGJlc3QgPSAtSW5maW5pdHk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIGlmICh4c1tpXSA+IGJlc3QpIHsgYmVzdCA9IHhzW2ldOyBpZHggPSBpOyB9XG4gIHJldHVybiBpZHg7XG59XG5mdW5jdGlvbiBzbW9vdGgxZCh4czogbnVtYmVyW10sIGsgPSAzKSB7XG4gIGNvbnN0IG4gPSB4cy5sZW5ndGg7XG4gIGlmIChuID09PSAwIHx8IGsgPD0gMSkgcmV0dXJuIHhzLnNsaWNlKCk7XG4gIGNvbnN0IGhhbGYgPSBNYXRoLmZsb29yKGsgLyAyKTtcbiAgY29uc3Qgb3V0ID0gbmV3IEFycmF5KG4pLmZpbGwoMCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgbGV0IHMgPSAwLCBjID0gMDtcbiAgICBmb3IgKGxldCBqID0gaSAtIGhhbGY7IGogPD0gaSArIGhhbGY7IGorKykgaWYgKGogPj0gMCAmJiBqIDwgbikgeyBzICs9IHhzW2pdOyBjKys7IH1cbiAgICBvdXRbaV0gPSBzIC8gKGMgfHwgMSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuLy8gLS0tLS0tLS0tLSBDb3JlOiBjb21wdXRlSWRockJpbnMgLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUlkaHJCaW5zKFxuICBwb2ludHM6IE1hcmtldFBvaW50W10sXG4gIG9wZW5pbmc6IE9wZW5pbmdFeGFjdCxcbiAgY2ZnOiBQYXJ0aWFsPElkaHJDb25maWc+ID0ge30sXG4pOiBJZGhyQmlucyB7XG4gIC8vIGxvY2FsIGNvbmZpZyAoZml4ZXMg4oCcQyBpcyBub3QgZGVmaW5lZOKAnSlcbiAgY29uc3QgQzogSWRockNvbmZpZyA9IHsgLi4uREVGQVVMVF9JREhSLCAuLi5jZmcgfTtcblxuICAvLyByZXR1cm5zIGFzIGxvZyhweCAvIHAwKVxuICBjb25zdCBwMCA9IE51bWJlcihvcGVuaW5nPy5iZW5jaG1hcmsgPz8gMCk7XG4gIGNvbnN0IHJldHVybnM6IG51bWJlcltdID0gW107XG4gIGZvciAoY29uc3QgcCBvZiBwb2ludHMpIHtcbiAgICBjb25zdCBweCA9IE51bWJlcihwPy5wcmljZSA/PyAwKTtcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHB4KSAmJiBweCA+IDAgJiYgTnVtYmVyLmlzRmluaXRlKHAwKSAmJiBwMCA+IDApIHtcbiAgICAgIHJldHVybnMucHVzaChNYXRoLmxvZyhweCAvIHAwKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcm9idXN0IHN0YXRzXG4gIGNvbnN0IG11MCA9IG1lYW4ocmV0dXJucyk7XG4gIGNvbnN0IHNkMCA9IE1hdGgubWF4KHN0ZGV2KHJldHVybnMpLCBDLnNNaW4pO1xuXG4gIC8vIHJhbmdlIGFuZCBiaW5zXG4gIGNvbnN0IHNwYW4gPSBDLmFscGhhICogc2QwO1xuICBjb25zdCByTWluID0gbXUwIC0gc3BhbjtcbiAgY29uc3Qgck1heCA9IG11MCArIHNwYW47XG5cbiAgY29uc3QgYmluc0Zyb21QYXJ0cyA9IEMuaW5uZXJCaW5zICsgMiAqIEMub3V0ZXJCaW5zICsgMTtcbiAgY29uc3QgYmlucyA9IE1hdGgubWF4KDgsIE1hdGguZmxvb3IoQy50b3RhbEJpbnMgPz8gYmluc0Zyb21QYXJ0cykpO1xuXG4gIGNvbnN0IGVkZ2VzID0gbGluc3BhY2Uock1pbiwgck1heCwgYmlucyk7XG5cbiAgLy8gY291bnRzIChuZWFyZXN0LWVkZ2UpXG4gIGNvbnN0IGNvdW50cyA9IG5ldyBBcnJheShiaW5zKS5maWxsKDApO1xuICBjb25zdCBzdGVwID0gYmlucyA+IDEgPyAock1heCAtIHJNaW4pIC8gKGJpbnMgLSAxKSA6IDE7XG4gIGlmIChzdGVwID4gMCkge1xuICAgIGZvciAoY29uc3QgciBvZiByZXR1cm5zKSB7XG4gICAgICBjb25zdCBpaSA9IGNsYW1wKE1hdGgucm91bmQoKHIgLSByTWluKSAvIHN0ZXApLCAwLCBiaW5zIC0gMSk7XG4gICAgICBjb3VudHNbaWldICs9IDE7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdG90YWwgPSBjb3VudHMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gIGNvbnN0IHByb2JzID0gY291bnRzLm1hcChjID0+ICh0b3RhbCA+IDAgPyBjIC8gdG90YWwgOiAwKSk7XG5cbiAgY29uc3QgaW5XaW46IG51bWJlcltdID0gW107XG4gIGZvciAoY29uc3QgciBvZiByZXR1cm5zKSBpZiAociA+PSByTWluICYmIHIgPD0gck1heCkgaW5XaW4ucHVzaChyKTtcbiAgY29uc3QgbXVSID0gbWVhbihpbldpbik7XG4gIGNvbnN0IHN0ZFIgPSBNYXRoLm1heChzdGRldihpbldpbiksIEMuc01pbik7XG5cbiAgcmV0dXJuIHsgZWRnZXMsIGNvdW50cywgcHJvYnMsIG11Uiwgc3RkUiwgc2lnbWFHbG9iYWw6IHN0ZFIgfTtcbn1cblxuLy8gLS0tLS0tLS0tLSBOdWNsZWkgKHBlYWsgZXh0cmFjdGlvbikgLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdE51Y2xlaShiaW5zOiBJZGhyQmlucywgazogbnVtYmVyKTogTnVjbGV1c1tdIHtcbiAgY29uc3Qgc20gPSBzbW9vdGgxZChiaW5zLmNvdW50cywgNSk7XG4gIGNvbnN0IG4gPSBzbS5sZW5ndGg7XG5cbiAgLy8gY2VudHJhbCBkaWZmZXJlbmNlcyBmb3IgMXN0LzJuZCBkZXJpdmF0aXZlc1xuICBjb25zdCBmaXJzdDogbnVtYmVyW10gPSBuZXcgQXJyYXkobikuZmlsbCgwKTtcbiAgY29uc3Qgc2Vjb25kOiBudW1iZXJbXSA9IG5ldyBBcnJheShuKS5maWxsKDApO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICBmaXJzdFtpXSA9IChzbVtpICsgMV0gLSBzbVtpIC0gMV0pIC8gMjtcbiAgICBzZWNvbmRbaV0gPSBzbVtpICsgMV0gLSAyICogc21baV0gKyBzbVtpIC0gMV07XG4gIH1cblxuICAvLyBzaW1wbGUgbG9jYWwgbWF4aW1hXG4gIGNvbnN0IHBlYWtzOiBBcnJheTx7IGk6IG51bWJlcjsgdjogbnVtYmVyIH0+ID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbiAtIDE7IGkrKykge1xuICAgIGlmIChzbVtpXSA+IHNtW2kgLSAxXSAmJiBzbVtpXSA+IHNtW2kgKyAxXSkgcGVha3MucHVzaCh7IGksIHY6IHNtW2ldIH0pO1xuICB9XG4gIHBlYWtzLnNvcnQoKGEsIGIpID0+IGIudiAtIGEudik7XG4gIGNvbnN0IHRvcCA9IHBlYWtzLnNsaWNlKDAsIE1hdGgubWF4KDEsIGspKTtcblxuICBjb25zdCB0b3RhbCA9IGJpbnMuY291bnRzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIHx8IDE7XG5cbiAgLy8gbWF0Y2ggeW91ciBOdWNsZXVzIHR5cGUgZXhhY3RseVxuICBjb25zdCBudWNsZWk6IE51Y2xldXNbXSA9IHRvcC5tYXAoKHsgaSwgdiB9KSA9PiAoe1xuICAgIGJpbkluZGV4OiBpLFxuICAgIGRlbnNpdHk6IHYgLyB0b3RhbCxcbiAgICBmaXJzdERlZ3JlZTogZmlyc3RbaV0gPz8gMCxcbiAgICBzZWNvbmREZWdyZWU6IHNlY29uZFtpXSA/PyAwLFxuICB9KSk7XG5cbiAgcmV0dXJuIG51Y2xlaTtcbn1cblxuLy8gLS0tLS0tLS0tLSBGbG9hdGluZyBNb2RlIChtZXRyaWNzKSAtLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlRk0oXG4gIHBvaW50czogTWFya2V0UG9pbnRbXSxcbiAgb3BlbmluZzogT3BlbmluZ0V4YWN0LFxuICBjZmc6IFBhcnRpYWw8SWRockNvbmZpZz4gPSB7fSxcbikge1xuICBjb25zdCBDOiBJZGhyQ29uZmlnID0geyAuLi5ERUZBVUxUX0lESFIsIC4uLmNmZyB9O1xuICBjb25zdCBoaXN0ID0gY29tcHV0ZUlkaHJCaW5zKHBvaW50cywgb3BlbmluZywgQyk7XG5cbiAgY29uc3QgbW9kZUlkeCA9IGFyZ01heChoaXN0LmNvdW50cyk7XG4gIGNvbnN0IGdmbSA9IGhpc3QuZWRnZXNbbW9kZUlkeF0gPz8gMDtcblxuICBjb25zdCBwMCA9IE51bWJlcihvcGVuaW5nPy5iZW5jaG1hcmsgPz8gMCk7XG4gIGNvbnN0IHJldHM6IG51bWJlcltdID0gW107XG4gIGZvciAoY29uc3QgcCBvZiBwb2ludHMpIHtcbiAgICBjb25zdCBweCA9IE51bWJlcihwPy5wcmljZSA/PyAwKTtcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHB4KSAmJiBweCA+IDAgJiYgTnVtYmVyLmlzRmluaXRlKHAwKSAmJiBwMCA+IDApIHtcbiAgICAgIHJldHMucHVzaChNYXRoLmxvZyhweCAvIHAwKSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc2lnbWEgPSBoaXN0LnNpZ21hR2xvYmFsO1xuICBjb25zdCB6QWJzID0gcmV0cy5sZW5ndGhcbiAgICA/IHJldHMucmVkdWNlKChhLCByKSA9PiBhICsgTWF0aC5hYnMoKHIgLSBoaXN0Lm11UikgLyAoc2lnbWEgfHwgMSkpLCAwKSAvIHJldHMubGVuZ3RoXG4gICAgOiAwO1xuXG4gIC8vIGNydWRlIGlubmVyL291dGVyIG1hc3MgYXJvdW5kIHRoZSBtb2RlXG4gIGNvbnN0IGxlZnRDb3VudCAgPSBoaXN0LmNvdW50cy5zbGljZSgwLCBtb2RlSWR4KS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgY29uc3QgcmlnaHRDb3VudCA9IGhpc3QuY291bnRzLnNsaWNlKG1vZGVJZHggKyAxKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgY29uc3QgdklubmVyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obGVmdENvdW50LCByaWdodENvdW50KSk7XG4gIGNvbnN0IHZPdXRlciA9IE1hdGgubWF4KDAsIGxlZnRDb3VudCArIHJpZ2h0Q291bnQgLSB2SW5uZXIpO1xuXG4gIC8vIGhpc3RvZ3JhbSByb3VnaG5lc3MgaW5kaWNhdG9yc1xuICBjb25zdCBjZW50ZXIgPSBoaXN0Lm11UjtcbiAgY29uc3QgaW5lcnRpYSA9IHJldHMucmVkdWNlKChhY2MsIHIpID0+IGFjYyArIChyIC0gY2VudGVyKSAqKiAyLCAwKSAvIChyZXRzLmxlbmd0aCB8fCAxKTtcbiAgY29uc3Qgc20gPSBzbW9vdGgxZChoaXN0LmNvdW50cywgMyk7XG4gIGxldCBkaXNydXB0aW9uID0gMDtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBzbS5sZW5ndGg7IGkrKykgZGlzcnVwdGlvbiArPSBNYXRoLmFicyhzbVtpXSAtIHNtW2kgLSAxXSk7XG4gIGRpc3J1cHRpb24gLz0gKHNtLmxlbmd0aCB8fCAxKTtcblxuICBjb25zdCBudWNsZWkgPSBleHRyYWN0TnVjbGVpKGhpc3QsIEMudG9wTik7XG5cbiAgcmV0dXJuIHtcbiAgICBnZm0sXG4gICAgY29uZmlkZW5jZTogMSAvICgxICsgekFicyksXG4gICAgaW5lcnRpYSxcbiAgICBkaXNydXB0aW9uLFxuICAgIHpNZWFuQWJzOiB6QWJzLFxuICAgIHNpZ21hR2xvYmFsOiBzaWdtYSxcbiAgICB2SW5uZXIsXG4gICAgdk91dGVyLFxuICAgIG51Y2xlaSwgLy8gbWF0Y2hlcyBOdWNsZXVzIHR5cGUgdXNlZCBpbiB5b3VyIHJlcG9cbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLSBIZWxwZXJzIC0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVJZGhyQmluc04oXG4gIHBvaW50czogTWFya2V0UG9pbnRbXSxcbiAgb3BlbmluZzogT3BlbmluZ0V4YWN0LFxuICBjZmc6IFBhcnRpYWw8SWRockNvbmZpZz4gPSB7fSxcbiAgTiA9IDEyOFxuKSB7XG4gIHJldHVybiBjb21wdXRlSWRockJpbnMocG9pbnRzLCBvcGVuaW5nLCB7IC4uLmNmZywgdG90YWxCaW5zOiBOIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplSWRocihpZGhyOiBJZGhyQmlucykge1xuICByZXR1cm4ge1xuICAgIGVkZ2VzOiBpZGhyLmVkZ2VzLFxuICAgIGNvdW50czogaWRoci5jb3VudHMsXG4gICAgcHJvYnM6IGlkaHIucHJvYnMsXG4gICAgbXVSOiBpZGhyLm11UixcbiAgICBzdGRSOiBpZGhyLnN0ZFIsXG4gICAgc2lnbWFHbG9iYWw6IGlkaHIuc2lnbWFHbG9iYWwsXG4gIH07XG59XG5cbi8vIEtlZXAgYnVpbGRTdHJBdXggY29tcGF0aWJpbGl0eSBpZiBpdCBpbXBvcnRzIHsgaWRociB9XG5leHBvcnQgZnVuY3Rpb24gaWRocihcbiAgcG9pbnRzOiBNYXJrZXRQb2ludFtdLFxuICBvcGVuaW5nOiBPcGVuaW5nRXhhY3QsXG4gIGNmZzogUGFydGlhbDxJZGhyQ29uZmlnPiA9IHt9XG4pOiBJZGhyUmVzdWx0IHtcbiAgY29uc3QgYmlucyA9IGNvbXB1dGVJZGhyQmlucyhwb2ludHMsIG9wZW5pbmcsIGNmZyk7XG4gIGNvbnN0IG51Y2xlaSA9IGV4dHJhY3ROdWNsZWkoYmlucywgKGNmZy50b3BOID8/IERFRkFVTFRfSURIUi50b3BOKSk7XG4gIHJldHVybiB7IG51Y2xlaSwgc2FtcGxlRmlyc3REZWdyZWVzOiBbXSwgb3V0bGllckNvdW50OiAwIH07XG59XG4iXSwibmFtZXMiOlsiREVGQVVMVF9JREhSIiwiaW5uZXJCaW5zIiwib3V0ZXJCaW5zIiwiYWxwaGEiLCJzTWluIiwidG9wTiIsImNsYW1wIiwibiIsImxvIiwiaGkiLCJtZWFuIiwieHMiLCJsZW5ndGgiLCJyZWR1Y2UiLCJhIiwiYiIsInN0ZGV2IiwibSIsInYiLCJhY2MiLCJ4IiwiTWF0aCIsInNxcnQiLCJtYXgiLCJsaW5zcGFjZSIsIm1pbiIsInN0ZXAiLCJBcnJheSIsImZyb20iLCJfIiwiaSIsImFyZ01heCIsImlkeCIsImJlc3QiLCJJbmZpbml0eSIsInNtb290aDFkIiwiayIsInNsaWNlIiwiaGFsZiIsImZsb29yIiwib3V0IiwiZmlsbCIsInMiLCJjIiwiaiIsImNvbXB1dGVJZGhyQmlucyIsInBvaW50cyIsIm9wZW5pbmciLCJjZmciLCJDIiwicDAiLCJOdW1iZXIiLCJiZW5jaG1hcmsiLCJyZXR1cm5zIiwicCIsInB4IiwicHJpY2UiLCJpc0Zpbml0ZSIsInB1c2giLCJsb2ciLCJtdTAiLCJzZDAiLCJzcGFuIiwick1pbiIsInJNYXgiLCJiaW5zRnJvbVBhcnRzIiwiYmlucyIsInRvdGFsQmlucyIsImVkZ2VzIiwiY291bnRzIiwiciIsImlpIiwicm91bmQiLCJ0b3RhbCIsInByb2JzIiwibWFwIiwiaW5XaW4iLCJtdVIiLCJzdGRSIiwic2lnbWFHbG9iYWwiLCJleHRyYWN0TnVjbGVpIiwic20iLCJmaXJzdCIsInNlY29uZCIsInBlYWtzIiwic29ydCIsInRvcCIsIm51Y2xlaSIsImJpbkluZGV4IiwiZGVuc2l0eSIsImZpcnN0RGVncmVlIiwic2Vjb25kRGVncmVlIiwiY29tcHV0ZUZNIiwiaGlzdCIsIm1vZGVJZHgiLCJnZm0iLCJyZXRzIiwic2lnbWEiLCJ6QWJzIiwiYWJzIiwibGVmdENvdW50IiwicmlnaHRDb3VudCIsInZJbm5lciIsInZPdXRlciIsImNlbnRlciIsImluZXJ0aWEiLCJkaXNydXB0aW9uIiwiY29uZmlkZW5jZSIsInpNZWFuQWJzIiwiY29tcHV0ZUlkaHJCaW5zTiIsIk4iLCJzZXJpYWxpemVJZGhyIiwiaWRociIsInNhbXBsZUZpcnN0RGVncmVlcyIsIm91dGxpZXJDb3VudCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/frame/idhr.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/frame/session.ts":
/*!****************************************************!*\
  !*** ./src/core/features/str-aux/frame/session.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportStreams: () => (/* binding */ exportStreams),\n/* harmony export */   getOrInitSymbolSession: () => (/* binding */ getOrInitSymbolSession),\n/* harmony export */   updateSymbolSession: () => (/* binding */ updateSymbolSession)\n/* harmony export */ });\n// --- TYPES ---\nconst SESS = globalThis.__STR_AUX_SESS__ ?? new Map();\nglobalThis.__STR_AUX_SESS__ = SESS;\nfunction sgn(x, eps = 0) {\n    if (x > eps) return 1;\n    if (x < -eps) return -1;\n    return 0;\n}\nfunction getOrInitSymbolSession(sessionId, symbol, openingPrice, nowTs, etaPct = 0.05, epsShiftPct = 0.2, K = 5) {\n    const key = `${sessionId}:${symbol}`;\n    const cur = SESS.get(key);\n    if (cur) return cur;\n    const snap0 = {\n        ts: nowTs,\n        price: openingPrice,\n        benchPct: 0,\n        pctDrv: 0,\n        pct24h: 0\n    };\n    const ss = {\n        openingTs: nowTs,\n        openingPrice,\n        priceMin: openingPrice,\n        priceMax: openingPrice,\n        benchPctMin: 0,\n        benchPctMax: 0,\n        swaps: 0,\n        shifts: 0,\n        etaPct,\n        epsShiftPct,\n        K,\n        lastBenchSign: 0,\n        gfmRefPrice: undefined,\n        gfmCalcPrice: undefined,\n        gfmOpeningPrice: undefined,\n        aboveCount: 0,\n        belowCount: 0,\n        uiEpoch: 0,\n        snapPrev: snap0,\n        snapCur: snap0,\n        greatestBenchAbs: 0,\n        greatestDrvAbs: 0,\n        greatestPct24hAbs: 0,\n        gfmDeltaAbsPct: 0,\n        lastPrice: openingPrice\n    };\n    SESS.set(key, ss);\n    return ss;\n}\n/**\n * Update with latest market data + CURRENT calculated GFM (GFMc).\n * - Initializes GFMr once (first valid GFMc).\n * - Builds band around GFMr. Counts consecutive out-of-band hits.\n * - On confirmation (>=K): shift, snapshot prev/cur, re-anchor GFMr = current GFMc, uiEpoch++.\n */ function updateSymbolSession(ss, price, ts, gfmCalcPrice, pct24hNow) {\n    // record current calc GFM\n    if (Number.isFinite(gfmCalcPrice) && gfmCalcPrice > 0) {\n        ss.gfmCalcPrice = gfmCalcPrice;\n    }\n    // initialize anchor GFMr once\n    if (ss.gfmRefPrice === undefined && ss.gfmCalcPrice !== undefined && ss.gfmCalcPrice > 0) {\n        ss.gfmRefPrice = ss.gfmCalcPrice;\n        if (ss.gfmOpeningPrice === undefined) {\n            ss.gfmOpeningPrice = ss.gfmCalcPrice;\n        }\n    }\n    // instantaneous\n    const benchPct = (price / ss.openingPrice - 1) * 100;\n    const prevPrice = ss.lastPrice ?? price;\n    const pctDrv = (price / prevPrice - 1) * 100;\n    ss.lastPrice = price;\n    // stats\n    ss.priceMin = Math.min(ss.priceMin, price);\n    ss.priceMax = Math.max(ss.priceMax, price);\n    ss.benchPctMin = Math.min(ss.benchPctMin, benchPct);\n    ss.benchPctMax = Math.max(ss.benchPctMax, benchPct);\n    // swaps with small hysteresis on benchPct\n    const s = sgn(benchPct, ss.etaPct);\n    if (s !== 0 && ss.lastBenchSign !== 0 && s !== ss.lastBenchSign) ss.swaps += 1;\n    if (s !== 0) ss.lastBenchSign = s;\n    // GFM relative to GFMr\n    const refGfm = ss.gfmRefPrice;\n    const calcGfm = ss.gfmCalcPrice;\n    const deltaPct = refGfm && refGfm > 0 && calcGfm && calcGfm > 0 ? (calcGfm / refGfm - 1) * 100 : 0;\n    ss.gfmDeltaAbsPct = Math.abs(deltaPct);\n    // shift detection: positive delta vs GFMr must persist for K cycles\n    let justShifted = false;\n    if (refGfm && refGfm > 0 && calcGfm && calcGfm > 0) {\n        if (deltaPct >= ss.epsShiftPct) {\n            ss.aboveCount += 1;\n        } else {\n            ss.aboveCount = 0;\n        }\n        ss.belowCount = 0;\n        if (ss.aboveCount >= ss.K) {\n            // snapshot + re-anchor to CURRENT GFMc\n            snapshotOnShift(ss, price, ts, benchPct, pctDrv, pct24hNow);\n            ss.gfmRefPrice = calcGfm; // GFMr  GFMc\n            ss.gfmDeltaAbsPct = 0;\n            ss.aboveCount = 0;\n            ss.belowCount = 0;\n            ss.shifts += 1;\n            ss.uiEpoch += 1; // UI change signal\n            justShifted = true;\n        }\n    } else {\n        ss.aboveCount = 0;\n        ss.belowCount = 0;\n    }\n    // greatest magnitudes\n    ss.greatestBenchAbs = Math.max(ss.greatestBenchAbs, Math.abs(benchPct));\n    ss.greatestDrvAbs = Math.max(ss.greatestDrvAbs, Math.abs(pctDrv));\n    ss.greatestPct24hAbs = Math.max(ss.greatestPct24hAbs, Math.abs(pct24hNow));\n    return {\n        benchPct,\n        pctDrv,\n        pct24h: pct24hNow,\n        isShift: justShifted,\n        gfmDeltaAbsPct: ss.gfmDeltaAbsPct,\n        gfmRefPrice: ss.gfmRefPrice ?? null,\n        gfmCalcPrice: ss.gfmCalcPrice ?? null,\n        uiEpoch: ss.uiEpoch\n    };\n}\nfunction snapshotOnShift(ss, price, ts, benchPct, pctDrv, pct24h) {\n    ss.snapPrev = ss.snapCur;\n    ss.snapCur = {\n        ts,\n        price,\n        benchPct,\n        pctDrv,\n        pct24h\n    };\n}\nfunction exportStreams(ss) {\n    return {\n        benchmark: {\n            prev: ss.snapPrev.price,\n            cur: ss.snapCur.price,\n            greatest: ss.priceMax\n        },\n        pct24h: {\n            prev: ss.snapPrev.pct24h,\n            cur: ss.snapCur.pct24h,\n            greatest: ss.greatestPct24hAbs\n        },\n        pct_drv: {\n            prev: ss.snapPrev.pctDrv,\n            cur: ss.snapCur.pctDrv,\n            greatest: ss.greatestDrvAbs\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L2ZyYW1lL3Nlc3Npb24udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0JBQWdCO0FBcUVoQixNQUFNQSxPQUNKLFdBQW9CRSxnQkFBZ0IsSUFBSSxJQUFJQztBQUM3Q0YsV0FBbUJDLGdCQUFnQixHQUFHRjtBQUV2QyxTQUFTSSxJQUFJQyxDQUFTLEVBQUVDLE1BQU0sQ0FBQztJQUM3QixJQUFJRCxJQUFJQyxLQUFLLE9BQU87SUFDcEIsSUFBSUQsSUFBSSxDQUFDQyxLQUFLLE9BQU8sQ0FBQztJQUN0QixPQUFPO0FBQ1Q7QUFFTyxTQUFTQyx1QkFDZEMsU0FBaUIsRUFDakJDLE1BQWMsRUFDZEMsWUFBb0IsRUFDcEJDLEtBQWEsRUFDYkMsU0FBUyxJQUFJLEVBQ2JDLGNBQWMsR0FBRyxFQUNqQkMsSUFBSSxDQUFDO0lBRUwsTUFBTUMsTUFBTSxHQUFHUCxVQUFVLENBQUMsRUFBRUMsUUFBUTtJQUNwQyxNQUFNTyxNQUFNaEIsS0FBS2lCLEdBQUcsQ0FBQ0Y7SUFDckIsSUFBSUMsS0FBSyxPQUFPQTtJQUVoQixNQUFNRSxRQUFrQjtRQUFFQyxJQUFJUjtRQUFPUyxPQUFPVjtRQUFjVyxVQUFVO1FBQUdDLFFBQVE7UUFBR0MsUUFBUTtJQUFFO0lBQzVGLE1BQU1DLEtBQW9CO1FBQ3hCQyxXQUFXZDtRQUNYRDtRQUVBZ0IsVUFBVWhCO1FBQ1ZpQixVQUFVakI7UUFDVmtCLGFBQWE7UUFDYkMsYUFBYTtRQUViQyxPQUFPO1FBQ1BDLFFBQVE7UUFFUm5CO1FBQ0FDO1FBQ0FDO1FBRUFrQixlQUFlO1FBRWZDLGFBQWFDO1FBQ2JDLGNBQWNEO1FBQ2RFLGlCQUFpQkY7UUFFakJHLFlBQVk7UUFDWkMsWUFBWTtRQUVaQyxTQUFTO1FBRVRDLFVBQVV0QjtRQUNWdUIsU0FBU3ZCO1FBRVR3QixrQkFBa0I7UUFDbEJDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBRW5CQyxnQkFBZ0I7UUFFaEJDLFdBQVdwQztJQUNi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QVEsQ0FBQ2xCLE1BQU07WUFBRU4sS0FBS1EsR0FBR2lCLE9BQU8sQ0FBQ25CLE1BQU07WUFBRTZDLFVBQVUzQyxHQUFHbUIsY0FBYztRQUFDO0lBQzdGO0FBQ0YiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxjb3JlXFxmZWF0dXJlc1xcc3RyLWF1eFxcZnJhbWVcXHNlc3Npb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gLS0tIFRZUEVTIC0tLVxuZXhwb3J0IHR5cGUgU25hcHNob3QgPSB7XG4gIHRzOiBudW1iZXI7XG4gIHByaWNlOiBudW1iZXI7XG4gIGJlbmNoUGN0OiBudW1iZXI7ICAgLy8gMTAwKihwL29wZW4tMSlcbiAgcGN0RHJ2OiBudW1iZXI7ICAgICAvLyAxMDAqKHBfdC9wX3t0LTF9LTEpXG4gIHBjdDI0aDogbnVtYmVyOyAgICAgLy8gZnJvbSBCaW5hbmNlIDI0aFxufTtcblxuZXhwb3J0IHR5cGUgU3RyZWFtcyA9IHtcbiAgYmVuY2htYXJrOiB7IHByZXY6IG51bWJlcjsgY3VyOiBudW1iZXI7IGdyZWF0ZXN0OiBudW1iZXIgfTtcbiAgcGN0MjRoOiAgICB7IHByZXY6IG51bWJlcjsgY3VyOiBudW1iZXI7IGdyZWF0ZXN0OiBudW1iZXIgfTtcbiAgcGN0X2RydjogICB7IHByZXY6IG51bWJlcjsgY3VyOiBudW1iZXI7IGdyZWF0ZXN0OiBudW1iZXIgfTtcbn07XG5cbmV4cG9ydCB0eXBlIFN5bWJvbFNlc3Npb24gPSB7XG4gIG9wZW5pbmdUczogbnVtYmVyO1xuICBvcGVuaW5nUHJpY2U6IG51bWJlcjtcblxuICAvLyBzdGF0c1xuICBwcmljZU1pbjogbnVtYmVyO1xuICBwcmljZU1heDogbnVtYmVyO1xuICBiZW5jaFBjdE1pbjogbnVtYmVyO1xuICBiZW5jaFBjdE1heDogbnVtYmVyO1xuXG4gIC8vIGNvdW50ZXJzXG4gIHN3YXBzOiBudW1iZXI7XG4gIHNoaWZ0czogbnVtYmVyO1xuXG4gIC8vIHRocmVzaG9sZHNcbiAgZXRhUGN0OiBudW1iZXI7ICAgICAgLy8gc3dhcCBoeXN0ZXJlc2lzICUsIHRpbnkgZS5nLiAwLjA1XG4gIGVwc1NoaWZ0UGN0OiBudW1iZXI7IC8vIHNoaWZ0IGJhbmQgJSwgZS5nLiAwLjJcbiAgSzogbnVtYmVyOyAgICAgICAgICAgLy8gY29uc2VjdXRpdmUgY3ljbGVzXG5cbiAgLy8gc2lnbnNcbiAgbGFzdEJlbmNoU2lnbjogbnVtYmVyO1xuXG4gIC8vIEdGTTpcbiAgZ2ZtUmVmUHJpY2U/OiBudW1iZXI7ICAgICAgLy8gR0ZNciAoYW5jaG9yKTogbW92ZXMgT05MWSBvbiBjb25maXJtZWQgc2hpZnRcbiAgZ2ZtQ2FsY1ByaWNlPzogbnVtYmVyOyAgICAgLy8gR0ZNYyAobGF0ZXN0IGNhbGMpOiByZWNhbGN1bGF0ZWQgZXZlcnkgdGlja1xuICBnZm1PcGVuaW5nUHJpY2U/OiBudW1iZXI7ICAvLyBHRk0gYXQgc2Vzc2lvbiBzdGFydCAob0dGTSlcbiAgXG4gIC8vIHNoaWZ0IHN0YWdpbmdcbiAgYWJvdmVDb3VudDogbnVtYmVyO1xuICBiZWxvd0NvdW50OiBudW1iZXI7XG5cbiAgLy8gVUkgZXBvY2ggKGluY3JlbWVudHMgb25seSBvbiBzaGlmdClcbiAgdWlFcG9jaDogbnVtYmVyO1xuXG4gIC8vIHNuYXBzaG90cyAoYWR2YW5jZSBvbmx5IG9uIHNoaWZ0KVxuICBzbmFwUHJldjogU25hcHNob3Q7XG4gIHNuYXBDdXI6IFNuYXBzaG90O1xuXG4gIC8vIGdyZWF0ZXN0IG1hZ25pdHVkZXMgKGFicylcbiAgZ3JlYXRlc3RCZW5jaEFiczogbnVtYmVyO1xuICBncmVhdGVzdERydkFiczogbnVtYmVyO1xuICBncmVhdGVzdFBjdDI0aEFiczogbnVtYmVyO1xuXG4gIC8vIGRpYWdub3N0aWNzXG4gIGdmbURlbHRhQWJzUGN0OiBudW1iZXI7XG5cbiAgbGFzdFByaWNlPzogbnVtYmVyO1xufTtcblxuLy8gSE1SLXNhZmUgc3RvcmVcbmRlY2xhcmUgZ2xvYmFsIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhclxuICB2YXIgX19TVFJfQVVYX1NFU1NfXzogTWFwPHN0cmluZywgU3ltYm9sU2Vzc2lvbj4gfCB1bmRlZmluZWQ7XG59XG5jb25zdCBTRVNTOiBNYXA8c3RyaW5nLCBTeW1ib2xTZXNzaW9uPiA9XG4gIChnbG9iYWxUaGlzIGFzIGFueSkuX19TVFJfQVVYX1NFU1NfXyA/PyBuZXcgTWFwKCk7XG4oZ2xvYmFsVGhpcyBhcyBhbnkpLl9fU1RSX0FVWF9TRVNTX18gPSBTRVNTO1xuXG5mdW5jdGlvbiBzZ24oeDogbnVtYmVyLCBlcHMgPSAwKSB7XG4gIGlmICh4ID4gZXBzKSByZXR1cm4gMTtcbiAgaWYgKHggPCAtZXBzKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3JJbml0U3ltYm9sU2Vzc2lvbihcbiAgc2Vzc2lvbklkOiBzdHJpbmcsXG4gIHN5bWJvbDogc3RyaW5nLFxuICBvcGVuaW5nUHJpY2U6IG51bWJlcixcbiAgbm93VHM6IG51bWJlcixcbiAgZXRhUGN0ID0gMC4wNSxcbiAgZXBzU2hpZnRQY3QgPSAwLjIsXG4gIEsgPSA1XG4pOiBTeW1ib2xTZXNzaW9uIHtcbiAgY29uc3Qga2V5ID0gYCR7c2Vzc2lvbklkfToke3N5bWJvbH1gO1xuICBjb25zdCBjdXIgPSBTRVNTLmdldChrZXkpO1xuICBpZiAoY3VyKSByZXR1cm4gY3VyO1xuXG4gIGNvbnN0IHNuYXAwOiBTbmFwc2hvdCA9IHsgdHM6IG5vd1RzLCBwcmljZTogb3BlbmluZ1ByaWNlLCBiZW5jaFBjdDogMCwgcGN0RHJ2OiAwLCBwY3QyNGg6IDAgfTtcbiAgY29uc3Qgc3M6IFN5bWJvbFNlc3Npb24gPSB7XG4gICAgb3BlbmluZ1RzOiBub3dUcyxcbiAgICBvcGVuaW5nUHJpY2UsXG5cbiAgICBwcmljZU1pbjogb3BlbmluZ1ByaWNlLFxuICAgIHByaWNlTWF4OiBvcGVuaW5nUHJpY2UsXG4gICAgYmVuY2hQY3RNaW46IDAsXG4gICAgYmVuY2hQY3RNYXg6IDAsXG5cbiAgICBzd2FwczogMCxcbiAgICBzaGlmdHM6IDAsXG5cbiAgICBldGFQY3QsXG4gICAgZXBzU2hpZnRQY3QsXG4gICAgSyxcblxuICAgIGxhc3RCZW5jaFNpZ246IDAsXG5cbiAgICBnZm1SZWZQcmljZTogdW5kZWZpbmVkLFxuICAgIGdmbUNhbGNQcmljZTogdW5kZWZpbmVkLFxuICAgIGdmbU9wZW5pbmdQcmljZTogdW5kZWZpbmVkLFxuXG4gICAgYWJvdmVDb3VudDogMCxcbiAgICBiZWxvd0NvdW50OiAwLFxuXG4gICAgdWlFcG9jaDogMCxcblxuICAgIHNuYXBQcmV2OiBzbmFwMCxcbiAgICBzbmFwQ3VyOiBzbmFwMCxcblxuICAgIGdyZWF0ZXN0QmVuY2hBYnM6IDAsXG4gICAgZ3JlYXRlc3REcnZBYnM6IDAsXG4gICAgZ3JlYXRlc3RQY3QyNGhBYnM6IDAsXG5cbiAgICBnZm1EZWx0YUFic1BjdDogMCxcblxuICAgIGxhc3RQcmljZTogb3BlbmluZ1ByaWNlLFxuICB9O1xuICBTRVNTLnNldChrZXksIHNzKTtcbiAgcmV0dXJuIHNzO1xufVxuXG4vKipcbiAqIFVwZGF0ZSB3aXRoIGxhdGVzdCBtYXJrZXQgZGF0YSArIENVUlJFTlQgY2FsY3VsYXRlZCBHRk0gKEdGTWMpLlxuICogLSBJbml0aWFsaXplcyBHRk1yIG9uY2UgKGZpcnN0IHZhbGlkIEdGTWMpLlxuICogLSBCdWlsZHMgYmFuZCBhcm91bmQgR0ZNci4gQ291bnRzIGNvbnNlY3V0aXZlIG91dC1vZi1iYW5kIGhpdHMuXG4gKiAtIE9uIGNvbmZpcm1hdGlvbiAoPj1LKTogc2hpZnQsIHNuYXBzaG90IHByZXYvY3VyLCByZS1hbmNob3IgR0ZNciA9IGN1cnJlbnQgR0ZNYywgdWlFcG9jaCsrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlU3ltYm9sU2Vzc2lvbihcbiAgc3M6IFN5bWJvbFNlc3Npb24sXG4gIHByaWNlOiBudW1iZXIsXG4gIHRzOiBudW1iZXIsXG4gIGdmbUNhbGNQcmljZTogbnVtYmVyLCAvLyBHRk1jXG4gIHBjdDI0aE5vdzogbnVtYmVyXG4pIHtcbiAgLy8gcmVjb3JkIGN1cnJlbnQgY2FsYyBHRk1cbiAgaWYgKE51bWJlci5pc0Zpbml0ZShnZm1DYWxjUHJpY2UpICYmIGdmbUNhbGNQcmljZSA+IDApIHtcbiAgICBzcy5nZm1DYWxjUHJpY2UgPSBnZm1DYWxjUHJpY2U7XG4gIH1cblxuICAvLyBpbml0aWFsaXplIGFuY2hvciBHRk1yIG9uY2VcbiAgaWYgKHNzLmdmbVJlZlByaWNlID09PSB1bmRlZmluZWQgJiYgc3MuZ2ZtQ2FsY1ByaWNlICE9PSB1bmRlZmluZWQgJiYgc3MuZ2ZtQ2FsY1ByaWNlID4gMCkge1xuICAgIHNzLmdmbVJlZlByaWNlID0gc3MuZ2ZtQ2FsY1ByaWNlO1xuICAgIGlmIChzcy5nZm1PcGVuaW5nUHJpY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3MuZ2ZtT3BlbmluZ1ByaWNlID0gc3MuZ2ZtQ2FsY1ByaWNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluc3RhbnRhbmVvdXNcbiAgY29uc3QgYmVuY2hQY3QgPSAoKHByaWNlIC8gc3Mub3BlbmluZ1ByaWNlKSAtIDEpICogMTAwO1xuICBjb25zdCBwcmV2UHJpY2UgPSBzcy5sYXN0UHJpY2UgPz8gcHJpY2U7XG4gIGNvbnN0IHBjdERydiA9ICgocHJpY2UgLyBwcmV2UHJpY2UpIC0gMSkgKiAxMDA7XG4gIHNzLmxhc3RQcmljZSA9IHByaWNlO1xuXG4gIC8vIHN0YXRzXG4gIHNzLnByaWNlTWluID0gTWF0aC5taW4oc3MucHJpY2VNaW4sIHByaWNlKTtcbiAgc3MucHJpY2VNYXggPSBNYXRoLm1heChzcy5wcmljZU1heCwgcHJpY2UpO1xuICBzcy5iZW5jaFBjdE1pbiA9IE1hdGgubWluKHNzLmJlbmNoUGN0TWluLCBiZW5jaFBjdCk7XG4gIHNzLmJlbmNoUGN0TWF4ID0gTWF0aC5tYXgoc3MuYmVuY2hQY3RNYXgsIGJlbmNoUGN0KTtcblxuICAvLyBzd2FwcyB3aXRoIHNtYWxsIGh5c3RlcmVzaXMgb24gYmVuY2hQY3RcbiAgY29uc3QgcyA9IHNnbihiZW5jaFBjdCwgc3MuZXRhUGN0KTtcbiAgaWYgKHMgIT09IDAgJiYgc3MubGFzdEJlbmNoU2lnbiAhPT0gMCAmJiBzICE9PSBzcy5sYXN0QmVuY2hTaWduKSBzcy5zd2FwcyArPSAxO1xuICBpZiAocyAhPT0gMCkgc3MubGFzdEJlbmNoU2lnbiA9IHM7XG5cbiAgLy8gR0ZNzpQgcmVsYXRpdmUgdG8gR0ZNclxuICBjb25zdCByZWZHZm0gPSBzcy5nZm1SZWZQcmljZTtcbiAgY29uc3QgY2FsY0dmbSA9IHNzLmdmbUNhbGNQcmljZTtcbiAgY29uc3QgZGVsdGFQY3QgPVxuICAgIHJlZkdmbSAmJiByZWZHZm0gPiAwICYmIGNhbGNHZm0gJiYgY2FsY0dmbSA+IDBcbiAgICAgID8gKChjYWxjR2ZtIC8gcmVmR2ZtKSAtIDEpICogMTAwXG4gICAgICA6IDA7XG4gIHNzLmdmbURlbHRhQWJzUGN0ID0gTWF0aC5hYnMoZGVsdGFQY3QpO1xuXG4gIC8vIHNoaWZ0IGRldGVjdGlvbjogcG9zaXRpdmUgZGVsdGEgdnMgR0ZNciBtdXN0IHBlcnNpc3QgZm9yIEsgY3ljbGVzXG4gIGxldCBqdXN0U2hpZnRlZCA9IGZhbHNlO1xuICBpZiAocmVmR2ZtICYmIHJlZkdmbSA+IDAgJiYgY2FsY0dmbSAmJiBjYWxjR2ZtID4gMCkge1xuICAgIGlmIChkZWx0YVBjdCA+PSBzcy5lcHNTaGlmdFBjdCkge1xuICAgICAgc3MuYWJvdmVDb3VudCArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzcy5hYm92ZUNvdW50ID0gMDtcbiAgICB9XG4gICAgc3MuYmVsb3dDb3VudCA9IDA7XG5cbiAgICBpZiAoc3MuYWJvdmVDb3VudCA+PSBzcy5LKSB7XG4gICAgICAvLyBzbmFwc2hvdCArIHJlLWFuY2hvciB0byBDVVJSRU5UIEdGTWNcbiAgICAgIHNuYXBzaG90T25TaGlmdChzcywgcHJpY2UsIHRzLCBiZW5jaFBjdCwgcGN0RHJ2LCBwY3QyNGhOb3cpO1xuICAgICAgc3MuZ2ZtUmVmUHJpY2UgPSBjYWxjR2ZtOyAvLyBHRk1yIOKGkCBHRk1jXG4gICAgICBzcy5nZm1EZWx0YUFic1BjdCA9IDA7XG4gICAgICBzcy5hYm92ZUNvdW50ID0gMDtcbiAgICAgIHNzLmJlbG93Q291bnQgPSAwO1xuICAgICAgc3Muc2hpZnRzICs9IDE7XG4gICAgICBzcy51aUVwb2NoICs9IDE7ICAgICAgICAgICAgICAgICAvLyBVSSBjaGFuZ2Ugc2lnbmFsXG4gICAgICBqdXN0U2hpZnRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNzLmFib3ZlQ291bnQgPSAwO1xuICAgIHNzLmJlbG93Q291bnQgPSAwO1xuICB9XG5cbiAgLy8gZ3JlYXRlc3QgbWFnbml0dWRlc1xuICBzcy5ncmVhdGVzdEJlbmNoQWJzICA9IE1hdGgubWF4KHNzLmdyZWF0ZXN0QmVuY2hBYnMsICBNYXRoLmFicyhiZW5jaFBjdCkpO1xuICBzcy5ncmVhdGVzdERydkFicyAgICA9IE1hdGgubWF4KHNzLmdyZWF0ZXN0RHJ2QWJzLCAgICBNYXRoLmFicyhwY3REcnYpKTtcbiAgc3MuZ3JlYXRlc3RQY3QyNGhBYnMgPSBNYXRoLm1heChzcy5ncmVhdGVzdFBjdDI0aEFicywgTWF0aC5hYnMocGN0MjRoTm93KSk7XG5cbiAgcmV0dXJuIHtcbiAgICBiZW5jaFBjdCwgcGN0RHJ2LCBwY3QyNGg6IHBjdDI0aE5vdyxcbiAgICBpc1NoaWZ0OiBqdXN0U2hpZnRlZCxcbiAgICBnZm1EZWx0YUFic1BjdDogc3MuZ2ZtRGVsdGFBYnNQY3QsXG4gICAgZ2ZtUmVmUHJpY2U6IHNzLmdmbVJlZlByaWNlID8/IG51bGwsXG4gICAgZ2ZtQ2FsY1ByaWNlOiBzcy5nZm1DYWxjUHJpY2UgPz8gbnVsbCxcbiAgICB1aUVwb2NoOiBzcy51aUVwb2NoLFxuICB9O1xufVxuXG5mdW5jdGlvbiBzbmFwc2hvdE9uU2hpZnQoXG4gIHNzOiBTeW1ib2xTZXNzaW9uLFxuICBwcmljZTogbnVtYmVyLFxuICB0czogbnVtYmVyLFxuICBiZW5jaFBjdDogbnVtYmVyLFxuICBwY3REcnY6IG51bWJlcixcbiAgcGN0MjRoOiBudW1iZXJcbikge1xuICBzcy5zbmFwUHJldiA9IHNzLnNuYXBDdXI7XG4gIHNzLnNuYXBDdXIgPSB7IHRzLCBwcmljZSwgYmVuY2hQY3QsIHBjdERydiwgcGN0MjRoIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBvcnRTdHJlYW1zKHNzOiBTeW1ib2xTZXNzaW9uKTogU3RyZWFtcyB7XG4gIHJldHVybiB7XG4gICAgYmVuY2htYXJrOiB7IHByZXY6IHNzLnNuYXBQcmV2LnByaWNlLCBjdXI6IHNzLnNuYXBDdXIucHJpY2UsIGdyZWF0ZXN0OiBzcy5wcmljZU1heCB9LFxuICAgIHBjdDI0aDogICAgeyBwcmV2OiBzcy5zbmFwUHJldi5wY3QyNGgsIGN1cjogc3Muc25hcEN1ci5wY3QyNGgsIGdyZWF0ZXN0OiBzcy5ncmVhdGVzdFBjdDI0aEFicyB9LFxuICAgIHBjdF9kcnY6ICAgeyBwcmV2OiBzcy5zbmFwUHJldi5wY3REcnYsIGN1cjogc3Muc25hcEN1ci5wY3REcnYsIGdyZWF0ZXN0OiBzcy5ncmVhdGVzdERydkFicyB9LFxuICB9O1xufVxuIl0sIm5hbWVzIjpbIlNFU1MiLCJnbG9iYWxUaGlzIiwiX19TVFJfQVVYX1NFU1NfXyIsIk1hcCIsInNnbiIsIngiLCJlcHMiLCJnZXRPckluaXRTeW1ib2xTZXNzaW9uIiwic2Vzc2lvbklkIiwic3ltYm9sIiwib3BlbmluZ1ByaWNlIiwibm93VHMiLCJldGFQY3QiLCJlcHNTaGlmdFBjdCIsIksiLCJrZXkiLCJjdXIiLCJnZXQiLCJzbmFwMCIsInRzIiwicHJpY2UiLCJiZW5jaFBjdCIsInBjdERydiIsInBjdDI0aCIsInNzIiwib3BlbmluZ1RzIiwicHJpY2VNaW4iLCJwcmljZU1heCIsImJlbmNoUGN0TWluIiwiYmVuY2hQY3RNYXgiLCJzd2FwcyIsInNoaWZ0cyIsImxhc3RCZW5jaFNpZ24iLCJnZm1SZWZQcmljZSIsInVuZGVmaW5lZCIsImdmbUNhbGNQcmljZSIsImdmbU9wZW5pbmdQcmljZSIsImFib3ZlQ291bnQiLCJiZWxvd0NvdW50IiwidWlFcG9jaCIsInNuYXBQcmV2Iiwic25hcEN1ciIsImdyZWF0ZXN0QmVuY2hBYnMiLCJncmVhdGVzdERydkFicyIsImdyZWF0ZXN0UGN0MjRoQWJzIiwiZ2ZtRGVsdGFBYnNQY3QiLCJsYXN0UHJpY2UiLCJzZXQiLCJ1cGRhdGVTeW1ib2xTZXNzaW9uIiwicGN0MjRoTm93IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJwcmV2UHJpY2UiLCJNYXRoIiwibWluIiwibWF4IiwicyIsInJlZkdmbSIsImNhbGNHZm0iLCJkZWx0YVBjdCIsImFicyIsImp1c3RTaGlmdGVkIiwic25hcHNob3RPblNoaWZ0IiwiaXNTaGlmdCIsImV4cG9ydFN0cmVhbXMiLCJiZW5jaG1hcmsiLCJwcmV2IiwiZ3JlYXRlc3QiLCJwY3RfZHJ2Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/frame/session.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/sampling/index.ts":
/*!*****************************************************!*\
  !*** ./src/core/features/str-aux/sampling/index.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_SAMPLER_CONFIG: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SAMPLER_CONFIG),\n/* harmony export */   SamplingStore: () => (/* reexport safe */ _store__WEBPACK_IMPORTED_MODULE_2__.SamplingStore),\n/* harmony export */   SamplingStoreError: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.SamplingStoreError),\n/* harmony export */   getSamplingStore: () => (/* reexport safe */ _store__WEBPACK_IMPORTED_MODULE_2__.getSamplingStore),\n/* harmony export */   orderedWindowKeys: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.orderedWindowKeys),\n/* harmony export */   reduceStatusCounts: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.reduceStatusCounts),\n/* harmony export */   summarizeMark: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.summarizeMark),\n/* harmony export */   summarizeSnapshotWindow: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.summarizeSnapshotWindow),\n/* harmony export */   summarizeWindowMarkers: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.summarizeWindowMarkers)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"(rsc)/./src/core/features/str-aux/sampling/types.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"(rsc)/./src/core/features/str-aux/sampling/utils.ts\");\n/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./store */ \"(rsc)/./src/core/features/str-aux/sampling/store.ts\");\n// src/core/features/str-aux/sampling/index.ts\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3NhbXBsaW5nL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDhDQUE4QztBQUN0QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxjb3JlXFxmZWF0dXJlc1xcc3RyLWF1eFxcc2FtcGxpbmdcXGluZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb3JlL2ZlYXR1cmVzL3N0ci1hdXgvc2FtcGxpbmcvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCIuL3R5cGVzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi91dGlsc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc3RvcmVcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/sampling/index.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/sampling/store.ts":
/*!*****************************************************!*\
  !*** ./src/core/features/str-aux/sampling/store.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SamplingStore: () => (/* binding */ SamplingStore),\n/* harmony export */   getSamplingStore: () => (/* binding */ getSamplingStore)\n/* harmony export */ });\n/* harmony import */ var _core_sources_binance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/sources/binance */ \"(rsc)/./src/core/sources/binance.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"(rsc)/./src/core/features/str-aux/sampling/utils.ts\");\n// src/core/features/str-aux/sampling/store.ts\n\n\nconst clampStatus = (status, target)=>{\n    if (status === \"error\" || target === \"error\") return \"error\";\n    if (status === \"warn\" || target === \"warn\") return \"warn\";\n    return \"ok\";\n};\nclass SamplingStore {\n    constructor(config = _utils__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SAMPLER_CONFIG){\n        this.states = new Map();\n        this.config = config;\n        this.maxWindowDurationMs = Math.max(...Object.values(config.windows).map((w)=>w.durationMs));\n        this.expectedPointsPerCycle = Math.max(1, Math.round(config.cycleDurationMs / config.pointIntervalMs));\n    }\n    async collect(symbol, opts) {\n        const symbolKey = this.normalizeSymbol(symbol);\n        const state = this.ensureState(symbolKey);\n        const now = Date.now();\n        if (opts?.point) {\n            const mark = this.pushPoint(symbolKey, {\n                ...opts.point,\n                symbol: symbolKey\n            });\n            return {\n                point: opts.point,\n                closedMark: mark,\n                snapshot: this.snapshot(symbolKey, state)\n            };\n        }\n        if (!opts?.force && state.lastPoint && now - state.lastPoint.ts < this.config.pointIntervalMs * 0.75) {\n            return {\n                point: null,\n                closedMark: null,\n                snapshot: this.snapshot(symbolKey, state)\n            };\n        }\n        const point = await this.fetchPoint(symbolKey);\n        if (!point) {\n            return {\n                point: null,\n                closedMark: null,\n                snapshot: this.snapshot(symbolKey, state)\n            };\n        }\n        const mark = this.pushPoint(symbolKey, point);\n        return {\n            point,\n            closedMark: mark,\n            snapshot: this.snapshot(symbolKey, state)\n        };\n    }\n    getPoints(symbol, window) {\n        const symbolKey = this.normalizeSymbol(symbol);\n        const state = this.states.get(symbolKey);\n        if (!state) return [];\n        const durationMs = this.config.windows[window]?.durationMs ?? this.maxWindowDurationMs;\n        const refTs = state.lastPoint?.ts ?? Date.now();\n        const cutoff = refTs - durationMs;\n        const list = state.history;\n        let idx = 0;\n        while(idx < list.length && list[idx].ts < cutoff)idx += 1;\n        return list.slice(idx);\n    }\n    getMarks(symbol, window) {\n        const state = this.states.get(this.normalizeSymbol(symbol));\n        if (!state) return [];\n        return [\n            ...state.windows[window]\n        ];\n    }\n    snapshot(symbol, stateOverride) {\n        const symbolKey = this.normalizeSymbol(symbol);\n        const state = stateOverride ?? this.ensureState(symbolKey);\n        const cycleStatus = this.computeCycleStatus(state, Date.now());\n        const windows = {\n            \"30m\": this.buildWindowSummary(\"30m\", state),\n            \"1h\": this.buildWindowSummary(\"1h\", state),\n            \"3h\": this.buildWindowSummary(\"3h\", state)\n        };\n        return {\n            symbol: symbolKey,\n            cycle: cycleStatus,\n            windows,\n            lastPoint: state.lastPoint,\n            lastClosedMark: state.lastClosedMark,\n            historySize: state.history.length\n        };\n    }\n    get expectedPoints() {\n        return this.expectedPointsPerCycle;\n    }\n    normalizeSymbol(symbol) {\n        return String(symbol ?? \"\").trim().toUpperCase();\n    }\n    ensureState(symbol) {\n        const existing = this.states.get(symbol);\n        if (existing) return existing;\n        const init = {\n            currentStart: null,\n            currentPoints: [],\n            lastPoint: null,\n            lastClosedMark: null,\n            history: [],\n            windows: {\n                \"30m\": [],\n                \"1h\": [],\n                \"3h\": []\n            }\n        };\n        this.states.set(symbol, init);\n        return init;\n    }\n    async fetchPoint(symbol) {\n        try {\n            const ob = await (0,_core_sources_binance__WEBPACK_IMPORTED_MODULE_0__.fetchOrderBook)(symbol, 50);\n            if (!(ob.mid > 0)) return null;\n            const ts = ob.ts ?? Date.now();\n            const bestBid = Number.isFinite(ob.bestBid) ? ob.bestBid : ob.mid;\n            const bestAsk = Number.isFinite(ob.bestAsk) ? ob.bestAsk : ob.mid;\n            const spread = Number.isFinite(bestBid) && Number.isFinite(bestAsk) ? Math.abs(bestAsk - bestBid) : 0;\n            return {\n                symbol,\n                ts,\n                mid: ob.mid,\n                bestBid,\n                bestAsk,\n                spread,\n                bidVolume: Number.isFinite(ob.bidVol) ? ob.bidVol : 0,\n                askVolume: Number.isFinite(ob.askVol) ? ob.askVol : 0\n            };\n        } catch (err) {\n            if (err instanceof _utils__WEBPACK_IMPORTED_MODULE_1__.SamplingStoreError) throw err;\n            return null;\n        }\n    }\n    pushPoint(symbol, point) {\n        const state = this.ensureState(symbol);\n        const ts = point.ts;\n        if (state.lastPoint && ts <= state.lastPoint.ts) {\n            point = {\n                ...point,\n                ts: state.lastPoint.ts + 1\n            };\n        }\n        state.lastPoint = point;\n        state.history.push(point);\n        this.pruneHistory(state);\n        if (!state.currentPoints.length) {\n            state.currentPoints = [\n                point\n            ];\n            state.currentStart = point.ts;\n            return null;\n        }\n        const cycleStart = state.currentStart ?? state.currentPoints[0]?.ts ?? point.ts;\n        state.currentStart = cycleStart;\n        const elapsed = ts - cycleStart;\n        if (elapsed < this.config.cycleDurationMs) {\n            state.currentPoints.push(point);\n            return null;\n        }\n        const mark = this.buildMark(symbol, cycleStart, state.currentPoints);\n        this.storeMark(state, mark);\n        state.lastClosedMark = mark;\n        state.currentPoints = [\n            point\n        ];\n        state.currentStart = point.ts;\n        return mark;\n    }\n    pruneHistory(state) {\n        const cutoff = (state.lastPoint?.ts ?? Date.now()) - this.maxWindowDurationMs;\n        let drop = 0;\n        while(drop < state.history.length && state.history[drop].ts < cutoff)drop += 1;\n        if (drop > 0) state.history.splice(0, drop);\n    }\n    buildMark(symbol, startedAt, points) {\n        const list = [\n            ...points\n        ].sort((a, b)=>a.ts - b.ts);\n        const first = list[0];\n        const last = list[list.length - 1] ?? first;\n        const priceValues = list.map((p)=>p.mid).filter((v)=>Number.isFinite(v));\n        const spreadValues = list.map((p)=>p.spread).filter((v)=>Number.isFinite(v));\n        const bidVolumes = list.map((p)=>p.bidVolume).filter((v)=>Number.isFinite(v));\n        const askVolumes = list.map((p)=>p.askVolume).filter((v)=>Number.isFinite(v));\n        const priceMin = priceValues.length ? Math.min(...priceValues) : NaN;\n        const priceMax = priceValues.length ? Math.max(...priceValues) : NaN;\n        const priceAvg = priceValues.length ? priceValues.reduce((s, v)=>s + v, 0) / priceValues.length : NaN;\n        const spreadMin = spreadValues.length ? Math.min(...spreadValues) : NaN;\n        const spreadMax = spreadValues.length ? Math.max(...spreadValues) : NaN;\n        const spreadAvg = spreadValues.length ? spreadValues.reduce((s, v)=>s + v, 0) / spreadValues.length : NaN;\n        const bidVolume = bidVolumes.reduce((s, v)=>s + v, 0);\n        const askVolume = askVolumes.reduce((s, v)=>s + v, 0);\n        const expectedNominal = this.expectedPointsPerCycle;\n        const actualDurationMs = last && startedAt !== null ? Math.max(0, last.ts - startedAt) : this.config.cycleDurationMs;\n        const expectedFromDuration = Math.max(1, Math.round(actualDurationMs / this.config.pointIntervalMs));\n        const expectedPoints = Math.min(expectedNominal, Math.max(1, expectedFromDuration));\n        const warnFloor = Math.max(1, Math.ceil(expectedPoints * 0.5));\n        const tolerance = Math.max(1, Math.ceil(expectedPoints * 0.25));\n        const minOk = Math.max(1, expectedPoints - tolerance);\n        let status = \"ok\";\n        const notes = [];\n        if (!list.length) {\n            status = \"error\";\n            notes.push(\"empty_cycle\");\n        } else {\n            if (priceValues.length === 0) {\n                status = \"error\";\n                notes.push(\"no_prices\");\n            }\n            if (list.length < warnFloor) {\n                status = clampStatus(status, \"warn\");\n                notes.push(\"too_few_points\");\n            } else if (list.length < minOk) {\n                status = clampStatus(status, \"warn\");\n                notes.push(\"partial_cycle\");\n            }\n            if (last && startedAt !== null) {\n                const intended = this.config.cycleDurationMs;\n                const delta = last.ts - startedAt - intended;\n                if (delta > this.config.pointIntervalMs) {\n                    status = clampStatus(status, \"warn\");\n                    notes.push(\"extended_cycle\");\n                }\n            }\n        }\n        const startTs = startedAt ?? first?.ts ?? last?.ts ?? Date.now();\n        const closeTs = last?.ts ?? startTs;\n        return {\n            id: `${symbol}:${startTs}`,\n            symbol,\n            startedAt: startTs,\n            closedAt: closeTs,\n            durationMs: Math.max(0, closeTs - startTs),\n            pointsCount: list.length,\n            price: {\n                open: first?.mid ?? NaN,\n                close: last?.mid ?? NaN,\n                min: priceMin,\n                max: priceMax,\n                avg: priceAvg\n            },\n            spread: {\n                min: spreadMin,\n                max: spreadMax,\n                avg: spreadAvg\n            },\n            volume: {\n                bid: bidVolume,\n                ask: askVolume,\n                total: bidVolume + askVolume\n            },\n            points: list,\n            health: {\n                status,\n                notes,\n                expectedPoints\n            }\n        };\n    }\n    storeMark(state, mark) {\n        for (const key of Object.keys(this.config.windows)){\n            const window = state.windows[key];\n            window.push(mark);\n            const cap = this.config.windows[key]?.capacity ?? window.length;\n            while(window.length > cap)window.shift();\n        }\n    }\n    computeCycleStatus(state, now) {\n        const points = state.currentPoints.length;\n        const expectedNominal = this.expectedPointsPerCycle;\n        const startTs = state.currentStart ?? state.currentPoints[0]?.ts ?? null;\n        const lastPointTs = state.currentPoints[state.currentPoints.length - 1]?.ts ?? state.lastPoint?.ts ?? now;\n        const elapsed = startTs != null ? Math.max(0, (lastPointTs ?? now) - startTs) : 0;\n        const expectedRaw = startTs != null ? Math.max(1, Math.round(elapsed / this.config.pointIntervalMs)) : Math.max(1, Math.min(points || expectedNominal, expectedNominal));\n        const expectedSoFar = Math.min(expectedNominal, expectedRaw);\n        const tolerance = Math.max(1, Math.ceil(expectedSoFar * 0.3));\n        let status = \"ok\";\n        const notes = [];\n        if (!points) {\n            status = \"warn\";\n            notes.push(\"idle_cycle\");\n        } else if (expectedSoFar >= 3 && points + tolerance < expectedSoFar) {\n            status = \"warn\";\n            notes.push(\"low_points\");\n        } else if (points > expectedNominal * 1.5) {\n            status = \"warn\";\n            notes.push(\"extended_cycle\");\n        }\n        const closingAt = startTs ? startTs + this.config.cycleDurationMs : null;\n        return {\n            startedAt: startTs,\n            pointsCollected: points,\n            expectedPoints: expectedSoFar,\n            closingAt,\n            status,\n            notes\n        };\n    }\n    buildWindowSummary(key, state) {\n        const window = state.windows[key];\n        const counts = {\n            ok: 0,\n            warn: 0,\n            error: 0\n        };\n        for (const mark of window){\n            counts[mark.health.status] += 1;\n        }\n        const cfg = this.config.windows[key];\n        return {\n            key,\n            capacity: cfg?.capacity ?? window.length,\n            size: window.length,\n            marks: [\n                ...window\n            ],\n            statusCounts: counts\n        };\n    }\n}\nfunction getSamplingStore(config) {\n    if (!globalThis.__STR_AUX_SAMPLING_STORE__) {\n        globalThis.__STR_AUX_SAMPLING_STORE__ = new SamplingStore(config ?? _utils__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SAMPLER_CONFIG);\n    }\n    return globalThis.__STR_AUX_SAMPLING_STORE__;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3NhbXBsaW5nL3N0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSw4Q0FBOEM7QUFDVTtBQUl2QztBQW9CakIsTUFBTUcsY0FBYyxDQUFDQyxRQUE4QkM7SUFDakQsSUFBSUQsV0FBVyxXQUFXQyxXQUFXLFNBQVMsT0FBTztJQUNyRCxJQUFJRCxXQUFXLFVBQVVDLFdBQVcsUUFBUSxPQUFPO0lBQ25ELE9BQU87QUFDVDtBQVFPLE1BQU1DO0lBTVgsWUFBWUMsU0FBd0JOLDBEQUFzQixDQUFFO2FBSjNDTyxTQUFTLElBQUlDO1FBSzVCLElBQUksQ0FBQ0YsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0csbUJBQW1CLEdBQUdDLEtBQUtDLEdBQUcsSUFBSUMsT0FBT0MsTUFBTSxDQUFDUCxPQUFPUSxPQUFPLEVBQUVDLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxFQUFFQyxVQUFVO1FBQzVGLElBQUksQ0FBQ0Msc0JBQXNCLEdBQUdSLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLUyxLQUFLLENBQUNiLE9BQU9jLGVBQWUsR0FBR2QsT0FBT2UsZUFBZTtJQUN0RztJQUVBLE1BQU1DLFFBQVFDLE1BQWMsRUFBRUMsSUFBaUQsRUFBMEI7UUFDdkcsTUFBTUMsWUFBWSxJQUFJLENBQUNDLGVBQWUsQ0FBQ0g7UUFDdkMsTUFBTUksUUFBUSxJQUFJLENBQUNDLFdBQVcsQ0FBQ0g7UUFDL0IsTUFBTUksTUFBTUMsS0FBS0QsR0FBRztRQUVwQixJQUFJTCxNQUFNTyxPQUFPO1lBQ2YsTUFBTUMsT0FBTyxJQUFJLENBQUNDLFNBQVMsQ0FBQ1IsV0FBVztnQkFBRSxHQUFHRCxLQUFLTyxLQUFLO2dCQUFFUixRQUFRRTtZQUFVO1lBQzFFLE9BQU87Z0JBQUVNLE9BQU9QLEtBQUtPLEtBQUs7Z0JBQUVHLFlBQVlGO2dCQUFNRyxVQUFVLElBQUksQ0FBQ0EsUUFBUSxDQUFDVixXQUFXRTtZQUFPO1FBQzFGO1FBRUEs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VXNlcnNcXEd1c1xcc291cmNlXFxyZXBvXFxkeW5hbWljc1xcZHluYW1pY3MtYlxcY3J5cHRvcGktZHluYW1pY3NcXHNyY1xcY29yZVxcZmVhdHVyZXNcXHN0ci1hdXhcXHNhbXBsaW5nXFxzdG9yZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3NhbXBsaW5nL3N0b3JlLnRzXG5pbXBvcnQgeyBmZXRjaE9yZGVyQm9vayB9IGZyb20gXCJAL2NvcmUvc291cmNlcy9iaW5hbmNlXCI7XG5pbXBvcnQge1xuICBERUZBVUxUX1NBTVBMRVJfQ09ORklHLFxuICBTYW1wbGluZ1N0b3JlRXJyb3IsXG59IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgdHlwZSB7XG4gIFNhbXBsZXJDb25maWcsXG4gIFNhbXBsaW5nSGVhbHRoU3RhdHVzLFxuICBTYW1wbGluZ01hcmssXG4gIFNhbXBsaW5nUG9pbnQsXG4gIFNhbXBsaW5nU25hcHNob3QsXG4gIFNhbXBsaW5nV2luZG93S2V5LFxuICBTYW1wbGluZ1dpbmRvd1N1bW1hcnksXG59IGZyb20gXCIuL3R5cGVzXCI7XG5cbnR5cGUgU3ltYm9sU3RhdGUgPSB7XG4gIGN1cnJlbnRTdGFydDogbnVtYmVyIHwgbnVsbDtcbiAgY3VycmVudFBvaW50czogU2FtcGxpbmdQb2ludFtdO1xuICBsYXN0UG9pbnQ6IFNhbXBsaW5nUG9pbnQgfCBudWxsO1xuICBsYXN0Q2xvc2VkTWFyazogU2FtcGxpbmdNYXJrIHwgbnVsbDtcbiAgaGlzdG9yeTogU2FtcGxpbmdQb2ludFtdO1xuICB3aW5kb3dzOiBSZWNvcmQ8U2FtcGxpbmdXaW5kb3dLZXksIFNhbXBsaW5nTWFya1tdPjtcbn07XG5cbmNvbnN0IGNsYW1wU3RhdHVzID0gKHN0YXR1czogU2FtcGxpbmdIZWFsdGhTdGF0dXMsIHRhcmdldDogU2FtcGxpbmdIZWFsdGhTdGF0dXMpOiBTYW1wbGluZ0hlYWx0aFN0YXR1cyA9PiB7XG4gIGlmIChzdGF0dXMgPT09IFwiZXJyb3JcIiB8fCB0YXJnZXQgPT09IFwiZXJyb3JcIikgcmV0dXJuIFwiZXJyb3JcIjtcbiAgaWYgKHN0YXR1cyA9PT0gXCJ3YXJuXCIgfHwgdGFyZ2V0ID09PSBcIndhcm5cIikgcmV0dXJuIFwid2FyblwiO1xuICByZXR1cm4gXCJva1wiO1xufTtcblxuZXhwb3J0IHR5cGUgQ29sbGVjdFJlc3VsdCA9IHtcbiAgcG9pbnQ6IFNhbXBsaW5nUG9pbnQgfCBudWxsO1xuICBjbG9zZWRNYXJrOiBTYW1wbGluZ01hcmsgfCBudWxsO1xuICBzbmFwc2hvdDogU2FtcGxpbmdTbmFwc2hvdDtcbn07XG5cbmV4cG9ydCBjbGFzcyBTYW1wbGluZ1N0b3JlIHtcbiAgcmVhZG9ubHkgY29uZmlnOiBTYW1wbGVyQ29uZmlnO1xuICBwcml2YXRlIHJlYWRvbmx5IHN0YXRlcyA9IG5ldyBNYXA8c3RyaW5nLCBTeW1ib2xTdGF0ZT4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhXaW5kb3dEdXJhdGlvbk1zOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgZXhwZWN0ZWRQb2ludHNQZXJDeWNsZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogU2FtcGxlckNvbmZpZyA9IERFRkFVTFRfU0FNUExFUl9DT05GSUcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm1heFdpbmRvd0R1cmF0aW9uTXMgPSBNYXRoLm1heCguLi5PYmplY3QudmFsdWVzKGNvbmZpZy53aW5kb3dzKS5tYXAoKHcpID0+IHcuZHVyYXRpb25NcykpO1xuICAgIHRoaXMuZXhwZWN0ZWRQb2ludHNQZXJDeWNsZSA9IE1hdGgubWF4KDEsIE1hdGgucm91bmQoY29uZmlnLmN5Y2xlRHVyYXRpb25NcyAvIGNvbmZpZy5wb2ludEludGVydmFsTXMpKTtcbiAgfVxuXG4gIGFzeW5jIGNvbGxlY3Qoc3ltYm9sOiBzdHJpbmcsIG9wdHM/OiB7IGZvcmNlPzogYm9vbGVhbjsgcG9pbnQ/OiBTYW1wbGluZ1BvaW50IH0pOiBQcm9taXNlPENvbGxlY3RSZXN1bHQ+IHtcbiAgICBjb25zdCBzeW1ib2xLZXkgPSB0aGlzLm5vcm1hbGl6ZVN5bWJvbChzeW1ib2wpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5lbnN1cmVTdGF0ZShzeW1ib2xLZXkpO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBpZiAob3B0cz8ucG9pbnQpIHtcbiAgICAgIGNvbnN0IG1hcmsgPSB0aGlzLnB1c2hQb2ludChzeW1ib2xLZXksIHsgLi4ub3B0cy5wb2ludCwgc3ltYm9sOiBzeW1ib2xLZXkgfSk7XG4gICAgICByZXR1cm4geyBwb2ludDogb3B0cy5wb2ludCwgY2xvc2VkTWFyazogbWFyaywgc25hcHNob3Q6IHRoaXMuc25hcHNob3Qoc3ltYm9sS2V5LCBzdGF0ZSkgfTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdHM/LmZvcmNlICYmIHN0YXRlLmxhc3RQb2ludCAmJiBub3cgLSBzdGF0ZS5sYXN0UG9pbnQudHMgPCB0aGlzLmNvbmZpZy5wb2ludEludGVydmFsTXMgKiAwLjc1KSB7XG4gICAgICByZXR1cm4geyBwb2ludDogbnVsbCwgY2xvc2VkTWFyazogbnVsbCwgc25hcHNob3Q6IHRoaXMuc25hcHNob3Qoc3ltYm9sS2V5LCBzdGF0ZSkgfTtcbiAgICB9XG5cbiAgICBjb25zdCBwb2ludCA9IGF3YWl0IHRoaXMuZmV0Y2hQb2ludChzeW1ib2xLZXkpO1xuICAgIGlmICghcG9pbnQpIHtcbiAgICAgIHJldHVybiB7IHBvaW50OiBudWxsLCBjbG9zZWRNYXJrOiBudWxsLCBzbmFwc2hvdDogdGhpcy5zbmFwc2hvdChzeW1ib2xLZXksIHN0YXRlKSB9O1xuICAgIH1cblxuICAgIGNvbnN0IG1hcmsgPSB0aGlzLnB1c2hQb2ludChzeW1ib2xLZXksIHBvaW50KTtcbiAgICByZXR1cm4geyBwb2ludCwgY2xvc2VkTWFyazogbWFyaywgc25hcHNob3Q6IHRoaXMuc25hcHNob3Qoc3ltYm9sS2V5LCBzdGF0ZSkgfTtcbiAgfVxuXG4gIGdldFBvaW50cyhzeW1ib2w6IHN0cmluZywgd2luZG93OiBTYW1wbGluZ1dpbmRvd0tleSk6IFNhbXBsaW5nUG9pbnRbXSB7XG4gICAgY29uc3Qgc3ltYm9sS2V5ID0gdGhpcy5ub3JtYWxpemVTeW1ib2woc3ltYm9sKTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGVzLmdldChzeW1ib2xLZXkpO1xuICAgIGlmICghc3RhdGUpIHJldHVybiBbXTtcbiAgICBjb25zdCBkdXJhdGlvbk1zID0gdGhpcy5jb25maWcud2luZG93c1t3aW5kb3ddPy5kdXJhdGlvbk1zID8/IHRoaXMubWF4V2luZG93RHVyYXRpb25NcztcbiAgICBjb25zdCByZWZUcyA9IHN0YXRlLmxhc3RQb2ludD8udHMgPz8gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBjdXRvZmYgPSByZWZUcyAtIGR1cmF0aW9uTXM7XG4gICAgY29uc3QgbGlzdCA9IHN0YXRlLmhpc3Rvcnk7XG4gICAgbGV0IGlkeCA9IDA7XG4gICAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoICYmIGxpc3RbaWR4XS50cyA8IGN1dG9mZikgaWR4ICs9IDE7XG4gICAgcmV0dXJuIGxpc3Quc2xpY2UoaWR4KTtcbiAgfVxuXG4gIGdldE1hcmtzKHN5bWJvbDogc3RyaW5nLCB3aW5kb3c6IFNhbXBsaW5nV2luZG93S2V5KTogU2FtcGxpbmdNYXJrW10ge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZXMuZ2V0KHRoaXMubm9ybWFsaXplU3ltYm9sKHN5bWJvbCkpO1xuICAgIGlmICghc3RhdGUpIHJldHVybiBbXTtcbiAgICByZXR1cm4gWy4uLnN0YXRlLndpbmRvd3Nbd2luZG93XV07XG4gIH1cblxuICBzbmFwc2hvdChzeW1ib2w6IHN0cmluZywgc3RhdGVPdmVycmlkZT86IFN5bWJvbFN0YXRlKTogU2FtcGxpbmdTbmFwc2hvdCB7XG4gICAgY29uc3Qgc3ltYm9sS2V5ID0gdGhpcy5ub3JtYWxpemVTeW1ib2woc3ltYm9sKTtcbiAgICBjb25zdCBzdGF0ZSA9IHN0YXRlT3ZlcnJpZGUgPz8gdGhpcy5lbnN1cmVTdGF0ZShzeW1ib2xLZXkpO1xuICAgIGNvbnN0IGN5Y2xlU3RhdHVzID0gdGhpcy5jb21wdXRlQ3ljbGVTdGF0dXMoc3RhdGUsIERhdGUubm93KCkpO1xuXG4gICAgY29uc3Qgd2luZG93czogUmVjb3JkPFNhbXBsaW5nV2luZG93S2V5LCBTYW1wbGluZ1dpbmRvd1N1bW1hcnk+ID0ge1xuICAgICAgXCIzMG1cIjogdGhpcy5idWlsZFdpbmRvd1N1bW1hcnkoXCIzMG1cIiwgc3RhdGUpLFxuICAgICAgXCIxaFwiOiB0aGlzLmJ1aWxkV2luZG93U3VtbWFyeShcIjFoXCIsIHN0YXRlKSxcbiAgICAgIFwiM2hcIjogdGhpcy5idWlsZFdpbmRvd1N1bW1hcnkoXCIzaFwiLCBzdGF0ZSksXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBzeW1ib2w6IHN5bWJvbEtleSxcbiAgICAgIGN5Y2xlOiBjeWNsZVN0YXR1cyxcbiAgICAgIHdpbmRvd3MsXG4gICAgICBsYXN0UG9pbnQ6IHN0YXRlLmxhc3RQb2ludCxcbiAgICAgIGxhc3RDbG9zZWRNYXJrOiBzdGF0ZS5sYXN0Q2xvc2VkTWFyayxcbiAgICAgIGhpc3RvcnlTaXplOiBzdGF0ZS5oaXN0b3J5Lmxlbmd0aCxcbiAgICB9O1xuICB9XG5cbiAgZ2V0IGV4cGVjdGVkUG9pbnRzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZXhwZWN0ZWRQb2ludHNQZXJDeWNsZTtcbiAgfVxuXG4gIHByaXZhdGUgbm9ybWFsaXplU3ltYm9sKHN5bWJvbDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gU3RyaW5nKHN5bWJvbCA/PyBcIlwiKS50cmltKCkudG9VcHBlckNhc2UoKTtcbiAgfVxuXG4gIHByaXZhdGUgZW5zdXJlU3RhdGUoc3ltYm9sOiBzdHJpbmcpOiBTeW1ib2xTdGF0ZSB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLnN0YXRlcy5nZXQoc3ltYm9sKTtcbiAgICBpZiAoZXhpc3RpbmcpIHJldHVybiBleGlzdGluZztcbiAgICBjb25zdCBpbml0OiBTeW1ib2xTdGF0ZSA9IHtcbiAgICAgIGN1cnJlbnRTdGFydDogbnVsbCxcbiAgICAgIGN1cnJlbnRQb2ludHM6IFtdLFxuICAgICAgbGFzdFBvaW50OiBudWxsLFxuICAgICAgbGFzdENsb3NlZE1hcms6IG51bGwsXG4gICAgICBoaXN0b3J5OiBbXSxcbiAgICAgIHdpbmRvd3M6IHtcbiAgICAgICAgXCIzMG1cIjogW10sXG4gICAgICAgIFwiMWhcIjogW10sXG4gICAgICAgIFwiM2hcIjogW10sXG4gICAgICB9LFxuICAgIH07XG4gICAgdGhpcy5zdGF0ZXMuc2V0KHN5bWJvbCwgaW5pdCk7XG4gICAgcmV0dXJuIGluaXQ7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZldGNoUG9pbnQoc3ltYm9sOiBzdHJpbmcpOiBQcm9taXNlPFNhbXBsaW5nUG9pbnQgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG9iID0gYXdhaXQgZmV0Y2hPcmRlckJvb2soc3ltYm9sLCA1MCk7XG4gICAgICBpZiAoIShvYi5taWQgPiAwKSkgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCB0cyA9IG9iLnRzID8/IERhdGUubm93KCk7XG4gICAgICBjb25zdCBiZXN0QmlkID0gTnVtYmVyLmlzRmluaXRlKG9iLmJlc3RCaWQpID8gb2IuYmVzdEJpZCA6IG9iLm1pZDtcbiAgICAgIGNvbnN0IGJlc3RBc2sgPSBOdW1iZXIuaXNGaW5pdGUob2IuYmVzdEFzaykgPyBvYi5iZXN0QXNrIDogb2IubWlkO1xuICAgICAgY29uc3Qgc3ByZWFkID0gTnVtYmVyLmlzRmluaXRlKGJlc3RCaWQpICYmIE51bWJlci5pc0Zpbml0ZShiZXN0QXNrKSA/IE1hdGguYWJzKGJlc3RBc2sgLSBiZXN0QmlkKSA6IDA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzeW1ib2wsXG4gICAgICAgIHRzLFxuICAgICAgICBtaWQ6IG9iLm1pZCxcbiAgICAgICAgYmVzdEJpZCxcbiAgICAgICAgYmVzdEFzayxcbiAgICAgICAgc3ByZWFkLFxuICAgICAgICBiaWRWb2x1bWU6IE51bWJlci5pc0Zpbml0ZShvYi5iaWRWb2wpID8gb2IuYmlkVm9sIDogMCxcbiAgICAgICAgYXNrVm9sdW1lOiBOdW1iZXIuaXNGaW5pdGUob2IuYXNrVm9sKSA/IG9iLmFza1ZvbCA6IDAsXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFNhbXBsaW5nU3RvcmVFcnJvcikgdGhyb3cgZXJyO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwdXNoUG9pbnQoc3ltYm9sOiBzdHJpbmcsIHBvaW50OiBTYW1wbGluZ1BvaW50KTogU2FtcGxpbmdNYXJrIHwgbnVsbCB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmVuc3VyZVN0YXRlKHN5bWJvbCk7XG4gICAgY29uc3QgdHMgPSBwb2ludC50cztcbiAgICBpZiAoc3RhdGUubGFzdFBvaW50ICYmIHRzIDw9IHN0YXRlLmxhc3RQb2ludC50cykge1xuICAgICAgcG9pbnQgPSB7IC4uLnBvaW50LCB0czogc3RhdGUubGFzdFBvaW50LnRzICsgMSB9O1xuICAgIH1cblxuICAgIHN0YXRlLmxhc3RQb2ludCA9IHBvaW50O1xuICAgIHN0YXRlLmhpc3RvcnkucHVzaChwb2ludCk7XG4gICAgdGhpcy5wcnVuZUhpc3Rvcnkoc3RhdGUpO1xuXG4gICAgaWYgKCFzdGF0ZS5jdXJyZW50UG9pbnRzLmxlbmd0aCkge1xuICAgICAgc3RhdGUuY3VycmVudFBvaW50cyA9IFtwb2ludF07XG4gICAgICBzdGF0ZS5jdXJyZW50U3RhcnQgPSBwb2ludC50cztcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGN5Y2xlU3RhcnQgPSBzdGF0ZS5jdXJyZW50U3RhcnQgPz8gc3RhdGUuY3VycmVudFBvaW50c1swXT8udHMgPz8gcG9pbnQudHM7XG4gICAgc3RhdGUuY3VycmVudFN0YXJ0ID0gY3ljbGVTdGFydDtcbiAgICBjb25zdCBlbGFwc2VkID0gdHMgLSBjeWNsZVN0YXJ0O1xuICAgIGlmIChlbGFwc2VkIDwgdGhpcy5jb25maWcuY3ljbGVEdXJhdGlvbk1zKSB7XG4gICAgICBzdGF0ZS5jdXJyZW50UG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgbWFyayA9IHRoaXMuYnVpbGRNYXJrKHN5bWJvbCwgY3ljbGVTdGFydCwgc3RhdGUuY3VycmVudFBvaW50cyk7XG4gICAgdGhpcy5zdG9yZU1hcmsoc3RhdGUsIG1hcmspO1xuICAgIHN0YXRlLmxhc3RDbG9zZWRNYXJrID0gbWFyaztcbiAgICBzdGF0ZS5jdXJyZW50UG9pbnRzID0gW3BvaW50XTtcbiAgICBzdGF0ZS5jdXJyZW50U3RhcnQgPSBwb2ludC50cztcbiAgICByZXR1cm4gbWFyaztcbiAgfVxuXG4gIHByaXZhdGUgcHJ1bmVIaXN0b3J5KHN0YXRlOiBTeW1ib2xTdGF0ZSkge1xuICAgIGNvbnN0IGN1dG9mZiA9IChzdGF0ZS5sYXN0UG9pbnQ/LnRzID8/IERhdGUubm93KCkpIC0gdGhpcy5tYXhXaW5kb3dEdXJhdGlvbk1zO1xuICAgIGxldCBkcm9wID0gMDtcbiAgICB3aGlsZSAoZHJvcCA8IHN0YXRlLmhpc3RvcnkubGVuZ3RoICYmIHN0YXRlLmhpc3RvcnlbZHJvcF0udHMgPCBjdXRvZmYpIGRyb3AgKz0gMTtcbiAgICBpZiAoZHJvcCA+IDApIHN0YXRlLmhpc3Rvcnkuc3BsaWNlKDAsIGRyb3ApO1xuICB9XG5cbiAgcHJpdmF0ZSBidWlsZE1hcmsoc3ltYm9sOiBzdHJpbmcsIHN0YXJ0ZWRBdDogbnVtYmVyIHwgbnVsbCwgcG9pbnRzOiBTYW1wbGluZ1BvaW50W10pOiBTYW1wbGluZ01hcmsge1xuICAgIGNvbnN0IGxpc3QgPSBbLi4ucG9pbnRzXS5zb3J0KChhLCBiKSA9PiBhLnRzIC0gYi50cyk7XG4gICAgY29uc3QgZmlyc3QgPSBsaXN0WzBdO1xuICAgIGNvbnN0IGxhc3QgPSBsaXN0W2xpc3QubGVuZ3RoIC0gMV0gPz8gZmlyc3Q7XG4gICAgY29uc3QgcHJpY2VWYWx1ZXMgPSBsaXN0Lm1hcCgocCkgPT4gcC5taWQpLmZpbHRlcigodikgPT4gTnVtYmVyLmlzRmluaXRlKHYpKTtcbiAgICBjb25zdCBzcHJlYWRWYWx1ZXMgPSBsaXN0Lm1hcCgocCkgPT4gcC5zcHJlYWQpLmZpbHRlcigodikgPT4gTnVtYmVyLmlzRmluaXRlKHYpKTtcbiAgICBjb25zdCBiaWRWb2x1bWVzID0gbGlzdC5tYXAoKHApID0+IHAuYmlkVm9sdW1lKS5maWx0ZXIoKHYpID0+IE51bWJlci5pc0Zpbml0ZSh2KSk7XG4gICAgY29uc3QgYXNrVm9sdW1lcyA9IGxpc3QubWFwKChwKSA9PiBwLmFza1ZvbHVtZSkuZmlsdGVyKCh2KSA9PiBOdW1iZXIuaXNGaW5pdGUodikpO1xuXG4gICAgY29uc3QgcHJpY2VNaW4gPSBwcmljZVZhbHVlcy5sZW5ndGggPyBNYXRoLm1pbiguLi5wcmljZVZhbHVlcykgOiBOYU47XG4gICAgY29uc3QgcHJpY2VNYXggPSBwcmljZVZhbHVlcy5sZW5ndGggPyBNYXRoLm1heCguLi5wcmljZVZhbHVlcykgOiBOYU47XG4gICAgY29uc3QgcHJpY2VBdmcgPSBwcmljZVZhbHVlcy5sZW5ndGggPyBwcmljZVZhbHVlcy5yZWR1Y2UoKHMsIHYpID0+IHMgKyB2LCAwKSAvIHByaWNlVmFsdWVzLmxlbmd0aCA6IE5hTjtcblxuICAgIGNvbnN0IHNwcmVhZE1pbiA9IHNwcmVhZFZhbHVlcy5sZW5ndGggPyBNYXRoLm1pbiguLi5zcHJlYWRWYWx1ZXMpIDogTmFOO1xuICAgIGNvbnN0IHNwcmVhZE1heCA9IHNwcmVhZFZhbHVlcy5sZW5ndGggPyBNYXRoLm1heCguLi5zcHJlYWRWYWx1ZXMpIDogTmFOO1xuICAgIGNvbnN0IHNwcmVhZEF2ZyA9IHNwcmVhZFZhbHVlcy5sZW5ndGggPyBzcHJlYWRWYWx1ZXMucmVkdWNlKChzLCB2KSA9PiBzICsgdiwgMCkgLyBzcHJlYWRWYWx1ZXMubGVuZ3RoIDogTmFOO1xuXG4gICAgY29uc3QgYmlkVm9sdW1lID0gYmlkVm9sdW1lcy5yZWR1Y2UoKHMsIHYpID0+IHMgKyB2LCAwKTtcbiAgICBjb25zdCBhc2tWb2x1bWUgPSBhc2tWb2x1bWVzLnJlZHVjZSgocywgdikgPT4gcyArIHYsIDApO1xuXG4gICAgY29uc3QgZXhwZWN0ZWROb21pbmFsID0gdGhpcy5leHBlY3RlZFBvaW50c1BlckN5Y2xlO1xuICAgIGNvbnN0IGFjdHVhbER1cmF0aW9uTXMgPVxuICAgICAgbGFzdCAmJiBzdGFydGVkQXQgIT09IG51bGwgPyBNYXRoLm1heCgwLCBsYXN0LnRzIC0gc3RhcnRlZEF0KSA6IHRoaXMuY29uZmlnLmN5Y2xlRHVyYXRpb25NcztcbiAgICBjb25zdCBleHBlY3RlZEZyb21EdXJhdGlvbiA9IE1hdGgubWF4KDEsIE1hdGgucm91bmQoYWN0dWFsRHVyYXRpb25NcyAvIHRoaXMuY29uZmlnLnBvaW50SW50ZXJ2YWxNcykpO1xuICAgIGNvbnN0IGV4cGVjdGVkUG9pbnRzID0gTWF0aC5taW4oZXhwZWN0ZWROb21pbmFsLCBNYXRoLm1heCgxLCBleHBlY3RlZEZyb21EdXJhdGlvbikpO1xuICAgIGNvbnN0IHdhcm5GbG9vciA9IE1hdGgubWF4KDEsIE1hdGguY2VpbChleHBlY3RlZFBvaW50cyAqIDAuNSkpO1xuICAgIGNvbnN0IHRvbGVyYW5jZSA9IE1hdGgubWF4KDEsIE1hdGguY2VpbChleHBlY3RlZFBvaW50cyAqIDAuMjUpKTtcbiAgICBjb25zdCBtaW5PayA9IE1hdGgubWF4KDEsIGV4cGVjdGVkUG9pbnRzIC0gdG9sZXJhbmNlKTtcbiAgICBsZXQgc3RhdHVzOiBTYW1wbGluZ0hlYWx0aFN0YXR1cyA9IFwib2tcIjtcbiAgICBjb25zdCBub3Rlczogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAoIWxpc3QubGVuZ3RoKSB7XG4gICAgICBzdGF0dXMgPSBcImVycm9yXCI7XG4gICAgICBub3Rlcy5wdXNoKFwiZW1wdHlfY3ljbGVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcmljZVZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3RhdHVzID0gXCJlcnJvclwiO1xuICAgICAgICBub3Rlcy5wdXNoKFwibm9fcHJpY2VzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3QubGVuZ3RoIDwgd2FybkZsb29yKSB7XG4gICAgICAgIHN0YXR1cyA9IGNsYW1wU3RhdHVzKHN0YXR1cywgXCJ3YXJuXCIpO1xuICAgICAgICBub3Rlcy5wdXNoKFwidG9vX2Zld19wb2ludHNcIik7XG4gICAgICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoIDwgbWluT2spIHtcbiAgICAgICAgc3RhdHVzID0gY2xhbXBTdGF0dXMoc3RhdHVzLCBcIndhcm5cIik7XG4gICAgICAgIG5vdGVzLnB1c2goXCJwYXJ0aWFsX2N5Y2xlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3QgJiYgc3RhcnRlZEF0ICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGludGVuZGVkID0gdGhpcy5jb25maWcuY3ljbGVEdXJhdGlvbk1zO1xuICAgICAgICBjb25zdCBkZWx0YSA9IChsYXN0LnRzIC0gc3RhcnRlZEF0KSAtIGludGVuZGVkO1xuICAgICAgICBpZiAoZGVsdGEgPiB0aGlzLmNvbmZpZy5wb2ludEludGVydmFsTXMpIHtcbiAgICAgICAgICBzdGF0dXMgPSBjbGFtcFN0YXR1cyhzdGF0dXMsIFwid2FyblwiKTtcbiAgICAgICAgICBub3Rlcy5wdXNoKFwiZXh0ZW5kZWRfY3ljbGVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzdGFydFRzID0gc3RhcnRlZEF0ID8/IChmaXJzdD8udHMgPz8gbGFzdD8udHMgPz8gRGF0ZS5ub3coKSk7XG4gICAgY29uc3QgY2xvc2VUcyA9IGxhc3Q/LnRzID8/IHN0YXJ0VHM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGAke3N5bWJvbH06JHtzdGFydFRzfWAsXG4gICAgICBzeW1ib2wsXG4gICAgICBzdGFydGVkQXQ6IHN0YXJ0VHMsXG4gICAgICBjbG9zZWRBdDogY2xvc2VUcyxcbiAgICAgIGR1cmF0aW9uTXM6IE1hdGgubWF4KDAsIGNsb3NlVHMgLSBzdGFydFRzKSxcbiAgICAgIHBvaW50c0NvdW50OiBsaXN0Lmxlbmd0aCxcbiAgICAgIHByaWNlOiB7XG4gICAgICAgIG9wZW46IGZpcnN0Py5taWQgPz8gTmFOLFxuICAgICAgICBjbG9zZTogbGFzdD8ubWlkID8/IE5hTixcbiAgICAgICAgbWluOiBwcmljZU1pbixcbiAgICAgICAgbWF4OiBwcmljZU1heCxcbiAgICAgICAgYXZnOiBwcmljZUF2ZyxcbiAgICAgIH0sXG4gICAgICBzcHJlYWQ6IHtcbiAgICAgICAgbWluOiBzcHJlYWRNaW4sXG4gICAgICAgIG1heDogc3ByZWFkTWF4LFxuICAgICAgICBhdmc6IHNwcmVhZEF2ZyxcbiAgICAgIH0sXG4gICAgICB2b2x1bWU6IHtcbiAgICAgICAgYmlkOiBiaWRWb2x1bWUsXG4gICAgICAgIGFzazogYXNrVm9sdW1lLFxuICAgICAgICB0b3RhbDogYmlkVm9sdW1lICsgYXNrVm9sdW1lLFxuICAgICAgfSxcbiAgICAgIHBvaW50czogbGlzdCxcbiAgICAgIGhlYWx0aDoge1xuICAgICAgICBzdGF0dXMsXG4gICAgICAgIG5vdGVzLFxuICAgICAgICBleHBlY3RlZFBvaW50cyxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgc3RvcmVNYXJrKHN0YXRlOiBTeW1ib2xTdGF0ZSwgbWFyazogU2FtcGxpbmdNYXJrKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5jb25maWcud2luZG93cykgYXMgU2FtcGxpbmdXaW5kb3dLZXlbXSkge1xuICAgICAgY29uc3Qgd2luZG93ID0gc3RhdGUud2luZG93c1trZXldO1xuICAgICAgd2luZG93LnB1c2gobWFyayk7XG4gICAgICBjb25zdCBjYXAgPSB0aGlzLmNvbmZpZy53aW5kb3dzW2tleV0/LmNhcGFjaXR5ID8/IHdpbmRvdy5sZW5ndGg7XG4gICAgICB3aGlsZSAod2luZG93Lmxlbmd0aCA+IGNhcCkgd2luZG93LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb21wdXRlQ3ljbGVTdGF0dXMoc3RhdGU6IFN5bWJvbFN0YXRlLCBub3c6IG51bWJlcikge1xuICAgIGNvbnN0IHBvaW50cyA9IHN0YXRlLmN1cnJlbnRQb2ludHMubGVuZ3RoO1xuICAgIGNvbnN0IGV4cGVjdGVkTm9taW5hbCA9IHRoaXMuZXhwZWN0ZWRQb2ludHNQZXJDeWNsZTtcbiAgICBjb25zdCBzdGFydFRzID0gc3RhdGUuY3VycmVudFN0YXJ0ID8/IHN0YXRlLmN1cnJlbnRQb2ludHNbMF0/LnRzID8/IG51bGw7XG4gICAgY29uc3QgbGFzdFBvaW50VHMgPSBzdGF0ZS5jdXJyZW50UG9pbnRzW3N0YXRlLmN1cnJlbnRQb2ludHMubGVuZ3RoIC0gMV0/LnRzXG4gICAgICA/PyBzdGF0ZS5sYXN0UG9pbnQ/LnRzXG4gICAgICA/PyBub3c7XG4gICAgY29uc3QgZWxhcHNlZCA9IHN0YXJ0VHMgIT0gbnVsbCA/IE1hdGgubWF4KDAsIChsYXN0UG9pbnRUcyA/PyBub3cpIC0gc3RhcnRUcykgOiAwO1xuICAgIGNvbnN0IGV4cGVjdGVkUmF3ID0gc3RhcnRUcyAhPSBudWxsXG4gICAgICA/IE1hdGgubWF4KDEsIE1hdGgucm91bmQoZWxhcHNlZCAvIHRoaXMuY29uZmlnLnBvaW50SW50ZXJ2YWxNcykpXG4gICAgICA6IE1hdGgubWF4KDEsIE1hdGgubWluKHBvaW50cyB8fCBleHBlY3RlZE5vbWluYWwsIGV4cGVjdGVkTm9taW5hbCkpO1xuICAgIGNvbnN0IGV4cGVjdGVkU29GYXIgPSBNYXRoLm1pbihleHBlY3RlZE5vbWluYWwsIGV4cGVjdGVkUmF3KTtcbiAgICBjb25zdCB0b2xlcmFuY2UgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwoZXhwZWN0ZWRTb0ZhciAqIDAuMykpO1xuICAgIGxldCBzdGF0dXM6IFNhbXBsaW5nSGVhbHRoU3RhdHVzID0gXCJva1wiO1xuICAgIGNvbnN0IG5vdGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGlmICghcG9pbnRzKSB7XG4gICAgICBzdGF0dXMgPSBcIndhcm5cIjtcbiAgICAgIG5vdGVzLnB1c2goXCJpZGxlX2N5Y2xlXCIpO1xuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRTb0ZhciA+PSAzICYmIHBvaW50cyArIHRvbGVyYW5jZSA8IGV4cGVjdGVkU29GYXIpIHtcbiAgICAgIHN0YXR1cyA9IFwid2FyblwiO1xuICAgICAgbm90ZXMucHVzaChcImxvd19wb2ludHNcIik7XG4gICAgfSBlbHNlIGlmIChwb2ludHMgPiBleHBlY3RlZE5vbWluYWwgKiAxLjUpIHtcbiAgICAgIHN0YXR1cyA9IFwid2FyblwiO1xuICAgICAgbm90ZXMucHVzaChcImV4dGVuZGVkX2N5Y2xlXCIpO1xuICAgIH1cbiAgICBjb25zdCBjbG9zaW5nQXQgPSBzdGFydFRzID8gc3RhcnRUcyArIHRoaXMuY29uZmlnLmN5Y2xlRHVyYXRpb25NcyA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0ZWRBdDogc3RhcnRUcyxcbiAgICAgIHBvaW50c0NvbGxlY3RlZDogcG9pbnRzLFxuICAgICAgZXhwZWN0ZWRQb2ludHM6IGV4cGVjdGVkU29GYXIsXG4gICAgICBjbG9zaW5nQXQsXG4gICAgICBzdGF0dXMsXG4gICAgICBub3RlcyxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBidWlsZFdpbmRvd1N1bW1hcnkoa2V5OiBTYW1wbGluZ1dpbmRvd0tleSwgc3RhdGU6IFN5bWJvbFN0YXRlKTogU2FtcGxpbmdXaW5kb3dTdW1tYXJ5IHtcbiAgICBjb25zdCB3aW5kb3cgPSBzdGF0ZS53aW5kb3dzW2tleV07XG4gICAgY29uc3QgY291bnRzOiBSZWNvcmQ8U2FtcGxpbmdIZWFsdGhTdGF0dXMsIG51bWJlcj4gPSB7IG9rOiAwLCB3YXJuOiAwLCBlcnJvcjogMCB9O1xuICAgIGZvciAoY29uc3QgbWFyayBvZiB3aW5kb3cpIHtcbiAgICAgIGNvdW50c1ttYXJrLmhlYWx0aC5zdGF0dXNdICs9IDE7XG4gICAgfVxuICAgIGNvbnN0IGNmZyA9IHRoaXMuY29uZmlnLndpbmRvd3Nba2V5XTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5LFxuICAgICAgY2FwYWNpdHk6IGNmZz8uY2FwYWNpdHkgPz8gd2luZG93Lmxlbmd0aCxcbiAgICAgIHNpemU6IHdpbmRvdy5sZW5ndGgsXG4gICAgICBtYXJrczogWy4uLndpbmRvd10sXG4gICAgICBzdGF0dXNDb3VudHM6IGNvdW50cyxcbiAgICB9O1xuICB9XG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhclxuICB2YXIgX19TVFJfQVVYX1NBTVBMSU5HX1NUT1JFX186IFNhbXBsaW5nU3RvcmUgfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTYW1wbGluZ1N0b3JlKGNvbmZpZz86IFNhbXBsZXJDb25maWcpOiBTYW1wbGluZ1N0b3JlIHtcbiAgaWYgKCEoZ2xvYmFsVGhpcyBhcyBhbnkpLl9fU1RSX0FVWF9TQU1QTElOR19TVE9SRV9fKSB7XG4gICAgKGdsb2JhbFRoaXMgYXMgYW55KS5fX1NUUl9BVVhfU0FNUExJTkdfU1RPUkVfXyA9IG5ldyBTYW1wbGluZ1N0b3JlKGNvbmZpZyA/PyBERUZBVUxUX1NBTVBMRVJfQ09ORklHKTtcbiAgfVxuICByZXR1cm4gKGdsb2JhbFRoaXMgYXMgYW55KS5fX1NUUl9BVVhfU0FNUExJTkdfU1RPUkVfXyE7XG59XG4iXSwibmFtZXMiOlsiZmV0Y2hPcmRlckJvb2siLCJERUZBVUxUX1NBTVBMRVJfQ09ORklHIiwiU2FtcGxpbmdTdG9yZUVycm9yIiwiY2xhbXBTdGF0dXMiLCJzdGF0dXMiLCJ0YXJnZXQiLCJTYW1wbGluZ1N0b3JlIiwiY29uZmlnIiwic3RhdGVzIiwiTWFwIiwibWF4V2luZG93RHVyYXRpb25NcyIsIk1hdGgiLCJtYXgiLCJPYmplY3QiLCJ2YWx1ZXMiLCJ3aW5kb3dzIiwibWFwIiwidyIsImR1cmF0aW9uTXMiLCJleHBlY3RlZFBvaW50c1BlckN5Y2xlIiwicm91bmQiLCJjeWNsZUR1cmF0aW9uTXMiLCJwb2ludEludGVydmFsTXMiLCJjb2xsZWN0Iiwic3ltYm9sIiwib3B0cyIsInN5bWJvbEtleSIsIm5vcm1hbGl6ZVN5bWJvbCIsInN0YXRlIiwiZW5zdXJlU3RhdGUiLCJub3ciLCJEYXRlIiwicG9pbnQiLCJtYXJrIiwicHVzaFBvaW50IiwiY2xvc2VkTWFyayIsInNuYXBzaG90IiwiZm9yY2UiLCJsYXN0UG9pbnQiLCJ0cyIsImZldGNoUG9pbnQiLCJnZXRQb2ludHMiLCJ3aW5kb3ciLCJnZXQiLCJyZWZUcyIsImN1dG9mZiIsImxpc3QiLCJoaXN0b3J5IiwiaWR4IiwibGVuZ3RoIiwic2xpY2UiLCJnZXRNYXJrcyIsInN0YXRlT3ZlcnJpZGUiLCJjeWNsZVN0YXR1cyIsImNvbXB1dGVDeWNsZVN0YXR1cyIsImJ1aWxkV2luZG93U3VtbWFyeSIsImN5Y2xlIiwibGFzdENsb3NlZE1hcmsiLCJoaXN0b3J5U2l6ZSIsImV4cGVjdGVkUG9pbnRzIiwiU3RyaW5nIiwidHJpbSIsInRvVXBwZXJDYXNlIiwiZXhpc3RpbmciLCJpbml0IiwiY3VycmVudFN0YXJ0IiwiY3VycmVudFBvaW50cyIsInNldCIsIm9iIiwibWlkIiwiYmVzdEJpZCIsIk51bWJlciIsImlzRmluaXRlIiwiYmVzdEFzayIsInNwcmVhZCIsImFicyIsImJpZFZvbHVtZSIsImJpZFZvbCIsImFza1ZvbHVtZSIsImFza1ZvbCIsImVyciIsInB1c2giLCJwcnVuZUhpc3RvcnkiLCJjeWNsZVN0YXJ0IiwiZWxhcHNlZCIsImJ1aWxkTWFyayIsInN0b3JlTWFyayIsImRyb3AiLCJzcGxpY2UiLCJzdGFydGVkQXQiLCJwb2ludHMiLCJzb3J0IiwiYSIsImIiLCJmaXJzdCIsImxhc3QiLCJwcmljZVZhbHVlcyIsInAiLCJmaWx0ZXIiLCJ2Iiwic3ByZWFkVmFsdWVzIiwiYmlkVm9sdW1lcyIsImFza1ZvbHVtZXMiLCJwcmljZU1pbiIsIm1pbiIsIk5hTiIsInByaWNlTWF4IiwicHJpY2VBdmciLCJyZWR1Y2UiLCJzIiwic3ByZWFkTWluIiwic3ByZWFkTWF4Iiwic3ByZWFkQXZnIiwiZXhwZWN0ZWROb21pbmFsIiwiYWN0dWFsRHVyYXRpb25NcyIsImV4cGVjdGVkRnJvbUR1cmF0aW9uIiwid2FybkZsb29yIiwiY2VpbCIsInRvbGVyYW5jZSIsIm1pbk9rIiwibm90ZXMiLCJpbnRlbmRlZCIsImRlbHRhIiwic3RhcnRUcyIsImNsb3NlVHMiLCJpZCIsImNsb3NlZEF0IiwicG9pbnRzQ291bnQiLCJwcmljZSIsIm9wZW4iLCJjbG9zZSIsImF2ZyIsInZvbHVtZSIsImJpZCIsImFzayIsInRvdGFsIiwiaGVhbHRoIiwia2V5Iiwia2V5cyIsImNhcCIsImNhcGFjaXR5Iiwic2hpZnQiLCJsYXN0UG9pbnRUcyIsImV4cGVjdGVkUmF3IiwiZXhwZWN0ZWRTb0ZhciIsImNsb3NpbmdBdCIsInBvaW50c0NvbGxlY3RlZCIsImNvdW50cyIsIm9rIiwid2FybiIsImVycm9yIiwiY2ZnIiwic2l6ZSIsIm1hcmtzIiwic3RhdHVzQ291bnRzIiwiZ2V0U2FtcGxpbmdTdG9yZSIsImdsb2JhbFRoaXMiLCJfX1NUUl9BVVhfU0FNUExJTkdfU1RPUkVfXyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/sampling/store.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/sampling/types.ts":
/*!*****************************************************!*\
  !*** ./src/core/features/str-aux/sampling/types.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// src/core/features/str-aux/sampling/types.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3NhbXBsaW5nL3R5cGVzLnRzIiwibWFwcGluZ3MiOiI7QUFBQSw4Q0FBOEM7QUFtRjVDIiwic291cmNlcyI6WyJIOlxcVXNlcnNcXEd1c1xcc291cmNlXFxyZXBvXFxkeW5hbWljc1xcZHluYW1pY3MtYlxcY3J5cHRvcGktZHluYW1pY3NcXHNyY1xcY29yZVxcZmVhdHVyZXNcXHN0ci1hdXhcXHNhbXBsaW5nXFx0eXBlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3NhbXBsaW5nL3R5cGVzLnRzXG5leHBvcnQgdHlwZSBTYW1wbGluZ1dpbmRvd0tleSA9IFwiMzBtXCIgfCBcIjFoXCIgfCBcIjNoXCI7XG5cbmV4cG9ydCB0eXBlIFNhbXBsaW5nSGVhbHRoU3RhdHVzID0gXCJva1wiIHwgXCJ3YXJuXCIgfCBcImVycm9yXCI7XG5cbmV4cG9ydCB0eXBlIFNhbXBsaW5nUG9pbnQgPSB7XG4gIHN5bWJvbDogc3RyaW5nO1xuICB0czogbnVtYmVyO1xuICBtaWQ6IG51bWJlcjtcbiAgYmVzdEJpZDogbnVtYmVyO1xuICBiZXN0QXNrOiBudW1iZXI7XG4gIHNwcmVhZDogbnVtYmVyO1xuICBiaWRWb2x1bWU6IG51bWJlcjtcbiAgYXNrVm9sdW1lOiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBTYW1wbGluZ01hcmsgPSB7XG4gIGlkOiBzdHJpbmc7XG4gIHN5bWJvbDogc3RyaW5nO1xuICBzdGFydGVkQXQ6IG51bWJlcjtcbiAgY2xvc2VkQXQ6IG51bWJlcjtcbiAgZHVyYXRpb25NczogbnVtYmVyO1xuICBwb2ludHNDb3VudDogbnVtYmVyO1xuICBwcmljZToge1xuICAgIG9wZW46IG51bWJlcjtcbiAgICBjbG9zZTogbnVtYmVyO1xuICAgIG1pbjogbnVtYmVyO1xuICAgIG1heDogbnVtYmVyO1xuICAgIGF2ZzogbnVtYmVyO1xuICB9O1xuICBzcHJlYWQ6IHtcbiAgICBtaW46IG51bWJlcjtcbiAgICBtYXg6IG51bWJlcjtcbiAgICBhdmc6IG51bWJlcjtcbiAgfTtcbiAgdm9sdW1lOiB7XG4gICAgYmlkOiBudW1iZXI7XG4gICAgYXNrOiBudW1iZXI7XG4gICAgdG90YWw6IG51bWJlcjtcbiAgfTtcbiAgcG9pbnRzOiBTYW1wbGluZ1BvaW50W107XG4gIGhlYWx0aDoge1xuICAgIHN0YXR1czogU2FtcGxpbmdIZWFsdGhTdGF0dXM7XG4gICAgbm90ZXM6IHN0cmluZ1tdO1xuICAgIGV4cGVjdGVkUG9pbnRzOiBudW1iZXI7XG4gIH07XG59O1xuXG5leHBvcnQgdHlwZSBTYW1wbGluZ1dpbmRvd1N1bW1hcnkgPSB7XG4gIGtleTogU2FtcGxpbmdXaW5kb3dLZXk7XG4gIGNhcGFjaXR5OiBudW1iZXI7XG4gIHNpemU6IG51bWJlcjtcbiAgbWFya3M6IFNhbXBsaW5nTWFya1tdO1xuICBzdGF0dXNDb3VudHM6IFJlY29yZDxTYW1wbGluZ0hlYWx0aFN0YXR1cywgbnVtYmVyPjtcbn07XG5cbmV4cG9ydCB0eXBlIFNhbXBsaW5nQ3ljbGVTbmFwc2hvdCA9IHtcbiAgc3RhcnRlZEF0OiBudW1iZXIgfCBudWxsO1xuICBwb2ludHNDb2xsZWN0ZWQ6IG51bWJlcjtcbiAgZXhwZWN0ZWRQb2ludHM6IG51bWJlcjtcbiAgY2xvc2luZ0F0OiBudW1iZXIgfCBudWxsO1xuICBzdGF0dXM6IFNhbXBsaW5nSGVhbHRoU3RhdHVzO1xuICBub3Rlczogc3RyaW5nW107XG59O1xuXG5leHBvcnQgdHlwZSBTYW1wbGluZ1NuYXBzaG90ID0ge1xuICBzeW1ib2w6IHN0cmluZztcbiAgY3ljbGU6IFNhbXBsaW5nQ3ljbGVTbmFwc2hvdDtcbiAgd2luZG93czogUmVjb3JkPFNhbXBsaW5nV2luZG93S2V5LCBTYW1wbGluZ1dpbmRvd1N1bW1hcnk+O1xuICBsYXN0UG9pbnQ6IFNhbXBsaW5nUG9pbnQgfCBudWxsO1xuICBsYXN0Q2xvc2VkTWFyazogU2FtcGxpbmdNYXJrIHwgbnVsbDtcbiAgaGlzdG9yeVNpemU6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIFNhbXBsZXJXaW5kb3dDb25maWcgPSB7XG4gIGR1cmF0aW9uTXM6IG51bWJlcjtcbiAgY2FwYWNpdHk6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIFNhbXBsZXJDb25maWcgPSB7XG4gIHBvaW50SW50ZXJ2YWxNczogbnVtYmVyO1xuICBjeWNsZUR1cmF0aW9uTXM6IG51bWJlcjtcbiAgd2luZG93czogUmVjb3JkPFNhbXBsaW5nV2luZG93S2V5LCBTYW1wbGVyV2luZG93Q29uZmlnPjtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/sampling/types.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/sampling/utils.ts":
/*!*****************************************************!*\
  !*** ./src/core/features/str-aux/sampling/utils.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_SAMPLER_CONFIG: () => (/* binding */ DEFAULT_SAMPLER_CONFIG),\n/* harmony export */   SamplingStoreError: () => (/* binding */ SamplingStoreError),\n/* harmony export */   orderedWindowKeys: () => (/* binding */ orderedWindowKeys),\n/* harmony export */   reduceStatusCounts: () => (/* binding */ reduceStatusCounts),\n/* harmony export */   summarizeMark: () => (/* binding */ summarizeMark),\n/* harmony export */   summarizeSnapshotWindow: () => (/* binding */ summarizeSnapshotWindow),\n/* harmony export */   summarizeWindowMarkers: () => (/* binding */ summarizeWindowMarkers)\n/* harmony export */ });\n// src/core/features/str-aux/sampling/utils.ts\nconst DEFAULT_SAMPLER_CONFIG = {\n    pointIntervalMs: 5000,\n    cycleDurationMs: 40000,\n    windows: {\n        \"30m\": {\n            durationMs: 30 * 60 * 1000,\n            capacity: 45\n        },\n        \"1h\": {\n            durationMs: 60 * 60 * 1000,\n            capacity: 90\n        },\n        \"3h\": {\n            durationMs: 3 * 60 * 60 * 1000,\n            capacity: 270\n        }\n    }\n};\nclass SamplingStoreError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"SamplingStoreError\";\n    }\n}\nfunction summarizeMark(mark) {\n    const points = mark.points ?? [];\n    return {\n        id: mark.id,\n        symbol: mark.symbol,\n        startedAt: mark.startedAt,\n        closedAt: mark.closedAt,\n        durationMs: mark.durationMs,\n        pointsCount: mark.pointsCount,\n        expectedPoints: mark.health.expectedPoints,\n        price: mark.price,\n        spread: mark.spread,\n        volume: mark.volume,\n        health: mark.health,\n        pointRefs: {\n            first: points[0] ?? null,\n            third: points[2] ?? null,\n            last: points[points.length - 1] ?? null\n        }\n    };\n}\nfunction summarizeWindowMarkers(window) {\n    const picks = (indexes)=>indexes.map((i)=>i >= 0 && i < window.marks.length ? window.marks[i] : null).filter((m)=>Boolean(m));\n    const head = picks([\n        0\n    ]).map(summarizeMark)[0] ?? null;\n    const twentieth = picks([\n        19\n    ]).map(summarizeMark)[0] ?? null;\n    const twentyFirst = picks([\n        20\n    ]).map(summarizeMark)[0] ?? null;\n    const tail = picks([\n        window.marks.length - 1\n    ]).map(summarizeMark)[0] ?? null;\n    return {\n        head,\n        twentieth,\n        twentyFirst,\n        tail\n    };\n}\nfunction reduceStatusCounts(marks) {\n    const counts = {\n        ok: 0,\n        warn: 0,\n        error: 0\n    };\n    for (const mark of marks)counts[mark.health.status] += 1;\n    return counts;\n}\nfunction orderedWindowKeys() {\n    return [\n        \"30m\",\n        \"1h\",\n        \"3h\"\n    ];\n}\nfunction summarizeSnapshotWindow(snapshot, key) {\n    const summary = snapshot.windows[key];\n    return {\n        cycle: snapshot.cycle,\n        window: {\n            key,\n            capacity: summary.capacity,\n            size: summary.size,\n            statusCounts: summary.statusCounts,\n            markers: summarizeWindowMarkers(summary)\n        },\n        lastPoint: snapshot.lastPoint,\n        lastClosedMark: snapshot.lastClosedMark ? summarizeMark(snapshot.lastClosedMark) : null\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3NhbXBsaW5nL3V0aWxzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSw4Q0FBOEM7QUFZdkMsTUFBTUEseUJBQXdDO0lBQ25EQyxpQkFBaUI7SUFDakJDLGlCQUFpQjtJQUNqQkMsU0FBUztRQUNQLE9BQU87WUFBRUMsWUFBWSxLQUFLLEtBQUs7WUFBT0MsVUFBVTtRQUFHO1FBQ25ELE1BQU07WUFBRUQsWUFBWSxLQUFLLEtBQUs7WUFBT0MsVUFBVTtRQUFHO1FBQ2xELE1BQU07WUFBRUQsWUFBWSxJQUFJLEtBQUssS0FBSztZQUFPQyxVQUFVO1FBQUk7SUFDekQ7QUFDRixFQUFFO0FBRUssTUFBTUMsMkJBQTJCQztJQUN0QyxZQUFZQyxPQUFlLENBQUU7UUFDM0IsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQXFCTyxTQUFTQyxjQUFjQyxJQUFrQjtJQUM5QyxNQUFNQyxTQUFTRCxLQUFLQyxNQUFNLElBQUksRUFBRTtJQUNoQyxPQUFPO1FBQ0xDLElBQUlGLEtBQUtFLEVBQUU7UUFDWEMsUUFBUUgsS0FBS0csTUFBTTtRQUNuQkMsV0FBV0osS0FBS0ksU0FBUztRQUN6QkMsVUFBVUwsS0FBS0ssUUFBUTtRQUN2QlosWUFBWU8sS0FBS1AsVUFBVTtRQUMzQmEsYUFBYU4sS0FBS00sV0FBVztRQUM3QkMsZ0JBQWdCUCxLQUFLUSxNQUFNLENBQUNELGNBQWM7UUFDMUNFLE9BQU9ULEtBQUtTLEtBQUs7UUFDakJDLFFBQVFWLEtBQUtVLE1BQU07UUFDbkJDLFFBQVFYLEtBQUtXLE1BQU07UUFDbkJILFFBQVFSLEtBQUtRLE1BQU07UUFDbkJJLFdBQVc7WUFDVEMsT0FBT1osTUFBTSxDQUFDLEVBQUUsSUFBSTtZQUNwQmEsT0FBT2IsTUFBTSxDQUFDLEVBQUUsSUFBSTtZQUNwQmMsTUFBTWQsTUFBTSxDQUFDQSxPQUFPZSxNQUFNLEdBQUcsRUFBRSxJQUFJO1FBQ3JDO0lBQ0Y7QUFDRjtBQUVPLFNBQVNDLHVCQUF1QkMsTUFBNkI7SUFDbEUsTUFBTUMsUUFBUSxDQUFDQyxVQUNiQSxRQUNHQyxHQUFHLENBQUMsQ0FBQ0MsSUFBT0EsS0FBSyxLQUFLQSxJQUFJSixPQUFPSyxLQUFLLENBQUNQLE1BQU0sR0FBR0UsT0FBT0ssS0FBSyxDQUFDRCxFQUFFLEdBQUcsTUFDbEVFLE1BQU0sQ0FBQyxDQUFDQyxJQUF5QkMsUUFBUUQ7SUFFOUMsTUFBTUUsT0FBT1IsTUFBTTtRQUFDO0tBQUUsRUFBRUUsR0FBRyxDQUFDdEIsY0FBYyxDQUFDLEVBQUUsSUFBSTtJQUNqRCxNQUFNNkIsWUFBWVQsTUFBTTtRQUFDO0tBQUcsRUFBRUUsR0FBRyxDQUFDdEIsY0FBYyxDQUFDLEVBQUUsSUFBSTtJQUN2RCxNQUFNOEIsY0FBY1YsTUFBTTtRQUFDO0tBQUcsRUFBRUUsR0FBRyxDQUFDdEIsY0FBYyxDQUFDLEVBQUUsSUFBSTtJQUN6RCxNQUFNK0IsT0FBT1gsTUFBTTtRQUFDRCxPQUFPSyxLQUFLLENBQUNQLE1BQU0sR0FBRztLQUFFLEVBQUVLLEdBQUcsQ0FBQ3RCLGNBQWMsQ0FBQyxFQUFFLElBQUk7SUFFdkUsT0FBTztRQUNMNEI7UUFDQUM7UUFDQUM7UUFDQUM7SUFDRjtBQUNGO0FBRU8sU0FBU0MsbUJBQW1CUixLQUFxQjtJQUN0RCxNQUFNUyxTQUErQztRQUFFQyxJQUFJO1FBQUdDLE1BQU07UUFBR0MsT0FBTztJQUFFO0lBQ2hGLEtBQUssTUFBTW5DLFFBQVF1QixNQUFPUyxNQUFNLENBQUNoQyxLQUFLUSxNQUFNLENBQUM0QixNQUFNLENBQUMsSUFBSTtJQUN4RCxPQUFPSjtBQUNUO0FBRU8sU0FBU0s7SUFDZCxPQUFPO1FBQUM7UUFBTztRQUFNO0tBQUs7QUFDNUI7QUFlTyxTQUFTQyx3QkFDZEMsUUFBMEIsRUFDMUJDLEdBQXNCO0lBRXRCLE1BQU1DLFVBQVVGLFNBQVMvQyxPQUFPLENBQUNnRCxJQUFJO0lBQ3JDLE9BQU87UUFDTEUsT0FBT0gsU0FBU0csS0FBSztRQUNyQnhCLFFBQVE7WUFDTnNCO1lBQ0E5QyxVQUFVK0MsUUFBUS9DLFFBQVE7WUFDMUJpRCxNQUFNRixRQUFRRSxJQUFJO1lBQ2xCQyxjQUFjSCxRQUFRRyxZQUFZO1lBQ2xDQyxTQUFTNUIsdUJBQXVCd0I7UUFDbEM7UUFDQUssV0FBV1AsU0FBU08sU0FBUztRQUM3QkMsZ0JBQWdCUixTQUFTUSxjQUFjLEdBQUdoRCxjQUFjd0MsU0FBU1EsY0FBYyxJQUFJO0lBQ3JGO0FBQ0YiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxjb3JlXFxmZWF0dXJlc1xcc3RyLWF1eFxcc2FtcGxpbmdcXHV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb3JlL2ZlYXR1cmVzL3N0ci1hdXgvc2FtcGxpbmcvdXRpbHMudHNcbmltcG9ydCB7XG4gIHR5cGUgU2FtcGxlckNvbmZpZyxcbiAgdHlwZSBTYW1wbGluZ0N5Y2xlU25hcHNob3QsXG4gIHR5cGUgU2FtcGxpbmdIZWFsdGhTdGF0dXMsXG4gIHR5cGUgU2FtcGxpbmdNYXJrLFxuICB0eXBlIFNhbXBsaW5nUG9pbnQsXG4gIHR5cGUgU2FtcGxpbmdTbmFwc2hvdCxcbiAgdHlwZSBTYW1wbGluZ1dpbmRvd0tleSxcbiAgdHlwZSBTYW1wbGluZ1dpbmRvd1N1bW1hcnksXG59IGZyb20gXCIuL3R5cGVzXCI7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NBTVBMRVJfQ09ORklHOiBTYW1wbGVyQ29uZmlnID0ge1xuICBwb2ludEludGVydmFsTXM6IDVfMDAwLFxuICBjeWNsZUR1cmF0aW9uTXM6IDQwXzAwMCxcbiAgd2luZG93czoge1xuICAgIFwiMzBtXCI6IHsgZHVyYXRpb25NczogMzAgKiA2MCAqIDFfMDAwLCBjYXBhY2l0eTogNDUgfSxcbiAgICBcIjFoXCI6IHsgZHVyYXRpb25NczogNjAgKiA2MCAqIDFfMDAwLCBjYXBhY2l0eTogOTAgfSxcbiAgICBcIjNoXCI6IHsgZHVyYXRpb25NczogMyAqIDYwICogNjAgKiAxXzAwMCwgY2FwYWNpdHk6IDI3MCB9LFxuICB9LFxufTtcblxuZXhwb3J0IGNsYXNzIFNhbXBsaW5nU3RvcmVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJTYW1wbGluZ1N0b3JlRXJyb3JcIjtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBNYXJrU3VtbWFyeSA9IHtcbiAgaWQ6IHN0cmluZztcbiAgc3ltYm9sOiBzdHJpbmc7XG4gIHN0YXJ0ZWRBdDogbnVtYmVyO1xuICBjbG9zZWRBdDogbnVtYmVyO1xuICBkdXJhdGlvbk1zOiBudW1iZXI7XG4gIHBvaW50c0NvdW50OiBudW1iZXI7XG4gIGV4cGVjdGVkUG9pbnRzOiBudW1iZXI7XG4gIHByaWNlOiBTYW1wbGluZ01hcmtbXCJwcmljZVwiXTtcbiAgc3ByZWFkOiBTYW1wbGluZ01hcmtbXCJzcHJlYWRcIl07XG4gIHZvbHVtZTogU2FtcGxpbmdNYXJrW1widm9sdW1lXCJdO1xuICBoZWFsdGg6IFNhbXBsaW5nTWFya1tcImhlYWx0aFwiXTtcbiAgcG9pbnRSZWZzOiB7XG4gICAgZmlyc3Q6IFNhbXBsaW5nUG9pbnQgfCBudWxsO1xuICAgIHRoaXJkOiBTYW1wbGluZ1BvaW50IHwgbnVsbDtcbiAgICBsYXN0OiBTYW1wbGluZ1BvaW50IHwgbnVsbDtcbiAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBzdW1tYXJpemVNYXJrKG1hcms6IFNhbXBsaW5nTWFyayk6IE1hcmtTdW1tYXJ5IHtcbiAgY29uc3QgcG9pbnRzID0gbWFyay5wb2ludHMgPz8gW107XG4gIHJldHVybiB7XG4gICAgaWQ6IG1hcmsuaWQsXG4gICAgc3ltYm9sOiBtYXJrLnN5bWJvbCxcbiAgICBzdGFydGVkQXQ6IG1hcmsuc3RhcnRlZEF0LFxuICAgIGNsb3NlZEF0OiBtYXJrLmNsb3NlZEF0LFxuICAgIGR1cmF0aW9uTXM6IG1hcmsuZHVyYXRpb25NcyxcbiAgICBwb2ludHNDb3VudDogbWFyay5wb2ludHNDb3VudCxcbiAgICBleHBlY3RlZFBvaW50czogbWFyay5oZWFsdGguZXhwZWN0ZWRQb2ludHMsXG4gICAgcHJpY2U6IG1hcmsucHJpY2UsXG4gICAgc3ByZWFkOiBtYXJrLnNwcmVhZCxcbiAgICB2b2x1bWU6IG1hcmsudm9sdW1lLFxuICAgIGhlYWx0aDogbWFyay5oZWFsdGgsXG4gICAgcG9pbnRSZWZzOiB7XG4gICAgICBmaXJzdDogcG9pbnRzWzBdID8/IG51bGwsXG4gICAgICB0aGlyZDogcG9pbnRzWzJdID8/IG51bGwsXG4gICAgICBsYXN0OiBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdID8/IG51bGwsXG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1bW1hcml6ZVdpbmRvd01hcmtlcnMod2luZG93OiBTYW1wbGluZ1dpbmRvd1N1bW1hcnkpIHtcbiAgY29uc3QgcGlja3MgPSAoaW5kZXhlczogbnVtYmVyW10pID0+XG4gICAgaW5kZXhlc1xuICAgICAgLm1hcCgoaSkgPT4gKGkgPj0gMCAmJiBpIDwgd2luZG93Lm1hcmtzLmxlbmd0aCA/IHdpbmRvdy5tYXJrc1tpXSA6IG51bGwpKVxuICAgICAgLmZpbHRlcigobSk6IG0gaXMgU2FtcGxpbmdNYXJrID0+IEJvb2xlYW4obSkpO1xuXG4gIGNvbnN0IGhlYWQgPSBwaWNrcyhbMF0pLm1hcChzdW1tYXJpemVNYXJrKVswXSA/PyBudWxsO1xuICBjb25zdCB0d2VudGlldGggPSBwaWNrcyhbMTldKS5tYXAoc3VtbWFyaXplTWFyaylbMF0gPz8gbnVsbDtcbiAgY29uc3QgdHdlbnR5Rmlyc3QgPSBwaWNrcyhbMjBdKS5tYXAoc3VtbWFyaXplTWFyaylbMF0gPz8gbnVsbDtcbiAgY29uc3QgdGFpbCA9IHBpY2tzKFt3aW5kb3cubWFya3MubGVuZ3RoIC0gMV0pLm1hcChzdW1tYXJpemVNYXJrKVswXSA/PyBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgaGVhZCxcbiAgICB0d2VudGlldGgsXG4gICAgdHdlbnR5Rmlyc3QsXG4gICAgdGFpbCxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZVN0YXR1c0NvdW50cyhtYXJrczogU2FtcGxpbmdNYXJrW10pOiBSZWNvcmQ8U2FtcGxpbmdIZWFsdGhTdGF0dXMsIG51bWJlcj4ge1xuICBjb25zdCBjb3VudHM6IFJlY29yZDxTYW1wbGluZ0hlYWx0aFN0YXR1cywgbnVtYmVyPiA9IHsgb2s6IDAsIHdhcm46IDAsIGVycm9yOiAwIH07XG4gIGZvciAoY29uc3QgbWFyayBvZiBtYXJrcykgY291bnRzW21hcmsuaGVhbHRoLnN0YXR1c10gKz0gMTtcbiAgcmV0dXJuIGNvdW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9yZGVyZWRXaW5kb3dLZXlzKCk6IFNhbXBsaW5nV2luZG93S2V5W10ge1xuICByZXR1cm4gW1wiMzBtXCIsIFwiMWhcIiwgXCIzaFwiXTtcbn1cblxuZXhwb3J0IHR5cGUgU2FtcGxpbmdXaW5kb3dEaWdlc3QgPSB7XG4gIGN5Y2xlOiBTYW1wbGluZ0N5Y2xlU25hcHNob3Q7XG4gIHdpbmRvdzoge1xuICAgIGtleTogU2FtcGxpbmdXaW5kb3dLZXk7XG4gICAgY2FwYWNpdHk6IG51bWJlcjtcbiAgICBzaXplOiBudW1iZXI7XG4gICAgc3RhdHVzQ291bnRzOiBSZWNvcmQ8U2FtcGxpbmdIZWFsdGhTdGF0dXMsIG51bWJlcj47XG4gICAgbWFya2VyczogUmV0dXJuVHlwZTx0eXBlb2Ygc3VtbWFyaXplV2luZG93TWFya2Vycz47XG4gIH07XG4gIGxhc3RQb2ludDogU2FtcGxpbmdQb2ludCB8IG51bGw7XG4gIGxhc3RDbG9zZWRNYXJrOiBNYXJrU3VtbWFyeSB8IG51bGw7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gc3VtbWFyaXplU25hcHNob3RXaW5kb3coXG4gIHNuYXBzaG90OiBTYW1wbGluZ1NuYXBzaG90LFxuICBrZXk6IFNhbXBsaW5nV2luZG93S2V5XG4pOiBTYW1wbGluZ1dpbmRvd0RpZ2VzdCB7XG4gIGNvbnN0IHN1bW1hcnkgPSBzbmFwc2hvdC53aW5kb3dzW2tleV07XG4gIHJldHVybiB7XG4gICAgY3ljbGU6IHNuYXBzaG90LmN5Y2xlLFxuICAgIHdpbmRvdzoge1xuICAgICAga2V5LFxuICAgICAgY2FwYWNpdHk6IHN1bW1hcnkuY2FwYWNpdHksXG4gICAgICBzaXplOiBzdW1tYXJ5LnNpemUsXG4gICAgICBzdGF0dXNDb3VudHM6IHN1bW1hcnkuc3RhdHVzQ291bnRzLFxuICAgICAgbWFya2Vyczogc3VtbWFyaXplV2luZG93TWFya2VycyhzdW1tYXJ5KSxcbiAgICB9LFxuICAgIGxhc3RQb2ludDogc25hcHNob3QubGFzdFBvaW50LFxuICAgIGxhc3RDbG9zZWRNYXJrOiBzbmFwc2hvdC5sYXN0Q2xvc2VkTWFyayA/IHN1bW1hcml6ZU1hcmsoc25hcHNob3QubGFzdENsb3NlZE1hcmspIDogbnVsbCxcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJERUZBVUxUX1NBTVBMRVJfQ09ORklHIiwicG9pbnRJbnRlcnZhbE1zIiwiY3ljbGVEdXJhdGlvbk1zIiwid2luZG93cyIsImR1cmF0aW9uTXMiLCJjYXBhY2l0eSIsIlNhbXBsaW5nU3RvcmVFcnJvciIsIkVycm9yIiwibWVzc2FnZSIsIm5hbWUiLCJzdW1tYXJpemVNYXJrIiwibWFyayIsInBvaW50cyIsImlkIiwic3ltYm9sIiwic3RhcnRlZEF0IiwiY2xvc2VkQXQiLCJwb2ludHNDb3VudCIsImV4cGVjdGVkUG9pbnRzIiwiaGVhbHRoIiwicHJpY2UiLCJzcHJlYWQiLCJ2b2x1bWUiLCJwb2ludFJlZnMiLCJmaXJzdCIsInRoaXJkIiwibGFzdCIsImxlbmd0aCIsInN1bW1hcml6ZVdpbmRvd01hcmtlcnMiLCJ3aW5kb3ciLCJwaWNrcyIsImluZGV4ZXMiLCJtYXAiLCJpIiwibWFya3MiLCJmaWx0ZXIiLCJtIiwiQm9vbGVhbiIsImhlYWQiLCJ0d2VudGlldGgiLCJ0d2VudHlGaXJzdCIsInRhaWwiLCJyZWR1Y2VTdGF0dXNDb3VudHMiLCJjb3VudHMiLCJvayIsIndhcm4iLCJlcnJvciIsInN0YXR1cyIsIm9yZGVyZWRXaW5kb3dLZXlzIiwic3VtbWFyaXplU25hcHNob3RXaW5kb3ciLCJzbmFwc2hvdCIsImtleSIsInN1bW1hcnkiLCJjeWNsZSIsInNpemUiLCJzdGF0dXNDb3VudHMiLCJtYXJrZXJzIiwibGFzdFBvaW50IiwibGFzdENsb3NlZE1hcmsiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/sampling/utils.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/symbols/index.ts":
/*!****************************************************!*\
  !*** ./src/core/features/str-aux/symbols/index.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KNOWN_QUOTES: () => (/* binding */ KNOWN_QUOTES),\n/* harmony export */   resolveSymbolSelection: () => (/* binding */ resolveSymbolSelection),\n/* harmony export */   splitSymbol: () => (/* binding */ splitSymbol)\n/* harmony export */ });\n/* harmony import */ var _lib_settings_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/settings/server */ \"(rsc)/./src/lib/settings/server.ts\");\n/* harmony import */ var _lib_markets_pairs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/markets/pairs */ \"(rsc)/./src/lib/markets/pairs.ts\");\n\n\nconst KNOWN_QUOTES = [\n    \"USDT\",\n    \"BTC\",\n    \"ETH\",\n    \"BNB\",\n    \"BUSD\",\n    \"FDUSD\",\n    \"USDC\",\n    \"TUSD\"\n];\nconst DEFAULT_FALLBACK_BASES = [\n    \"BTC\",\n    \"ETH\",\n    \"BNB\",\n    \"SOL\",\n    \"ADA\",\n    \"XRP\",\n    \"DOGE\"\n];\nconst sanitizeSymbol = (value)=>{\n    if (typeof value !== \"string\") return \"\";\n    const raw = value.trim().toUpperCase();\n    if (!raw) return \"\";\n    return /^[A-Z0-9]{5,20}$/.test(raw) ? raw : \"\";\n};\nfunction parseList(values) {\n    const out = [];\n    for (const value of values){\n        if (!value) continue;\n        for (const token of value.split(\",\")){\n            const trimmed = token.trim();\n            if (trimmed) out.push(trimmed);\n        }\n    }\n    return out;\n}\nfunction collectQueryValues(url, keys) {\n    const collected = [];\n    for (const key of keys){\n        const values = url.searchParams.getAll(key);\n        if (!values.length) continue;\n        collected.push(...parseList(values));\n    }\n    return collected;\n}\nasync function getPreviewSymbols(origin) {\n    try {\n        const response = await fetch(`${origin}/api/preview/symbols`, {\n            cache: \"no-store\"\n        });\n        if (!response.ok) return [];\n        const payload = await response.json();\n        return Array.isArray(payload?.symbols) ? payload.symbols.map((s)=>String(s ?? \"\").trim().toUpperCase()) : [];\n    } catch  {\n        return [];\n    }\n}\nasync function getSettingsSymbols(origin) {\n    try {\n        const response = await fetch(`${origin}/api/preview/universe/symbols`, {\n            cache: \"no-store\"\n        });\n        if (!response.ok) return [];\n        const payload = await response.json();\n        return Array.isArray(payload?.symbols) ? payload.symbols.map((s)=>String(s ?? \"\").trim().toUpperCase()) : [];\n    } catch  {\n        return [];\n    }\n}\nfunction splitSymbol(symbol, fallbackQuote = \"USDT\") {\n    const value = String(symbol ?? \"\").trim().toUpperCase();\n    if (!value) return {\n        base: \"\",\n        quote: fallbackQuote\n    };\n    for (const quote of KNOWN_QUOTES){\n        if (value.endsWith(quote) && value.length > quote.length) {\n            return {\n                base: value.slice(0, -quote.length),\n                quote\n            };\n        }\n    }\n    if (fallbackQuote && value.endsWith(fallbackQuote) && value.length > fallbackQuote.length) {\n        return {\n            base: value.slice(0, -fallbackQuote.length),\n            quote: fallbackQuote\n        };\n    }\n    return {\n        base: value.replace(/USDT$/i, \"\"),\n        quote: fallbackQuote\n    };\n}\nasync function resolveBases(origin, quote) {\n    const fromSettings = (0,_lib_markets_pairs__WEBPACK_IMPORTED_MODULE_1__.dedupeCoins)(await (0,_lib_settings_server__WEBPACK_IMPORTED_MODULE_0__.resolveCoinsFromSettings)()).filter((coin)=>coin && coin !== quote);\n    if (fromSettings.length) {\n        return {\n            bases: fromSettings,\n            source: \"settings\"\n        };\n    }\n    const settingsSymbols = await getSettingsSymbols(origin);\n    if (settingsSymbols.length) {\n        const bases = (0,_lib_markets_pairs__WEBPACK_IMPORTED_MODULE_1__.dedupeCoins)(settingsSymbols.map((symbol)=>splitSymbol(symbol, quote).base)).filter((coin)=>coin && coin !== quote);\n        if (bases.length) {\n            return {\n                bases,\n                source: \"settings_symbols\"\n            };\n        }\n    }\n    const previewSymbols = await getPreviewSymbols(origin);\n    if (previewSymbols.length) {\n        const bases = (0,_lib_markets_pairs__WEBPACK_IMPORTED_MODULE_1__.dedupeCoins)(previewSymbols.map((symbol)=>splitSymbol(symbol, quote).base)).filter((coin)=>coin && coin !== quote);\n        if (bases.length) {\n            return {\n                bases,\n                source: \"preview\"\n            };\n        }\n    }\n    const env = String(process.env.NEXT_PUBLIC_COINS ?? \"\").trim().toUpperCase();\n    if (env) {\n        const bases = (0,_lib_markets_pairs__WEBPACK_IMPORTED_MODULE_1__.dedupeCoins)(env.split(/[\\s,]+/g).filter(Boolean)).filter((coin)=>coin && coin !== quote);\n        if (bases.length) {\n            return {\n                bases,\n                source: \"env\"\n            };\n        }\n    }\n    const fallback = (0,_lib_markets_pairs__WEBPACK_IMPORTED_MODULE_1__.dedupeCoins)(DEFAULT_FALLBACK_BASES).filter((coin)=>coin && coin !== quote);\n    return {\n        bases: fallback,\n        source: \"fallback\"\n    };\n}\nfunction buildDefaults(bases, quote) {\n    const sanitizedQuote = (0,_lib_markets_pairs__WEBPACK_IMPORTED_MODULE_1__.normalizeCoin)(quote) || \"USDT\";\n    if (sanitizedQuote === \"USDT\") {\n        return (0,_lib_markets_pairs__WEBPACK_IMPORTED_MODULE_1__.usdtLegsFromCoins)(bases);\n    }\n    return bases.map((base)=>(0,_lib_markets_pairs__WEBPACK_IMPORTED_MODULE_1__.normalizeCoin)(base)).filter((base)=>base && base !== sanitizedQuote).map((base)=>`${base}${sanitizedQuote}`);\n}\nfunction dedupePreserveOrder(items) {\n    const seen = new Set();\n    const out = [];\n    for (const item of items){\n        const key = item.toUpperCase();\n        if (seen.has(key)) continue;\n        seen.add(key);\n        out.push(item);\n    }\n    return out;\n}\nfunction sanitizeSymbols(values) {\n    return dedupePreserveOrder(values.map((value)=>sanitizeSymbol(value)).filter((value)=>Boolean(value)));\n}\nfunction sanitizeBases(values) {\n    return (0,_lib_markets_pairs__WEBPACK_IMPORTED_MODULE_1__.dedupeCoins)(values.map((value)=>(0,_lib_markets_pairs__WEBPACK_IMPORTED_MODULE_1__.normalizeCoin)(value))).filter(Boolean);\n}\nasync function resolveSymbolSelection(url, opts) {\n    const quote = (opts?.quote ?? \"USDT\").toUpperCase();\n    const baseTokens = collectQueryValues(url, [\n        \"bases\",\n        \"base\"\n    ]);\n    const explicitBases = sanitizeBases(baseTokens).filter((coin)=>coin !== quote);\n    const hasQueryBases = explicitBases.length > 0;\n    const baseUniverse = hasQueryBases ? {\n        bases: explicitBases,\n        source: \"query\"\n    } : await resolveBases(url.origin, quote);\n    const defaults = buildDefaults(baseUniverse.bases, quote);\n    const extraTokens = collectQueryValues(url, [\n        \"extra\",\n        \"extras\",\n        \"include\"\n    ]);\n    const extras = sanitizeSymbols(extraTokens);\n    const symbolTokens = collectQueryValues(url, [\n        \"symbols\",\n        \"symbol\"\n    ]);\n    const explicit = sanitizeSymbols(symbolTokens);\n    const symbols = explicit.length ? explicit : dedupePreserveOrder([\n        ...defaults,\n        ...extras\n    ]);\n    const quotes = dedupePreserveOrder(symbols.map((symbol)=>splitSymbol(symbol, quote).quote).filter(Boolean));\n    return {\n        bases: baseUniverse.bases,\n        defaults,\n        extras,\n        explicit,\n        symbols,\n        quote,\n        quotes,\n        source: baseUniverse.source\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3N5bWJvbHMvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBaUU7QUFLcEM7QUFFN0IsTUFBTUksZUFBZTtJQUFDO0lBQU87SUFBTTtJQUFNO0lBQU07SUFBTztJQUFRO0lBQU87Q0FBTztBQUk1RSxNQUFNQyx5QkFBeUI7SUFBQztJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtDQUFPO0FBcUIzRSxNQUFNQyxpQkFBaUIsQ0FBQ0M7SUFDdEIsSUFBSSxPQUFPQSxVQUFVLFVBQVUsT0FBTztJQUN0QyxNQUFNQyxNQUFNRCxNQUFNRSxJQUFJLEdBQUdDLFdBQVc7SUFDcEMsSUFBSSxDQUFDRixLQUFLLE9BQU87SUFDakIsT0FBTyxtQkFBbUJHLElBQUksQ0FBQ0gsT0FBT0EsTUFBTTtBQUM5QztBQUVBLFNBQVNJLFVBQVVDLE1BQWdCO0lBQ2pDLE1BQU1DLE1BQWdCLEVBQUU7SUFDeEIsS0FBSyxNQUFNUCxTQUFTTSxPQUFRO1FBQzFCLElBQUksQ0FBQ04sT0FBTztRQUNaLEtBQUssTUFBTVEsU0FBU1IsTUFBTVMsS0FBSyxDQUFDLEtBQU07WUFDcEMsTUFBTUMsVUFBVUYsTUFBTU4sSUFBSTtZQUMxQixJQUFJUSxTQUFTSCxJQUFJSSxJQUFJLENBQUNEO1FBQ3hCO0lBQ0Y7SUFDQSxPQUFPSDtBQUNUO0FBRUEsU0FBU0ssbUJBQW1CQyxHQUFRLEVBQUVDLElBQWM7SUFDbEQsTUFBTUMsWUFBc0IsRUFBRTtJQUM5QixLQUFLLE1BQU1DLE9BQU9GLEtBQU07UUFDdEIsTUFBTVIsU0FBU08sSUFBSUksWUFBWSxDQUFDQyxNQUFNLENBQUNGO1FBQ3ZDLElBQUksQ0FBQ1YsT0FBT2EsTUFBTSxFQUFFO1FBQ3BCSixVQUFVSixJQUFJLElBQUlOLFVBQVVDO0lBQzlCO0lBQ0EsT0FBT1M7QUFDVDtBQUVBLGVBQWVLLGtCQUFrQkMsTUFBYztJQUM3QyxJQUFJO1FBQ0YsTUFBTUMsV0FBVyxNQUFN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QU1FLGVBQWVoRSxtQkFBbUJDLEtBQUs7UUFBQztRQUFXO0tBQVM7SUFDbEUsTUFBTWdFLFdBQVdaLGdCQUFnQlc7SUFFakMsTUFBTTlDLFVBQVUrQyxTQUFTMUQsTUFBTSxHQUMzQjBELFdBQ0FuQixvQkFBb0I7V0FBSWU7V0FBYUU7S0FBTztJQUVoRCxNQUFNRyxTQUFTcEIsb0JBQ2I1QixRQUNHQyxHQUFHLENBQUMsQ0FBQ0ssU0FBV0QsWUFBWUMsUUFBUUcsT0FBT0EsS0FBSyxFQUNoRE0sTUFBTSxDQUFDUztJQUdaLE9BQU87UUFDTFAsT0FBT3lCLGFBQWF6QixLQUFLO1FBQ3pCMEI7UUFDQUU7UUFDQUU7UUFDQS9DO1FBQ0FTO1FBQ0F1QztRQUNBOUIsUUFBUXdCLGFBQWF4QixNQUFNO0lBQzdCO0FBQ0Y7QUFFd0IiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxjb3JlXFxmZWF0dXJlc1xcc3RyLWF1eFxcc3ltYm9sc1xcaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVzb2x2ZUNvaW5zRnJvbVNldHRpbmdzIH0gZnJvbSBcIkAvbGliL3NldHRpbmdzL3NlcnZlclwiO1xuaW1wb3J0IHtcbiAgZGVkdXBlQ29pbnMsXG4gIG5vcm1hbGl6ZUNvaW4sXG4gIHVzZHRMZWdzRnJvbUNvaW5zLFxufSBmcm9tIFwiQC9saWIvbWFya2V0cy9wYWlyc1wiO1xuXG5jb25zdCBLTk9XTl9RVU9URVMgPSBbXCJVU0RUXCIsXCJCVENcIixcIkVUSFwiLFwiQk5CXCIsXCJCVVNEXCIsXCJGRFVTRFwiLFwiVVNEQ1wiLFwiVFVTRFwiXSBhcyBjb25zdDtcblxudHlwZSBLbm93blF1b3RlID0gKHR5cGVvZiBLTk9XTl9RVU9URVMpW251bWJlcl07XG5cbmNvbnN0IERFRkFVTFRfRkFMTEJBQ0tfQkFTRVMgPSBbXCJCVENcIixcIkVUSFwiLFwiQk5CXCIsXCJTT0xcIixcIkFEQVwiLFwiWFJQXCIsXCJET0dFXCJdO1xuXG5leHBvcnQgdHlwZSBTeW1ib2xTb3VyY2UgPVxuICB8IFwicXVlcnlcIlxuICB8IFwic2V0dGluZ3NcIlxuICB8IFwic2V0dGluZ3Nfc3ltYm9sc1wiXG4gIHwgXCJwcmV2aWV3XCJcbiAgfCBcImVudlwiXG4gIHwgXCJmYWxsYmFja1wiO1xuXG5leHBvcnQgdHlwZSBTeW1ib2xTZWxlY3Rpb24gPSB7XG4gIGJhc2VzOiBzdHJpbmdbXTtcbiAgZGVmYXVsdHM6IHN0cmluZ1tdO1xuICBleHRyYXM6IHN0cmluZ1tdO1xuICBleHBsaWNpdDogc3RyaW5nW107XG4gIHN5bWJvbHM6IHN0cmluZ1tdO1xuICBxdW90ZTogc3RyaW5nO1xuICBxdW90ZXM6IHN0cmluZ1tdO1xuICBzb3VyY2U6IFN5bWJvbFNvdXJjZTtcbn07XG5cbmNvbnN0IHNhbml0aXplU3ltYm9sID0gKHZhbHVlOiB1bmtub3duKTogc3RyaW5nID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIFwiXCI7XG4gIGNvbnN0IHJhdyA9IHZhbHVlLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIXJhdykgcmV0dXJuIFwiXCI7XG4gIHJldHVybiAvXltBLVowLTldezUsMjB9JC8udGVzdChyYXcpID8gcmF3IDogXCJcIjtcbn07XG5cbmZ1bmN0aW9uIHBhcnNlTGlzdCh2YWx1ZXM6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICBjb25zdCBvdXQ6IHN0cmluZ1tdID0gW107XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgaWYgKCF2YWx1ZSkgY29udGludWU7XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiB2YWx1ZS5zcGxpdChcIixcIikpIHtcbiAgICAgIGNvbnN0IHRyaW1tZWQgPSB0b2tlbi50cmltKCk7XG4gICAgICBpZiAodHJpbW1lZCkgb3V0LnB1c2godHJpbW1lZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3RRdWVyeVZhbHVlcyh1cmw6IFVSTCwga2V5czogc3RyaW5nW10pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IGNvbGxlY3RlZDogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IHZhbHVlcyA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0QWxsKGtleSk7XG4gICAgaWYgKCF2YWx1ZXMubGVuZ3RoKSBjb250aW51ZTtcbiAgICBjb2xsZWN0ZWQucHVzaCguLi5wYXJzZUxpc3QodmFsdWVzKSk7XG4gIH1cbiAgcmV0dXJuIGNvbGxlY3RlZDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0UHJldmlld1N5bWJvbHMob3JpZ2luOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtvcmlnaW59L2FwaS9wcmV2aWV3L3N5bWJvbHNgLCB7IGNhY2hlOiBcIm5vLXN0b3JlXCIgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHBheWxvYWQgPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpKSBhcyBhbnk7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocGF5bG9hZD8uc3ltYm9scylcbiAgICAgID8gcGF5bG9hZC5zeW1ib2xzLm1hcCgoczogdW5rbm93bikgPT4gU3RyaW5nKHMgPz8gXCJcIikudHJpbSgpLnRvVXBwZXJDYXNlKCkpXG4gICAgICA6IFtdO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0U2V0dGluZ3NTeW1ib2xzKG9yaWdpbjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7b3JpZ2lufS9hcGkvcHJldmlldy91bml2ZXJzZS9zeW1ib2xzYCwgeyBjYWNoZTogXCJuby1zdG9yZVwiIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHJldHVybiBbXTtcbiAgICBjb25zdCBwYXlsb2FkID0gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSkgYXMgYW55O1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHBheWxvYWQ/LnN5bWJvbHMpXG4gICAgICA/IHBheWxvYWQuc3ltYm9scy5tYXAoKHM6IHVua25vd24pID0+IFN0cmluZyhzID8/IFwiXCIpLnRyaW0oKS50b1VwcGVyQ2FzZSgpKVxuICAgICAgOiBbXTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFN5bWJvbChcbiAgc3ltYm9sOiBzdHJpbmcsXG4gIGZhbGxiYWNrUXVvdGU6IEtub3duUXVvdGUgfCBzdHJpbmcgPSBcIlVTRFRcIlxuKTogeyBiYXNlOiBzdHJpbmc7IHF1b3RlOiBzdHJpbmcgfSB7XG4gIGNvbnN0IHZhbHVlID0gU3RyaW5nKHN5bWJvbCA/PyBcIlwiKS50cmltKCkudG9VcHBlckNhc2UoKTtcbiAgaWYgKCF2YWx1ZSkgcmV0dXJuIHsgYmFzZTogXCJcIiwgcXVvdGU6IGZhbGxiYWNrUXVvdGUgfTtcbiAgZm9yIChjb25zdCBxdW90ZSBvZiBLTk9XTl9RVU9URVMpIHtcbiAgICBpZiAodmFsdWUuZW5kc1dpdGgocXVvdGUpICYmIHZhbHVlLmxlbmd0aCA+IHF1b3RlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHsgYmFzZTogdmFsdWUuc2xpY2UoMCwgLXF1b3RlLmxlbmd0aCksIHF1b3RlIH07XG4gICAgfVxuICB9XG4gIGlmIChmYWxsYmFja1F1b3RlICYmIHZhbHVlLmVuZHNXaXRoKGZhbGxiYWNrUXVvdGUpICYmIHZhbHVlLmxlbmd0aCA+IGZhbGxiYWNrUXVvdGUubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHsgYmFzZTogdmFsdWUuc2xpY2UoMCwgLWZhbGxiYWNrUXVvdGUubGVuZ3RoKSwgcXVvdGU6IGZhbGxiYWNrUXVvdGUgfTtcbiAgfVxuICByZXR1cm4geyBiYXNlOiB2YWx1ZS5yZXBsYWNlKC9VU0RUJC9pLCBcIlwiKSwgcXVvdGU6IGZhbGxiYWNrUXVvdGUgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUJhc2VzKFxuICBvcmlnaW46IHN0cmluZyxcbiAgcXVvdGU6IHN0cmluZ1xuKTogUHJvbWlzZTx7IGJhc2VzOiBzdHJpbmdbXTsgc291cmNlOiBTeW1ib2xTb3VyY2UgfT4ge1xuICBjb25zdCBmcm9tU2V0dGluZ3MgPSBkZWR1cGVDb2lucyhhd2FpdCByZXNvbHZlQ29pbnNGcm9tU2V0dGluZ3MoKSkuZmlsdGVyKFxuICAgIChjb2luKSA9PiBjb2luICYmIGNvaW4gIT09IHF1b3RlXG4gICk7XG4gIGlmIChmcm9tU2V0dGluZ3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHsgYmFzZXM6IGZyb21TZXR0aW5ncywgc291cmNlOiBcInNldHRpbmdzXCIgfTtcbiAgfVxuXG4gIGNvbnN0IHNldHRpbmdzU3ltYm9scyA9IGF3YWl0IGdldFNldHRpbmdzU3ltYm9scyhvcmlnaW4pO1xuICBpZiAoc2V0dGluZ3NTeW1ib2xzLmxlbmd0aCkge1xuICAgIGNvbnN0IGJhc2VzID0gZGVkdXBlQ29pbnMoXG4gICAgICBzZXR0aW5nc1N5bWJvbHMubWFwKChzeW1ib2wpID0+IHNwbGl0U3ltYm9sKHN5bWJvbCwgcXVvdGUpLmJhc2UpXG4gICAgKS5maWx0ZXIoKGNvaW4pID0+IGNvaW4gJiYgY29pbiAhPT0gcXVvdGUpO1xuICAgIGlmIChiYXNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7IGJhc2VzLCBzb3VyY2U6IFwic2V0dGluZ3Nfc3ltYm9sc1wiIH07XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcHJldmlld1N5bWJvbHMgPSBhd2FpdCBnZXRQcmV2aWV3U3ltYm9scyhvcmlnaW4pO1xuICBpZiAocHJldmlld1N5bWJvbHMubGVuZ3RoKSB7XG4gICAgY29uc3QgYmFzZXMgPSBkZWR1cGVDb2lucyhcbiAgICAgIHByZXZpZXdTeW1ib2xzLm1hcCgoc3ltYm9sKSA9PiBzcGxpdFN5bWJvbChzeW1ib2wsIHF1b3RlKS5iYXNlKVxuICAgICkuZmlsdGVyKChjb2luKSA9PiBjb2luICYmIGNvaW4gIT09IHF1b3RlKTtcbiAgICBpZiAoYmFzZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4geyBiYXNlcywgc291cmNlOiBcInByZXZpZXdcIiB9O1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVudiA9IFN0cmluZyhwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19DT0lOUyA/PyBcIlwiKVxuICAgIC50cmltKClcbiAgICAudG9VcHBlckNhc2UoKTtcbiAgaWYgKGVudikge1xuICAgIGNvbnN0IGJhc2VzID0gZGVkdXBlQ29pbnMoZW52LnNwbGl0KC9bXFxzLF0rL2cpLmZpbHRlcihCb29sZWFuKSkuZmlsdGVyKFxuICAgICAgKGNvaW4pID0+IGNvaW4gJiYgY29pbiAhPT0gcXVvdGVcbiAgICApO1xuICAgIGlmIChiYXNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7IGJhc2VzLCBzb3VyY2U6IFwiZW52XCIgfTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBmYWxsYmFjayA9IGRlZHVwZUNvaW5zKERFRkFVTFRfRkFMTEJBQ0tfQkFTRVMpLmZpbHRlcihcbiAgICAoY29pbikgPT4gY29pbiAmJiBjb2luICE9PSBxdW90ZVxuICApO1xuICByZXR1cm4geyBiYXNlczogZmFsbGJhY2ssIHNvdXJjZTogXCJmYWxsYmFja1wiIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRGVmYXVsdHMoYmFzZXM6IHN0cmluZ1tdLCBxdW90ZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICBjb25zdCBzYW5pdGl6ZWRRdW90ZSA9IG5vcm1hbGl6ZUNvaW4ocXVvdGUpIHx8IFwiVVNEVFwiO1xuICBpZiAoc2FuaXRpemVkUXVvdGUgPT09IFwiVVNEVFwiKSB7XG4gICAgcmV0dXJuIHVzZHRMZWdzRnJvbUNvaW5zKGJhc2VzKTtcbiAgfVxuICByZXR1cm4gYmFzZXNcbiAgICAubWFwKChiYXNlKSA9PiBub3JtYWxpemVDb2luKGJhc2UpKVxuICAgIC5maWx0ZXIoKGJhc2UpID0+IGJhc2UgJiYgYmFzZSAhPT0gc2FuaXRpemVkUXVvdGUpXG4gICAgLm1hcCgoYmFzZSkgPT4gYCR7YmFzZX0ke3Nhbml0aXplZFF1b3RlfWApO1xufVxuXG5mdW5jdGlvbiBkZWR1cGVQcmVzZXJ2ZU9yZGVyKGl0ZW1zOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBjb25zdCBvdXQ6IHN0cmluZ1tdID0gW107XG4gIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgIGNvbnN0IGtleSA9IGl0ZW0udG9VcHBlckNhc2UoKTtcbiAgICBpZiAoc2Vlbi5oYXMoa2V5KSkgY29udGludWU7XG4gICAgc2Vlbi5hZGQoa2V5KTtcbiAgICBvdXQucHVzaChpdGVtKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZVN5bWJvbHModmFsdWVzOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIGRlZHVwZVByZXNlcnZlT3JkZXIoXG4gICAgdmFsdWVzXG4gICAgICAubWFwKCh2YWx1ZSkgPT4gc2FuaXRpemVTeW1ib2wodmFsdWUpKVxuICAgICAgLmZpbHRlcigodmFsdWUpID0+IEJvb2xlYW4odmFsdWUpKVxuICApO1xufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZUJhc2VzKHZhbHVlczogc3RyaW5nW10pOiBzdHJpbmdbXSB7XG4gIHJldHVybiBkZWR1cGVDb2lucyh2YWx1ZXMubWFwKCh2YWx1ZSkgPT4gbm9ybWFsaXplQ29pbih2YWx1ZSkpKS5maWx0ZXIoQm9vbGVhbik7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlU3ltYm9sU2VsZWN0aW9uKFxuICB1cmw6IFVSTCxcbiAgb3B0cz86IHsgcXVvdGU/OiBzdHJpbmcgfVxuKTogUHJvbWlzZTxTeW1ib2xTZWxlY3Rpb24+IHtcbiAgY29uc3QgcXVvdGUgPSAob3B0cz8ucXVvdGUgPz8gXCJVU0RUXCIpLnRvVXBwZXJDYXNlKCk7XG5cbiAgY29uc3QgYmFzZVRva2VucyA9IGNvbGxlY3RRdWVyeVZhbHVlcyh1cmwsIFtcImJhc2VzXCIsIFwiYmFzZVwiXSk7XG4gIGNvbnN0IGV4cGxpY2l0QmFzZXMgPSBzYW5pdGl6ZUJhc2VzKGJhc2VUb2tlbnMpLmZpbHRlcigoY29pbikgPT4gY29pbiAhPT0gcXVvdGUpO1xuICBjb25zdCBoYXNRdWVyeUJhc2VzID0gZXhwbGljaXRCYXNlcy5sZW5ndGggPiAwO1xuXG4gIGNvbnN0IGJhc2VVbml2ZXJzZSA9IGhhc1F1ZXJ5QmFzZXNcbiAgICA/IHsgYmFzZXM6IGV4cGxpY2l0QmFzZXMsIHNvdXJjZTogXCJxdWVyeVwiIGFzIFN5bWJvbFNvdXJjZSB9XG4gICAgOiBhd2FpdCByZXNvbHZlQmFzZXModXJsLm9yaWdpbiwgcXVvdGUpO1xuXG4gIGNvbnN0IGRlZmF1bHRzID0gYnVpbGREZWZhdWx0cyhiYXNlVW5pdmVyc2UuYmFzZXMsIHF1b3RlKTtcblxuICBjb25zdCBleHRyYVRva2VucyA9IGNvbGxlY3RRdWVyeVZhbHVlcyh1cmwsIFtcImV4dHJhXCIsIFwiZXh0cmFzXCIsIFwiaW5jbHVkZVwiXSk7XG4gIGNvbnN0IGV4dHJhcyA9IHNhbml0aXplU3ltYm9scyhleHRyYVRva2Vucyk7XG5cbiAgY29uc3Qgc3ltYm9sVG9rZW5zID0gY29sbGVjdFF1ZXJ5VmFsdWVzKHVybCwgW1wic3ltYm9sc1wiLCBcInN5bWJvbFwiXSk7XG4gIGNvbnN0IGV4cGxpY2l0ID0gc2FuaXRpemVTeW1ib2xzKHN5bWJvbFRva2Vucyk7XG5cbiAgY29uc3Qgc3ltYm9scyA9IGV4cGxpY2l0Lmxlbmd0aFxuICAgID8gZXhwbGljaXRcbiAgICA6IGRlZHVwZVByZXNlcnZlT3JkZXIoWy4uLmRlZmF1bHRzLCAuLi5leHRyYXNdKTtcblxuICBjb25zdCBxdW90ZXMgPSBkZWR1cGVQcmVzZXJ2ZU9yZGVyKFxuICAgIHN5bWJvbHNcbiAgICAgIC5tYXAoKHN5bWJvbCkgPT4gc3BsaXRTeW1ib2woc3ltYm9sLCBxdW90ZSkucXVvdGUpXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBiYXNlczogYmFzZVVuaXZlcnNlLmJhc2VzLFxuICAgIGRlZmF1bHRzLFxuICAgIGV4dHJhcyxcbiAgICBleHBsaWNpdCxcbiAgICBzeW1ib2xzLFxuICAgIHF1b3RlLFxuICAgIHF1b3RlcyxcbiAgICBzb3VyY2U6IGJhc2VVbml2ZXJzZS5zb3VyY2UsXG4gIH07XG59XG5cbmV4cG9ydCB7IEtOT1dOX1FVT1RFUyB9O1xuIl0sIm5hbWVzIjpbInJlc29sdmVDb2luc0Zyb21TZXR0aW5ncyIsImRlZHVwZUNvaW5zIiwibm9ybWFsaXplQ29pbiIsInVzZHRMZWdzRnJvbUNvaW5zIiwiS05PV05fUVVPVEVTIiwiREVGQVVMVF9GQUxMQkFDS19CQVNFUyIsInNhbml0aXplU3ltYm9sIiwidmFsdWUiLCJyYXciLCJ0cmltIiwidG9VcHBlckNhc2UiLCJ0ZXN0IiwicGFyc2VMaXN0IiwidmFsdWVzIiwib3V0IiwidG9rZW4iLCJzcGxpdCIsInRyaW1tZWQiLCJwdXNoIiwiY29sbGVjdFF1ZXJ5VmFsdWVzIiwidXJsIiwia2V5cyIsImNvbGxlY3RlZCIsImtleSIsInNlYXJjaFBhcmFtcyIsImdldEFsbCIsImxlbmd0aCIsImdldFByZXZpZXdTeW1ib2xzIiwib3JpZ2luIiwicmVzcG9uc2UiLCJmZXRjaCIsImNhY2hlIiwib2siLCJwYXlsb2FkIiwianNvbiIsIkFycmF5IiwiaXNBcnJheSIsInN5bWJvbHMiLCJtYXAiLCJzIiwiU3RyaW5nIiwiZ2V0U2V0dGluZ3NTeW1ib2xzIiwic3BsaXRTeW1ib2wiLCJzeW1ib2wiLCJmYWxsYmFja1F1b3RlIiwiYmFzZSIsInF1b3RlIiwiZW5kc1dpdGgiLCJzbGljZSIsInJlcGxhY2UiLCJyZXNvbHZlQmFzZXMiLCJmcm9tU2V0dGluZ3MiLCJmaWx0ZXIiLCJjb2luIiwiYmFzZXMiLCJzb3VyY2UiLCJzZXR0aW5nc1N5bWJvbHMiLCJwcmV2aWV3U3ltYm9scyIsImVudiIsInByb2Nlc3MiLCJORVhUX1BVQkxJQ19DT0lOUyIsIkJvb2xlYW4iLCJmYWxsYmFjayIsImJ1aWxkRGVmYXVsdHMiLCJzYW5pdGl6ZWRRdW90ZSIsImRlZHVwZVByZXNlcnZlT3JkZXIiLCJpdGVtcyIsInNlZW4iLCJTZXQiLCJpdGVtIiwiaGFzIiwiYWRkIiwic2FuaXRpemVTeW1ib2xzIiwic2FuaXRpemVCYXNlcyIsInJlc29sdmVTeW1ib2xTZWxlY3Rpb24iLCJvcHRzIiwiYmFzZVRva2VucyIsImV4cGxpY2l0QmFzZXMiLCJoYXNRdWVyeUJhc2VzIiwiYmFzZVVuaXZlcnNlIiwiZGVmYXVsdHMiLCJleHRyYVRva2VucyIsImV4dHJhcyIsInN5bWJvbFRva2VucyIsImV4cGxpY2l0IiwicXVvdGVzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/symbols/index.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/features/str-aux/vectors.ts":
/*!**********************************************!*\
  !*** ./src/core/features/str-aux/vectors.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildVectorNuclei: () => (/* binding */ buildVectorNuclei),\n/* harmony export */   computeVectorSummary: () => (/* binding */ computeVectorSummary)\n/* harmony export */ });\n/* harmony import */ var _calc_tendency__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calc/tendency */ \"(rsc)/./src/core/features/str-aux/calc/tendency.ts\");\n// src/core/features/str-aux/vectors.ts\n// Shared scaffolding for STR-AUX tendency vectors (vInner, vOuter, vTendency, vSwap).\n// Consolidates the sampling/binning logic so both stats + API layers can reuse the same path.\n\nconst EPS = 1e-9;\nconst clamp01 = (value)=>Math.max(0, Math.min(1, value));\nconst SAFE_SCALE = (scale)=>Number.isFinite(scale) && scale ? Number(scale) : 100;\nconst SAFE_BINS = (bins)=>Math.max(1, Math.floor(Number.isFinite(bins) ? bins : 1));\nfunction sampleWeight(point) {\n    const primary = point.weight ?? point.w;\n    if (Number.isFinite(primary)) {\n        const value = Number(primary);\n        if (value > 0) return value;\n    }\n    if (Number.isFinite(point.volume)) {\n        const volume = Number(point.volume);\n        if (volume > 0) return volume;\n    }\n    return 1;\n}\nfunction nucleusWeight(nucleus) {\n    if (nucleus.weights && nucleus.weights.length) {\n        return nucleus.weights.reduce((sum, w)=>sum + (Number.isFinite(w) && w > 0 ? Number(w) : 0), 0);\n    }\n    return nucleus.values.length;\n}\nfunction buildVectorNuclei(points, binsCount) {\n    const bins = SAFE_BINS(binsCount);\n    if (!points?.length) {\n        return Array.from({\n            length: bins\n        }, ()=>({\n                values: [],\n                weights: []\n            }));\n    }\n    const prices = points.map((p)=>Number(p.price)).filter((price)=>Number.isFinite(price));\n    if (!prices.length) {\n        return Array.from({\n            length: bins\n        }, ()=>({\n                values: [],\n                weights: []\n            }));\n    }\n    const pMin = Math.min(...prices);\n    const pMax = Math.max(...prices);\n    const span = Math.max(EPS, pMax - pMin);\n    const buckets = new Map();\n    for (const point of points){\n        const price = Number(point.price);\n        if (!Number.isFinite(price)) continue;\n        const norm = clamp01((price - pMin) / span);\n        const index = Math.max(0, Math.min(bins - 1, Math.round(norm * (bins - 1))));\n        const weight = sampleWeight(point);\n        const entry = buckets.get(index) ?? {\n            values: [],\n            weights: []\n        };\n        entry.values.push(norm);\n        entry.weights.push(weight);\n        buckets.set(index, entry);\n    }\n    const nuclei = [];\n    for(let idx = 0; idx < bins; idx++){\n        const entry = buckets.get(idx);\n        nuclei.push(entry ? {\n            values: entry.values,\n            weights: entry.weights\n        } : {\n            values: [],\n            weights: []\n        });\n    }\n    return nuclei;\n}\nfunction computeVectorSummary(points, options) {\n    const scale = SAFE_SCALE(options.scale);\n    const bins = SAFE_BINS(options.bins);\n    const safePoints = Array.isArray(points) ? points.map((raw)=>{\n        const price = Number(raw?.price);\n        if (!Number.isFinite(price)) return null;\n        const vectorPoint = {\n            price,\n            ts: Number.isFinite(raw?.ts) ? Number(raw.ts) : undefined,\n            w: Number.isFinite(raw?.w) ? Number(raw.w) : undefined,\n            weight: Number.isFinite(raw?.weight) ? Number(raw.weight) : undefined,\n            volume: Number.isFinite(raw?.volume) ? Number(raw.volume) : undefined\n        };\n        return vectorPoint;\n    }).filter((p)=>Boolean(p)) : [];\n    const samples = safePoints.length;\n    const nuclei = buildVectorNuclei(safePoints, bins);\n    const composeWeights = nuclei.map((nu)=>({\n            gamma: nucleusWeight(nu)\n        }));\n    const weightSum = composeWeights.reduce((sum, w)=>{\n        const gamma = Number.isFinite(w.gamma) ? Math.max(0, w.gamma) : 0;\n        return sum + gamma;\n    }, 0);\n    const aggregateInner = (0,_calc_tendency__WEBPACK_IMPORTED_MODULE_0__.aggregateInnerNow)(nuclei, composeWeights, undefined, scale);\n    const outerScaled = (0,_calc_tendency__WEBPACK_IMPORTED_MODULE_0__.vOuter)(nuclei, composeWeights, {\n        scale\n    });\n    const historyInner = options.history?.inner ? [\n        ...options.history.inner\n    ] : [];\n    const historyTendency = options.history?.tendency ? [\n        ...options.history.tendency\n    ] : [];\n    const tendencySeries = historyTendency.concat([\n        outerScaled\n    ]);\n    const window = Math.max(3, Math.floor(options.tendencyWindow ?? 30));\n    const normalizer = options.tendencyNorm ?? 'mad';\n    const tendencyMetrics = (0,_calc_tendency__WEBPACK_IMPORTED_MODULE_0__.vTendencyFromSeries)(tendencySeries, {\n        window,\n        scale,\n        normalizer\n    });\n    let swap;\n    if (historyInner.length && historyTendency.length) {\n        const innerHist = historyInner.concat([\n            aggregateInner.scaled\n        ]);\n        const tendencyHist = historyTendency.concat([\n            tendencyMetrics.score\n        ]);\n        swap = (0,_calc_tendency__WEBPACK_IMPORTED_MODULE_0__.vSwapQuartiles)(innerHist, tendencyHist, {\n            scale,\n            alpha: options.swapAlpha ?? 1.2\n        });\n    }\n    const innerValues = nuclei.map((nu)=>(0,_calc_tendency__WEBPACK_IMPORTED_MODULE_0__.vInner)(nu, {\n            scale\n        }));\n    const perBin = innerValues.map((scaled, index)=>{\n        const gamma = Number.isFinite(composeWeights[index].gamma) ? Math.max(0, composeWeights[index].gamma) : 0;\n        const share = weightSum > 0 ? gamma / weightSum : innerValues.length ? 1 / innerValues.length : 0;\n        const samplesInBin = nuclei[index].values.length;\n        return {\n            index,\n            scaled,\n            unitless: scale ? scaled / scale : scaled,\n            gamma,\n            share,\n            samples: samplesInBin\n        };\n    });\n    return {\n        scale,\n        bins,\n        samples,\n        inner: {\n            scaled: aggregateInner.scaled,\n            unitless: aggregateInner.unitless,\n            weightSum,\n            perBin\n        },\n        outer: {\n            scaled: outerScaled\n        },\n        tendency: {\n            window,\n            normalizer,\n            series: tendencySeries,\n            metrics: tendencyMetrics\n        },\n        swap,\n        history: {\n            inner: historyInner.length ? historyInner : null,\n            tendency: historyTendency.length ? historyTendency : null\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3ZlY3RvcnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsdUNBQXVDO0FBQ3ZDLHNGQUFzRjtBQUN0Riw4RkFBOEY7QUFVckU7QUFFekIsTUFBTUssTUFBTTtBQUNaLE1BQU1DLFVBQVUsQ0FBQ0MsUUFBa0JDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsR0FBR0g7QUFzRTNELE1BQU1JLGFBQWEsQ0FBQ0MsUUFDbEJDLE9BQU9DLFFBQVEsQ0FBQ0YsVUFBVUEsUUFBUUMsT0FBT0QsU0FBUztBQUVwRCxNQUFNRyxZQUFZLENBQUNDLE9BQ2pCUixLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS1MsS0FBSyxDQUFDSixPQUFPQyxRQUFRLENBQUNFLFFBQVNBLE9BQWtCO0FBRXBFLFNBQVNFLGFBQWFDLEtBQWtCO0lBQ3RDLE1BQU1DLFVBQVVELE1BQU1FLE1BQU0sSUFBSUYsTUFBTUcsQ0FBQztJQUN2QyxJQUFJVCxPQUFPQyxRQUFRLENBQUNNLFVBQW9CO1FBQ3RDLE1BQU1iLFFBQVFNLE9BQU9PO1FBQ3JCLElBQUliLFFBQVEsR0FBRyxPQUFPQTtJQUN4QjtJQUVBLElBQUlNLE9BQU9DLFFBQVEsQ0FBQ0ssTUFBTUksTUFBTSxHQUFhO1FBQzNDLE1BQU1BLFNBQVNWLE9BQU9NLE1BQU1JLE1BQU07UUFDbEMsSUFBSUEsU0FBUyxHQUFHLE9BQU9BO0lBQ3pCO0lBRUEsT0FBTztBQUNUO0FBRUEsU0FBU0MsY0FBY0MsT0FBb0I7SUFDekMsSUFBSUEsUUFBUUMsT0FBTyxJQUFJRCxRQUFRQyxPQUFPLENBQUNDLE1BQU0sRUFBRTtRQUM3QyxPQUFPRixRQUFRQyxPQUFPLENBQUNFLE1BQU0sQ0FDM0IsQ0FBQ0MsS0FBS1AsSUFBTU8sTUFBT2hCLENBQUFBLE9BQU9DLFFBQVEsQ0FBQ1EsTUFBTUEsSUFBSSxJQUFJVCxPQUFPUyxLQUFLLElBQzdEO0lBRUo7SUFDQSxPQUFPRyxRQUFR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QWdEO1FBQ0FTLE9BQU87WUFDTFksUUFBUWhCLGVBQWVnQixNQUFNO1lBQzdCUyxVQUFVekIsZUFBZXlCLFFBQVE7WUFDakMxQjtZQUNBdUI7UUFDRjtRQUNBSSxPQUFPO1lBQ0xWLFFBQVFmO1FBQ1Y7UUFDQUssVUFBVTtZQUNSRztZQUNBRTtZQUNBZ0IsUUFBUXBCO1lBQ1JxQixTQUFTZjtRQUNYO1FBQ0FDO1FBQ0FYLFNBQVM7WUFDUEMsT0FBT0YsYUFBYTVDLE1BQU0sR0FBRzRDLGVBQWU7WUFDNUNJLFVBQVVELGdCQUFnQi9DLE1BQU0sR0FBRytDLGtCQUFrQjtRQUN2RDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxjb3JlXFxmZWF0dXJlc1xcc3RyLWF1eFxcdmVjdG9ycy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29yZS9mZWF0dXJlcy9zdHItYXV4L3ZlY3RvcnMudHNcbi8vIFNoYXJlZCBzY2FmZm9sZGluZyBmb3IgU1RSLUFVWCB0ZW5kZW5jeSB2ZWN0b3JzICh2SW5uZXIsIHZPdXRlciwgdlRlbmRlbmN5LCB2U3dhcCkuXG4vLyBDb25zb2xpZGF0ZXMgdGhlIHNhbXBsaW5nL2Jpbm5pbmcgbG9naWMgc28gYm90aCBzdGF0cyArIEFQSSBsYXllcnMgY2FuIHJldXNlIHRoZSBzYW1lIHBhdGguXG5cbmltcG9ydCB7XG4gIGFnZ3JlZ2F0ZUlubmVyTm93LFxuICB2SW5uZXIsXG4gIHZPdXRlcixcbiAgdlRlbmRlbmN5RnJvbVNlcmllcyxcbiAgdlN3YXBRdWFydGlsZXMsXG4gIHR5cGUgTnVjbGV1cyBhcyBUZW5kTnVjbGV1cyxcbiAgdHlwZSBDb21wb3NlV2VpZ2h0cyxcbn0gZnJvbSAnLi9jYWxjL3RlbmRlbmN5JztcblxuY29uc3QgRVBTID0gMWUtOTtcbmNvbnN0IGNsYW1wMDEgPSAodmFsdWU6IG51bWJlcikgPT4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdmFsdWUpKTtcblxuZXhwb3J0IHR5cGUgVmVjdG9yUG9pbnQgPSB7XG4gIHByaWNlOiBudW1iZXI7XG4gIHRzPzogbnVtYmVyO1xuICB3PzogbnVtYmVyO1xuICB3ZWlnaHQ/OiBudW1iZXI7XG4gIHZvbHVtZT86IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIFZlY3Rvckhpc3RvcnkgPSB7XG4gIGlubmVyPzogbnVtYmVyW107XG4gIHRlbmRlbmN5PzogbnVtYmVyW107XG59O1xuXG5leHBvcnQgdHlwZSBWZWN0b3JPcHRpb25zID0ge1xuICBiaW5zOiBudW1iZXI7XG4gIHNjYWxlPzogbnVtYmVyO1xuICBoaXN0b3J5PzogVmVjdG9ySGlzdG9yeTtcbiAgdGVuZGVuY3lXaW5kb3c/OiBudW1iZXI7XG4gIHRlbmRlbmN5Tm9ybT86ICdtYWQnIHwgJ3N0ZGV2JztcbiAgc3dhcEFscGhhPzogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgVmVjdG9yQmluU25hcHNob3QgPSB7XG4gIGluZGV4OiBudW1iZXI7XG4gIHNjYWxlZDogbnVtYmVyO1xuICB1bml0bGVzczogbnVtYmVyO1xuICBnYW1tYTogbnVtYmVyO1xuICBzaGFyZTogbnVtYmVyO1xuICBzYW1wbGVzOiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBWZWN0b3JTdW1tYXJ5ID0ge1xuICBzY2FsZTogbnVtYmVyO1xuICBiaW5zOiBudW1iZXI7XG4gIHNhbXBsZXM6IG51bWJlcjtcbiAgaW5uZXI6IHtcbiAgICBzY2FsZWQ6IG51bWJlcjtcbiAgICB1bml0bGVzczogbnVtYmVyO1xuICAgIHdlaWdodFN1bTogbnVtYmVyO1xuICAgIHBlckJpbjogVmVjdG9yQmluU25hcHNob3RbXTtcbiAgfTtcbiAgb3V0ZXI6IHtcbiAgICBzY2FsZWQ6IG51bWJlcjtcbiAgfTtcbiAgdGVuZGVuY3k6IHtcbiAgICB3aW5kb3c6IG51bWJlcjtcbiAgICBub3JtYWxpemVyOiAnbWFkJyB8ICdzdGRldic7XG4gICAgc2VyaWVzOiBudW1iZXJbXTtcbiAgICBtZXRyaWNzOiB7XG4gICAgICBkaXJlY3Rpb246IG51bWJlcjtcbiAgICAgIHN0cmVuZ3RoOiBudW1iZXI7XG4gICAgICBzbG9wZTogbnVtYmVyO1xuICAgICAgcjogbnVtYmVyO1xuICAgICAgc2NvcmU6IG51bWJlcjtcbiAgICB9O1xuICB9O1xuICBzd2FwPzoge1xuICAgIFE6IG51bWJlcjtcbiAgICBzY29yZTogbnVtYmVyO1xuICAgIHExOiBudW1iZXI7XG4gICAgcTM6IG51bWJlcjtcbiAgfTtcbiAgaGlzdG9yeToge1xuICAgIGlubmVyOiBudW1iZXJbXSB8IG51bGw7XG4gICAgdGVuZGVuY3k6IG51bWJlcltdIHwgbnVsbDtcbiAgfTtcbn07XG5cbmNvbnN0IFNBRkVfU0NBTEUgPSAoc2NhbGU6IG51bWJlciB8IHVuZGVmaW5lZCkgPT5cbiAgTnVtYmVyLmlzRmluaXRlKHNjYWxlKSAmJiBzY2FsZSA/IE51bWJlcihzY2FsZSkgOiAxMDA7XG5cbmNvbnN0IFNBRkVfQklOUyA9IChiaW5zOiBudW1iZXIgfCB1bmRlZmluZWQpID0+XG4gIE1hdGgubWF4KDEsIE1hdGguZmxvb3IoTnVtYmVyLmlzRmluaXRlKGJpbnMpID8gKGJpbnMgYXMgbnVtYmVyKSA6IDEpKTtcblxuZnVuY3Rpb24gc2FtcGxlV2VpZ2h0KHBvaW50OiBWZWN0b3JQb2ludCk6IG51bWJlciB7XG4gIGNvbnN0IHByaW1hcnkgPSBwb2ludC53ZWlnaHQgPz8gcG9pbnQudztcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShwcmltYXJ5IGFzIG51bWJlcikpIHtcbiAgICBjb25zdCB2YWx1ZSA9IE51bWJlcihwcmltYXJ5KTtcbiAgICBpZiAodmFsdWUgPiAwKSByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoTnVtYmVyLmlzRmluaXRlKHBvaW50LnZvbHVtZSBhcyBudW1iZXIpKSB7XG4gICAgY29uc3Qgdm9sdW1lID0gTnVtYmVyKHBvaW50LnZvbHVtZSk7XG4gICAgaWYgKHZvbHVtZSA+IDApIHJldHVybiB2b2x1bWU7XG4gIH1cblxuICByZXR1cm4gMTtcbn1cblxuZnVuY3Rpb24gbnVjbGV1c1dlaWdodChudWNsZXVzOiBUZW5kTnVjbGV1cyk6IG51bWJlciB7XG4gIGlmIChudWNsZXVzLndlaWdodHMgJiYgbnVjbGV1cy53ZWlnaHRzLmxlbmd0aCkge1xuICAgIHJldHVybiBudWNsZXVzLndlaWdodHMucmVkdWNlKFxuICAgICAgKHN1bSwgdykgPT4gc3VtICsgKE51bWJlci5pc0Zpbml0ZSh3KSAmJiB3ID4gMCA/IE51bWJlcih3KSA6IDApLFxuICAgICAgMFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG51Y2xldXMudmFsdWVzLmxlbmd0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkVmVjdG9yTnVjbGVpKHBvaW50czogVmVjdG9yUG9pbnRbXSwgYmluc0NvdW50OiBudW1iZXIpOiBUZW5kTnVjbGV1c1tdIHtcbiAgY29uc3QgYmlucyA9IFNBRkVfQklOUyhiaW5zQ291bnQpO1xuICBpZiAoIXBvaW50cz8ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGJpbnMgfSwgKCkgPT4gKHsgdmFsdWVzOiBbXSBhcyBudW1iZXJbXSwgd2VpZ2h0czogW10gYXMgbnVtYmVyW10gfSkpO1xuICB9XG5cbiAgY29uc3QgcHJpY2VzID0gcG9pbnRzXG4gICAgLm1hcCgocCkgPT4gTnVtYmVyKHAucHJpY2UpKVxuICAgIC5maWx0ZXIoKHByaWNlKSA9PiBOdW1iZXIuaXNGaW5pdGUocHJpY2UpKTtcbiAgaWYgKCFwcmljZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGJpbnMgfSwgKCkgPT4gKHsgdmFsdWVzOiBbXSBhcyBudW1iZXJbXSwgd2VpZ2h0czogW10gYXMgbnVtYmVyW10gfSkpO1xuICB9XG5cbiAgY29uc3QgcE1pbiA9IE1hdGgubWluKC4uLnByaWNlcyk7XG4gIGNvbnN0IHBNYXggPSBNYXRoLm1heCguLi5wcmljZXMpO1xuICBjb25zdCBzcGFuID0gTWF0aC5tYXgoRVBTLCBwTWF4IC0gcE1pbik7XG5cbiAgY29uc3QgYnVja2V0cyA9IG5ldyBNYXA8bnVtYmVyLCB7IHZhbHVlczogbnVtYmVyW107IHdlaWdodHM6IG51bWJlcltdIH0+KCk7XG4gIGZvciAoY29uc3QgcG9pbnQgb2YgcG9pbnRzKSB7XG4gICAgY29uc3QgcHJpY2UgPSBOdW1iZXIocG9pbnQucHJpY2UpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHByaWNlKSkgY29udGludWU7XG4gICAgY29uc3Qgbm9ybSA9IGNsYW1wMDEoKHByaWNlIC0gcE1pbikgLyBzcGFuKTtcbiAgICBjb25zdCBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGJpbnMgLSAxLCBNYXRoLnJvdW5kKG5vcm0gKiAoYmlucyAtIDEpKSkpO1xuICAgIGNvbnN0IHdlaWdodCA9IHNhbXBsZVdlaWdodChwb2ludCk7XG4gICAgY29uc3QgZW50cnkgPSBidWNrZXRzLmdldChpbmRleCkgPz8geyB2YWx1ZXM6IFtdLCB3ZWlnaHRzOiBbXSB9O1xuICAgIGVudHJ5LnZhbHVlcy5wdXNoKG5vcm0pO1xuICAgIGVudHJ5LndlaWdodHMucHVzaCh3ZWlnaHQpO1xuICAgIGJ1Y2tldHMuc2V0KGluZGV4LCBlbnRyeSk7XG4gIH1cblxuICBjb25zdCBudWNsZWk6IFRlbmROdWNsZXVzW10gPSBbXTtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgYmluczsgaWR4KyspIHtcbiAgICBjb25zdCBlbnRyeSA9IGJ1Y2tldHMuZ2V0KGlkeCk7XG4gICAgbnVjbGVpLnB1c2goXG4gICAgICBlbnRyeVxuICAgICAgICA/IHsgdmFsdWVzOiBlbnRyeS52YWx1ZXMsIHdlaWdodHM6IGVudHJ5LndlaWdodHMgfVxuICAgICAgICA6IHsgdmFsdWVzOiBbXSwgd2VpZ2h0czogW10gfVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG51Y2xlaTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVWZWN0b3JTdW1tYXJ5KFxuICBwb2ludHM6IFZlY3RvclBvaW50W10sXG4gIG9wdGlvbnM6IFZlY3Rvck9wdGlvbnNcbik6IFZlY3RvclN1bW1hcnkge1xuICBjb25zdCBzY2FsZSA9IFNBRkVfU0NBTEUob3B0aW9ucy5zY2FsZSk7XG4gIGNvbnN0IGJpbnMgPSBTQUZFX0JJTlMob3B0aW9ucy5iaW5zKTtcbiAgY29uc3Qgc2FmZVBvaW50cyA9IEFycmF5LmlzQXJyYXkocG9pbnRzKVxuICAgID8gcG9pbnRzXG4gICAgICAgIC5tYXAoKHJhdykgPT4ge1xuICAgICAgICAgIGNvbnN0IHByaWNlID0gTnVtYmVyKChyYXcgYXMgYW55KT8ucHJpY2UpO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHByaWNlKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgY29uc3QgdmVjdG9yUG9pbnQ6IFZlY3RvclBvaW50ID0ge1xuICAgICAgICAgICAgcHJpY2UsXG4gICAgICAgICAgICB0czogTnVtYmVyLmlzRmluaXRlKChyYXcgYXMgYW55KT8udHMpID8gTnVtYmVyKChyYXcgYXMgYW55KS50cykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB3OiBOdW1iZXIuaXNGaW5pdGUoKHJhdyBhcyBhbnkpPy53KSA/IE51bWJlcigocmF3IGFzIGFueSkudykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB3ZWlnaHQ6IE51bWJlci5pc0Zpbml0ZSgocmF3IGFzIGFueSk/LndlaWdodCkgPyBOdW1iZXIoKHJhdyBhcyBhbnkpLndlaWdodCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB2b2x1bWU6IE51bWJlci5pc0Zpbml0ZSgocmF3IGFzIGFueSk/LnZvbHVtZSkgPyBOdW1iZXIoKHJhdyBhcyBhbnkpLnZvbHVtZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gdmVjdG9yUG9pbnQ7XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoKHApOiBwIGlzIFZlY3RvclBvaW50ID0+IEJvb2xlYW4ocCkpXG4gICAgOiBbXTtcbiAgY29uc3Qgc2FtcGxlcyA9IHNhZmVQb2ludHMubGVuZ3RoO1xuXG4gIGNvbnN0IG51Y2xlaSA9IGJ1aWxkVmVjdG9yTnVjbGVpKHNhZmVQb2ludHMsIGJpbnMpO1xuICBjb25zdCBjb21wb3NlV2VpZ2h0czogQ29tcG9zZVdlaWdodHNbXSA9IG51Y2xlaS5tYXAoKG51KSA9PiAoeyBnYW1tYTogbnVjbGV1c1dlaWdodChudSkgfSkpO1xuICBjb25zdCB3ZWlnaHRTdW0gPSBjb21wb3NlV2VpZ2h0cy5yZWR1Y2UoKHN1bSwgdykgPT4ge1xuICAgIGNvbnN0IGdhbW1hID0gTnVtYmVyLmlzRmluaXRlKHcuZ2FtbWEgYXMgbnVtYmVyKSA/IE1hdGgubWF4KDAsIHcuZ2FtbWEgYXMgbnVtYmVyKSA6IDA7XG4gICAgcmV0dXJuIHN1bSArIGdhbW1hO1xuICB9LCAwKTtcblxuICBjb25zdCBhZ2dyZWdhdGVJbm5lciA9IGFnZ3JlZ2F0ZUlubmVyTm93KG51Y2xlaSwgY29tcG9zZVdlaWdodHMsIHVuZGVmaW5lZCwgc2NhbGUpO1xuICBjb25zdCBvdXRlclNjYWxlZCA9IHZPdXRlcihudWNsZWksIGNvbXBvc2VXZWlnaHRzLCB7IHNjYWxlIH0pO1xuXG4gIGNvbnN0IGhpc3RvcnlJbm5lciA9IG9wdGlvbnMuaGlzdG9yeT8uaW5uZXIgPyBbLi4ub3B0aW9ucy5oaXN0b3J5LmlubmVyXSA6IFtdO1xuICBjb25zdCBoaXN0b3J5VGVuZGVuY3kgPSBvcHRpb25zLmhpc3Rvcnk/LnRlbmRlbmN5ID8gWy4uLm9wdGlvbnMuaGlzdG9yeS50ZW5kZW5jeV0gOiBbXTtcbiAgY29uc3QgdGVuZGVuY3lTZXJpZXMgPSBoaXN0b3J5VGVuZGVuY3kuY29uY2F0KFtvdXRlclNjYWxlZF0pO1xuICBjb25zdCB3aW5kb3cgPSBNYXRoLm1heCgzLCBNYXRoLmZsb29yKG9wdGlvbnMudGVuZGVuY3lXaW5kb3cgPz8gMzApKTtcbiAgY29uc3Qgbm9ybWFsaXplciA9IG9wdGlvbnMudGVuZGVuY3lOb3JtID8/ICdtYWQnO1xuICBjb25zdCB0ZW5kZW5jeU1ldHJpY3MgPSB2VGVuZGVuY3lGcm9tU2VyaWVzKHRlbmRlbmN5U2VyaWVzLCB7XG4gICAgd2luZG93LFxuICAgIHNjYWxlLFxuICAgIG5vcm1hbGl6ZXIsXG4gIH0pO1xuXG4gIGxldCBzd2FwOlxuICAgIHwge1xuICAgICAgICBROiBudW1iZXI7XG4gICAgICAgIHNjb3JlOiBudW1iZXI7XG4gICAgICAgIHExOiBudW1iZXI7XG4gICAgICAgIHEzOiBudW1iZXI7XG4gICAgICB9XG4gICAgfCB1bmRlZmluZWQ7XG5cbiAgaWYgKGhpc3RvcnlJbm5lci5sZW5ndGggJiYgaGlzdG9yeVRlbmRlbmN5Lmxlbmd0aCkge1xuICAgIGNvbnN0IGlubmVySGlzdCA9IGhpc3RvcnlJbm5lci5jb25jYXQoW2FnZ3JlZ2F0ZUlubmVyLnNjYWxlZF0pO1xuICAgIGNvbnN0IHRlbmRlbmN5SGlzdCA9IGhpc3RvcnlUZW5kZW5jeS5jb25jYXQoW3RlbmRlbmN5TWV0cmljcy5zY29yZV0pO1xuICAgIHN3YXAgPSB2U3dhcFF1YXJ0aWxlcyhpbm5lckhpc3QsIHRlbmRlbmN5SGlzdCwge1xuICAgICAgc2NhbGUsXG4gICAgICBhbHBoYTogb3B0aW9ucy5zd2FwQWxwaGEgPz8gMS4yLFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgaW5uZXJWYWx1ZXMgPSBudWNsZWkubWFwKChudSkgPT4gdklubmVyKG51LCB7IHNjYWxlIH0pKTtcbiAgY29uc3QgcGVyQmluOiBWZWN0b3JCaW5TbmFwc2hvdFtdID0gaW5uZXJWYWx1ZXMubWFwKChzY2FsZWQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgZ2FtbWEgPSBOdW1iZXIuaXNGaW5pdGUoY29tcG9zZVdlaWdodHNbaW5kZXhdLmdhbW1hIGFzIG51bWJlcilcbiAgICAgID8gTWF0aC5tYXgoMCwgY29tcG9zZVdlaWdodHNbaW5kZXhdLmdhbW1hIGFzIG51bWJlcilcbiAgICAgIDogMDtcbiAgICBjb25zdCBzaGFyZSA9IHdlaWdodFN1bSA+IDAgPyBnYW1tYSAvIHdlaWdodFN1bSA6IGlubmVyVmFsdWVzLmxlbmd0aCA/IDEgLyBpbm5lclZhbHVlcy5sZW5ndGggOiAwO1xuICAgIGNvbnN0IHNhbXBsZXNJbkJpbiA9IG51Y2xlaVtpbmRleF0udmFsdWVzLmxlbmd0aDtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXgsXG4gICAgICBzY2FsZWQsXG4gICAgICB1bml0bGVzczogc2NhbGUgPyBzY2FsZWQgLyBzY2FsZSA6IHNjYWxlZCxcbiAgICAgIGdhbW1hLFxuICAgICAgc2hhcmUsXG4gICAgICBzYW1wbGVzOiBzYW1wbGVzSW5CaW4sXG4gICAgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBzY2FsZSxcbiAgICBiaW5zLFxuICAgIHNhbXBsZXMsXG4gICAgaW5uZXI6IHtcbiAgICAgIHNjYWxlZDogYWdncmVnYXRlSW5uZXIuc2NhbGVkLFxuICAgICAgdW5pdGxlc3M6IGFnZ3JlZ2F0ZUlubmVyLnVuaXRsZXNzLFxuICAgICAgd2VpZ2h0U3VtLFxuICAgICAgcGVyQmluLFxuICAgIH0sXG4gICAgb3V0ZXI6IHtcbiAgICAgIHNjYWxlZDogb3V0ZXJTY2FsZWQsXG4gICAgfSxcbiAgICB0ZW5kZW5jeToge1xuICAgICAgd2luZG93LFxuICAgICAgbm9ybWFsaXplcixcbiAgICAgIHNlcmllczogdGVuZGVuY3lTZXJpZXMsXG4gICAgICBtZXRyaWNzOiB0ZW5kZW5jeU1ldHJpY3MsXG4gICAgfSxcbiAgICBzd2FwLFxuICAgIGhpc3Rvcnk6IHtcbiAgICAgIGlubmVyOiBoaXN0b3J5SW5uZXIubGVuZ3RoID8gaGlzdG9yeUlubmVyIDogbnVsbCxcbiAgICAgIHRlbmRlbmN5OiBoaXN0b3J5VGVuZGVuY3kubGVuZ3RoID8gaGlzdG9yeVRlbmRlbmN5IDogbnVsbCxcbiAgICB9LFxuICB9O1xufVxuIl0sIm5hbWVzIjpbImFnZ3JlZ2F0ZUlubmVyTm93IiwidklubmVyIiwidk91dGVyIiwidlRlbmRlbmN5RnJvbVNlcmllcyIsInZTd2FwUXVhcnRpbGVzIiwiRVBTIiwiY2xhbXAwMSIsInZhbHVlIiwiTWF0aCIsIm1heCIsIm1pbiIsIlNBRkVfU0NBTEUiLCJzY2FsZSIsIk51bWJlciIsImlzRmluaXRlIiwiU0FGRV9CSU5TIiwiYmlucyIsImZsb29yIiwic2FtcGxlV2VpZ2h0IiwicG9pbnQiLCJwcmltYXJ5Iiwid2VpZ2h0IiwidyIsInZvbHVtZSIsIm51Y2xldXNXZWlnaHQiLCJudWNsZXVzIiwid2VpZ2h0cyIsImxlbmd0aCIsInJlZHVjZSIsInN1bSIsInZhbHVlcyIsImJ1aWxkVmVjdG9yTnVjbGVpIiwicG9pbnRzIiwiYmluc0NvdW50IiwiQXJyYXkiLCJmcm9tIiwicHJpY2VzIiwibWFwIiwicCIsInByaWNlIiwiZmlsdGVyIiwicE1pbiIsInBNYXgiLCJzcGFuIiwiYnVja2V0cyIsIk1hcCIsIm5vcm0iLCJpbmRleCIsInJvdW5kIiwiZW50cnkiLCJnZXQiLCJwdXNoIiwic2V0IiwibnVjbGVpIiwiaWR4IiwiY29tcHV0ZVZlY3RvclN1bW1hcnkiLCJvcHRpb25zIiwic2FmZVBvaW50cyIsImlzQXJyYXkiLCJyYXciLCJ2ZWN0b3JQb2ludCIsInRzIiwidW5kZWZpbmVkIiwiQm9vbGVhbiIsInNhbXBsZXMiLCJjb21wb3NlV2VpZ2h0cyIsIm51IiwiZ2FtbWEiLCJ3ZWlnaHRTdW0iLCJhZ2dyZWdhdGVJbm5lciIsIm91dGVyU2NhbGVkIiwiaGlzdG9yeUlubmVyIiwiaGlzdG9yeSIsImlubmVyIiwiaGlzdG9yeVRlbmRlbmN5IiwidGVuZGVuY3kiLCJ0ZW5kZW5jeVNlcmllcyIsImNvbmNhdCIsIndpbmRvdyIsInRlbmRlbmN5V2luZG93Iiwibm9ybWFsaXplciIsInRlbmRlbmN5Tm9ybSIsInRlbmRlbmN5TWV0cmljcyIsInN3YXAiLCJpbm5lckhpc3QiLCJzY2FsZWQiLCJ0ZW5kZW5jeUhpc3QiLCJzY29yZSIsImFscGhhIiwic3dhcEFscGhhIiwiaW5uZXJWYWx1ZXMiLCJwZXJCaW4iLCJzaGFyZSIsInNhbXBsZXNJbkJpbiIsInVuaXRsZXNzIiwib3V0ZXIiLCJzZXJpZXMiLCJtZXRyaWNzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/core/features/str-aux/vectors.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/sources/binance.ts":
/*!*************************************!*\
  !*** ./src/core/sources/binance.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fetch24hAll: () => (/* binding */ fetch24hAll),\n/* harmony export */   fetch24hForSymbols: () => (/* binding */ fetch24hForSymbols),\n/* harmony export */   fetchBookTicker: () => (/* binding */ fetchBookTicker),\n/* harmony export */   fetchKlines: () => (/* binding */ fetchKlines),\n/* harmony export */   fetchOrderBook: () => (/* binding */ fetchOrderBook),\n/* harmony export */   fetchOrderBooksForCoins: () => (/* binding */ fetchOrderBooksForCoins),\n/* harmony export */   fetchOrderBooksForSymbols: () => (/* binding */ fetchOrderBooksForSymbols),\n/* harmony export */   fetchTicker24h: () => (/* binding */ fetchTicker24h),\n/* harmony export */   fetchTicker24hNum: () => (/* binding */ fetchTicker24hNum),\n/* harmony export */   fetchTickersForCoins: () => (/* binding */ fetchTickersForCoins),\n/* harmony export */   getSettingsCoins: () => (/* binding */ getSettingsCoins),\n/* harmony export */   listSymbolsByQuote: () => (/* binding */ listSymbolsByQuote),\n/* harmony export */   mapTickerBySymbol: () => (/* binding */ mapTickerBySymbol),\n/* harmony export */   usdtSymbolsFor: () => (/* binding */ usdtSymbolsFor)\n/* harmony export */ });\n/* harmony import */ var _core_sources_binanceClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/core/sources/binanceClient */ \"(rsc)/./src/core/sources/binanceClient.ts\");\n/* harmony import */ var _lib_settings_server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/settings/server */ \"(rsc)/./src/lib/settings/server.ts\");\n// src/core/sources/binance.ts\n// Public REST adapter with ticker, klines and orderbook; settings-aware.\n\n\nconst num = (x, d = NaN)=>{\n    const n = Number(x);\n    return Number.isFinite(n) ? n : d;\n};\nasync function fetch24hAll(symbols) {\n    if (!symbols?.length) return [];\n    const qs = new URLSearchParams({\n        symbols: JSON.stringify(symbols)\n    });\n    const arr = await (0,_core_sources_binanceClient__WEBPACK_IMPORTED_MODULE_0__.fetchJson)(`/api/v3/ticker/24hr?${qs.toString()}`);\n    return (Array.isArray(arr) ? arr : []).map((t)=>({\n            symbol: String(t.symbol),\n            weightedAvgPrice: t.weightedAvgPrice,\n            lastPrice: t.lastPrice,\n            priceChangePercent: t.priceChangePercent,\n            priceChange: t.priceChange,\n            openPrice: t.openPrice\n        }));\n}\nfunction mapTickerBySymbol(arr) {\n    const out = {};\n    for (const t of arr)out[t.symbol] = t;\n    return out;\n}\nfunction normCoins(list) {\n    const set = new Set(), out = [];\n    for (const c of list ?? []){\n        const u = String(c || \"\").trim().toUpperCase();\n        if (!u || set.has(u)) continue;\n        set.add(u);\n        out.push(u);\n    }\n    if (!set.has(\"USDT\")) out.push(\"USDT\");\n    return out;\n}\nasync function getSettingsCoins() {\n    const s = await (0,_lib_settings_server__WEBPACK_IMPORTED_MODULE_1__.getAll)();\n    const from = normCoins(s.coinUniverse?.length ? s.coinUniverse : []);\n    return from.length ? from : normCoins([\n        \"BTC\",\n        \"ETH\",\n        \"BNB\",\n        \"SOL\",\n        \"ADA\",\n        \"XRP\",\n        \"PEPE\",\n        \"USDT\"\n    ]);\n}\nfunction usdtSymbolsFor(coins) {\n    return coins.filter((c)=>c !== \"USDT\").map((c)=>`${c}USDT`);\n}\n// Bulk USDT view used for triangulation (kept as-is, but now types are richer).\nasync function fetchTickersForCoins(coins) {\n    const uni = normCoins(coins ?? await getSettingsCoins());\n    const by = mapTickerBySymbol(await fetch24hAll(usdtSymbolsFor(uni)));\n    const out = {\n        USDT: {\n            price: 1,\n            pct24h: 0\n        }\n    };\n    for (const c of uni){\n        if (c === \"USDT\") continue;\n        const t = by[`${c}USDT`];\n        const price = t?.lastPrice != null ? Number(t.lastPrice) : Number(t?.weightedAvgPrice);\n        const pct = t?.priceChangePercent != null ? Number(t.priceChangePercent) : NaN;\n        if (Number.isFinite(price)) out[c] = {\n            price,\n            pct24h: Number.isFinite(pct) ? pct : 0\n        };\n    }\n    return out;\n}\nasync function fetchTicker24h(symbol) {\n    return (0,_core_sources_binanceClient__WEBPACK_IMPORTED_MODULE_0__.fetchJson)(\"/api/v3/ticker/24hr\", {\n        symbol: symbol.toUpperCase()\n    });\n}\n/** Normalized numeric helper: last, pct24h (percent units), delta (absolute) & open */ async function fetchTicker24hNum(symbol) {\n    const t = await fetchTicker24h(symbol);\n    const last = num(t.lastPrice, NaN);\n    const pct = num(t.priceChangePercent, NaN); // percent units\n    let delta = num(t.priceChange, NaN);\n    // robust open and delta if delta missing\n    let open = num(t.openPrice, NaN);\n    if (!Number.isFinite(open) && Number.isFinite(last) && Number.isFinite(pct)) {\n        const r = pct / 100;\n        open = last / (1 + r);\n    }\n    if (!Number.isFinite(delta) && Number.isFinite(last) && Number.isFinite(open)) {\n        delta = last - open;\n    }\n    return {\n        symbol: t.symbol,\n        last: Number.isFinite(last) ? last : null,\n        pct24h: Number.isFinite(pct) ? pct : null,\n        delta: Number.isFinite(delta) ? delta : null,\n        open: Number.isFinite(open) ? open : null\n    };\n}\nasync function fetchKlines(symbol, interval, limit = 128) {\n    return (0,_core_sources_binanceClient__WEBPACK_IMPORTED_MODULE_0__.fetchJson)(\"/api/v3/klines\", {\n        symbol,\n        interval,\n        limit\n    });\n}\nasync function fetchOrderBook(symbol, limit = 100) {\n    const depth = await (0,_core_sources_binanceClient__WEBPACK_IMPORTED_MODULE_0__.fetchJson)(\"/api/v3/depth\", {\n        symbol,\n        limit\n    });\n    const ts = Date.now();\n    const bestBid = num(depth.bids[0]?.[0]);\n    const bestAsk = num(depth.asks[0]?.[0]);\n    const mid = Number.isFinite(bestBid) && Number.isFinite(bestAsk) ? (bestBid + bestAsk) / 2 : NaN;\n    const bidVol = depth.bids.reduce((s, [_, q])=>s + num(q, 0), 0);\n    const askVol = depth.asks.reduce((s, [_, q])=>s + num(q, 0), 0);\n    return {\n        depth,\n        ts,\n        bestBid,\n        bestAsk,\n        mid,\n        bidVol,\n        askVol\n    };\n}\nasync function fetchOrderBooksForSymbols(symbols, limit = 100) {\n    const out = {};\n    await Promise.all((symbols ?? []).map(async (s)=>{\n        const sym = String(s || \"\").toUpperCase();\n        const { mid, bidVol, askVol } = await fetchOrderBook(sym, limit);\n        out[sym] = {\n            mid,\n            bidVol,\n            askVol\n        };\n    }));\n    return out;\n}\nasync function fetchOrderBooksForCoins(coins, limit = 100) {\n    const list = Array.isArray(coins) ? coins.map((c)=>String(c || '').toUpperCase()).filter(Boolean) : [];\n    const symbols = usdtSymbolsFor(list);\n    const books = await fetchOrderBooksForSymbols(symbols, limit);\n    const out = {};\n    for (const coin of list){\n        if (coin === \"USDT\") {\n            out[coin] = {\n                mid: 1,\n                bidVol: 0,\n                askVol: 0\n            };\n            continue;\n        }\n        const entry = books[`${coin}USDT`];\n        out[coin] = entry ?? {\n            mid: NaN,\n            bidVol: 0,\n            askVol: 0\n        };\n    }\n    if (!out.USDT) {\n        out.USDT = {\n            mid: 1,\n            bidVol: 0,\n            askVol: 0\n        };\n    }\n    return out;\n}\nasync function fetchBookTicker(symbol) {\n    const j = await (0,_core_sources_binanceClient__WEBPACK_IMPORTED_MODULE_0__.fetchJson)(\"/api/v3/ticker/bookTicker\", {\n        symbol\n    });\n    const bidPrice = num(j.bidPrice), askPrice = num(j.askPrice);\n    const mid = Number.isFinite(bidPrice) && Number.isFinite(askPrice) ? (bidPrice + askPrice) / 2 : NaN;\n    return {\n        bidPrice,\n        askPrice,\n        mid\n    };\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    fetch24hAll,\n    mapTickerBySymbol,\n    fetchTickersForCoins,\n    getSettingsCoins,\n    usdtSymbolsFor,\n    fetchKlines,\n    fetchOrderBook,\n    fetchOrderBooksForSymbols,\n    fetchOrderBooksForCoins,\n    fetchBookTicker,\n    fetchTicker24h,\n    fetchTicker24hNum\n});\n// src/sources/binance.ts\n// Minimal helpers to list symbols and fetch 24h stats.\n// Adjust base URL or fetch wrapper to your project conventions if needed.\nconst BASE = \"https://api.binance.com\";\nasync function listSymbolsByQuote(quote = \"USDT\") {\n    const r = await fetch(`${BASE}/api/v3/exchangeInfo`, {\n        cache: \"no-store\"\n    });\n    if (!r.ok) throw new Error(`exchangeInfo ${r.status}`);\n    const info = await r.json();\n    const syms = info.symbols.filter((s)=>s.status === \"TRADING\" && s.quoteAsset.toUpperCase() === quote.toUpperCase()).map((s)=>s.symbol).sort();\n    // de-dup\n    const out = [];\n    for (const s of syms)if (!out.length || out[out.length - 1] !== s) out.push(s);\n    return out;\n}\n// If you already have a project-specific fetch24h for one symbol, reuse it inside here.\nasync function fetch24hForSymbols(symbols) {\n    // Batch with Promise.all over /api/v3/ticker/24hr?symbol=XXXX\n    // (Binance also supports /ticker/24hr without symbol returning ALL, but it's heavy;\n    // if you prefer that, you can fetch once and filter.)\n    const qs = symbols.map((s)=>fetch(`${BASE}/api/v3/ticker/24hr?symbol=${s}`, {\n            cache: \"no-store\"\n        }).then((r)=>{\n            if (!r.ok) throw new Error(`24hr ${s} ${r.status}`);\n            return r.json();\n        }).catch((e)=>({\n                symbol: s,\n                _err: String(e)\n            })));\n    return Promise.all(qs);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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V0FBVyxJQUN0RmxCLEdBQUcsQ0FBQ3VCLENBQUFBLElBQUtBLEVBQUVyQixNQUFNLEVBQ2pCbUYsSUFBSTtJQUNQLFNBQVM7SUFDVCxNQUFNM0UsTUFBZ0IsRUFBRTtJQUN4QixLQUFLLE1BQU1hLEtBQUs0RCxLQUFNLElBQUksQ0FBQ3pFLElBQUluQixNQUFNLElBQUltQixHQUFHLENBQUNBLElBQUluQixNQUFNLEdBQUcsRUFBRSxLQUFLZ0MsR0FBR2IsSUFBSVcsSUFBSSxDQUFDRTtJQUM3RSxPQUFPYjtBQUNUO0FBRUEsd0ZBQXdGO0FBQ2pGLGVBQWU0RSxtQkFBbUJoRyxPQUFpQjtJQUN4RCw4REFBOEQ7SUFDOUQsb0ZBQW9GO0lBQ3BGLHNEQUFzRDtJQUN0RCxNQUFNRSxLQUFLRixRQUFRVSxHQUFHLENBQUN1QixDQUFBQSxJQUFLcUQsTUFBTSxHQUFHSCxLQUFLLDJCQUEyQixFQUFFbEQsR0FBRyxFQUFFO1lBQUVzRCxPQUFPO1FBQVcsR0FDN0ZVLElBQUksQ0FBQzlDLENBQUFBO1lBQ0osSUFBSSxDQUFDQSxFQUFFcUMsRUFBRSxFQUFFLE1BQU0sSUFBSUMsTUFBTSxDQUFDLEtBQUssRUFBRXhELEVBQUUsQ0FBQyxFQUFFa0IsRUFBRXVDLE1BQU0sRUFBRTtZQUNsRCxPQUFPdkMsRUFBRXlDLElBQUk7UUFDZixHQUNDTSxLQUFLLENBQUNDLENBQUFBLElBQU07Z0JBQUV2RixRQUFRcUI7Z0JBQUdtRSxNQUFNdkYsT0FBT3NGO1lBQUc7SUFDNUMsT0FBTzVCLFFBQVFDLEdBQUcsQ0FBQ3RFO0FBQ3JCIiwic291cmNlcyI6WyJIOlxcVXNlcnNcXEd1c1xcc291cmNlXFxyZXBvXFxkeW5hbWljc1xcZHluYW1pY3MtYlxcY3J5cHRvcGktZHluYW1pY3NcXHNyY1xcY29yZVxcc291cmNlc1xcYmluYW5jZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29yZS9zb3VyY2VzL2JpbmFuY2UudHNcclxuLy8gUHVibGljIFJFU1QgYWRhcHRlciB3aXRoIHRpY2tlciwga2xpbmVzIGFuZCBvcmRlcmJvb2s7IHNldHRpbmdzLWF3YXJlLlxyXG5cclxuaW1wb3J0IHsgZmV0Y2hKc29uIH0gZnJvbSBcIkAvY29yZS9zb3VyY2VzL2JpbmFuY2VDbGllbnRcIjtcclxuaW1wb3J0IHsgZ2V0QWxsIGFzIGdldFNldHRpbmdzIH0gZnJvbSBcIkAvbGliL3NldHRpbmdzL3NlcnZlclwiO1xyXG5cclxudHlwZSBJbnRlcnZhbCA9IFwiMW1cInxcIjNtXCJ8XCI1bVwifFwiMTVtXCJ8XCIzMG1cInxcIjFoXCJ8XCIyaFwifFwiNGhcInxcIjZoXCJ8XCI4aFwifFwiMTJoXCJ8XCIxZFwiO1xyXG5cclxuY29uc3QgbnVtID0gKHg6IGFueSwgZD1OYU4pID0+IHsgY29uc3QgbiA9IE51bWJlcih4KTsgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShuKSA/IG4gOiBkOyB9O1xyXG5cclxuLy8gLS0tLSAyNGggdGlja2VyIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbmV4cG9ydCB0eXBlIFRpY2tlcjI0aCA9IHtcclxuICBzeW1ib2w6IHN0cmluZztcclxuICB3ZWlnaHRlZEF2Z1ByaWNlPzogc3RyaW5nO1xyXG4gIGxhc3RQcmljZT86IHN0cmluZztcclxuICBwcmljZUNoYW5nZVBlcmNlbnQ/OiBzdHJpbmc7IC8vIHBlcmNlbnQgdW5pdHMgKGUuZy4gXCIwLjkzOTdcIilcclxuICBwcmljZUNoYW5nZT86IHN0cmluZzsgICAgICAgIC8vIGFic29sdXRlIGRlbHRhIChzYW1lIHVuaXRzIGFzIGxhc3RQcmljZSlcclxuICBvcGVuUHJpY2U/OiBzdHJpbmc7XHJcbn07XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2gyNGhBbGwoc3ltYm9sczogc3RyaW5nW10pOiBQcm9taXNlPFRpY2tlcjI0aFtdPiB7XHJcbiAgaWYgKCFzeW1ib2xzPy5sZW5ndGgpIHJldHVybiBbXTtcclxuICBjb25zdCBxcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBzeW1ib2xzOiBKU09OLnN0cmluZ2lmeShzeW1ib2xzKSB9KTtcclxuICBjb25zdCBhcnIgPSBhd2FpdCBmZXRjaEpzb248YW55W10+KGAvYXBpL3YzL3RpY2tlci8yNGhyPyR7cXMudG9TdHJpbmcoKX1gKTtcclxuICByZXR1cm4gKEFycmF5LmlzQXJyYXkoYXJyKSA/IGFyciA6IFtdKS5tYXAodCA9PiAoe1xyXG4gICAgc3ltYm9sOiBTdHJpbmcodC5zeW1ib2wpLFxyXG4gICAgd2VpZ2h0ZWRBdmdQcmljZTogdC53ZWlnaHRlZEF2Z1ByaWNlLFxyXG4gICAgbGFzdFByaWNlOiB0Lmxhc3RQcmljZSxcclxuICAgIHByaWNlQ2hhbmdlUGVyY2VudDogdC5wcmljZUNoYW5nZVBlcmNlbnQsXHJcbiAgICBwcmljZUNoYW5nZTogdC5wcmljZUNoYW5nZSxcclxuICAgIG9wZW5QcmljZTogdC5vcGVuUHJpY2UsXHJcbiAgfSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWFwVGlja2VyQnlTeW1ib2woYXJyOiBUaWNrZXIyNGhbXSk6IFJlY29yZDxzdHJpbmcsIFRpY2tlcjI0aD4ge1xyXG4gIGNvbnN0IG91dDogUmVjb3JkPHN0cmluZywgVGlja2VyMjRoPiA9IHt9O1xyXG4gIGZvciAoY29uc3QgdCBvZiBhcnIpIG91dFt0LnN5bWJvbF0gPSB0O1xyXG4gIHJldHVybiBvdXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vcm1Db2lucyhsaXN0Pzogc3RyaW5nW10pIHtcclxuICBjb25zdCBzZXQgPSBuZXcgU2V0PHN0cmluZz4oKSwgb3V0OiBzdHJpbmdbXSA9IFtdO1xyXG4gIGZvciAoY29uc3QgYyBvZiBsaXN0ID8/IFtdKSB7XHJcbiAgICBjb25zdCB1ID0gU3RyaW5nKGN8fFwiXCIpLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgaWYgKCF1IHx8IHNldC5oYXModSkpIGNvbnRpbnVlOyBzZXQuYWRkKHUpOyBvdXQucHVzaCh1KTtcclxuICB9XHJcbiAgaWYgKCFzZXQuaGFzKFwiVVNEVFwiKSkgb3V0LnB1c2goXCJVU0RUXCIpO1xyXG4gIHJldHVybiBvdXQ7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTZXR0aW5nc0NvaW5zKCk6IFByb21pc2U8c3RyaW5nW10+IHtcclxuICBjb25zdCBzID0gYXdhaXQgZ2V0U2V0dGluZ3MoKTtcclxuICBjb25zdCBmcm9tID0gbm9ybUNvaW5zKHMuY29pblVuaXZlcnNlPy5sZW5ndGggPyBzLmNvaW5Vbml2ZXJzZSA6IFtdKTtcclxuICByZXR1cm4gZnJvbS5sZW5ndGggPyBmcm9tIDogbm9ybUNvaW5zKFtcIkJUQ1wiLFwiRVRIXCIsXCJCTkJcIixcIlNPTFwiLFwiQURBXCIsXCJYUlBcIixcIlBFUEVcIixcIlVTRFRcIl0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNkdFN5bWJvbHNGb3IoY29pbnM6IHN0cmluZ1tdKSB7XHJcbiAgcmV0dXJuIGNvaW5zLmZpbHRlcihjID0+IGMgIT09IFwiVVNEVFwiKS5tYXAoYyA9PiBgJHtjfVVTRFRgKTtcclxufVxyXG5cclxuLy8gQnVsayBVU0RUIHZpZXcgdXNlZCBmb3IgdHJpYW5ndWxhdGlvbiAoa2VwdCBhcy1pcywgYnV0IG5vdyB0eXBlcyBhcmUgcmljaGVyKS5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoVGlja2Vyc0ZvckNvaW5zKGNvaW5zPzogc3RyaW5nW10pIHtcclxuICBjb25zdCB1bmkgPSBub3JtQ29pbnMoY29pbnMgPz8gKGF3YWl0IGdldFNldHRpbmdzQ29pbnMoKSkpO1xyXG4gIGNvbnN0IGJ5ID0gbWFwVGlja2VyQnlTeW1ib2woYXdhaXQgZmV0Y2gyNGhBbGwodXNkdFN5bWJvbHNGb3IodW5pKSkpO1xyXG4gIGNvbnN0IG91dDogUmVjb3JkPHN0cmluZyx7IHByaWNlOm51bWJlcjsgcGN0MjRoOm51bWJlciB9PiA9IHsgVVNEVDogeyBwcmljZToxLCBwY3QyNGg6MCB9IH07XHJcbiAgZm9yIChjb25zdCBjIG9mIHVuaSkge1xyXG4gICAgaWYgKGMgPT09IFwiVVNEVFwiKSBjb250aW51ZTtcclxuICAgIGNvbnN0IHQgPSBieVtgJHtjfVVTRFRgXTtcclxuICAgIGNvbnN0IHByaWNlID0gdD8ubGFzdFByaWNlICE9IG51bGwgPyBOdW1iZXIodC5sYXN0UHJpY2UpIDogTnVtYmVyKHQ/LndlaWdodGVkQXZnUHJpY2UpO1xyXG4gICAgY29uc3QgcGN0ID0gdD8ucHJpY2VDaGFuZ2VQZXJjZW50ICE9IG51bGwgPyBOdW1iZXIodC5wcmljZUNoYW5nZVBlcmNlbnQpIDogTmFOO1xyXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShwcmljZSkpIG91dFtjXSA9IHsgcHJpY2UsIHBjdDI0aDogTnVtYmVyLmlzRmluaXRlKHBjdCkgPyBwY3QgOiAwIH07XHJcbiAgfVxyXG4gIHJldHVybiBvdXQ7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFRpY2tlcjI0aChzeW1ib2w6IHN0cmluZyk6IFByb21pc2U8VGlja2VyMjRoPiB7XHJcbiAgcmV0dXJuIGZldGNoSnNvbjxUaWNrZXIyNGg+KFwiL2FwaS92My90aWNrZXIvMjRoclwiLCB7IHN5bWJvbDogc3ltYm9sLnRvVXBwZXJDYXNlKCkgfSk7XHJcbn1cclxuXHJcbi8qKiBOb3JtYWxpemVkIG51bWVyaWMgaGVscGVyOiBsYXN0LCBwY3QyNGggKHBlcmNlbnQgdW5pdHMpLCBkZWx0YSAoYWJzb2x1dGUpICYgb3BlbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hUaWNrZXIyNGhOdW0oc3ltYm9sOiBzdHJpbmcpOiBQcm9taXNlPHtcclxuICBzeW1ib2w6IHN0cmluZztcclxuICBsYXN0OiBudW1iZXIgfCBudWxsO1xyXG4gIHBjdDI0aDogbnVtYmVyIHwgbnVsbDsgIC8vIGUuZy4gMC45Mzk3XHJcbiAgZGVsdGE6IG51bWJlciB8IG51bGw7ICAgLy8gYWJzb2x1dGUgcHJpY2VDaGFuZ2VcclxuICBvcGVuOiBudW1iZXIgfCBudWxsO1xyXG59PiB7XHJcbiAgY29uc3QgdCA9IGF3YWl0IGZldGNoVGlja2VyMjRoKHN5bWJvbCk7XHJcbiAgY29uc3QgbGFzdCA9IG51bSh0Lmxhc3RQcmljZSwgTmFOKTtcclxuICBjb25zdCBwY3QgID0gbnVtKHQucHJpY2VDaGFuZ2VQZXJjZW50LCBOYU4pOyAvLyBwZXJjZW50IHVuaXRzXHJcbiAgbGV0IGRlbHRhICA9IG51bSh0LnByaWNlQ2hhbmdlLCBOYU4pO1xyXG4gIC8vIHJvYnVzdCBvcGVuIGFuZCBkZWx0YSBpZiBkZWx0YSBtaXNzaW5nXHJcbiAgbGV0IG9wZW4gPSBudW0odC5vcGVuUHJpY2UsIE5hTik7XHJcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUob3BlbikgJiYgTnVtYmVyLmlzRmluaXRlKGxhc3QpICYmIE51bWJlci5pc0Zpbml0ZShwY3QpKSB7XHJcbiAgICBjb25zdCByID0gcGN0IC8gMTAwO1xyXG4gICAgb3BlbiA9IGxhc3QgLyAoMSArIHIpO1xyXG4gIH1cclxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShkZWx0YSkgJiYgTnVtYmVyLmlzRmluaXRlKGxhc3QpICYmIE51bWJlci5pc0Zpbml0ZShvcGVuKSkge1xyXG4gICAgZGVsdGEgPSBsYXN0IC0gb3BlbjtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHN5bWJvbDogdC5zeW1ib2wsXHJcbiAgICBsYXN0OiBOdW1iZXIuaXNGaW5pdGUobGFzdCkgPyBsYXN0IDogbnVsbCxcclxuICAgIHBjdDI0aDogTnVtYmVyLmlzRmluaXRlKHBjdCkgPyBwY3QgOiBudWxsLFxyXG4gICAgZGVsdGE6IE51bWJlci5pc0Zpbml0ZShkZWx0YSkgPyBkZWx0YSA6IG51bGwsXHJcbiAgICBvcGVuOiBOdW1iZXIuaXNGaW5pdGUob3BlbikgPyBvcGVuIDogbnVsbCxcclxuICB9O1xyXG59XHJcblxyXG4vLyAtLS0tIGtsaW5lcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuZXhwb3J0IHR5cGUgUmF3S2xpbmUgPSBbbnVtYmVyLHN0cmluZyxzdHJpbmcsc3RyaW5nLHN0cmluZyxzdHJpbmcsbnVtYmVyLHN0cmluZyxudW1iZXIsc3RyaW5nLHN0cmluZyxzdHJpbmddO1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hLbGluZXMoc3ltYm9sOiBzdHJpbmcsIGludGVydmFsOiBJbnRlcnZhbCwgbGltaXQ9MTI4KTogUHJvbWlzZTxSYXdLbGluZVtdPiB7XHJcbiAgcmV0dXJuIGZldGNoSnNvbjxSYXdLbGluZVtdPihcIi9hcGkvdjMva2xpbmVzXCIsIHsgc3ltYm9sLCBpbnRlcnZhbCwgbGltaXQgfSk7XHJcbn1cclxuXHJcbi8vIC0tLS0gb3JkZXJib29rICsgYm9va1RpY2tlciAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG50eXBlIERlcHRoTGV2ZWwgPSBbc3RyaW5nLHN0cmluZ107XHJcbmV4cG9ydCB0eXBlIERlcHRoU25hcHNob3QgPSB7IGxhc3RVcGRhdGVJZDpudW1iZXI7IGJpZHM6RGVwdGhMZXZlbFtdOyBhc2tzOkRlcHRoTGV2ZWxbXSB9O1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoT3JkZXJCb29rKHN5bWJvbDogc3RyaW5nLCBsaW1pdDogNXwxMHwyMHw1MHwxMDB8NTAwfDEwMDAgPSAxMDApIHtcclxuICBjb25zdCBkZXB0aCA9IGF3YWl0IGZldGNoSnNvbjxEZXB0aFNuYXBzaG90PihcIi9hcGkvdjMvZGVwdGhcIiwgeyBzeW1ib2wsIGxpbWl0IH0pO1xyXG4gIGNvbnN0IHRzID0gRGF0ZS5ub3coKTtcclxuICBjb25zdCBiZXN0QmlkID0gbnVtKGRlcHRoLmJpZHNbMF0/LlswXSk7XHJcbiAgY29uc3QgYmVzdEFzayA9IG51bShkZXB0aC5hc2tzWzBdPy5bMF0pO1xyXG4gIGNvbnN0IG1pZCA9IE51bWJlci5pc0Zpbml0ZShiZXN0QmlkKSAmJiBOdW1iZXIuaXNGaW5pdGUoYmVzdEFzaykgPyAoYmVzdEJpZCArIGJlc3RBc2spLzIgOiBOYU47XHJcbiAgY29uc3QgYmlkVm9sID0gZGVwdGguYmlkcy5yZWR1Y2UoKHMsIFtfLHFdKSA9PiBzICsgbnVtKHEsMCksIDApO1xyXG4gIGNvbnN0IGFza1ZvbCA9IGRlcHRoLmFza3MucmVkdWNlKChzLCBbXyxxXSkgPT4gcyArIG51bShxLDApLCAwKTtcclxuICByZXR1cm4geyBkZXB0aCwgdHMsIGJlc3RCaWQsIGJlc3RBc2ssIG1pZCwgYmlkVm9sLCBhc2tWb2wgfTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoT3JkZXJCb29rc0ZvclN5bWJvbHMoXHJcbiAgc3ltYm9sczogc3RyaW5nW10sXHJcbiAgbGltaXQ6IDV8MTB8MjB8NTB8MTAwfDUwMHwxMDAwID0gMTAwXHJcbikge1xyXG4gIGNvbnN0IG91dDogUmVjb3JkPHN0cmluZyx7IG1pZDpudW1iZXI7IGJpZFZvbDpudW1iZXI7IGFza1ZvbDpudW1iZXIgfT4gPSB7fTtcclxuICBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgIChzeW1ib2xzID8/IFtdKS5tYXAoYXN5bmMgKHMpID0+IHtcclxuICAgICAgY29uc3Qgc3ltID0gU3RyaW5nKHMgfHwgXCJcIikudG9VcHBlckNhc2UoKTtcclxuICAgICAgY29uc3QgeyBtaWQsIGJpZFZvbCwgYXNrVm9sIH0gPSBhd2FpdCBmZXRjaE9yZGVyQm9vayhzeW0sIGxpbWl0KTtcclxuICAgICAgb3V0W3N5bV0gPSB7IG1pZCwgYmlkVm9sLCBhc2tWb2wgfTtcclxuICAgIH0pXHJcbiAgKTtcclxuICByZXR1cm4gb3V0O1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hPcmRlckJvb2tzRm9yQ29pbnMoXHJcbiAgY29pbnM6IHN0cmluZ1tdLFxyXG4gIGxpbWl0OiA1IHwgMTAgfCAyMCB8IDUwIHwgMTAwIHwgNTAwIHwgMTAwMCA9IDEwMFxyXG4pIHtcclxuICBjb25zdCBsaXN0ID0gQXJyYXkuaXNBcnJheShjb2lucykgPyBjb2lucy5tYXAoKGMpID0+IFN0cmluZyhjIHx8ICcnKS50b1VwcGVyQ2FzZSgpKS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcclxuICBjb25zdCBzeW1ib2xzID0gdXNkdFN5bWJvbHNGb3IobGlzdCk7XHJcbiAgY29uc3QgYm9va3MgPSBhd2FpdCBmZXRjaE9yZGVyQm9va3NGb3JTeW1ib2xzKHN5bWJvbHMsIGxpbWl0KTtcclxuICBjb25zdCBvdXQ6IFJlY29yZDxzdHJpbmcsIHsgbWlkOiBudW1iZXI7IGJpZFZvbDogbnVtYmVyOyBhc2tWb2w6IG51bWJlciB9PiA9IHt9O1xyXG4gIGZvciAoY29uc3QgY29pbiBvZiBsaXN0KSB7XHJcbiAgICBpZiAoY29pbiA9PT0gXCJVU0RUXCIpIHtcclxuICAgICAgb3V0W2NvaW5dID0geyBtaWQ6IDEsIGJpZFZvbDogMCwgYXNrVm9sOiAwIH07XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZW50cnkgPSBib29rc1tgJHtjb2lufVVTRFRgXTtcclxuICAgIG91dFtjb2luXSA9IGVudHJ5ID8/IHsgbWlkOiBOYU4sIGJpZFZvbDogMCwgYXNrVm9sOiAwIH07XHJcbiAgfVxyXG4gIGlmICghb3V0LlVTRFQpIHtcclxuICAgIG91dC5VU0RUID0geyBtaWQ6IDEsIGJpZFZvbDogMCwgYXNrVm9sOiAwIH07XHJcbiAgfVxyXG4gIHJldHVybiBvdXQ7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaEJvb2tUaWNrZXIoc3ltYm9sOiBzdHJpbmcpIHtcclxuICBjb25zdCBqID0gYXdhaXQgZmV0Y2hKc29uPHsgYmlkUHJpY2U6c3RyaW5nOyBhc2tQcmljZTpzdHJpbmcgfT4oXCIvYXBpL3YzL3RpY2tlci9ib29rVGlja2VyXCIsIHsgc3ltYm9sIH0pO1xyXG4gIGNvbnN0IGJpZFByaWNlID0gbnVtKGouYmlkUHJpY2UpLCBhc2tQcmljZSA9IG51bShqLmFza1ByaWNlKTtcclxuICBjb25zdCBtaWQgPSBOdW1iZXIuaXNGaW5pdGUoYmlkUHJpY2UpJiZOdW1iZXIuaXNGaW5pdGUoYXNrUHJpY2UpID8gKGJpZFByaWNlK2Fza1ByaWNlKS8yIDogTmFOO1xyXG4gIHJldHVybiB7IGJpZFByaWNlLCBhc2tQcmljZSwgbWlkIH07XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBmZXRjaDI0aEFsbCwgbWFwVGlja2VyQnlTeW1ib2wsIGZldGNoVGlja2Vyc0ZvckNvaW5zLCBnZXRTZXR0aW5nc0NvaW5zLCB1c2R0U3ltYm9sc0ZvcixcclxuICBmZXRjaEtsaW5lcywgZmV0Y2hPcmRlckJvb2ssIGZldGNoT3JkZXJCb29rc0ZvclN5bWJvbHMsIGZldGNoT3JkZXJCb29rc0ZvckNvaW5zLCBmZXRjaEJvb2tUaWNrZXIsXHJcbiAgZmV0Y2hUaWNrZXIyNGgsIGZldGNoVGlja2VyMjRoTnVtLFxyXG59O1xyXG5cclxuLy8gc3JjL3NvdXJjZXMvYmluYW5jZS50c1xyXG4vLyBNaW5pbWFsIGhlbHBlcnMgdG8gbGlzdCBzeW1ib2xzIGFuZCBmZXRjaCAyNGggc3RhdHMuXHJcbi8vIEFkanVzdCBiYXNlIFVSTCBvciBmZXRjaCB3cmFwcGVyIHRvIHlvdXIgcHJvamVjdCBjb252ZW50aW9ucyBpZiBuZWVkZWQuXHJcblxyXG5jb25zdCBCQVNFID0gXCJodHRwczovL2FwaS5iaW5hbmNlLmNvbVwiO1xyXG5cclxudHlwZSBFeFN5bWJvbCA9IHtcclxuICBzeW1ib2w6IHN0cmluZztcclxuICBzdGF0dXM6IHN0cmluZztcclxuICBiYXNlQXNzZXQ6IHN0cmluZztcclxuICBxdW90ZUFzc2V0OiBzdHJpbmc7XHJcbn07XHJcbnR5cGUgRXhjaGFuZ2VJbmZvID0geyBzeW1ib2xzOiBFeFN5bWJvbFtdIH07XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbGlzdFN5bWJvbHNCeVF1b3RlKHF1b3RlID0gXCJVU0RUXCIpOiBQcm9taXNlPHN0cmluZ1tdPiB7XHJcbiAgY29uc3QgciA9IGF3YWl0IGZldGNoKGAke0JBU0V9L2FwaS92My9leGNoYW5nZUluZm9gLCB7IGNhY2hlOiBcIm5vLXN0b3JlXCIgfSk7XHJcbiAgaWYgKCFyLm9rKSB0aHJvdyBuZXcgRXJyb3IoYGV4Y2hhbmdlSW5mbyAke3Iuc3RhdHVzfWApO1xyXG4gIGNvbnN0IGluZm8gPSAoYXdhaXQgci5qc29uKCkpIGFzIEV4Y2hhbmdlSW5mbztcclxuICBjb25zdCBzeW1zID0gaW5mby5zeW1ib2xzXHJcbiAgICAuZmlsdGVyKHMgPT4gcy5zdGF0dXMgPT09IFwiVFJBRElOR1wiICYmIHMucXVvdGVBc3NldC50b1VwcGVyQ2FzZSgpID09PSBxdW90ZS50b1VwcGVyQ2FzZSgpKVxyXG4gICAgLm1hcChzID0+IHMuc3ltYm9sKVxyXG4gICAgLnNvcnQoKTtcclxuICAvLyBkZS1kdXBcclxuICBjb25zdCBvdXQ6IHN0cmluZ1tdID0gW107XHJcbiAgZm9yIChjb25zdCBzIG9mIHN5bXMpIGlmICghb3V0Lmxlbmd0aCB8fCBvdXRbb3V0Lmxlbmd0aCAtIDFdICE9PSBzKSBvdXQucHVzaChzKTtcclxuICByZXR1cm4gb3V0O1xyXG59XHJcblxyXG4vLyBJZiB5b3UgYWxyZWFkeSBoYXZlIGEgcHJvamVjdC1zcGVjaWZpYyBmZXRjaDI0aCBmb3Igb25lIHN5bWJvbCwgcmV1c2UgaXQgaW5zaWRlIGhlcmUuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaDI0aEZvclN5bWJvbHMoc3ltYm9sczogc3RyaW5nW10pOiBQcm9taXNlPGFueVtdPiB7XHJcbiAgLy8gQmF0Y2ggd2l0aCBQcm9taXNlLmFsbCBvdmVyIC9hcGkvdjMvdGlja2VyLzI0aHI/c3ltYm9sPVhYWFhcclxuICAvLyAoQmluYW5jZSBhbHNvIHN1cHBvcnRzIC90aWNrZXIvMjRociB3aXRob3V0IHN5bWJvbCByZXR1cm5pbmcgQUxMLCBidXQgaXQncyBoZWF2eTtcclxuICAvLyBpZiB5b3UgcHJlZmVyIHRoYXQsIHlvdSBjYW4gZmV0Y2ggb25jZSBhbmQgZmlsdGVyLilcclxuICBjb25zdCBxcyA9IHN5bWJvbHMubWFwKHMgPT4gZmV0Y2goYCR7QkFTRX0vYXBpL3YzL3RpY2tlci8yNGhyP3N5bWJvbD0ke3N9YCwgeyBjYWNoZTogXCJuby1zdG9yZVwiIH0pXHJcbiAgICAudGhlbihyID0+IHtcclxuICAgICAgaWYgKCFyLm9rKSB0aHJvdyBuZXcgRXJyb3IoYDI0aHIgJHtzfSAke3Iuc3RhdHVzfWApO1xyXG4gICAgICByZXR1cm4gci5qc29uKCk7XHJcbiAgICB9KVxyXG4gICAgLmNhdGNoKGUgPT4gKHsgc3ltYm9sOiBzLCBfZXJyOiBTdHJpbmcoZSkgfSkpKTtcclxuICByZXR1cm4gUHJvbWlzZS5hbGwocXMpO1xyXG59XHJcblxyXG5cclxuXHJcbiJdLCJuYW1lcyI6WyJmZXRjaEpzb24iLCJnZXRBbGwiLCJnZXRTZXR0aW5ncyIsIm51bSIsIngiLCJkIiwiTmFOIiwibiIsIk51bWJlciIsImlzRmluaXRlIiwiZmV0Y2gyNGhBbGwiLCJzeW1ib2xzIiwibGVuZ3RoIiwicXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJKU09OIiwic3RyaW5naWZ5IiwiYXJyIiwidG9TdHJpbmciLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJ0Iiwic3ltYm9sIiwiU3RyaW5nIiwid2VpZ2h0ZWRBdmdQcmljZSIsImxhc3RQcmljZSIsInByaWNlQ2hhbmdlUGVyY2VudCIsInByaWNlQ2hhbmdlIiwib3BlblByaWNlIiwibWFwVGlja2VyQnlTeW1ib2wiLCJvdXQiLCJub3JtQ29pbnMiLCJsaXN0Iiwic2V0IiwiU2V0IiwiYyIsInUiLCJ0cmltIiwidG9VcHBlckNhc2UiLCJoYXMiLCJhZGQiLCJwdXNoIiwiZ2V0U2V0dGluZ3NDb2lucyIsInMiLCJmcm9tIiwiY29pblVuaXZlcnNlIiwidXNkdFN5bWJvbHNGb3IiLCJjb2lucyIsImZpbHRlciIsImZldGNoVGlja2Vyc0ZvckNvaW5zIiwidW5pIiwiYnkiLCJVU0RUIiwicHJpY2UiLCJwY3QyNGgiLCJwY3QiLCJmZXRjaFRpY2tlcjI0aCIsImZldGNoVGlja2VyMjRoTnVtIiwibGFzdCIsImRlbHRhIiwib3BlbiIsInIiLCJmZXRjaEtsaW5lcyIsImludGVydmFsIiwibGltaXQiLCJmZXRjaE9yZGVyQm9vayIsImRlcHRoIiwidHMiLCJEYXRlIiwibm93IiwiYmVzdEJpZCIsImJpZHMiLCJiZXN0QXNrIiwiYXNrcyIsIm1pZCIsImJpZFZvbCIsInJlZHVjZSIsIl8iLCJxIiwiYXNrVm9sIiwiZmV0Y2hPcmRlckJvb2tzRm9yU3ltYm9scyIsIlByb21pc2UiLCJhbGwiLCJzeW0iLCJmZXRjaE9yZGVyQm9va3NGb3JDb2lucyIsIkJvb2xlYW4iLCJib29rcyIsImNvaW4iLCJlbnRyeSIsImZldGNoQm9va1RpY2tlciIsImoiLCJiaWRQcmljZSIsImFza1ByaWNlIiwiQkFTRSIsImxpc3RTeW1ib2xzQnlRdW90ZSIsInF1b3RlIiwiZmV0Y2giLCJjYWNoZSIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJpbmZvIiwianNvbiIsInN5bXMiLCJxdW90ZUFzc2V0Iiwic29ydCIsImZldGNoMjRoRm9yU3ltYm9scyIsInRoZW4iLCJjYXRjaCIsImUiLCJfZXJyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/core/sources/binance.ts\n");

/***/ }),

/***/ "(rsc)/./src/core/sources/binanceClient.ts":
/*!*******************************************!*\
  !*** ./src/core/sources/binanceClient.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchJson: () => (/* binding */ fetchJson)\n/* harmony export */ });\n// src/core/sources/binanceClient.ts\n// Lightweight helper for Binance public REST calls used across the pipeline.\nconst DEFAULT_BASE = process.env.BINANCE_BASE_URL?.trim() || \"https://api.binance.com\";\nfunction buildUrl(path, query) {\n    const url = path.startsWith(\"http\") ? new URL(path) : new URL(path, DEFAULT_BASE);\n    if (query) {\n        for (const [key, value] of Object.entries(query)){\n            if (value === undefined || value === null) continue;\n            url.searchParams.set(key, String(value));\n        }\n    }\n    return url;\n}\nasync function fetchJson(path, query, init) {\n    const url = buildUrl(path, query);\n    const response = await fetch(url.toString(), {\n        method: \"GET\",\n        headers: {\n            Accept: \"application/json\",\n            ...init?.headers ?? {}\n        },\n        ...init\n    });\n    if (!response.ok) {\n        const text = await response.text().catch(()=>\"<no-body>\");\n        throw new Error(`binance ${url.pathname} -> ${response.status} ${text}`);\n    }\n    return await response.json();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29yZS9zb3VyY2VzL2JpbmFuY2VDbGllbnQudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG9DQUFvQztBQUNwQyw2RUFBNkU7QUFFN0UsTUFBTUEsZUFBZUMsUUFBUUMsR0FBRyxDQUFDQyxnQkFBZ0IsRUFBRUMsVUFBVTtBQUU3RCxTQUFTQyxTQUFTQyxJQUFZLEVBQUVDLEtBQW1EO0lBQ2pGLE1BQU1DLE1BQU1GLEtBQUtHLFVBQVUsQ0FBQyxVQUFVLElBQUlDLElBQUlKLFFBQVEsSUFBSUksSUFBSUosTUFBTU47SUFDcEUsSUFBSU8sT0FBTztRQUNULEtBQUssTUFBTSxDQUFDSSxLQUFLQyxNQUFNLElBQUlDLE9BQU9DLE9BQU8sQ0FBQ1AsT0FBUTtZQUNoRCxJQUFJSyxVQUFVRyxhQUFhSCxVQUFVLE1BQU07WUFDM0NKLElBQUlRLFlBQVksQ0FBQ0MsR0FBRyxDQUFDTixLQUFLTyxPQUFPTjtRQUNuQztJQUNGO0lBQ0EsT0FBT0o7QUFDVDtBQUVPLGVBQWVXLFVBQ3BCYixJQUFZLEVBQ1pDLEtBQW1ELEVBQ25EYSxJQUFrQjtJQUVsQixNQUFNWixNQUFNSCxTQUFTQyxNQUFNQztJQUMzQixNQUFNYyxXQUFXLE1BQU1DLE1BQU1kLElBQUllLFFBQVEsSUFBSTtRQUMzQ0MsUUFBUTtRQUNSQyxTQUFTO1lBQUVDLFFBQVE7WUFBb0IsR0FBSU4sTUFBTUssV0FBVyxDQUFDLENBQUM7UUFBRTtRQUNoRSxHQUFHTCxJQUFJO0lBQ1Q7SUFFQSxJQUFJLENBQUNDLFNBQVNNLEVBQUUsRUFBRTtRQUNoQixNQUFNQyxPQUFPLE1BQU1QLFNBQVNPLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU07UUFDL0MsTUFBTSxJQUFJQyxNQUFNLENBQUMsUUFBUSxFQUFFdEIsSUFBSXVCLFFBQVEsQ0FBQyxJQUFJLEVBQUVWLFNBQVNXLE1BQU0sQ0FBQyxDQUFDLEVBQUVKLE1BQU07SUFDekU7SUFFQSxPQUFRLE1BQU1QLFNBQVNZLElBQUk7QUFDN0IiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxjb3JlXFxzb3VyY2VzXFxiaW5hbmNlQ2xpZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb3JlL3NvdXJjZXMvYmluYW5jZUNsaWVudC50c1xuLy8gTGlnaHR3ZWlnaHQgaGVscGVyIGZvciBCaW5hbmNlIHB1YmxpYyBSRVNUIGNhbGxzIHVzZWQgYWNyb3NzIHRoZSBwaXBlbGluZS5cblxuY29uc3QgREVGQVVMVF9CQVNFID0gcHJvY2Vzcy5lbnYuQklOQU5DRV9CQVNFX1VSTD8udHJpbSgpIHx8IFwiaHR0cHM6Ly9hcGkuYmluYW5jZS5jb21cIjtcblxuZnVuY3Rpb24gYnVpbGRVcmwocGF0aDogc3RyaW5nLCBxdWVyeT86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IHVuZGVmaW5lZD4pIHtcbiAgY29uc3QgdXJsID0gcGF0aC5zdGFydHNXaXRoKFwiaHR0cFwiKSA/IG5ldyBVUkwocGF0aCkgOiBuZXcgVVJMKHBhdGgsIERFRkFVTFRfQkFTRSk7XG4gIGlmIChxdWVyeSkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5KSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCBTdHJpbmcodmFsdWUpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoSnNvbjxUID0gdW5rbm93bj4oXG4gIHBhdGg6IHN0cmluZyxcbiAgcXVlcnk/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXIgfCB1bmRlZmluZWQ+LFxuICBpbml0PzogUmVxdWVzdEluaXQsXG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgdXJsID0gYnVpbGRVcmwocGF0aCwgcXVlcnkpO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnM6IHsgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiwgLi4uKGluaXQ/LmhlYWRlcnMgPz8ge30pIH0sXG4gICAgLi4uaW5pdCxcbiAgfSk7XG5cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkuY2F0Y2goKCkgPT4gXCI8bm8tYm9keT5cIik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBiaW5hbmNlICR7dXJsLnBhdGhuYW1lfSAtPiAke3Jlc3BvbnNlLnN0YXR1c30gJHt0ZXh0fWApO1xuICB9XG5cbiAgcmV0dXJuIChhd2FpdCByZXNwb25zZS5qc29uKCkpIGFzIFQ7XG59XHJcbiJdLCJuYW1lcyI6WyJERUZBVUxUX0JBU0UiLCJwcm9jZXNzIiwiZW52IiwiQklOQU5DRV9CQVNFX1VSTCIsInRyaW0iLCJidWlsZFVybCIsInBhdGgiLCJxdWVyeSIsInVybCIsInN0YXJ0c1dpdGgiLCJVUkwiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJ1bmRlZmluZWQiLCJzZWFyY2hQYXJhbXMiLCJzZXQiLCJTdHJpbmciLCJmZXRjaEpzb24iLCJpbml0IiwicmVzcG9uc2UiLCJmZXRjaCIsInRvU3RyaW5nIiwibWV0aG9kIiwiaGVhZGVycyIsIkFjY2VwdCIsIm9rIiwidGV4dCIsImNhdGNoIiwiRXJyb3IiLCJwYXRobmFtZSIsInN0YXR1cyIsImpzb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/core/sources/binanceClient.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/markets/pairs.ts":
/*!**********************************!*\
  !*** ./src/lib/markets/pairs.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crossPairsFromCoins: () => (/* binding */ crossPairsFromCoins),\n/* harmony export */   dedupeCoins: () => (/* binding */ dedupeCoins),\n/* harmony export */   normalizeCoin: () => (/* binding */ normalizeCoin),\n/* harmony export */   pairsFromSettings: () => (/* binding */ pairsFromSettings),\n/* harmony export */   usdtLegsFromCoins: () => (/* binding */ usdtLegsFromCoins)\n/* harmony export */ });\n// src/lib/markets/pairs.ts\n// Shared, deterministic pair helpers used by both UI and API.\nconst QUOTE_SUFFIXES = [\n    \"USDT\",\n    \"USDC\",\n    \"FDUSD\",\n    \"TUSD\",\n    \"BUSD\"\n];\n/**\n * Normalizes a token symbol:\n * - Uppercase\n * - Remove non A-Z characters\n * - Strip known quote suffixes so cross combos never double-append quotes\n */ const normalizeCoin = (c)=>{\n    const upper = String(c || \"\").toUpperCase().replace(/[^A-Z]/g, \"\");\n    if (!upper) return \"\";\n    for (const suffix of QUOTE_SUFFIXES){\n        if (upper === suffix) return upper;\n        if (upper.endsWith(suffix) && upper.length > suffix.length) {\n            return upper.slice(0, -suffix.length);\n        }\n    }\n    return upper;\n};\nfunction dedupeCoins(bases) {\n    return Array.from(new Set((bases ?? []).map(normalizeCoin))).filter(Boolean);\n}\nfunction usdtLegsFromCoins(bases) {\n    const uniq = dedupeCoins(bases).filter((c)=>c && c !== \"USDT\");\n    return uniq.map((b)=>`${b}USDT`);\n}\n// Ordered permutations A->B (A !== B). No verification here.\nfunction crossPairsFromCoins(bases) {\n    const coins = dedupeCoins(bases).filter((c)=>c && c !== \"USDT\");\n    const out = [];\n    for(let i = 0; i < coins.length; i++){\n        for(let j = 0; j < coins.length; j++){\n            if (i === j) continue;\n            out.push(`${coins[i]}${coins[j]}`);\n        }\n    }\n    return out;\n}\n/**\n * Async builder with optional preview verification.\n * - If `verify` is provided, we filter USDT + cross by it.\n * - If not, we return only USDT legs (no synthetic crosses on the client).\n */ async function pairsFromSettings(bases, opts) {\n    const preferVerifiedUsdt = opts?.preferVerifiedUsdt ?? true;\n    const usdtCand = usdtLegsFromCoins(bases);\n    const crossCand = crossPairsFromCoins(bases);\n    if (!opts?.verify) {\n        return {\n            usdt: usdtCand,\n            cross: [],\n            all: usdtCand.slice()\n        };\n    }\n    const verified = await opts.verify([\n        ...usdtCand,\n        ...crossCand\n    ]);\n    const has = (s)=>verified.has(s.toUpperCase());\n    const usdt = verified.size && preferVerifiedUsdt ? usdtCand.filter(has) : usdtCand;\n    const cross = crossCand.filter(has);\n    const all = Array.from(new Set([\n        ...usdt,\n        ...cross\n    ]));\n    return {\n        usdt,\n        cross,\n        all\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL21hcmtldHMvcGFpcnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSwyQkFBMkI7QUFDM0IsOERBQThEO0FBSTlELE1BQU1BLGlCQUFpQjtJQUFDO0lBQVE7SUFBUTtJQUFTO0lBQVE7Q0FBTztBQUVoRTs7Ozs7Q0FLQyxHQUNNLE1BQU1DLGdCQUFnQixDQUFDQztJQUM1QixNQUFNQyxRQUFRQyxPQUFPRixLQUFLLElBQUlHLFdBQVcsR0FBR0MsT0FBTyxDQUFDLFdBQVc7SUFDL0QsSUFBSSxDQUFDSCxPQUFPLE9BQU87SUFDbkIsS0FBSyxNQUFNSSxVQUFVUCxlQUFnQjtRQUNuQyxJQUFJRyxVQUFVSSxRQUFRLE9BQU9KO1FBQzdCLElBQUlBLE1BQU1LLFFBQVEsQ0FBQ0QsV0FBV0osTUFBTU0sTUFBTSxHQUFHRixPQUFPRSxNQUFNLEVBQUU7WUFDMUQsT0FBT04sTUFBTU8sS0FBSyxDQUFDLEdBQUcsQ0FBQ0gsT0FBT0UsTUFBTTtRQUN0QztJQUNGO0lBQ0EsT0FBT047QUFDVCxFQUFFO0FBRUssU0FBU1EsWUFBWUMsS0FBZTtJQUN6QyxPQUFPQyxNQUFNQyxJQUFJLENBQUMsSUFBSUMsSUFBSSxDQUFDSCxTQUFTLEVBQUUsRUFBRUksR0FBRyxDQUFDZixpQkFBaUJnQixNQUFNLENBQUNDO0FBQ3RFO0FBRU8sU0FBU0Msa0JBQWtCUCxLQUFlO0lBQy9DLE1BQU1RLE9BQU9ULFlBQVlDLE9BQU9LLE1BQU0sQ0FBQyxDQUFDZixJQUFNQSxLQUFLQSxNQUFNO0lBQ3pELE9BQU9rQixLQUFLSixHQUFHLENBQUMsQ0FBQ0ssSUFBTSxHQUFHQSxFQUFFLElBQUksQ0FBQztBQUNuQztBQUVBLDZEQUE2RDtBQUN0RCxTQUFTQyxvQkFBb0JWLEtBQWU7SUFDakQsTUFBTVcsUUFBUVosWUFBWUMsT0FBT0ssTUFBTSxDQUFDLENBQUNmLElBQU1BLEtBQUtBLE1BQU07SUFDMUQsTUFBTXNCLE1BQWdCLEVBQUU7SUFDeEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLE1BQU1kLE1BQU0sRUFBRWdCLElBQUs7UUFDckMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILE1BQU1kLE1BQU0sRUFBRWlCLElBQUs7WUFDckMsSUFBSUQsTUFBTUMsR0FBRztZQUNiRixJQUFJRyxJQUFJLENBQUMsR0FBR0osS0FBSyxDQUFDRSxFQUFFLEdBQUdGLEtBQUssQ0FBQ0csRUFBRSxFQUFFO1FBQ25DO0lBQ0Y7SUFDQSxPQUFPRjtBQUNUO0FBRUE7Ozs7Q0FJQyxHQUNNLGVBQWVJLGtCQUNwQmhCLEtBQWUsRUFDZmlCLElBR0M7SUFFRCxNQUFNQyxxQkFBcUJELE1BQU1DLHNCQUFzQjtJQUV2RCxNQUFNQyxXQUFXWixrQkFBa0JQO0lBQ25DLE1BQU1vQixZQUFZVixvQkFBb0JWO0lBRXRDLElBQUksQ0FBQ2lCLE1BQU1JLFFBQVE7UUFDakIsT0FBTztZQUFFQyxNQUFNSDtZQUFVSSxPQUFPLEVBQUU7WUFBRUMsS0FBS0wsU0FBU3JCLEtBQUs7UUFBRztJQUM1RDtJQUVBLE1BQU0yQixXQUFXLE1BQU1SLEtBQUtJLE1BQU0sQ0FBQztXQUFJRjtXQUFhQztLQUFVO0lBQzlELE1BQU1NLE1BQU0sQ0FBQ0MsSUFBY0YsU0FBU0MsR0FBRyxDQUFDQyxFQUFFbEMsV0FBVztJQUVyRCxNQUFNNkIsT0FDSkcsU0FBU0csSUFBSSxJQUFJVixxQkFBcUJDLFNBQVNkLE1BQU0sQ0FBQ3FCLE9BQU9QO0lBQy9ELE1BQU1JLFFBQVFILFVBQVVmLE1BQU0sQ0FBQ3FCO0lBQy9CLE1BQU1GLE1BQU12QixNQUFNQyxJQUFJLENBQUMsSUFBSUMsSUFBSTtXQUFJbUI7V0FBU0M7S0FBTTtJQUNsRCxPQUFPO1FBQUVEO1FBQU1DO1FBQU9DO0lBQUk7QUFDNUIiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxsaWJcXG1hcmtldHNcXHBhaXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9saWIvbWFya2V0cy9wYWlycy50c1xuLy8gU2hhcmVkLCBkZXRlcm1pbmlzdGljIHBhaXIgaGVscGVycyB1c2VkIGJ5IGJvdGggVUkgYW5kIEFQSS5cblxuZXhwb3J0IHR5cGUgUGFpckF2YWlsYWJpbGl0eSA9IHsgdXNkdDogc3RyaW5nW107IGNyb3NzOiBzdHJpbmdbXTsgYWxsOiBzdHJpbmdbXSB9O1xuXG5jb25zdCBRVU9URV9TVUZGSVhFUyA9IFtcIlVTRFRcIiwgXCJVU0RDXCIsIFwiRkRVU0RcIiwgXCJUVVNEXCIsIFwiQlVTRFwiXSBhcyBjb25zdDtcblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgdG9rZW4gc3ltYm9sOlxuICogLSBVcHBlcmNhc2VcbiAqIC0gUmVtb3ZlIG5vbiBBLVogY2hhcmFjdGVyc1xuICogLSBTdHJpcCBrbm93biBxdW90ZSBzdWZmaXhlcyBzbyBjcm9zcyBjb21ib3MgbmV2ZXIgZG91YmxlLWFwcGVuZCBxdW90ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZUNvaW4gPSAoYzogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgY29uc3QgdXBwZXIgPSBTdHJpbmcoYyB8fCBcIlwiKS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL1teQS1aXS9nLCBcIlwiKTtcbiAgaWYgKCF1cHBlcikgcmV0dXJuIFwiXCI7XG4gIGZvciAoY29uc3Qgc3VmZml4IG9mIFFVT1RFX1NVRkZJWEVTKSB7XG4gICAgaWYgKHVwcGVyID09PSBzdWZmaXgpIHJldHVybiB1cHBlcjtcbiAgICBpZiAodXBwZXIuZW5kc1dpdGgoc3VmZml4KSAmJiB1cHBlci5sZW5ndGggPiBzdWZmaXgubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdXBwZXIuc2xpY2UoMCwgLXN1ZmZpeC5sZW5ndGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdXBwZXI7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVkdXBlQ29pbnMoYmFzZXM6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KChiYXNlcyA/PyBbXSkubWFwKG5vcm1hbGl6ZUNvaW4pKSkuZmlsdGVyKEJvb2xlYW4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNkdExlZ3NGcm9tQ29pbnMoYmFzZXM6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICBjb25zdCB1bmlxID0gZGVkdXBlQ29pbnMoYmFzZXMpLmZpbHRlcigoYykgPT4gYyAmJiBjICE9PSBcIlVTRFRcIik7XG4gIHJldHVybiB1bmlxLm1hcCgoYikgPT4gYCR7Yn1VU0RUYCk7XG59XG5cbi8vIE9yZGVyZWQgcGVybXV0YXRpb25zIEEtPkIgKEEgIT09IEIpLiBObyB2ZXJpZmljYXRpb24gaGVyZS5cbmV4cG9ydCBmdW5jdGlvbiBjcm9zc1BhaXJzRnJvbUNvaW5zKGJhc2VzOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgY29uc3QgY29pbnMgPSBkZWR1cGVDb2lucyhiYXNlcykuZmlsdGVyKChjKSA9PiBjICYmIGMgIT09IFwiVVNEVFwiKTtcbiAgY29uc3Qgb3V0OiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2lucy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGkgPT09IGopIGNvbnRpbnVlO1xuICAgICAgb3V0LnB1c2goYCR7Y29pbnNbaV19JHtjb2luc1tqXX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBc3luYyBidWlsZGVyIHdpdGggb3B0aW9uYWwgcHJldmlldyB2ZXJpZmljYXRpb24uXG4gKiAtIElmIGB2ZXJpZnlgIGlzIHByb3ZpZGVkLCB3ZSBmaWx0ZXIgVVNEVCArIGNyb3NzIGJ5IGl0LlxuICogLSBJZiBub3QsIHdlIHJldHVybiBvbmx5IFVTRFQgbGVncyAobm8gc3ludGhldGljIGNyb3NzZXMgb24gdGhlIGNsaWVudCkuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYWlyc0Zyb21TZXR0aW5ncyhcbiAgYmFzZXM6IHN0cmluZ1tdLFxuICBvcHRzPzoge1xuICAgIHZlcmlmeT86IChzeW1ib2xzOiBzdHJpbmdbXSkgPT4gUHJvbWlzZTxTZXQ8c3RyaW5nPj47XG4gICAgcHJlZmVyVmVyaWZpZWRVc2R0PzogYm9vbGVhbjsgLy8gZGVmYXVsdCB0cnVlXG4gIH1cbik6IFByb21pc2U8UGFpckF2YWlsYWJpbGl0eT4ge1xuICBjb25zdCBwcmVmZXJWZXJpZmllZFVzZHQgPSBvcHRzPy5wcmVmZXJWZXJpZmllZFVzZHQgPz8gdHJ1ZTtcblxuICBjb25zdCB1c2R0Q2FuZCA9IHVzZHRMZWdzRnJvbUNvaW5zKGJhc2VzKTtcbiAgY29uc3QgY3Jvc3NDYW5kID0gY3Jvc3NQYWlyc0Zyb21Db2lucyhiYXNlcyk7XG5cbiAgaWYgKCFvcHRzPy52ZXJpZnkpIHtcbiAgICByZXR1cm4geyB1c2R0OiB1c2R0Q2FuZCwgY3Jvc3M6IFtdLCBhbGw6IHVzZHRDYW5kLnNsaWNlKCkgfTtcbiAgfVxuXG4gIGNvbnN0IHZlcmlmaWVkID0gYXdhaXQgb3B0cy52ZXJpZnkoWy4uLnVzZHRDYW5kLCAuLi5jcm9zc0NhbmRdKTtcbiAgY29uc3QgaGFzID0gKHM6IHN0cmluZykgPT4gdmVyaWZpZWQuaGFzKHMudG9VcHBlckNhc2UoKSk7XG5cbiAgY29uc3QgdXNkdCA9XG4gICAgdmVyaWZpZWQuc2l6ZSAmJiBwcmVmZXJWZXJpZmllZFVzZHQgPyB1c2R0Q2FuZC5maWx0ZXIoaGFzKSA6IHVzZHRDYW5kO1xuICBjb25zdCBjcm9zcyA9IGNyb3NzQ2FuZC5maWx0ZXIoaGFzKTtcbiAgY29uc3QgYWxsID0gQXJyYXkuZnJvbShuZXcgU2V0KFsuLi51c2R0LCAuLi5jcm9zc10pKTtcbiAgcmV0dXJuIHsgdXNkdCwgY3Jvc3MsIGFsbCB9O1xufVxuIl0sIm5hbWVzIjpbIlFVT1RFX1NVRkZJWEVTIiwibm9ybWFsaXplQ29pbiIsImMiLCJ1cHBlciIsIlN0cmluZyIsInRvVXBwZXJDYXNlIiwicmVwbGFjZSIsInN1ZmZpeCIsImVuZHNXaXRoIiwibGVuZ3RoIiwic2xpY2UiLCJkZWR1cGVDb2lucyIsImJhc2VzIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwibWFwIiwiZmlsdGVyIiwiQm9vbGVhbiIsInVzZHRMZWdzRnJvbUNvaW5zIiwidW5pcSIsImIiLCJjcm9zc1BhaXJzRnJvbUNvaW5zIiwiY29pbnMiLCJvdXQiLCJpIiwiaiIsInB1c2giLCJwYWlyc0Zyb21TZXR0aW5ncyIsIm9wdHMiLCJwcmVmZXJWZXJpZmllZFVzZHQiLCJ1c2R0Q2FuZCIsImNyb3NzQ2FuZCIsInZlcmlmeSIsInVzZHQiLCJjcm9zcyIsImFsbCIsInZlcmlmaWVkIiwiaGFzIiwicyIsInNpemUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/markets/pairs.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/settings/schema.ts":
/*!************************************!*\
  !*** ./src/lib/settings/schema.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppSettings: () => (/* binding */ AppSettings),\n/* harmony export */   DEFAULT_SETTINGS: () => (/* binding */ DEFAULT_SETTINGS),\n/* harmony export */   SETTINGS_VERSION: () => (/* binding */ SETTINGS_VERSION),\n/* harmony export */   isAppSettings: () => (/* binding */ isAppSettings),\n/* harmony export */   mergeAppSettings: () => (/* binding */ mergeAppSettings),\n/* harmony export */   migrateSettings: () => (/* binding */ migrateSettings),\n/* harmony export */   normalizeCoinUniverse: () => (/* binding */ normalizeCoinUniverse)\n/* harmony export */ });\n// src/lib/settings/schema.ts\nconst SETTINGS_VERSION = 1;\nconst DEFAULT_SETTINGS = {\n    version: SETTINGS_VERSION,\n    coinUniverse: [],\n    profile: {\n        nickname: \"\",\n        email: \"\",\n        binanceKeyId: \"\"\n    },\n    stats: {\n        histogramLen: 64,\n        bmDecimals: 4,\n        idPctDecimals: 6\n    },\n    timing: {\n        autoRefresh: true,\n        autoRefreshMs: 40000,\n        secondaryEnabled: true,\n        secondaryCycles: 3,\n        strCycles: {\n            m30: 45,\n            h1: 90,\n            h3: 270\n        }\n    },\n    clustering: {\n        clusters: [\n            {\n                id: \"cl-1\",\n                name: \"Cluster 1\",\n                coins: []\n            }\n        ]\n    },\n    params: {\n        values: {\n            eta: 0.02,\n            epsilon: 0.2,\n            iota: 0.5\n        }\n    }\n};\n// ---------- internal helpers ----------\nconst toUpperArray = (value)=>{\n    if (!Array.isArray(value)) return [];\n    const seen = new Set();\n    const result = [];\n    for (const entry of value){\n        const upper = String(entry ?? \"\").trim().toUpperCase();\n        if (!upper || seen.has(upper)) continue;\n        seen.add(upper);\n        result.push(upper);\n    }\n    if (!seen.has(\"USDT\")) result.push(\"USDT\");\n    return result;\n};\nconst toNumber = (value, fallback)=>{\n    const parsed = Number(value);\n    return Number.isFinite(parsed) ? parsed : fallback;\n};\nconst clamp = (value, min, max)=>Math.min(max, Math.max(min, value));\nconst toClusterArray = (value)=>{\n    if (!Array.isArray(value)) return DEFAULT_SETTINGS.clustering.clusters;\n    return value.map((entry, index)=>{\n        const obj = entry && typeof entry === \"object\" ? entry : {};\n        return {\n            id: String(obj.id ?? `cl-${index + 1}`),\n            name: String(obj.name ?? `Cluster ${index + 1}`),\n            coins: toUpperArray(obj.coins)\n        };\n    });\n};\nconst toParams = (value)=>{\n    if (!value || typeof value !== \"object\") return {\n        ...DEFAULT_SETTINGS.params.values\n    };\n    const result = {\n        ...DEFAULT_SETTINGS.params.values\n    };\n    for (const [key, raw] of Object.entries(value)){\n        const parsed = Number(raw);\n        if (Number.isFinite(parsed)) result[key] = parsed;\n    }\n    return result;\n};\n// ---------- public migration (existing) ----------\nfunction migrateSettings(input) {\n    const s = input && typeof input === \"object\" ? input : {};\n    const statsSource = s.stats && typeof s.stats === \"object\" ? s.stats : {};\n    const timingSource = s.timing && typeof s.timing === \"object\" ? s.timing : {};\n    const timingCycles = timingSource.strCycles && typeof timingSource.strCycles === \"object\" ? timingSource.strCycles : {};\n    const out = {\n        version: SETTINGS_VERSION,\n        coinUniverse: toUpperArray(s.coinUniverse),\n        profile: {\n            nickname: String(s.profile?.nickname ?? \"\"),\n            email: String(s.profile?.email ?? \"\"),\n            binanceKeyId: String(s.profile?.binanceKeyId ?? \"\")\n        },\n        stats: {\n            histogramLen: Math.max(16, toNumber(statsSource.histogramLen, DEFAULT_SETTINGS.stats.histogramLen)),\n            bmDecimals: clamp(toNumber(statsSource.bmDecimals, DEFAULT_SETTINGS.stats.bmDecimals), 0, 6),\n            idPctDecimals: clamp(toNumber(statsSource.idPctDecimals, DEFAULT_SETTINGS.stats.idPctDecimals), 0, 8)\n        },\n        timing: {\n            autoRefresh: Boolean(timingSource.autoRefresh ?? DEFAULT_SETTINGS.timing.autoRefresh),\n            autoRefreshMs: Math.max(500, toNumber(timingSource.autoRefreshMs, DEFAULT_SETTINGS.timing.autoRefreshMs)),\n            secondaryEnabled: Boolean(timingSource.secondaryEnabled ?? DEFAULT_SETTINGS.timing.secondaryEnabled),\n            secondaryCycles: clamp(toNumber(timingSource.secondaryCycles, DEFAULT_SETTINGS.timing.secondaryCycles), 1, 10),\n            strCycles: {\n                m30: Math.max(1, toNumber(timingCycles.m30, DEFAULT_SETTINGS.timing.strCycles.m30)),\n                h1: Math.max(1, toNumber(timingCycles.h1, DEFAULT_SETTINGS.timing.strCycles.h1)),\n                h3: Math.max(1, toNumber(timingCycles.h3, DEFAULT_SETTINGS.timing.strCycles.h3))\n            }\n        },\n        clustering: {\n            clusters: toClusterArray(s.clustering?.clusters)\n        },\n        params: {\n            values: toParams(s.params?.values)\n        }\n    };\n    if (out.coinUniverse.length === 0) {\n        out.coinUniverse = [\n            ...DEFAULT_SETTINGS.coinUniverse\n        ];\n    }\n    return out;\n}\n/** Normalize coins from a string (comma/space-separated) or array; ensures USDT present and uppercase+deduped. */ function normalizeCoinUniverse(input) {\n    if (Array.isArray(input)) return toUpperArray(input);\n    if (typeof input === \"string\") {\n        const parts = input.split(/[,\\s]+/).map((s)=>s.trim()).filter(Boolean);\n        return toUpperArray(parts);\n    }\n    return toUpperArray([]);\n}\n/** Type guard to check if an object already looks like an AppSettings after migration. */ function isAppSettings(x) {\n    return !!x && typeof x === \"object\" && \"version\" in x && \"coinUniverse\" in x;\n}\n/**\n * Factory  create a normalized AppSettings object.\n * - If you pass nothing, you get migrated DEFAULT_SETTINGS.\n * - If you pass a deep-partial or any unknown, it is migrated safely.\n */ function AppSettings(input) {\n    return migrateSettings(input ?? DEFAULT_SETTINGS);\n}\n/** Merge a base AppSettings with a deep-partial patch, then normalize. */ function mergeAppSettings(base, patch) {\n    // shallow-merge at top level; nested objects are re-validated by migrateSettings\n    return migrateSettings({\n        ...base,\n        ...patch\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL3NldHRpbmdzL3NjaGVtYS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsNkJBQTZCO0FBcUJ0QixNQUFNQSxtQkFBbUIsRUFBRTtBQUUzQixNQUFNQyxtQkFBZ0M7SUFDM0NDLFNBQVNGO0lBQ1RHLGNBQWMsRUFBRTtJQUNoQkMsU0FBUztRQUFFQyxVQUFVO1FBQUlDLE9BQU87UUFBSUMsY0FBYztJQUFHO0lBQ3JEQyxPQUFPO1FBQUVDLGNBQWM7UUFBSUMsWUFBWTtRQUFHQyxlQUFlO0lBQUU7SUFDM0RDLFFBQVE7UUFDTkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLGtCQUFrQjtRQUNsQkMsaUJBQWlCO1FBQ2pCQyxXQUFXO1lBQUVDLEtBQUs7WUFBSUMsSUFBSTtZQUFJQyxJQUFJO1FBQUk7SUFDeEM7SUFDQUMsWUFBWTtRQUFFQyxVQUFVO1lBQUM7Z0JBQUVDLElBQUk7Z0JBQVFDLE1BQU07Z0JBQWFDLE9BQU8sRUFBRTtZQUFDO1NBQUU7SUFBQztJQUN2RUMsUUFBUTtRQUFFQyxRQUFRO1lBQUVDLEtBQUs7WUFBTUMsU0FBUztZQUFLQyxNQUFNO1FBQUk7SUFBRTtBQUUzRCxFQUFFO0FBRUYseUNBQXlDO0FBQ3pDLE1BQU1DLGVBQWUsQ0FBQ0M7SUFDcEIsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNGLFFBQVEsT0FBTyxFQUFFO0lBQ3BDLE1BQU1HLE9BQU8sSUFBSUM7SUFDakIsTUFBTUMsU0FBbUIsRUFBRTtJQUMzQixLQUFLLE1BQU1DLFNBQVNOLE1BQU87UUFDekIsTUFBTU8sUUFBUUMsT0FBT0YsU0FBUyxJQUFJRyxJQUFJLEdBQUdDLFdBQVc7UUFDcEQsSUFBSSxDQUFDSCxTQUFTSixLQUFLUSxHQUFHLENBQUNKLFFBQVE7UUFDL0JKLEtBQUtTLEdBQUcsQ0FBQ0w7UUFDVEYsT0FBT1EsSUFBSSxDQUFDTjtJQUNkO0lBQ0EsSUFBSSxDQUFDSixLQUFLUSxHQUFHLENBQUMsU0FBU04sT0FBT1EsSUFBSSxDQUFDO0lBQ25DLE9BQU9SO0FBQ1Q7QUFFQSxNQUFNUyxXQUFXLENBQUNkLE9BQWdCZTtJQUNoQyxNQUFNQyxTQUFTQyxPQUFPakI7SUFDdEIsT0FBT2lCLE9BQU9DLFFBQVEsQ0FBQ0YsVUFBVUEsU0FBU0Q7QUFDNUM7QUFFQSxNQUFNSSxRQUFRLENBQUNuQixPQUFlb0IsS0FBYUMsTUFDekNDLEtBQUtGLEdBQUcsQ0FBQ0MsS0FBS0MsS0FBS0QsR0FBRyxDQUFDRCxLQUFLcEI7QUFFOUIsTUFBTXVCLGlCQUFpQixDQUFDdkI7SUFDdEIsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNGLFFBQVEsT0FBTy9CLGlCQUFpQm9CLFVBQVUsQ0FBQ0MsUUFBUTtJQUN0RSxPQUFPVSxNQUFNd0IsR0FBRyxDQUFDLENBQUNsQixPQUFPbUI7UUFDdkIsTUFBTUMsTUFBTSxTQUFVLE9BQU9wQixVQUFVLFdBQVlBLFFBQW1DLENBQUM7UUFDdkYsT0FBTztZQUNMZixJQUFJaUIsT0FBT2tCLElBQUluQyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUVrQyxRQUFRLEdBQUc7WUFDdENqQyxNQUFNZ0IsT0FBT2tCLElBQUlsQyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUVpQyxRQUFRLEdBQUc7WUFDL0NoQyxPQUFPTSxhQUFhMkIsSUFBSWpDLEtBQUs7UUFDL0I7SUFDRjtBQUNGO0FBRUEsTUFBTWtDLFdBQVcsQ0FBQzNCO0lBQ2hCLElBQUksQ0FBQ0EsU0FBUyxPQUFPQSxVQUFVLFVBQVUsT0FBTztRQUFFLEdBQUcvQixpQkFBaUJ5QixNQUFNLENBQUNDLE1BQU07SUFBQztJQUNwRixNQUFNVSxTQUFpQztRQUFFLEdBQUdwQyxpQkFBaUJ5QixNQUFNLENBQUNDLE1BQU07SUFBQztJQUMzRSxLQUFLLE1BQU0sQ0FBQ2lDLEtBQUtDLElBQUksSUFBSUMsT0FBT0MsT0FBTyxDQUFDL0IsT0FBUTtRQUM5QyxNQUFNZ0IsU0FBU0MsT0FBT1k7UUFDdEIsSUFBSVosT0FBT0MsUUFBUSxDQUFDRixTQUFTWCxNQUFNLENBQUN1QixJQUFJLEdBQUdaO0lBQzdDO0lBQ0EsT0FBT1g7QUFDVDtBQUVBLG9EQUFvRDtBQUM3QyxTQUFTMkIsZ0JBQWdCQyxLQUFjO0lBQzVDLE1BQU1DLElBQUksU0FBVSxPQUFPRCxVQUFVLFdBQWFBLFFBQW9DLENBQUM7SUFFdkYsTUFBTUUsY0FBYyxFQUFHM0QsS0FBSyxJQUFJLE9BQU8wRCxFQUFFMUQsS0FBSyxLQUFLLFdBQVkwRCxFQUFFMUQsS0FBSyxHQUE4QixDQUFDO0lBQ3JHLE1BQU00RCxlQUFlLEVBQUd4RCxNQUFNLElBQUksT0FBT3NELEVBQUV0RCxNQUFNLEtBQUssV0FBWXNELEVBQUV0RCxNQUFNLEdBQThCLENBQUM7SUFDekcsTUFBTXlELGVBQWUsYUFBY3BELFNBQVMsSUFBSSxPQUFPbUQsYUFBYW5ELFNBQVMsS0FBSyxXQUM5RW1ELGFBQWFuRCxTQUFTLEdBQ3RCLENBQUM7SUFFTCxNQUFNcUQsTUFBbUI7UUFDdkJwRSxTQUFTRjtRQUNURyxjQUFjNEIsYUFBYW1DLEVBQUUvRCxZQUFZO1FBQ3pDQyxTQUFTO1lBQ1BDLFVBQVVtQyxPQUFPLEVBQUdwQyxPQUFPLEVBQTBDQyxZQUFZO1lBQ2pGQyxPQUFPa0MsT0FBTyxFQUFHcEMsT0FBTyxFQUEwQ0UsU0FBUztZQUMzRUMsY0FBY2lDLE9BQU8sRUFBR3BDLE9BQU8sRUFBMENHLGdCQUFnQjtRQUMzRjtRQUNBQyxPQUFPO1lBQ0xDLGNBQWM2QyxLQUFLRCxHQUFHLENBQUMsSUFBSVAsU0FBU3FCLFlBQVkxRCxZQUFZLEVBQUVSLGlCQUFpQk8sS0FBSyxDQUFDQyxZQUFZO1lBQ2pHQyxZQUFZeUMsTUFBTUwsU0FBU3FCLFlBQVl6RCxVQUFVLEVBQUVULGlCQUFpQk8sS0FBSyxDQUFDRSxVQUFVLEdBQUcsR0FBRztZQUMxRkMsZUFBZXdDLE1BQU1MLFNBQVNxQixZQUFZeEQsYUFBYSxFQUFFVixpQkFBaUJPLEtBQUssQ0FBQ0csYUFBYSxHQUFHLEdBQUc7UUFDckc7UUFDQUMsUUFBUTtZQUNOQyxhQUFhMEQsUUFBUUgsYUFBYXZELFdBQVcsSUFBSVosaUJBQWlCVyxNQUFNLENBQUNDLFdBQVc7WUFDcEZDLGVBQWV3QyxLQUFLRCxHQUFHLENBQUMsS0FBS1AsU0FBU3NCLGFBQWF0RCxhQUFhLEVBQUViLGlCQUFpQlcsTUFBTSxDQUFDRSxhQUFhO1lBQ3ZHQyxrQkFBa0J3RCxRQUFRSCxhQUFhckQsZ0JBQWdCLElBQUlkLGlCQUFpQlcsTUFBTSxDQUFDRyxnQkFBZ0I7WUFDbkdDLGlCQUFpQm1DLE1BQU1MLFNBQVNzQixhQUFhcEQsZUFBZSxFQUFFZixpQkFBaUJXLE1BQU0sQ0FBQ0ksZUFBZSxHQUFHLEdBQUc7WUFDM0dDLFdBQVc7Z0JBQ1RDLEtBQUtvQyxLQUFLRCxHQUFHLENBQUMsR0FBR1AsU0FBU3VCLGFBQWFuRCxHQUFHLEVBQUVqQixpQkFBaUJXLE1BQU0sQ0FBQ0ssU0FBUyxDQUFDQyxHQUFHO2dCQUNqRkMsSUFBSW1DLEtBQUtELEdBQUcsQ0FBQyxHQUFHUCxTQUFTdUIsYUFBYWxELEVBQUUsRUFBRWxCLGlCQUFpQlcsTUFBTSxDQUFDSyxTQUFTLENBQUNFLEVBQUU7Z0JBQzlFQyxJQUFJa0MsS0FBS0QsR0FBRyxDQUFDLEdBQUdQLFNBQVN1QixhQUFhakQsRUFBRSxFQUFFbkIsaUJBQWlCVyxNQUFNLENBQUNLLFNBQVMsQ0FBQ0csRUFBRTtZQUNoRjtRQUNGO1FBQ0FDLFlBQVk7WUFBRUMsVUFBVWlDLGVBQWdCVyxFQUFFN0MsVUFBVSxFQUEwQ0M7UUFBVTtRQUN4R0ksUUFBUTtZQUFFQyxRQUFRZ0MsU0FBVU8sRUFBRXhDLE1BQU0sRUFBMENDO1FBQVE7SUFDeEY7SUFFQSxJQUFJMkMsSUFBSW5FLFlBQVksQ0FBQ3FFLE1BQU0sS0FBSyxHQUFHO1FBQ2pDRixJQUFJbkUsWUFBWSxHQUFHO2VBQUlGLGlCQUFpQkUsWUFBWTtTQUFDO0lBQ3ZEO0lBRUEsT0FBT21FO0FBQ1Q7QUFRQSxnSEFBZ0gsR0FDekcsU0FBU0csc0JBQXNCUixLQUFrQztJQUN0RSxJQUFJaEMsTUFBTUMsT0FBTyxDQUFDK0IsUUFBUSxPQUFPbEMsYUFBYWtDO0lBQzlDLElBQUksT0FBT0EsVUFBVSxVQUFVO1FBQzdCLE1BQU1TLFFBQVFULE1BQU1VLEtBQUssQ0FBQyxVQUFVbkIsR0FBRyxDQUFDVSxDQUFBQSxJQUFLQSxFQUFFekIsSUFBSSxJQUFJbUMsTUFBTSxDQUFDTDtRQUM5RCxPQUFPeEMsYUFBYTJDO0lBQ3RCO0lBQ0EsT0FBTzNDLGFBQWEsRUFBRTtBQUN4QjtBQUVBLHdGQUF3RixHQUNqRixTQUFTOEMsY0FBY0MsQ0FBVTtJQUN0QyxPQUFPLENBQUMsQ0FBQ0EsS0FBSyxPQUFPQSxNQUFNLFlBQVksYUFBY0EsS0FBYSxrQkFBbUJBO0FBQ3ZGO0FBRUE7Ozs7Q0FJQyxHQUNNLFNBQVNDLFlBQVlkLEtBQTBDO0lBQ3BFLE9BQU9ELGdCQUFnQkMsU0FBU2hFO0FBQ2xDO0FBRUEsd0VBQXdFLEdBQ2pFLFNBQVMrRSxpQkFBaUJDLElBQWlCLEVBQUVDLEtBQStCO0lBQ2pGLGlGQUFpRjtJQUNqRixPQUFPbEIsZ0JBQWdCO1FBQUUsR0FBR2lCLElBQUk7UUFBRSxHQUFHQyxLQUFLO0lBQUM7QUFDN0MiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxsaWJcXHNldHRpbmdzXFxzY2hlbWEudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2xpYi9zZXR0aW5ncy9zY2hlbWEudHNcbmV4cG9ydCB0eXBlIENsdXN0ZXIgPSB7IGlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZzsgY29pbnM6IHN0cmluZ1tdIH07XG5cbmV4cG9ydCB0eXBlIEFwcFNldHRpbmdzID0ge1xuICB2ZXJzaW9uOiBudW1iZXI7XG4gIGNvaW5Vbml2ZXJzZTogc3RyaW5nW107XG4gIHByb2ZpbGU6IHsgbmlja25hbWU6IHN0cmluZzsgZW1haWw6IHN0cmluZzsgYmluYW5jZUtleUlkOiBzdHJpbmcgfTtcbiAgc3RhdHM6IHsgaGlzdG9ncmFtTGVuOiBudW1iZXI7IGJtRGVjaW1hbHM6IG51bWJlcjsgaWRQY3REZWNpbWFsczogbnVtYmVyIH07XG4gIHRpbWluZzoge1xuICAgIGF1dG9SZWZyZXNoOiBib29sZWFuOyAgICAgICAgICAgLy8gPC0tIHJlcXVpcmVkIGZsYWdcbiAgICBhdXRvUmVmcmVzaE1zOiBudW1iZXI7XG4gICAgc2Vjb25kYXJ5RW5hYmxlZDogYm9vbGVhbjtcbiAgICBzZWNvbmRhcnlDeWNsZXM6IG51bWJlcjsgICAgICAgIC8vIDEuLjEwXG4gICAgc3RyQ3ljbGVzOiB7IG0zMDogbnVtYmVyOyBoMTogbnVtYmVyOyBoMzogbnVtYmVyIH07XG4gIH07XG4gIGNsdXN0ZXJpbmc6IHtcbiAgICBjbHVzdGVyczogQ2x1c3RlcltdO1xuICB9O1xuICBwYXJhbXM6IHsgdmFsdWVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+IH07XG59O1xuXG5leHBvcnQgY29uc3QgU0VUVElOR1NfVkVSU0lPTiA9IDE7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBBcHBTZXR0aW5ncyA9IHtcbiAgdmVyc2lvbjogU0VUVElOR1NfVkVSU0lPTixcbiAgY29pblVuaXZlcnNlOiBbXSxcbiAgcHJvZmlsZTogeyBuaWNrbmFtZTogXCJcIiwgZW1haWw6IFwiXCIsIGJpbmFuY2VLZXlJZDogXCJcIiB9LFxuICBzdGF0czogeyBoaXN0b2dyYW1MZW46IDY0LCBibURlY2ltYWxzOiA0LCBpZFBjdERlY2ltYWxzOiA2IH0sXG4gIHRpbWluZzoge1xuICAgIGF1dG9SZWZyZXNoOiB0cnVlLFxuICAgIGF1dG9SZWZyZXNoTXM6IDQwXzAwMCxcbiAgICBzZWNvbmRhcnlFbmFibGVkOiB0cnVlLFxuICAgIHNlY29uZGFyeUN5Y2xlczogMyxcbiAgICBzdHJDeWNsZXM6IHsgbTMwOiA0NSwgaDE6IDkwLCBoMzogMjcwIH0sXG4gIH0sXG4gIGNsdXN0ZXJpbmc6IHsgY2x1c3RlcnM6IFt7IGlkOiBcImNsLTFcIiwgbmFtZTogXCJDbHVzdGVyIDFcIiwgY29pbnM6IFtdIH1dIH0sXG4gIHBhcmFtczogeyB2YWx1ZXM6IHsgZXRhOiAwLjAyLCBlcHNpbG9uOiAwLjIsIGlvdGE6IDAuNSB9IH0sXG4gIFxufTtcblxuLy8gLS0tLS0tLS0tLSBpbnRlcm5hbCBoZWxwZXJzIC0tLS0tLS0tLS1cbmNvbnN0IHRvVXBwZXJBcnJheSA9ICh2YWx1ZTogdW5rbm93bik6IHN0cmluZ1tdID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIFtdO1xuICBjb25zdCBzZWVuID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChjb25zdCBlbnRyeSBvZiB2YWx1ZSkge1xuICAgIGNvbnN0IHVwcGVyID0gU3RyaW5nKGVudHJ5ID8/IFwiXCIpLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xuICAgIGlmICghdXBwZXIgfHwgc2Vlbi5oYXModXBwZXIpKSBjb250aW51ZTtcbiAgICBzZWVuLmFkZCh1cHBlcik7XG4gICAgcmVzdWx0LnB1c2godXBwZXIpO1xuICB9XG4gIGlmICghc2Vlbi5oYXMoXCJVU0RUXCIpKSByZXN1bHQucHVzaChcIlVTRFRcIik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCB0b051bWJlciA9ICh2YWx1ZTogdW5rbm93biwgZmFsbGJhY2s6IG51bWJlcik6IG51bWJlciA9PiB7XG4gIGNvbnN0IHBhcnNlZCA9IE51bWJlcih2YWx1ZSk7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUocGFyc2VkKSA/IHBhcnNlZCA6IGZhbGxiYWNrO1xufTtcblxuY29uc3QgY2xhbXAgPSAodmFsdWU6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyID0+XG4gIE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2YWx1ZSkpO1xuXG5jb25zdCB0b0NsdXN0ZXJBcnJheSA9ICh2YWx1ZTogdW5rbm93bik6IENsdXN0ZXJbXSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiBERUZBVUxUX1NFVFRJTkdTLmNsdXN0ZXJpbmcuY2x1c3RlcnM7XG4gIHJldHVybiB2YWx1ZS5tYXAoKGVudHJ5LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG9iaiA9IChlbnRyeSAmJiB0eXBlb2YgZW50cnkgPT09IFwib2JqZWN0XCIpID8gZW50cnkgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gOiB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IFN0cmluZyhvYmouaWQgPz8gYGNsLSR7aW5kZXggKyAxfWApLFxuICAgICAgbmFtZTogU3RyaW5nKG9iai5uYW1lID8/IGBDbHVzdGVyICR7aW5kZXggKyAxfWApLFxuICAgICAgY29pbnM6IHRvVXBwZXJBcnJheShvYmouY29pbnMpLFxuICAgIH07XG4gIH0pO1xufTtcblxuY29uc3QgdG9QYXJhbXMgPSAodmFsdWU6IHVua25vd24pOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0+IHtcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHJldHVybiB7IC4uLkRFRkFVTFRfU0VUVElOR1MucGFyYW1zLnZhbHVlcyB9O1xuICBjb25zdCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7IC4uLkRFRkFVTFRfU0VUVElOR1MucGFyYW1zLnZhbHVlcyB9O1xuICBmb3IgKGNvbnN0IFtrZXksIHJhd10gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgY29uc3QgcGFyc2VkID0gTnVtYmVyKHJhdyk7XG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShwYXJzZWQpKSByZXN1bHRba2V5XSA9IHBhcnNlZDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gLS0tLS0tLS0tLSBwdWJsaWMgbWlncmF0aW9uIChleGlzdGluZykgLS0tLS0tLS0tLVxuZXhwb3J0IGZ1bmN0aW9uIG1pZ3JhdGVTZXR0aW5ncyhpbnB1dDogdW5rbm93bik6IEFwcFNldHRpbmdzIHtcbiAgY29uc3QgcyA9IChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpID8gKGlucHV0IGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KSA6IHt9O1xuXG4gIGNvbnN0IHN0YXRzU291cmNlID0gKHMuc3RhdHMgJiYgdHlwZW9mIHMuc3RhdHMgPT09IFwib2JqZWN0XCIpID8gcy5zdGF0cyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA6IHt9O1xuICBjb25zdCB0aW1pbmdTb3VyY2UgPSAocy50aW1pbmcgJiYgdHlwZW9mIHMudGltaW5nID09PSBcIm9iamVjdFwiKSA/IHMudGltaW5nIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+IDoge307XG4gIGNvbnN0IHRpbWluZ0N5Y2xlcyA9ICh0aW1pbmdTb3VyY2Uuc3RyQ3ljbGVzICYmIHR5cGVvZiB0aW1pbmdTb3VyY2Uuc3RyQ3ljbGVzID09PSBcIm9iamVjdFwiKVxuICAgID8gdGltaW5nU291cmNlLnN0ckN5Y2xlcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICAgIDoge307XG5cbiAgY29uc3Qgb3V0OiBBcHBTZXR0aW5ncyA9IHtcbiAgICB2ZXJzaW9uOiBTRVRUSU5HU19WRVJTSU9OLFxuICAgIGNvaW5Vbml2ZXJzZTogdG9VcHBlckFycmF5KHMuY29pblVuaXZlcnNlKSxcbiAgICBwcm9maWxlOiB7XG4gICAgICBuaWNrbmFtZTogU3RyaW5nKChzLnByb2ZpbGUgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCB1bmRlZmluZWQpPy5uaWNrbmFtZSA/PyBcIlwiKSxcbiAgICAgIGVtYWlsOiBTdHJpbmcoKHMucHJvZmlsZSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IHVuZGVmaW5lZCk/LmVtYWlsID8/IFwiXCIpLFxuICAgICAgYmluYW5jZUtleUlkOiBTdHJpbmcoKHMucHJvZmlsZSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IHVuZGVmaW5lZCk/LmJpbmFuY2VLZXlJZCA/PyBcIlwiKSxcbiAgICB9LFxuICAgIHN0YXRzOiB7XG4gICAgICBoaXN0b2dyYW1MZW46IE1hdGgubWF4KDE2LCB0b051bWJlcihzdGF0c1NvdXJjZS5oaXN0b2dyYW1MZW4sIERFRkFVTFRfU0VUVElOR1Muc3RhdHMuaGlzdG9ncmFtTGVuKSksXG4gICAgICBibURlY2ltYWxzOiBjbGFtcCh0b051bWJlcihzdGF0c1NvdXJjZS5ibURlY2ltYWxzLCBERUZBVUxUX1NFVFRJTkdTLnN0YXRzLmJtRGVjaW1hbHMpLCAwLCA2KSxcbiAgICAgIGlkUGN0RGVjaW1hbHM6IGNsYW1wKHRvTnVtYmVyKHN0YXRzU291cmNlLmlkUGN0RGVjaW1hbHMsIERFRkFVTFRfU0VUVElOR1Muc3RhdHMuaWRQY3REZWNpbWFscyksIDAsIDgpLFxuICAgIH0sXG4gICAgdGltaW5nOiB7XG4gICAgICBhdXRvUmVmcmVzaDogQm9vbGVhbih0aW1pbmdTb3VyY2UuYXV0b1JlZnJlc2ggPz8gREVGQVVMVF9TRVRUSU5HUy50aW1pbmcuYXV0b1JlZnJlc2gpLFxuICAgICAgYXV0b1JlZnJlc2hNczogTWF0aC5tYXgoNTAwLCB0b051bWJlcih0aW1pbmdTb3VyY2UuYXV0b1JlZnJlc2hNcywgREVGQVVMVF9TRVRUSU5HUy50aW1pbmcuYXV0b1JlZnJlc2hNcykpLFxuICAgICAgc2Vjb25kYXJ5RW5hYmxlZDogQm9vbGVhbih0aW1pbmdTb3VyY2Uuc2Vjb25kYXJ5RW5hYmxlZCA/PyBERUZBVUxUX1NFVFRJTkdTLnRpbWluZy5zZWNvbmRhcnlFbmFibGVkKSxcbiAgICAgIHNlY29uZGFyeUN5Y2xlczogY2xhbXAodG9OdW1iZXIodGltaW5nU291cmNlLnNlY29uZGFyeUN5Y2xlcywgREVGQVVMVF9TRVRUSU5HUy50aW1pbmcuc2Vjb25kYXJ5Q3ljbGVzKSwgMSwgMTApLFxuICAgICAgc3RyQ3ljbGVzOiB7XG4gICAgICAgIG0zMDogTWF0aC5tYXgoMSwgdG9OdW1iZXIodGltaW5nQ3ljbGVzLm0zMCwgREVGQVVMVF9TRVRUSU5HUy50aW1pbmcuc3RyQ3ljbGVzLm0zMCkpLFxuICAgICAgICBoMTogTWF0aC5tYXgoMSwgdG9OdW1iZXIodGltaW5nQ3ljbGVzLmgxLCBERUZBVUxUX1NFVFRJTkdTLnRpbWluZy5zdHJDeWNsZXMuaDEpKSxcbiAgICAgICAgaDM6IE1hdGgubWF4KDEsIHRvTnVtYmVyKHRpbWluZ0N5Y2xlcy5oMywgREVGQVVMVF9TRVRUSU5HUy50aW1pbmcuc3RyQ3ljbGVzLmgzKSksXG4gICAgICB9LFxuICAgIH0sXG4gICAgY2x1c3RlcmluZzogeyBjbHVzdGVyczogdG9DbHVzdGVyQXJyYXkoKHMuY2x1c3RlcmluZyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IHVuZGVmaW5lZCk/LmNsdXN0ZXJzKSB9LFxuICAgIHBhcmFtczogeyB2YWx1ZXM6IHRvUGFyYW1zKChzLnBhcmFtcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IHVuZGVmaW5lZCk/LnZhbHVlcykgfSxcbiAgfTtcblxuICBpZiAob3V0LmNvaW5Vbml2ZXJzZS5sZW5ndGggPT09IDApIHtcbiAgICBvdXQuY29pblVuaXZlcnNlID0gWy4uLkRFRkFVTFRfU0VUVElOR1MuY29pblVuaXZlcnNlXTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIC0tLS0tLS0tLS0gTkVXOiBwdWJsaWMsIGVyZ29ub21pYyBoZWxwZXJzIC0tLS0tLS0tLS1cbi8qKiBEZWVwIHBhcnRpYWwgdHlwZSBmb3IgZXJnb25vbWljIHBhdGNoaW5nL2NyZWF0aW9uLiAqL1xuZXhwb3J0IHR5cGUgRGVlcFBhcnRpYWw8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdPzogVFtLXSBleHRlbmRzIG9iamVjdCA/IERlZXBQYXJ0aWFsPFRbS10+IDogVFtLXTtcbn07XG5cbi8qKiBOb3JtYWxpemUgY29pbnMgZnJvbSBhIHN0cmluZyAoY29tbWEvc3BhY2Utc2VwYXJhdGVkKSBvciBhcnJheTsgZW5zdXJlcyBVU0RUIHByZXNlbnQgYW5kIHVwcGVyY2FzZStkZWR1cGVkLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvaW5Vbml2ZXJzZShpbnB1dDogc3RyaW5nIHwgc3RyaW5nW10gfCB1bmtub3duKTogc3RyaW5nW10ge1xuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHJldHVybiB0b1VwcGVyQXJyYXkoaW5wdXQpO1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgcGFydHMgPSBpbnB1dC5zcGxpdCgvWyxcXHNdKy8pLm1hcChzID0+IHMudHJpbSgpKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgcmV0dXJuIHRvVXBwZXJBcnJheShwYXJ0cyk7XG4gIH1cbiAgcmV0dXJuIHRvVXBwZXJBcnJheShbXSk7XG59XG5cbi8qKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGFuIG9iamVjdCBhbHJlYWR5IGxvb2tzIGxpa2UgYW4gQXBwU2V0dGluZ3MgYWZ0ZXIgbWlncmF0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXBwU2V0dGluZ3MoeDogdW5rbm93bik6IHggaXMgQXBwU2V0dGluZ3Mge1xuICByZXR1cm4gISF4ICYmIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmIFwidmVyc2lvblwiIGluICh4IGFzIGFueSkgJiYgXCJjb2luVW5pdmVyc2VcIiBpbiAoeCBhcyBhbnkpO1xufVxuXG4vKipcbiAqIEZhY3Rvcnkg4oCUIGNyZWF0ZSBhIG5vcm1hbGl6ZWQgQXBwU2V0dGluZ3Mgb2JqZWN0LlxuICogLSBJZiB5b3UgcGFzcyBub3RoaW5nLCB5b3UgZ2V0IG1pZ3JhdGVkIERFRkFVTFRfU0VUVElOR1MuXG4gKiAtIElmIHlvdSBwYXNzIGEgZGVlcC1wYXJ0aWFsIG9yIGFueSB1bmtub3duLCBpdCBpcyBtaWdyYXRlZCBzYWZlbHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBBcHBTZXR0aW5ncyhpbnB1dD86IERlZXBQYXJ0aWFsPEFwcFNldHRpbmdzPiB8IHVua25vd24pOiBBcHBTZXR0aW5ncyB7XG4gIHJldHVybiBtaWdyYXRlU2V0dGluZ3MoaW5wdXQgPz8gREVGQVVMVF9TRVRUSU5HUyk7XG59XG5cbi8qKiBNZXJnZSBhIGJhc2UgQXBwU2V0dGluZ3Mgd2l0aCBhIGRlZXAtcGFydGlhbCBwYXRjaCwgdGhlbiBub3JtYWxpemUuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VBcHBTZXR0aW5ncyhiYXNlOiBBcHBTZXR0aW5ncywgcGF0Y2g6IERlZXBQYXJ0aWFsPEFwcFNldHRpbmdzPik6IEFwcFNldHRpbmdzIHtcbiAgLy8gc2hhbGxvdy1tZXJnZSBhdCB0b3AgbGV2ZWw7IG5lc3RlZCBvYmplY3RzIGFyZSByZS12YWxpZGF0ZWQgYnkgbWlncmF0ZVNldHRpbmdzXG4gIHJldHVybiBtaWdyYXRlU2V0dGluZ3MoeyAuLi5iYXNlLCAuLi5wYXRjaCB9KTtcbn1cbiJdLCJuYW1lcyI6WyJTRVRUSU5HU19WRVJTSU9OIiwiREVGQVVMVF9TRVRUSU5HUyIsInZlcnNpb24iLCJjb2luVW5pdmVyc2UiLCJwcm9maWxlIiwibmlja25hbWUiLCJlbWFpbCIsImJpbmFuY2VLZXlJZCIsInN0YXRzIiwiaGlzdG9ncmFtTGVuIiwiYm1EZWNpbWFscyIsImlkUGN0RGVjaW1hbHMiLCJ0aW1pbmciLCJhdXRvUmVmcmVzaCIsImF1dG9SZWZyZXNoTXMiLCJzZWNvbmRhcnlFbmFibGVkIiwic2Vjb25kYXJ5Q3ljbGVzIiwic3RyQ3ljbGVzIiwibTMwIiwiaDEiLCJoMyIsImNsdXN0ZXJpbmciLCJjbHVzdGVycyIsImlkIiwibmFtZSIsImNvaW5zIiwicGFyYW1zIiwidmFsdWVzIiwiZXRhIiwiZXBzaWxvbiIsImlvdGEiLCJ0b1VwcGVyQXJyYXkiLCJ2YWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsInNlZW4iLCJTZXQiLCJyZXN1bHQiLCJlbnRyeSIsInVwcGVyIiwiU3RyaW5nIiwidHJpbSIsInRvVXBwZXJDYXNlIiwiaGFzIiwiYWRkIiwicHVzaCIsInRvTnVtYmVyIiwiZmFsbGJhY2siLCJwYXJzZWQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImNsYW1wIiwibWluIiwibWF4IiwiTWF0aCIsInRvQ2x1c3RlckFycmF5IiwibWFwIiwiaW5kZXgiLCJvYmoiLCJ0b1BhcmFtcyIsImtleSIsInJhdyIsIk9iamVjdCIsImVudHJpZXMiLCJtaWdyYXRlU2V0dGluZ3MiLCJpbnB1dCIsInMiLCJzdGF0c1NvdXJjZSIsInRpbWluZ1NvdXJjZSIsInRpbWluZ0N5Y2xlcyIsIm91dCIsIkJvb2xlYW4iLCJsZW5ndGgiLCJub3JtYWxpemVDb2luVW5pdmVyc2UiLCJwYXJ0cyIsInNwbGl0IiwiZmlsdGVyIiwiaXNBcHBTZXR0aW5ncyIsIngiLCJBcHBTZXR0aW5ncyIsIm1lcmdlQXBwU2V0dGluZ3MiLCJiYXNlIiwicGF0Y2giXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/settings/schema.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/settings/server.ts":
/*!************************************!*\
  !*** ./src/lib/settings/server.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAll: () => (/* binding */ getAll),\n/* harmony export */   resolveCoinsFromSettings: () => (/* binding */ resolveCoinsFromSettings),\n/* harmony export */   serializeSettingsCookie: () => (/* binding */ serializeSettingsCookie),\n/* harmony export */   setAll: () => (/* binding */ setAll)\n/* harmony export */ });\n/* harmony import */ var private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! private-next-rsc-server-reference */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js\");\n/* harmony import */ var private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! private-next-rsc-action-encryption */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/server/app-render/encryption.js\");\n/* harmony import */ var private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_headers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/headers */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/api/headers.js\");\n/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./schema */ \"(rsc)/./src/lib/settings/schema.ts\");\n/* harmony import */ var _markets_pairs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../markets/pairs */ \"(rsc)/./src/lib/markets/pairs.ts\");\n/* harmony import */ var private_next_rsc_action_validate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! private-next-rsc-action-validate */ \"(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-flight-loader/action-validate.js\");\n// src/lib/settings/server.ts\n/* __next_internal_action_entry_do_not_use__ {\"00532f31c65bd9d7119874b7c000efa42c3a9e2e3a\":\"getAll\",\"00696b0d07c16ebe05246c326940d3b9133dac036c\":\"resolveCoinsFromSettings\",\"402b519d81502a95cf319ddb5b60bce32907aa6f08\":\"setAll\",\"40f9a1c8f3a3ab5d85ba51065396bf00a061db869e\":\"serializeSettingsCookie\"} */ \n\n\n\n\nconst COOKIE_KEY = \"appSettings\";\nconst LEGACY_COOKIE_KEYS = [\n    \"cp_settings_v1\"\n];\nconst ONE_YEAR = 60 * 60 * 24 * 365;\n// normalize list and guarantee USDT\nfunction normCoins(input) {\n    const arr = Array.isArray(input) ? input : [];\n    const seen = new Set();\n    const out = [];\n    for (const raw of arr){\n        const coin = (0,_markets_pairs__WEBPACK_IMPORTED_MODULE_4__.normalizeCoin)(raw);\n        if (!coin || seen.has(coin)) continue;\n        seen.add(coin);\n        out.push(coin);\n    }\n    if (!seen.has(\"USDT\")) {\n        seen.add(\"USDT\");\n        out.push(\"USDT\");\n    }\n    return out;\n}\nfunction safeParseJSON(v) {\n    if (!v) return null;\n    try {\n        return JSON.parse(v);\n    } catch  {\n        return null;\n    }\n}\nasync function getAll() {\n    const jar = await (0,next_headers__WEBPACK_IMPORTED_MODULE_2__.cookies)();\n    const raw = jar.get(COOKIE_KEY)?.value;\n    const parsed = safeParseJSON(raw);\n    const s = (0,_schema__WEBPACK_IMPORTED_MODULE_3__.migrateSettings)(parsed ?? _schema__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_SETTINGS);\n    s.coinUniverse = normCoins(s.coinUniverse);\n    return s;\n}\nasync function serializeSettingsCookie(nextValue) {\n    // Merge against current cookie so partial/stale payloads cannot wipe fields\n    const current = await getAll();\n    const merged = (0,_schema__WEBPACK_IMPORTED_MODULE_3__.migrateSettings)({\n        ...current,\n        ...nextValue\n    });\n    const normalized = {\n        ...merged,\n        coinUniverse: normCoins(merged.coinUniverse)\n    };\n    const value = JSON.stringify(normalized);\n    const cookie = {\n        name: COOKIE_KEY,\n        value,\n        options: {\n            httpOnly: false,\n            sameSite: \"lax\",\n            path: \"/\",\n            maxAge: ONE_YEAR\n        }\n    };\n    return {\n        settings: normalized,\n        cookie\n    };\n}\nasync function setAll(nextValue) {\n    const jar = await (0,next_headers__WEBPACK_IMPORTED_MODULE_2__.cookies)();\n    const { settings, cookie } = await serializeSettingsCookie(nextValue);\n    jar.set(cookie.name, cookie.value, cookie.options);\n    // cleanup legacy names\n    const mutable = jar;\n    if (mutable.delete) {\n        for (const legacy of LEGACY_COOKIE_KEYS){\n            if (legacy !== cookie.name) mutable.delete(legacy);\n        }\n    }\n    return settings;\n}\n/** Convenience: normalized coin universe from the cookie. */ async function resolveCoinsFromSettings() {\n    const s = await getAll();\n    return s.coinUniverse.length ? s.coinUniverse : normCoins(_schema__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_SETTINGS.coinUniverse);\n}\n\n(0,private_next_rsc_action_validate__WEBPACK_IMPORTED_MODULE_5__.ensureServerEntryExports)([\n    getAll,\n    serializeSettingsCookie,\n    setAll,\n    resolveCoinsFromSettings\n]);\n(0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(getAll, \"00532f31c65bd9d7119874b7c000efa42c3a9e2e3a\", null);\n(0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(serializeSettingsCookie, \"40f9a1c8f3a3ab5d85ba51065396bf00a061db869e\", null);\n(0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(setAll, \"402b519d81502a95cf319ddb5b60bce32907aa6f08\", null);\n(0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(resolveCoinsFromSettings, \"00696b0d07c16ebe05246c326940d3b9133dac036c\", null);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ozs7SUF2RHNCTjtJQVNBTztJQTJCQWM7SUFnQkFLOztBQXBEQTFCLDBGQUFBQSxDQUFBQTtBQVNBTywwRkFBQUEsQ0FBQUE7QUEyQkFjLDBGQUFBQSxDQUFBQTtBQWdCQUssMEZBQUFBLENBQUFBIiwic291cmNlcyI6WyJIOlxcVXNlcnNcXEd1c1xcc291cmNlXFxyZXBvXFxkeW5hbWljc1xcZHluYW1pY3MtYlxcY3J5cHRvcGktZHluYW1pY3NcXHNyY1xcbGliXFxzZXR0aW5nc1xcc2VydmVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9saWIvc2V0dGluZ3Mvc2VydmVyLnRzXHJcblwidXNlIHNlcnZlclwiO1xuXG5pbXBvcnQgeyBjb29raWVzIH0gZnJvbSBcIm5leHQvaGVhZGVyc1wiO1xuaW1wb3J0IHsgREVGQVVMVF9TRVRUSU5HUywgbWlncmF0ZVNldHRpbmdzLCB0eXBlIEFwcFNldHRpbmdzIH0gZnJvbSBcIi4vc2NoZW1hXCI7XG5pbXBvcnQgeyBub3JtYWxpemVDb2luIH0gZnJvbSBcIi4uL21hcmtldHMvcGFpcnNcIjtcblxuY29uc3QgQ09PS0lFX0tFWSA9IFwiYXBwU2V0dGluZ3NcIjtcbmNvbnN0IExFR0FDWV9DT09LSUVfS0VZUyA9IFtcImNwX3NldHRpbmdzX3YxXCJdO1xuY29uc3QgT05FX1lFQVIgPSA2MCAqIDYwICogMjQgKiAzNjU7XG5cbi8vIG5vcm1hbGl6ZSBsaXN0IGFuZCBndWFyYW50ZWUgVVNEVFxuZnVuY3Rpb24gbm9ybUNvaW5zKGlucHV0OiB1bmtub3duKTogc3RyaW5nW10ge1xuICBjb25zdCBhcnIgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW107XG4gIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgY29uc3Qgb3V0OiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGNvbnN0IHJhdyBvZiBhcnIpIHtcbiAgICBjb25zdCBjb2luID0gbm9ybWFsaXplQ29pbihyYXcgYXMgc3RyaW5nKTtcbiAgICBpZiAoIWNvaW4gfHwgc2Vlbi5oYXMoY29pbikpIGNvbnRpbnVlO1xuICAgIHNlZW4uYWRkKGNvaW4pO1xuICAgIG91dC5wdXNoKGNvaW4pO1xuICB9XG4gIGlmICghc2Vlbi5oYXMoXCJVU0RUXCIpKSB7XG4gICAgc2Vlbi5hZGQoXCJVU0RUXCIpO1xuICAgIG91dC5wdXNoKFwiVVNEVFwiKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBzYWZlUGFyc2VKU09OKHY6IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGwpOiBhbnkgfCBudWxsIHtcbiAgaWYgKCF2KSByZXR1cm4gbnVsbDtcbiAgdHJ5IHsgcmV0dXJuIEpTT04ucGFyc2Uodik7IH0gY2F0Y2ggeyByZXR1cm4gbnVsbDsgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsKCk6IFByb21pc2U8QXBwU2V0dGluZ3M+IHtcbiAgY29uc3QgamFyID0gYXdhaXQgY29va2llcygpO1xuICBjb25zdCByYXcgPSBqYXIuZ2V0KENPT0tJRV9LRVkpPy52YWx1ZTtcbiAgY29uc3QgcGFyc2VkID0gc2FmZVBhcnNlSlNPTihyYXcpO1xuICBjb25zdCBzID0gbWlncmF0ZVNldHRpbmdzKHBhcnNlZCA/PyBERUZBVUxUX1NFVFRJTkdTKTtcbiAgcy5jb2luVW5pdmVyc2UgPSBub3JtQ29pbnMocy5jb2luVW5pdmVyc2UpO1xuICByZXR1cm4gcztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlcmlhbGl6ZVNldHRpbmdzQ29va2llKG5leHRWYWx1ZTogdW5rbm93bik6IFByb21pc2U8e1xuICBzZXR0aW5nczogQXBwU2V0dGluZ3M7XG4gIGNvb2tpZTogeyBuYW1lOiBzdHJpbmc7IHZhbHVlOiBzdHJpbmc7IG9wdGlvbnM6IFBhcmFtZXRlcnM8QXdhaXRlZDxSZXR1cm5UeXBlPHR5cGVvZiBjb29raWVzPj5bXCJzZXRcIl0+WzJdIH07XG59PiB7XG4gIC8vIE1lcmdlIGFnYWluc3QgY3VycmVudCBjb29raWUgc28gcGFydGlhbC9zdGFsZSBwYXlsb2FkcyBjYW5ub3Qgd2lwZSBmaWVsZHNcbiAgY29uc3QgY3VycmVudCA9IGF3YWl0IGdldEFsbCgpO1xuICBjb25zdCBtZXJnZWQgPSBtaWdyYXRlU2V0dGluZ3MoeyAuLi5jdXJyZW50LCAuLi4obmV4dFZhbHVlIGFzIGFueSkgfSk7XG5cbiAgY29uc3Qgbm9ybWFsaXplZDogQXBwU2V0dGluZ3MgPSB7XG4gICAgLi4ubWVyZ2VkLFxuICAgIGNvaW5Vbml2ZXJzZTogbm9ybUNvaW5zKG1lcmdlZC5jb2luVW5pdmVyc2UpLFxuICB9O1xuXG4gIGNvbnN0IHZhbHVlID0gSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZCk7XG4gIGNvbnN0IGNvb2tpZSA9IHtcbiAgICBuYW1lOiBDT09LSUVfS0VZLFxuICAgIHZhbHVlLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGh0dHBPbmx5OiBmYWxzZSxcbiAgICAgIHNhbWVTaXRlOiBcImxheFwiIGFzIGNvbnN0LFxuICAgICAgcGF0aDogXCIvXCIsXG4gICAgICBtYXhBZ2U6IE9ORV9ZRUFSLFxuICAgIH0sXG4gIH07XG4gIHJldHVybiB7IHNldHRpbmdzOiBub3JtYWxpemVkLCBjb29raWUgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldEFsbChuZXh0VmFsdWU6IHVua25vd24pOiBQcm9taXNlPEFwcFNldHRpbmdzPiB7XG4gIGNvbnN0IGphciA9IGF3YWl0IGNvb2tpZXMoKTtcbiAgY29uc3QgeyBzZXR0aW5ncywgY29va2llIH0gPSBhd2FpdCBzZXJpYWxpemVTZXR0aW5nc0Nvb2tpZShuZXh0VmFsdWUpO1xuICBqYXIuc2V0KGNvb2tpZS5uYW1lLCBjb29raWUudmFsdWUsIGNvb2tpZS5vcHRpb25zKTtcblxuICAvLyBjbGVhbnVwIGxlZ2FjeSBuYW1lc1xuICBjb25zdCBtdXRhYmxlID0gamFyIGFzIHVua25vd24gYXMgeyBkZWxldGU/OiAobmFtZTogc3RyaW5nKSA9PiB2b2lkIH07XG4gIGlmIChtdXRhYmxlLmRlbGV0ZSkge1xuICAgIGZvciAoY29uc3QgbGVnYWN5IG9mIExFR0FDWV9DT09LSUVfS0VZUykge1xuICAgICAgaWYgKGxlZ2FjeSAhPT0gY29va2llLm5hbWUpIG11dGFibGUuZGVsZXRlKGxlZ2FjeSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXR0aW5ncztcbn1cblxuLyoqIENvbnZlbmllbmNlOiBub3JtYWxpemVkIGNvaW4gdW5pdmVyc2UgZnJvbSB0aGUgY29va2llLiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVDb2luc0Zyb21TZXR0aW5ncygpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIGNvbnN0IHMgPSBhd2FpdCBnZXRBbGwoKTtcbiAgcmV0dXJuIHMuY29pblVuaXZlcnNlLmxlbmd0aCA/IHMuY29pblVuaXZlcnNlIDogbm9ybUNvaW5zKERFRkFVTFRfU0VUVElOR1MuY29pblVuaXZlcnNlKTtcbn1cbiJdLCJuYW1lcyI6WyJjb29raWVzIiwiREVGQVVMVF9TRVRUSU5HUyIsIm1pZ3JhdGVTZXR0aW5ncyIsIm5vcm1hbGl6ZUNvaW4iLCJDT09LSUVfS0VZIiwiTEVHQUNZX0NPT0tJRV9LRVlTIiwiT05FX1lFQVIiLCJub3JtQ29pbnMiLCJpbnB1dCIsImFyciIsIkFycmF5IiwiaXNBcnJheSIsInNlZW4iLCJTZXQiLCJvdXQiLCJyYXciLCJjb2luIiwiaGFzIiwiYWRkIiwicHVzaCIsInNhZmVQYXJzZUpTT04iLCJ2IiwiSlNPTiIsInBhcnNlIiwiZ2V0QWxsIiwiamFyIiwiZ2V0IiwidmFsdWUiLCJwYXJzZWQiLCJzIiwiY29pblVuaXZlcnNlIiwic2VyaWFsaXplU2V0dGluZ3NDb29raWUiLCJuZXh0VmFsdWUiLCJjdXJyZW50IiwibWVyZ2VkIiwibm9ybWFsaXplZCIsInN0cmluZ2lmeSIsImNvb2tpZSIsIm5hbWUiLCJvcHRpb25zIiwiaHR0cE9ubHkiLCJzYW1lU2l0ZSIsInBhdGgiLCJtYXhBZ2UiLCJzZXR0aW5ncyIsInNldEFsbCIsInNldCIsIm11dGFibGUiLCJkZWxldGUiLCJsZWdhY3kiLCJyZXNvbHZlQ29pbnNGcm9tU2V0dGluZ3MiLCJsZW5ndGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/settings/server.ts\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!**************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \**************************************************************************************************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "../app-render/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/server/app-render/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/action-async-storage.external.js");

/***/ }),

/***/ "../app-render/after-task-async-storage.external":
/*!***********************************************************************************!*\
  !*** external "next/dist/server/app-render/after-task-async-storage.external.js" ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ "../app-render/work-async-storage.external":
/*!*****************************************************************************!*\
  !*** external "next/dist/server/app-render/work-async-storage.external.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ "../app-render/work-unit-async-storage.external":
/*!**********************************************************************************!*\
  !*** external "next/dist/server/app-render/work-unit-async-storage.external.js" ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ "module":
/*!*************************!*\
  !*** external "module" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("module");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "next/dist/shared/lib/no-fallback-error.external":
/*!******************************************************************!*\
  !*** external "next/dist/shared/lib/no-fallback-error.external" ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/no-fallback-error.external");

/***/ }),

/***/ "next/dist/shared/lib/router/utils/app-paths":
/*!**************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/app-paths" ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/app-paths");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5"], () => (__webpack_exec__("(rsc)/./node_modules/.pnpm/next@15.5.2_@playwright+tes_b7e6c280e9a1b4309347c0bf0ab476d5/node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fstr-aux%2Fstats%2Froute&page=%2Fapi%2Fstr-aux%2Fstats%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fstr-aux%2Fstats%2Froute.ts&appDir=H%3A%5CUsers%5CGus%5Csource%5Crepo%5Cdynamics%5Cdynamics-b%5Ccryptopi-dynamics%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=H%3A%5CUsers%5CGus%5Csource%5Crepo%5Cdynamics%5Cdynamics-b%5Ccryptopi-dynamics&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!")));
module.exports = __webpack_exports__;

})();