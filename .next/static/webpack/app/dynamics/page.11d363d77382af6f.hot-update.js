"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dynamics/page",{

/***/ "(app-pages-browser)/./src/app/matrices/colouring.ts":
/*!***************************************!*\
  !*** ./src/app/matrices/colouring.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FROZEN_RING_COLORS: () => (/* binding */ FROZEN_RING_COLORS),\n/* harmony export */   FROZEN_STAGE_BACKGROUNDS: () => (/* binding */ FROZEN_STAGE_BACKGROUNDS),\n/* harmony export */   MOO_NEGATIVE_SHADES: () => (/* binding */ MOO_NEGATIVE_SHADES),\n/* harmony export */   MOO_POSITIVE_SHADES: () => (/* binding */ MOO_POSITIVE_SHADES),\n/* harmony export */   MUTED_BACKGROUND: () => (/* binding */ MUTED_BACKGROUND),\n/* harmony export */   NEGATIVE_SHADES: () => (/* binding */ NEGATIVE_SHADES),\n/* harmony export */   POSITIVE_SHADES: () => (/* binding */ POSITIVE_SHADES),\n/* harmony export */   PREVIEW_RING_COLORS: () => (/* binding */ PREVIEW_RING_COLORS),\n/* harmony export */   SIGN_FLIP_RING_COLORS: () => (/* binding */ SIGN_FLIP_RING_COLORS),\n/* harmony export */   ZERO_BACKGROUND: () => (/* binding */ ZERO_BACKGROUND),\n/* harmony export */   loadPreviewSymbolSet: () => (/* binding */ loadPreviewSymbolSet),\n/* harmony export */   resolveCellPresentation: () => (/* binding */ resolveCellPresentation)\n/* harmony export */ });\n/* harmony import */ var _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/features/matrices/colors */ \"(app-pages-browser)/./src/components/features/matrices/colors.ts\");\n/* harmony import */ var _lib_preview__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/preview */ \"(app-pages-browser)/./src/lib/preview.ts\");\n\n\nconst POSITIVE_SHADES = _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_POSITIVE_SHADES;\nconst NEGATIVE_SHADES = _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_NEGATIVE_SHADES;\nconst MOO_POSITIVE_SHADES = _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_MOO_POSITIVE_SHADES;\nconst MOO_NEGATIVE_SHADES = _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_MOO_NEGATIVE_SHADES;\nconst ZERO_BACKGROUND = (0,_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.withAlpha)(_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_AMBER, 0.32);\nconst MUTED_BACKGROUND = (0,_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.withAlpha)(_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_MUTED, 0.28);\nconst FROZEN_STAGE_BACKGROUNDS = {\n    recent: (0,_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.withAlpha)(_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS.recent, 0.42),\n    mid: (0,_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.withAlpha)(_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS.mid, 0.5),\n    long: (0,_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.withAlpha)(_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS.long, 0.62)\n};\nconst PREVIEW_RING_COLORS = {\n    direct: \"#34d399\",\n    inverse: \"#f87171\",\n    missing: \"#94a3b8\",\n    frozen: _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_FROZEN\n};\nconst FROZEN_RING_COLORS = {\n    recent: _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS.recent,\n    mid: _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS.mid,\n    long: _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS.long\n};\nconst SIGN_FLIP_RING_COLORS = {\n    minusToPlus: \"#38bdf8\",\n    plusToMinus: \"#fb923c\"\n};\nconst makeSet = (values)=>{\n    const out = new Set();\n    for (const value of values){\n        out.add(String(value !== null && value !== void 0 ? value : \"\").toUpperCase());\n    }\n    return out;\n};\nconst hasSymbol = (set, symbol)=>{\n    if (!set) return false;\n    return set.has(String(symbol !== null && symbol !== void 0 ? symbol : \"\").toUpperCase());\n};\nconst clampPaletteIndex = (idx, palette)=>{\n    if (!palette.length) return 0;\n    if (idx < 0) return palette.length - 1;\n    if (idx >= palette.length) return palette.length - 1;\n    return idx;\n};\nfunction resolveBaseRingColor(param) {\n    let { frozen, frozenStage, ringStrategy, directSymbol, inverseSymbol, symbolSets } = param;\n    if (frozen) {\n        if (frozenStage) return _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS[frozenStage];\n        return PREVIEW_RING_COLORS.frozen;\n    }\n    if (ringStrategy === \"none\") return null;\n    const hasDirect = hasSymbol(symbolSets.preview, directSymbol) || hasSymbol(symbolSets.payload, directSymbol);\n    if (hasDirect) return PREVIEW_RING_COLORS.direct;\n    const hasInverse = hasSymbol(symbolSets.preview, inverseSymbol) || hasSymbol(symbolSets.payload, inverseSymbol);\n    if (hasInverse) return PREVIEW_RING_COLORS.inverse;\n    return PREVIEW_RING_COLORS.missing;\n}\nfunction detectSignFlip(param) {\n    let { ringStrategy, frozen, current, previous } = param;\n    if (ringStrategy !== \"sign-flip\" || frozen) return null;\n    if (current == null || previous == null) return null;\n    if (!Number.isFinite(current) || !Number.isFinite(previous)) return null;\n    const prevSign = Math.sign(previous);\n    const currSign = Math.sign(current);\n    if (prevSign > 0 && currSign < 0) return \"plusToMinus\";\n    if (prevSign < 0 && currSign > 0) return \"minusToPlus\";\n    return null;\n}\nfunction resolveCellPresentation(param) {\n    let { rules, value, prevValue, frozen, frozenStage = null, directSymbol, inverseSymbol, symbolSets } = param;\n    const sanitize = (input)=>{\n        if (input == null) return null;\n        const num = Number(input);\n        if (!Number.isFinite(num)) return null;\n        if (Math.abs(num) <= _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.NULL_SENSITIVITY) return null;\n        return num;\n    };\n    var _rules_positivePalette;\n    const palettePositive = (_rules_positivePalette = rules.positivePalette) !== null && _rules_positivePalette !== void 0 ? _rules_positivePalette : POSITIVE_SHADES;\n    var _rules_negativePalette;\n    const paletteNegative = (_rules_negativePalette = rules.negativePalette) !== null && _rules_negativePalette !== void 0 ? _rules_negativePalette : NEGATIVE_SHADES;\n    const normalizedValue = sanitize(value);\n    const derived = rules.derive(normalizedValue);\n    const normalizedPrev = prevValue === undefined ? null : sanitize(prevValue !== null && prevValue !== void 0 ? prevValue : null);\n    const previousDerived = prevValue === undefined ? null : rules.derive(normalizedPrev);\n    let polarity = \"neutral\";\n    let background = normalizedValue == null ? ZERO_BACKGROUND : MUTED_BACKGROUND;\n    let textColor;\n    const effectiveStage = frozenStage !== null && frozenStage !== void 0 ? frozenStage : frozen ? \"mid\" : null;\n    if (frozen || effectiveStage) {\n        const stage = effectiveStage !== null && effectiveStage !== void 0 ? effectiveStage : \"mid\";\n        background = FROZEN_STAGE_BACKGROUNDS[stage];\n        textColor = stage === \"long\" ? \"#ede9fe\" : \"#20103f\";\n    } else if (derived != null && Number.isFinite(derived)) {\n        const abs = Math.abs(derived);\n        if (abs < rules.zeroFloor) {\n            background = ZERO_BACKGROUND;\n            textColor = \"#422006\";\n        } else {\n            const idx = rules.thresholds.findIndex((t)=>abs < t);\n            const palette = derived >= 0 ? palettePositive : paletteNegative;\n            const paletteIndex = clampPaletteIndex(idx === -1 ? palette.length - 1 : idx, palette);\n            var _palette_paletteIndex, _ref;\n            const hex = (_ref = (_palette_paletteIndex = palette[paletteIndex]) !== null && _palette_paletteIndex !== void 0 ? _palette_paletteIndex : palette[palette.length - 1]) !== null && _ref !== void 0 ? _ref : \"#0f172a\";\n            background = (0,_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.withAlpha)(hex, 0.85);\n            polarity = derived >= 0 ? \"positive\" : \"negative\";\n        }\n    } else {\n        background = MUTED_BACKGROUND;\n    }\n    const ringColor = resolveBaseRingColor({\n        frozen,\n        frozenStage: effectiveStage,\n        ringStrategy: rules.ringStrategy,\n        directSymbol,\n        inverseSymbol,\n        symbolSets\n    });\n    const signFlip = detectSignFlip({\n        ringStrategy: rules.ringStrategy,\n        frozen,\n        current: derived,\n        previous: previousDerived\n    });\n    let finalRing = ringColor;\n    if (signFlip === \"plusToMinus\") {\n        finalRing = SIGN_FLIP_RING_COLORS.plusToMinus;\n    } else if (signFlip === \"minusToPlus\") {\n        finalRing = SIGN_FLIP_RING_COLORS.minusToPlus;\n    }\n    return {\n        background,\n        polarity,\n        textColor,\n        ringColor: finalRing,\n        derived,\n        signFlip,\n        frozenStage: effectiveStage\n    };\n}\nasync function loadPreviewSymbolSet(coins) {\n    const normalized = coins.map((coin)=>String(coin !== null && coin !== void 0 ? coin : \"\").toUpperCase());\n    const { symbols, source } = await (0,_lib_preview__WEBPACK_IMPORTED_MODULE_1__.getPreviewSymbols)(normalized);\n    const normalizedSymbols = symbols.map((sym)=>String(sym !== null && sym !== void 0 ? sym : \"\").toUpperCase());\n    return {\n        symbols: normalizedSymbols,\n        set: makeSet(normalizedSymbols),\n        source\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvbWF0cmljZXMvY29sb3VyaW5nLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBYStDO0FBQ3VCO0FBd0IvRCxNQUFNVyxrQkFBa0JQLHVGQUFxQkEsQ0FBQztBQUM5QyxNQUFNUSxrQkFBa0JULHVGQUFxQkEsQ0FBQztBQUM5QyxNQUFNVSxzQkFBc0JQLDJGQUF5QkEsQ0FBQztBQUN0RCxNQUFNUSxzQkFBc0JULDJGQUF5QkEsQ0FBQztBQUV0RCxNQUFNVSxrQkFBa0JOLCtFQUFTQSxDQUFDVCw2RUFBV0EsRUFBRSxNQUFNO0FBQ3JELE1BQU1nQixtQkFBbUJQLCtFQUFTQSxDQUFDUCw2RUFBV0EsRUFBRSxNQUFNO0FBQ3RELE1BQU1lLDJCQUF3RDtJQUNuRUMsUUFBUVQsK0VBQVNBLENBQUNELHFGQUFtQkEsQ0FBQ1UsTUFBTSxFQUFFO0lBQzlDQyxLQUFLViwrRUFBU0EsQ0FBQ0QscUZBQW1CQSxDQUFDVyxHQUFHLEVBQUU7SUFDeENDLE1BQU1YLCtFQUFTQSxDQUFDRCxxRkFBbUJBLENBQUNZLElBQUksRUFBRTtBQUM1QyxFQUFFO0FBRUssTUFBTUMsc0JBQXNCO0lBQ2pDQyxRQUFRO0lBQ1JDLFNBQVM7SUFDVEMsU0FBUztJQUNUQyxRQUFReEIsOEVBQVlBO0FBQ3RCLEVBQVc7QUFFSixNQUFNeUIscUJBQWtEO0lBQzdEUixRQUFRVixxRkFBbUJBLENBQUNVLE1BQU07SUFDbENDLEtBQUtYLHFGQUFtQkEsQ0FBQ1csR0FBRztJQUM1QkMsTUFBTVoscUZBQW1CQSxDQUFDWSxJQUFJO0FBQ2hDLEVBQUU7QUFFSyxNQUFNTyx3QkFBd0I7SUFDbkNDLGFBQWE7SUFDYkMsYUFBYTtBQUNmLEVBQVc7QUFPWCxNQUFNQyxVQUFVLENBQUNDO0lBQ2YsTUFBTUMsTUFBTSxJQUFJQztJQUNoQixLQUFLLE1BQU1DLFNBQVNILE9BQVE7UUFDMUJDLElBQUlHLEdBQUcsQ0FBQ0MsT0FBT0Ysa0JBQUFBLG1C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QztJQUNGLE9BQU87UUFDTE0sYUFBYW5FO0lBQ2Y7SUFFQSxNQUFNNkUsWUFBWS9DLHFCQUFxQjtRQUNyQ3JCO1FBQ0FzQixhQUFhc0M7UUFDYnJDLGNBQWNrQixNQUFNbEIsWUFBWTtRQUNoQ0M7UUFDQUM7UUFDQUM7SUFDRjtJQUVBLE1BQU0yQyxXQUFXdEMsZUFBZTtRQUM5QlIsY0FBY2tCLE1BQU1sQixZQUFZO1FBQ2hDdkI7UUFDQWdDLFNBQVNvQjtRQUNUbkIsVUFBVXVCO0lBQ1o7SUFFQSxJQUFJYyxZQUFZRjtJQUNoQixJQUFJQyxhQUFhLGVBQWU7UUFDOUJDLFlBQVlwRSxzQkFBc0JFLFdBQVc7SUFDL0MsT0FBTyxJQUFJaUUsYUFBYSxlQUFlO1FBQ3JDQyxZQUFZcEUsc0JBQXNCQyxXQUFXO0lBQy9DO0lBRUEsT0FBTztRQUNMdUQ7UUFDQUQ7UUFDQUU7UUFDQVMsV0FBV0U7UUFDWGxCO1FBQ0FpQjtRQUNBL0MsYUFBYXNDO0lBQ2Y7QUFDRjtBQUVPLGVBQWVXLHFCQUNwQkMsS0FBZTtJQUVmLE1BQU1DLGFBQWFELE1BQU1FLEdBQUcsQ0FBQyxDQUFDQyxPQUFTaEUsT0FBT2dFLGlCQUFBQSxrQkFBQUEsT0FBUSxJQUFJL0QsV0FBVztJQUNyRSxNQUFNLEVBQUVnRSxPQUFPLEVBQUVDLE1BQU0sRUFBRSxHQUFHLE1BQU01RiwrREFBaUJBLENBQUN3RjtJQUNwRCxNQUFNSyxvQkFBb0JGLFFBQVFGLEdBQUcsQ0FBQyxDQUFDSyxNQUFRcEUsT0FBT29FLGdCQUFBQSxpQkFBQUEsTUFBTyxJQUFJbkUsV0FBVztJQUM1RSxPQUFPO1FBQ0xnRSxTQUFTRTtRQUNUaEUsS0FBS1QsUUFBUXlFO1FBQ2JEO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiSDpcXFVzZXJzXFxHdXNcXHNvdXJjZVxccmVwb1xcZHluYW1pY3NcXGR5bmFtaWNzLWJcXGNyeXB0b3BpLWR5bmFtaWNzXFxzcmNcXGFwcFxcbWF0cmljZXNcXGNvbG91cmluZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE1hdHJpeENlbGwgfSBmcm9tIFwiQC9jb21wb25lbnRzL2ZlYXR1cmVzL21hdHJpY2VzL01hdHJpeFwiO1xuaW1wb3J0IHtcbiAgQ09MT1JfQU1CRVIsXG4gIENPTE9SX0ZST1pFTixcbiAgQ09MT1JfTVVURUQsXG4gIENPTE9SX05FR0FUSVZFX1NIQURFUyxcbiAgQ09MT1JfUE9TSVRJVkVfU0hBREVTLFxuICBDT0xPUl9NT09fTkVHQVRJVkVfU0hBREVTLFxuICBDT0xPUl9NT09fUE9TSVRJVkVfU0hBREVTLFxuICBOVUxMX1NFTlNJVElWSVRZLFxuICBGUk9aRU5fU1RBR0VfQ09MT1JTLFxuICB0eXBlIEZyb3plblN0YWdlLFxuICB3aXRoQWxwaGEsXG59IGZyb20gXCJAL2NvbXBvbmVudHMvZmVhdHVyZXMvbWF0cmljZXMvY29sb3JzXCI7XG5pbXBvcnQgeyBnZXRQcmV2aWV3U3ltYm9scywgdHlwZSBQcmV2aWV3U291cmNlIH0gZnJvbSBcIkAvbGliL3ByZXZpZXdcIjtcblxuZXhwb3J0IHR5cGUgUmluZ1N0cmF0ZWd5ID0gXCJwcmV2aWV3XCIgfCBcInNpZ24tZmxpcFwiIHwgXCJub25lXCI7XG5cbmV4cG9ydCB0eXBlIE1hdHJpeENvbG9yUnVsZXMgPSB7XG4gIGtleTogc3RyaW5nO1xuICB0aHJlc2hvbGRzOiByZWFkb25seSBudW1iZXJbXTtcbiAgcG9zaXRpdmVQYWxldHRlPzogcmVhZG9ubHkgc3RyaW5nW107XG4gIG5lZ2F0aXZlUGFsZXR0ZT86IHJlYWRvbmx5IHN0cmluZ1tdO1xuICB6ZXJvRmxvb3I6IG51bWJlcjtcbiAgZGVyaXZlOiAodmFsdWU6IG51bWJlciB8IG51bGwpID0+IG51bWJlciB8IG51bGw7XG4gIHJpbmdTdHJhdGVneTogUmluZ1N0cmF0ZWd5O1xufTtcblxuZXhwb3J0IHR5cGUgQ2VsbFByZXNlbnRhdGlvbiA9IHtcbiAgYmFja2dyb3VuZDogc3RyaW5nO1xuICBwb2xhcml0eTogTWF0cml4Q2VsbFtcInBvbGFyaXR5XCJdO1xuICB0ZXh0Q29sb3I/OiBzdHJpbmc7XG4gIHJpbmdDb2xvcjogc3RyaW5nIHwgbnVsbDtcbiAgZGVyaXZlZDogbnVtYmVyIHwgbnVsbDtcbiAgc2lnbkZsaXA6IFwicGx1c1RvTWludXNcIiB8IFwibWludXNUb1BsdXNcIiB8IG51bGw7XG4gIGZyb3plblN0YWdlOiBGcm96ZW5TdGFnZSB8IG51bGw7XG59O1xuXG5leHBvcnQgY29uc3QgUE9TSVRJVkVfU0hBREVTID0gQ09MT1JfUE9TSVRJVkVfU0hBREVTO1xuZXhwb3J0IGNvbnN0IE5FR0FUSVZFX1NIQURFUyA9IENPTE9SX05FR0FUSVZFX1NIQURFUztcbmV4cG9ydCBjb25zdCBNT09fUE9TSVRJVkVfU0hBREVTID0gQ09MT1JfTU9PX1BPU0lUSVZFX1NIQURFUztcbmV4cG9ydCBjb25zdCBNT09fTkVHQVRJVkVfU0hBREVTID0gQ09MT1JfTU9PX05FR0FUSVZFX1NIQURFUztcblxuZXhwb3J0IGNvbnN0IFpFUk9fQkFDS0dST1VORCA9IHdpdGhBbHBoYShDT0xPUl9BTUJFUiwgMC4zMik7XG5leHBvcnQgY29uc3QgTVVURURfQkFDS0dST1VORCA9IHdpdGhBbHBoYShDT0xPUl9NVVRFRCwgMC4yOCk7XG5leHBvcnQgY29uc3QgRlJPWkVOX1NUQUdFX0JBQ0tHUk9VTkRTOiBSZWNvcmQ8RnJvemVuU3RhZ2UsIHN0cmluZz4gPSB7XG4gIHJlY2VudDogd2l0aEFscGhhKEZST1pFTl9TVEFHRV9DT0xPUlMucmVjZW50LCAwLjQyKSxcbiAgbWlkOiB3aXRoQWxwaGEoRlJPWkVOX1NUQUdFX0NPTE9SUy5taWQsIDAuNSksXG4gIGxvbmc6IHdpdGhBbHBoYShGUk9aRU5fU1RBR0VfQ09MT1JTLmxvbmcsIDAuNjIpLFxufTtcblxuZXhwb3J0IGNvbnN0IFBSRVZJRVdfUklOR19DT0xPUlMgPSB7XG4gIGRpcmVjdDogXCIjMzRkMzk5XCIsXG4gIGludmVyc2U6IFwiI2Y4NzE3MVwiLFxuICBtaXNzaW5nOiBcIiM5NGEzYjhcIixcbiAgZnJvemVuOiBDT0xPUl9GUk9aRU4sXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgRlJPWkVOX1JJTkdfQ09MT1JTOiBSZWNvcmQ8RnJvemVuU3RhZ2UsIHN0cmluZz4gPSB7XG4gIHJlY2VudDogRlJPWkVOX1NUQUdFX0NPTE9SUy5yZWNlbnQsXG4gIG1pZDogRlJPWkVOX1NUQUdFX0NPTE9SUy5taWQsXG4gIGxvbmc6IEZST1pFTl9TVEFHRV9DT0xPUlMubG9uZyxcbn07XG5cbmV4cG9ydCBjb25zdCBTSUdOX0ZMSVBfUklOR19DT0xPUlMgPSB7XG4gIG1pbnVzVG9QbHVzOiBcIiMzOGJkZjhcIixcbiAgcGx1c1RvTWludXM6IFwiI2ZiOTIzY1wiLFxufSBhcyBjb25zdDtcblxudHlwZSBTeW1ib2xTZXRzID0ge1xuICBwcmV2aWV3OiBTZXQ8c3RyaW5nPjtcbiAgcGF5bG9hZD86IFNldDxzdHJpbmc+O1xufTtcblxuY29uc3QgbWFrZVNldCA9ICh2YWx1ZXM6IEl0ZXJhYmxlPHN0cmluZz4pOiBTZXQ8c3RyaW5nPiA9PiB7XG4gIGNvbnN0IG91dCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgIG91dC5hZGQoU3RyaW5nKHZhbHVlID8/IFwiXCIpLnRvVXBwZXJDYXNlKCkpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG5jb25zdCBoYXNTeW1ib2wgPSAoc2V0OiBTZXQ8c3RyaW5nPiB8IHVuZGVmaW5lZCwgc3ltYm9sOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgaWYgKCFzZXQpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHNldC5oYXMoU3RyaW5nKHN5bWJvbCA/PyBcIlwiKS50b1VwcGVyQ2FzZSgpKTtcbn07XG5cbmNvbnN0IGNsYW1wUGFsZXR0ZUluZGV4ID0gKGlkeDogbnVtYmVyLCBwYWxldHRlOiByZWFkb25seSBzdHJpbmdbXSk6IG51bWJlciA9PiB7XG4gIGlmICghcGFsZXR0ZS5sZW5ndGgpIHJldHVybiAwO1xuICBpZiAoaWR4IDwgMCkgcmV0dXJuIHBhbGV0dGUubGVuZ3RoIC0gMTtcbiAgaWYgKGlkeCA+PSBwYWxldHRlLmxlbmd0aCkgcmV0dXJuIHBhbGV0dGUubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIGlkeDtcbn07XG5cbmZ1bmN0aW9uIHJlc29sdmVCYXNlUmluZ0NvbG9yKHtcbiAgZnJvemVuLFxuICBmcm96ZW5TdGFnZSxcbiAgcmluZ1N0cmF0ZWd5LFxuICBkaXJlY3RTeW1ib2wsXG4gIGludmVyc2VTeW1ib2wsXG4gIHN5bWJvbFNldHMsXG59OiB7XG4gIGZyb3plbjogYm9vbGVhbjtcbiAgZnJvemVuU3RhZ2U6IEZyb3plblN0YWdlIHwgbnVsbDtcbiAgcmluZ1N0cmF0ZWd5OiBSaW5nU3RyYXRlZ3k7XG4gIGRpcmVjdFN5bWJvbDogc3RyaW5nO1xuICBpbnZlcnNlU3ltYm9sOiBzdHJpbmc7XG4gIHN5bWJvbFNldHM6IFN5bWJvbFNldHM7XG59KTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmIChmcm96ZW4pIHtcbiAgICBpZiAoZnJvemVuU3RhZ2UpIHJldHVybiBGUk9aRU5fU1RBR0VfQ09MT1JTW2Zyb3plblN0YWdlXTtcbiAgICByZXR1cm4gUFJFVklFV19SSU5HX0NPTE9SUy5mcm96ZW47XG4gIH1cbiAgaWYgKHJpbmdTdHJhdGVneSA9PT0gXCJub25lXCIpIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IGhhc0RpcmVjdCA9IGhhc1N5bWJvbChzeW1ib2xTZXRzLnByZXZpZXcsIGRpcmVjdFN5bWJvbCkgfHwgaGFzU3ltYm9sKHN5bWJvbFNldHMucGF5bG9hZCwgZGlyZWN0U3ltYm9sKTtcbiAgaWYgKGhhc0RpcmVjdCkgcmV0dXJuIFBSRVZJRVdfUklOR19DT0xPUlMuZGlyZWN0O1xuXG4gIGNvbnN0IGhhc0ludmVyc2UgPSBoYXNTeW1ib2woc3ltYm9sU2V0cy5wcmV2aWV3LCBpbnZlcnNlU3ltYm9sKSB8fCBoYXNTeW1ib2woc3ltYm9sU2V0cy5wYXlsb2FkLCBpbnZlcnNlU3ltYm9sKTtcbiAgaWYgKGhhc0ludmVyc2UpIHJldHVybiBQUkVWSUVXX1JJTkdfQ09MT1JTLmludmVyc2U7XG5cbiAgcmV0dXJuIFBSRVZJRVdfUklOR19DT0xPUlMubWlzc2luZztcbn1cblxuZnVuY3Rpb24gZGV0ZWN0U2lnbkZsaXAoe1xuICByaW5nU3RyYXRlZ3ksXG4gIGZyb3plbixcbiAgY3VycmVudCxcbiAgcHJldmlvdXMsXG59OiB7XG4gIHJpbmdTdHJhdGVneTogUmluZ1N0cmF0ZWd5O1xuICBmcm96ZW46IGJvb2xlYW47XG4gIGN1cnJlbnQ6IG51bWJlciB8IG51bGw7XG4gIHByZXZpb3VzOiBudW1iZXIgfCBudWxsO1xufSk6IFwicGx1c1RvTWludXNcIiB8IFwibWludXNUb1BsdXNcIiB8IG51bGwge1xuICBpZiAocmluZ1N0cmF0ZWd5ICE9PSBcInNpZ24tZmxpcFwiIHx8IGZyb3plbikgcmV0dXJuIG51bGw7XG4gIGlmIChjdXJyZW50ID09IG51bGwgfHwgcHJldmlvdXMgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGN1cnJlbnQpIHx8ICFOdW1iZXIuaXNGaW5pdGUocHJldmlvdXMpKSByZXR1cm4gbnVsbDtcblxuICBjb25zdCBwcmV2U2lnbiA9IE1hdGguc2lnbihwcmV2aW91cyk7XG4gIGNvbnN0IGN1cnJTaWduID0gTWF0aC5zaWduKGN1cnJlbnQpO1xuICBpZiAocHJldlNpZ24gPiAwICYmIGN1cnJTaWduIDwgMCkgcmV0dXJuIFwicGx1c1RvTWludXNcIjtcbiAgaWYgKHByZXZTaWduIDwgMCAmJiBjdXJyU2lnbiA+IDApIHJldHVybiBcIm1pbnVzVG9QbHVzXCI7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUNlbGxQcmVzZW50YXRpb24oe1xuICBydWxlcyxcbiAgdmFsdWUsXG4gIHByZXZWYWx1ZSxcbiAgZnJvemVuLFxuICBmcm96ZW5TdGFnZSA9IG51bGwsXG4gIGRpcmVjdFN5bWJvbCxcbiAgaW52ZXJzZVN5bWJvbCxcbiAgc3ltYm9sU2V0cyxcbn06IHtcbiAgcnVsZXM6IE1hdHJpeENvbG9yUnVsZXM7XG4gIHZhbHVlOiBudW1iZXIgfCBudWxsO1xuICBwcmV2VmFsdWU/OiBudW1iZXIgfCBudWxsO1xuICBmcm96ZW46IGJvb2xlYW47XG4gIGZyb3plblN0YWdlPzogRnJvemVuU3RhZ2UgfCBudWxsO1xuICBkaXJlY3RTeW1ib2w6IHN0cmluZztcbiAgaW52ZXJzZVN5bWJvbDogc3RyaW5nO1xuICBzeW1ib2xTZXRzOiBTeW1ib2xTZXRzO1xufSk6IENlbGxQcmVzZW50YXRpb24ge1xuICBjb25zdCBzYW5pdGl6ZSA9IChpbnB1dDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCk6IG51bWJlciB8IG51bGwgPT4ge1xuICAgIGlmIChpbnB1dCA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBudW0gPSBOdW1iZXIoaW5wdXQpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG51bSkpIHJldHVybiBudWxsO1xuICAgIGlmIChNYXRoLmFicyhudW0pIDw9IE5VTExfU0VOU0lUSVZJVFkpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgY29uc3QgcGFsZXR0ZVBvc2l0aXZlID0gcnVsZXMucG9zaXRpdmVQYWxldHRlID8/IFBPU0lUSVZFX1NIQURFUztcbiAgY29uc3QgcGFsZXR0ZU5lZ2F0aXZlID0gcnVsZXMubmVnYXRpdmVQYWxldHRlID8/IE5FR0FUSVZFX1NIQURFUztcbiAgY29uc3Qgbm9ybWFsaXplZFZhbHVlID0gc2FuaXRpemUodmFsdWUpO1xuICBjb25zdCBkZXJpdmVkID0gcnVsZXMuZGVyaXZlKG5vcm1hbGl6ZWRWYWx1ZSk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRQcmV2ID0gcHJldlZhbHVlID09PSB1bmRlZmluZWQgPyBudWxsIDogc2FuaXRpemUocHJldlZhbHVlID8/IG51bGwpO1xuICBjb25zdCBwcmV2aW91c0Rlcml2ZWQgPSBwcmV2VmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBydWxlcy5kZXJpdmUobm9ybWFsaXplZFByZXYpO1xuXG4gIGxldCBwb2xhcml0eTogTWF0cml4Q2VsbFtcInBvbGFyaXR5XCJdID0gXCJuZXV0cmFsXCI7XG4gIGxldCBiYWNrZ3JvdW5kID0gbm9ybWFsaXplZFZhbHVlID09IG51bGwgPyBaRVJPX0JBQ0tHUk9VTkQgOiBNVVRFRF9CQUNLR1JPVU5EO1xuICBsZXQgdGV4dENvbG9yOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3QgZWZmZWN0aXZlU3RhZ2U6IEZyb3plblN0YWdlIHwgbnVsbCA9IGZyb3plblN0YWdlID8/IChmcm96ZW4gPyBcIm1pZFwiIDogbnVsbCk7XG5cbiAgaWYgKGZyb3plbiB8fCBlZmZlY3RpdmVTdGFnZSkge1xuICAgIGNvbnN0IHN0YWdlID0gZWZmZWN0aXZlU3RhZ2UgPz8gXCJtaWRcIjtcbiAgICBiYWNrZ3JvdW5kID0gRlJPWkVOX1NUQUdFX0JBQ0tHUk9VTkRTW3N0YWdlXTtcbiAgICB0ZXh0Q29sb3IgPSBzdGFnZSA9PT0gXCJsb25nXCIgPyBcIiNlZGU5ZmVcIiA6IFwiIzIwMTAzZlwiO1xuICB9IGVsc2UgaWYgKGRlcml2ZWQgIT0gbnVsbCAmJiBOdW1iZXIuaXNGaW5pdGUoZGVyaXZlZCkpIHtcbiAgICBjb25zdCBhYnMgPSBNYXRoLmFicyhkZXJpdmVkKTtcbiAgICBpZiAoYWJzIDwgcnVsZXMuemVyb0Zsb29yKSB7XG4gICAgICBiYWNrZ3JvdW5kID0gWkVST19CQUNLR1JPVU5EO1xuICAgICAgdGV4dENvbG9yID0gXCIjNDIyMDA2XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlkeCA9IHJ1bGVzLnRocmVzaG9sZHMuZmluZEluZGV4KCh0KSA9PiBhYnMgPCB0KTtcbiAgICAgIGNvbnN0IHBhbGV0dGUgPSBkZXJpdmVkID49IDAgPyBwYWxldHRlUG9zaXRpdmUgOiBwYWxldHRlTmVnYXRpdmU7XG4gICAgICBjb25zdCBwYWxldHRlSW5kZXggPSBjbGFtcFBhbGV0dGVJbmRleChpZHggPT09IC0xID8gcGFsZXR0ZS5sZW5ndGggLSAxIDogaWR4LCBwYWxldHRlKTtcbiAgICAgIGNvbnN0IGhleCA9IHBhbGV0dGVbcGFsZXR0ZUluZGV4XSA/PyBwYWxldHRlW3BhbGV0dGUubGVuZ3RoIC0gMV0gPz8gXCIjMGYxNzJhXCI7XG4gICAgICBiYWNrZ3JvdW5kID0gd2l0aEFscGhhKGhleCwgMC44NSk7XG4gICAgICBwb2xhcml0eSA9IGRlcml2ZWQgPj0gMCA/IFwicG9zaXRpdmVcIiA6IFwibmVnYXRpdmVcIjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFja2dyb3VuZCA9IE1VVEVEX0JBQ0tHUk9VTkQ7XG4gIH1cblxuICBjb25zdCByaW5nQ29sb3IgPSByZXNvbHZlQmFzZVJpbmdDb2xvcih7XG4gICAgZnJvemVuLFxuICAgIGZyb3plblN0YWdlOiBlZmZlY3RpdmVTdGFnZSxcbiAgICByaW5nU3RyYXRlZ3k6IHJ1bGVzLnJpbmdTdHJhdGVneSxcbiAgICBkaXJlY3RTeW1ib2wsXG4gICAgaW52ZXJzZVN5bWJvbCxcbiAgICBzeW1ib2xTZXRzLFxuICB9KTtcblxuICBjb25zdCBzaWduRmxpcCA9IGRldGVjdFNpZ25GbGlwKHtcbiAgICByaW5nU3RyYXRlZ3k6IHJ1bGVzLnJpbmdTdHJhdGVneSxcbiAgICBmcm96ZW4sXG4gICAgY3VycmVudDogZGVyaXZlZCxcbiAgICBwcmV2aW91czogcHJldmlvdXNEZXJpdmVkLFxuICB9KTtcblxuICBsZXQgZmluYWxSaW5nID0gcmluZ0NvbG9yO1xuICBpZiAoc2lnbkZsaXAgPT09IFwicGx1c1RvTWludXNcIikge1xuICAgIGZpbmFsUmluZyA9IFNJR05fRkxJUF9SSU5HX0NPTE9SUy5wbHVzVG9NaW51cztcbiAgfSBlbHNlIGlmIChzaWduRmxpcCA9PT0gXCJtaW51c1RvUGx1c1wiKSB7XG4gICAgZmluYWxSaW5nID0gU0lHTl9GTElQX1JJTkdfQ09MT1JTLm1pbnVzVG9QbHVzO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiYWNrZ3JvdW5kLFxuICAgIHBvbGFyaXR5LFxuICAgIHRleHRDb2xvcixcbiAgICByaW5nQ29sb3I6IGZpbmFsUmluZyxcbiAgICBkZXJpdmVkLFxuICAgIHNpZ25GbGlwLFxuICAgIGZyb3plblN0YWdlOiBlZmZlY3RpdmVTdGFnZSxcbiAgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRQcmV2aWV3U3ltYm9sU2V0KFxuICBjb2luczogc3RyaW5nW11cbik6IFByb21pc2U8eyBzeW1ib2xzOiBzdHJpbmdbXTsgc2V0OiBTZXQ8c3RyaW5nPjsgc291cmNlOiBQcmV2aWV3U291cmNlIH0+IHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IGNvaW5zLm1hcCgoY29pbikgPT4gU3RyaW5nKGNvaW4gPz8gXCJcIikudG9VcHBlckNhc2UoKSk7XG4gIGNvbnN0IHsgc3ltYm9scywgc291cmNlIH0gPSBhd2FpdCBnZXRQcmV2aWV3U3ltYm9scyhub3JtYWxpemVkKTtcbiAgY29uc3Qgbm9ybWFsaXplZFN5bWJvbHMgPSBzeW1ib2xzLm1hcCgoc3ltKSA9PiBTdHJpbmcoc3ltID8/IFwiXCIpLnRvVXBwZXJDYXNlKCkpO1xuICByZXR1cm4ge1xuICAgIHN5bWJvbHM6IG5vcm1hbGl6ZWRTeW1ib2xzLFxuICAgIHNldDogbWFrZVNldChub3JtYWxpemVkU3ltYm9scyksXG4gICAgc291cmNlLFxuICB9O1xufVxuIl0sIm5hbWVzIjpbIkNPTE9SX0FNQkVSIiwiQ09MT1JfRlJPWkVOIiwiQ09MT1JfTVVURUQiLCJDT0xPUl9ORUdBVElWRV9TSEFERVMiLCJDT0xPUl9QT1NJVElWRV9TSEFERVMiLCJDT0xPUl9NT09fTkVHQVRJVkVfU0hBREVTIiwiQ09MT1JfTU9PX1BPU0lUSVZFX1NIQURFUyIsIk5VTExfU0VOU0lUSVZJVFkiLCJGUk9aRU5fU1RBR0VfQ09MT1JTIiwid2l0aEFscGhhIiwiZ2V0UHJldmlld1N5bWJvbHMiLCJQT1NJVElWRV9TSEFERVMiLCJORUdBVElWRV9TSEFERVMiLCJNT09fUE9TSVRJVkVfU0hBREVTIiwiTU9PX05FR0FUSVZFX1NIQURFUyIsIlpFUk9fQkFDS0dST1VORCIsIk1VVEVEX0JBQ0tHUk9VTkQiLCJGUk9aRU5fU1RBR0VfQkFDS0dST1VORFMiLCJyZWNlbnQiLCJtaWQiLCJsb25nIiwiUFJFVklFV19SSU5HX0NPTE9SUyIsImRpcmVjdCIsImludmVyc2UiLCJtaXNzaW5nIiwiZnJvemVuIiwiRlJPWkVOX1JJTkdfQ09MT1JTIiwiU0lHTl9GTElQX1JJTkdfQ09MT1JTIiwibWludXNUb1BsdXMiLCJwbHVzVG9NaW51cyIsIm1ha2VTZXQiLCJ2YWx1ZXMiLCJvdXQiLCJTZXQiLCJ2YWx1ZSIsImFkZCIsIlN0cmluZyIsInRvVXBwZXJDYXNlIiwiaGFzU3ltYm9sIiwic2V0Iiwic3ltYm9sIiwiaGFzIiwiY2xhbXBQYWxldHRlSW5kZXgiLCJpZHgiLCJwYWxldHRlIiwibGVuZ3RoIiwicmVzb2x2ZUJhc2VSaW5nQ29sb3IiLCJmcm96ZW5TdGFnZSIsInJpbmdTdHJhdGVneSIsImRpcmVjdFN5bWJvbCIsImludmVyc2VTeW1ib2wiLCJzeW1ib2xTZXRzIiwiaGFzRGlyZWN0IiwicHJldmlldyIsInBheWxvYWQiLCJoYXNJbnZlcnNlIiwiZGV0ZWN0U2lnbkZsaXAiLCJjdXJyZW50IiwicHJldmlvdXMiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInByZXZTaWduIiwiTWF0aCIsInNpZ24iLCJjdXJyU2lnbiIsInJlc29sdmVDZWxsUHJlc2VudGF0aW9uIiwicnVsZXMiLCJwcmV2VmFsdWUiLCJzYW5pdGl6ZSIsImlucHV0IiwibnVtIiwiYWJzIiwicGFsZXR0ZVBvc2l0aXZlIiwicG9zaXRpdmVQYWxldHRlIiwicGFsZXR0ZU5lZ2F0aXZlIiwibmVnYXRpdmVQYWxldHRlIiwibm9ybWFsaXplZFZhbHVlIiwiZGVyaXZlZCIsImRlcml2ZSIsIm5vcm1hbGl6ZWRQcmV2IiwidW5kZWZpbmVkIiwicHJldmlvdXNEZXJpdmVkIiwicG9sYXJpdHkiLCJiYWNrZ3JvdW5kIiwidGV4dENvbG9yIiwiZWZmZWN0aXZlU3RhZ2UiLCJzdGFnZSIsInplcm9GbG9vciIsInRocmVzaG9sZHMiLCJmaW5kSW5kZXgiLCJ0IiwicGFsZXR0ZUluZGV4IiwiaGV4IiwicmluZ0NvbG9yIiwic2lnbkZsaXAiLCJmaW5hbFJpbmciLCJsb2FkUHJldmlld1N5bWJvbFNldCIsImNvaW5zIiwibm9ybWFsaXplZCIsIm1hcCIsImNvaW4iLCJzeW1ib2xzIiwic291cmNlIiwibm9ybWFsaXplZFN5bWJvbHMiLCJzeW0iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/matrices/colouring.ts\n"));

/***/ })

});