"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dynamics/page",{

/***/ "(app-pages-browser)/./src/app/matrices/colouring.ts":
/*!***************************************!*\
  !*** ./src/app/matrices/colouring.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FROZEN_RING_COLORS: () => (/* binding */ FROZEN_RING_COLORS),\n/* harmony export */   FROZEN_STAGE_BACKGROUNDS: () => (/* binding */ FROZEN_STAGE_BACKGROUNDS),\n/* harmony export */   MOO_NEGATIVE_SHADES: () => (/* binding */ MOO_NEGATIVE_SHADES),\n/* harmony export */   MOO_POSITIVE_SHADES: () => (/* binding */ MOO_POSITIVE_SHADES),\n/* harmony export */   MUTED_BACKGROUND: () => (/* binding */ MUTED_BACKGROUND),\n/* harmony export */   NEGATIVE_SHADES: () => (/* binding */ NEGATIVE_SHADES),\n/* harmony export */   POSITIVE_SHADES: () => (/* binding */ POSITIVE_SHADES),\n/* harmony export */   PREVIEW_RING_COLORS: () => (/* binding */ PREVIEW_RING_COLORS),\n/* harmony export */   SIGN_FLIP_RING_COLORS: () => (/* binding */ SIGN_FLIP_RING_COLORS),\n/* harmony export */   ZERO_BACKGROUND: () => (/* binding */ ZERO_BACKGROUND),\n/* harmony export */   loadPreviewSymbolSet: () => (/* binding */ loadPreviewSymbolSet),\n/* harmony export */   resolveCellPresentation: () => (/* binding */ resolveCellPresentation)\n/* harmony export */ });\n/* harmony import */ var _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/features/matrices/colors */ \"(app-pages-browser)/./src/components/features/matrices/colors.ts\");\n/* harmony import */ var _lib_preview__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/preview */ \"(app-pages-browser)/./src/lib/preview.ts\");\n\n\nconst POSITIVE_SHADES = _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_POSITIVE_SHADES;\nconst NEGATIVE_SHADES = _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_NEGATIVE_SHADES;\nconst MOO_POSITIVE_SHADES = _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_MOO_POSITIVE_SHADES;\nconst MOO_NEGATIVE_SHADES = _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_MOO_NEGATIVE_SHADES;\nconst ZERO_BACKGROUND = (0,_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.withAlpha)(_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_AMBER, 0.32);\nconst MUTED_BACKGROUND = (0,_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.withAlpha)(_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_MUTED, 0.28);\nconst FROZEN_STAGE_BACKGROUNDS = {\n    recent: (0,_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.withAlpha)(_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS.recent, 0.42),\n    mid: (0,_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.withAlpha)(_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS.mid, 0.5),\n    long: (0,_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.withAlpha)(_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS.long, 0.62)\n};\nconst PREVIEW_RING_COLORS = {\n    direct: \"#34d399\",\n    inverse: \"#f87171\",\n    missing: \"#94a3b8\",\n    frozen: _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_FROZEN\n};\nconst FROZEN_RING_COLORS = {\n    recent: _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS.recent,\n    mid: _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS.mid,\n    long: _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS.long\n};\nconst SIGN_FLIP_RING_COLORS = {\n    minusToPlus: \"#38bdf8\",\n    plusToMinus: \"#fb923c\"\n};\nconst makeSet = (values)=>{\n    const out = new Set();\n    for (const value of values){\n        out.add(String(value !== null && value !== void 0 ? value : \"\").toUpperCase());\n    }\n    return out;\n};\nconst hasSymbol = (set, symbol)=>{\n    if (!set) return false;\n    return set.has(String(symbol !== null && symbol !== void 0 ? symbol : \"\").toUpperCase());\n};\nconst clampPaletteIndex = (idx, palette)=>{\n    if (!palette.length) return 0;\n    if (idx < 0) return palette.length - 1;\n    if (idx >= palette.length) return palette.length - 1;\n    return idx;\n};\nfunction resolveBaseRingColor(param) {\n    let { frozen, frozenStage, ringStrategy, directSymbol, inverseSymbol, symbolSets } = param;\n    if (frozen) {\n        if (frozenStage) return _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS[frozenStage];\n        return PREVIEW_RING_COLORS.frozen;\n    }\n    if (ringStrategy === \"none\") return null;\n    const hasDirect = hasSymbol(symbolSets.preview, directSymbol) || hasSymbol(symbolSets.payload, directSymbol);\n    if (hasDirect) return PREVIEW_RING_COLORS.direct;\n    const hasInverse = hasSymbol(symbolSets.preview, inverseSymbol) || hasSymbol(symbolSets.payload, inverseSymbol);\n    if (hasInverse) return PREVIEW_RING_COLORS.inverse;\n    return PREVIEW_RING_COLORS.missing;\n}\nfunction detectSignFlip(param) {\n    let { ringStrategy, frozen, current, previous } = param;\n    if (ringStrategy !== \"sign-flip\" || frozen) return null;\n    if (current == null || previous == null) return null;\n    if (!Number.isFinite(current) || !Number.isFinite(previous)) return null;\n    const prevSign = Math.sign(previous);\n    const currSign = Math.sign(current);\n    if (prevSign > 0 && currSign < 0) return \"plusToMinus\";\n    if (prevSign < 0 && currSign > 0) return \"minusToPlus\";\n    return null;\n}\nfunction resolveCellPresentation(param) {\n    let { rules, value, prevValue, frozen, frozenStage = null, directSymbol, inverseSymbol, symbolSets } = param;\n    var _rules_positivePalette;\n    const palettePositive = (_rules_positivePalette = rules.positivePalette) !== null && _rules_positivePalette !== void 0 ? _rules_positivePalette : POSITIVE_SHADES;\n    var _rules_negativePalette;\n    const paletteNegative = (_rules_negativePalette = rules.negativePalette) !== null && _rules_negativePalette !== void 0 ? _rules_negativePalette : NEGATIVE_SHADES;\n    const derived = rules.derive(value);\n    const previousDerived = prevValue === undefined ? null : rules.derive(prevValue !== null && prevValue !== void 0 ? prevValue : null);\n    let polarity = \"neutral\";\n    let background = value == null ? ZERO_BACKGROUND : MUTED_BACKGROUND;\n    let textColor;\n    const effectiveStage = frozenStage !== null && frozenStage !== void 0 ? frozenStage : frozen ? \"mid\" : null;\n    if (frozen || effectiveStage) {\n        const stage = effectiveStage !== null && effectiveStage !== void 0 ? effectiveStage : \"mid\";\n        background = FROZEN_STAGE_BACKGROUNDS[stage];\n        textColor = stage === \"long\" ? \"#ede9fe\" : \"#20103f\";\n    } else if (derived != null && Number.isFinite(derived)) {\n        const abs = Math.abs(derived);\n        if (abs < rules.zeroFloor) {\n            background = ZERO_BACKGROUND;\n            textColor = \"#422006\";\n        } else {\n            const idx = rules.thresholds.findIndex((t)=>abs < t);\n            const palette = derived >= 0 ? palettePositive : paletteNegative;\n            const paletteIndex = clampPaletteIndex(idx === -1 ? palette.length - 1 : idx, palette);\n            var _palette_paletteIndex, _ref;\n            const hex = (_ref = (_palette_paletteIndex = palette[paletteIndex]) !== null && _palette_paletteIndex !== void 0 ? _palette_paletteIndex : palette[palette.length - 1]) !== null && _ref !== void 0 ? _ref : \"#0f172a\";\n            background = (0,_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.withAlpha)(hex, 0.85);\n            polarity = derived >= 0 ? \"positive\" : \"negative\";\n        }\n    } else {\n        background = MUTED_BACKGROUND;\n    }\n    const ringColor = resolveBaseRingColor({\n        frozen,\n        frozenStage: effectiveStage,\n        ringStrategy: rules.ringStrategy,\n        directSymbol,\n        inverseSymbol,\n        symbolSets\n    });\n    const signFlip = detectSignFlip({\n        ringStrategy: rules.ringStrategy,\n        frozen,\n        current: derived,\n        previous: previousDerived\n    });\n    let finalRing = ringColor;\n    if (signFlip === \"plusToMinus\") {\n        finalRing = SIGN_FLIP_RING_COLORS.plusToMinus;\n    } else if (signFlip === \"minusToPlus\") {\n        finalRing = SIGN_FLIP_RING_COLORS.minusToPlus;\n    }\n    return {\n        background,\n        polarity,\n        textColor,\n        ringColor: finalRing,\n        derived,\n        signFlip,\n        frozenStage: effectiveStage\n    };\n}\nasync function loadPreviewSymbolSet(coins) {\n    const normalized = coins.map((coin)=>String(coin !== null && coin !== void 0 ? coin : \"\").toUpperCase());\n    const { symbols, source } = await (0,_lib_preview__WEBPACK_IMPORTED_MODULE_1__.getPreviewSymbols)(normalized);\n    const normalizedSymbols = symbols.map((sym)=>String(sym !== null && sym !== void 0 ? sym : \"\").toUpperCase());\n    return {\n        symbols: normalizedSymbols,\n        set: makeSet(normalizedSymbols),\n        source\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvbWF0cmljZXMvY29sb3VyaW5nLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBWStDO0FBQ3VCO0FBd0IvRCxNQUFNVSxrQkFBa0JOLHVGQUFxQkEsQ0FBQztBQUM5QyxNQUFNTyxrQkFBa0JSLHVGQUFxQkEsQ0FBQztBQUM5QyxNQUFNUyxzQkFBc0JOLDJGQUF5QkEsQ0FBQztBQUN0RCxNQUFNTyxzQkFBc0JSLDJGQUF5QkEsQ0FBQztBQUV0RCxNQUFNUyxrQkFBa0JOLCtFQUFTQSxDQUFDUiw2RUFBV0EsRUFBRSxNQUFNO0FBQ3JELE1BQU1lLG1CQUFtQlAsK0VBQVNBLENBQUNOLDZFQUFXQSxFQUFFLE1BQU07QUFDdEQsTUFBTWMsMkJBQXdEO0lBQ25FQyxRQUFRVCwrRUFBU0EsQ0FBQ0QscUZBQW1CQSxDQUFDVSxNQUFNLEVBQUU7SUFDOUNDLEtBQUtWLCtFQUFTQSxDQUFDRCxxRkFBbUJBLENBQUNXLEdBQUcsRUFBRTtJQUN4Q0MsTUFBTVgsK0VBQVNBLENBQUNELHFGQUFtQkEsQ0FBQ1ksSUFBSSxFQUFFO0FBQzVDLEVBQUU7QUFFSyxNQUFNQyxzQkFBc0I7SUFDakNDLFFBQVE7SUFDUkMsU0FBUztJQUNUQyxTQUFTO0lBQ1RDLFFBQVF2Qiw4RUFBWUE7QUFDdEIsRUFBVztBQUVKLE1BQU13QixxQkFBa0Q7SUFDN0RSLFFBQVFWLHFGQUFtQkEsQ0FBQ1UsTUFBTTtJQUNsQ0MsS0FBS1gscUZBQW1CQSxDQUFDVyxHQUFHO0lBQzVCQyxNQUFNWixxRkFBbUJBLENBQUNZLElBQUk7QUFDaEMsRUFBRTtBQUVLLE1BQU1PLHdCQUF3QjtJQUNuQ0MsYUFBYTtJQUNiQyxhQUFhO0FBQ2YsRUFBVztBQU9YLE1BQU1DLFVBQVUsQ0FBQ0M7SUFDZixNQUFNQyxNQUFNLElBQUlDO0lBQ2hCLEtBQUssTUFBTUMsU0FBU0gsT0FBUTtRQUMxQkMsSUFBSUcsR0FBRyxDQUFDQyxPQUFPRixrQkFBQUEsbUJB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QUFZL0Qsc0JBQXNCRSxXQUFXO0lBQy9DLE9BQU8sSUFBSTRELGFBQWEsZUFBZTtRQUNyQ0MsWUFBWS9ELHNCQUFzQkMsV0FBVztJQUMvQztJQUVBLE9BQU87UUFDTGlEO1FBQ0FEO1FBQ0FFO1FBQ0FVLFdBQVdFO1FBQ1hsQjtRQUNBaUI7UUFDQTFDLGFBQWFnQztJQUNmO0FBQ0Y7QUFFTyxlQUFlWSxxQkFDcEJDLEtBQWU7SUFFZixNQUFNQyxhQUFhRCxNQUFNRSxHQUFHLENBQUMsQ0FBQ0MsT0FBUzNELE9BQU8yRCxpQkFBQUEsa0JBQUFBLE9BQVEsSUFBSTFELFdBQVc7SUFDckUsTUFBTSxFQUFFMkQsT0FBTyxFQUFFQyxNQUFNLEVBQUUsR0FBRyxNQUFNdkYsK0RBQWlCQSxDQUFDbUY7SUFDcEQsTUFBTUssb0JBQW9CRixRQUFRRixHQUFHLENBQUMsQ0FBQ0ssTUFBUS9ELE9BQU8rRCxnQkFBQUEsaUJBQUFBLE1BQU8sSUFBSTlELFdBQVc7SUFDNUUsT0FBTztRQUNMMkQsU0FBU0U7UUFDVDNELEtBQUtULFFBQVFvRTtRQUNiRDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxhcHBcXG1hdHJpY2VzXFxjb2xvdXJpbmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBNYXRyaXhDZWxsIH0gZnJvbSBcIkAvY29tcG9uZW50cy9mZWF0dXJlcy9tYXRyaWNlcy9NYXRyaXhcIjtcbmltcG9ydCB7XG4gIENPTE9SX0FNQkVSLFxuICBDT0xPUl9GUk9aRU4sXG4gIENPTE9SX01VVEVELFxuICBDT0xPUl9ORUdBVElWRV9TSEFERVMsXG4gIENPTE9SX1BPU0lUSVZFX1NIQURFUyxcbiAgQ09MT1JfTU9PX05FR0FUSVZFX1NIQURFUyxcbiAgQ09MT1JfTU9PX1BPU0lUSVZFX1NIQURFUyxcbiAgRlJPWkVOX1NUQUdFX0NPTE9SUyxcbiAgdHlwZSBGcm96ZW5TdGFnZSxcbiAgd2l0aEFscGhhLFxufSBmcm9tIFwiQC9jb21wb25lbnRzL2ZlYXR1cmVzL21hdHJpY2VzL2NvbG9yc1wiO1xuaW1wb3J0IHsgZ2V0UHJldmlld1N5bWJvbHMsIHR5cGUgUHJldmlld1NvdXJjZSB9IGZyb20gXCJAL2xpYi9wcmV2aWV3XCI7XG5cbmV4cG9ydCB0eXBlIFJpbmdTdHJhdGVneSA9IFwicHJldmlld1wiIHwgXCJzaWduLWZsaXBcIiB8IFwibm9uZVwiO1xuXG5leHBvcnQgdHlwZSBNYXRyaXhDb2xvclJ1bGVzID0ge1xuICBrZXk6IHN0cmluZztcbiAgdGhyZXNob2xkczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHBvc2l0aXZlUGFsZXR0ZT86IHJlYWRvbmx5IHN0cmluZ1tdO1xuICBuZWdhdGl2ZVBhbGV0dGU/OiByZWFkb25seSBzdHJpbmdbXTtcbiAgemVyb0Zsb29yOiBudW1iZXI7XG4gIGRlcml2ZTogKHZhbHVlOiBudW1iZXIgfCBudWxsKSA9PiBudW1iZXIgfCBudWxsO1xuICByaW5nU3RyYXRlZ3k6IFJpbmdTdHJhdGVneTtcbn07XG5cbmV4cG9ydCB0eXBlIENlbGxQcmVzZW50YXRpb24gPSB7XG4gIGJhY2tncm91bmQ6IHN0cmluZztcbiAgcG9sYXJpdHk6IE1hdHJpeENlbGxbXCJwb2xhcml0eVwiXTtcbiAgdGV4dENvbG9yPzogc3RyaW5nO1xuICByaW5nQ29sb3I6IHN0cmluZyB8IG51bGw7XG4gIGRlcml2ZWQ6IG51bWJlciB8IG51bGw7XG4gIHNpZ25GbGlwOiBcInBsdXNUb01pbnVzXCIgfCBcIm1pbnVzVG9QbHVzXCIgfCBudWxsO1xuICBmcm96ZW5TdGFnZTogRnJvemVuU3RhZ2UgfCBudWxsO1xufTtcblxuZXhwb3J0IGNvbnN0IFBPU0lUSVZFX1NIQURFUyA9IENPTE9SX1BPU0lUSVZFX1NIQURFUztcbmV4cG9ydCBjb25zdCBORUdBVElWRV9TSEFERVMgPSBDT0xPUl9ORUdBVElWRV9TSEFERVM7XG5leHBvcnQgY29uc3QgTU9PX1BPU0lUSVZFX1NIQURFUyA9IENPTE9SX01PT19QT1NJVElWRV9TSEFERVM7XG5leHBvcnQgY29uc3QgTU9PX05FR0FUSVZFX1NIQURFUyA9IENPTE9SX01PT19ORUdBVElWRV9TSEFERVM7XG5cbmV4cG9ydCBjb25zdCBaRVJPX0JBQ0tHUk9VTkQgPSB3aXRoQWxwaGEoQ09MT1JfQU1CRVIsIDAuMzIpO1xuZXhwb3J0IGNvbnN0IE1VVEVEX0JBQ0tHUk9VTkQgPSB3aXRoQWxwaGEoQ09MT1JfTVVURUQsIDAuMjgpO1xuZXhwb3J0IGNvbnN0IEZST1pFTl9TVEFHRV9CQUNLR1JPVU5EUzogUmVjb3JkPEZyb3plblN0YWdlLCBzdHJpbmc+ID0ge1xuICByZWNlbnQ6IHdpdGhBbHBoYShGUk9aRU5fU1RBR0VfQ09MT1JTLnJlY2VudCwgMC40MiksXG4gIG1pZDogd2l0aEFscGhhKEZST1pFTl9TVEFHRV9DT0xPUlMubWlkLCAwLjUpLFxuICBsb25nOiB3aXRoQWxwaGEoRlJPWkVOX1NUQUdFX0NPTE9SUy5sb25nLCAwLjYyKSxcbn07XG5cbmV4cG9ydCBjb25zdCBQUkVWSUVXX1JJTkdfQ09MT1JTID0ge1xuICBkaXJlY3Q6IFwiIzM0ZDM5OVwiLFxuICBpbnZlcnNlOiBcIiNmODcxNzFcIixcbiAgbWlzc2luZzogXCIjOTRhM2I4XCIsXG4gIGZyb3plbjogQ09MT1JfRlJPWkVOLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IEZST1pFTl9SSU5HX0NPTE9SUzogUmVjb3JkPEZyb3plblN0YWdlLCBzdHJpbmc+ID0ge1xuICByZWNlbnQ6IEZST1pFTl9TVEFHRV9DT0xPUlMucmVjZW50LFxuICBtaWQ6IEZST1pFTl9TVEFHRV9DT0xPUlMubWlkLFxuICBsb25nOiBGUk9aRU5fU1RBR0VfQ09MT1JTLmxvbmcsXG59O1xuXG5leHBvcnQgY29uc3QgU0lHTl9GTElQX1JJTkdfQ09MT1JTID0ge1xuICBtaW51c1RvUGx1czogXCIjMzhiZGY4XCIsXG4gIHBsdXNUb01pbnVzOiBcIiNmYjkyM2NcIixcbn0gYXMgY29uc3Q7XG5cbnR5cGUgU3ltYm9sU2V0cyA9IHtcbiAgcHJldmlldzogU2V0PHN0cmluZz47XG4gIHBheWxvYWQ/OiBTZXQ8c3RyaW5nPjtcbn07XG5cbmNvbnN0IG1ha2VTZXQgPSAodmFsdWVzOiBJdGVyYWJsZTxzdHJpbmc+KTogU2V0PHN0cmluZz4gPT4ge1xuICBjb25zdCBvdXQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICBvdXQuYWRkKFN0cmluZyh2YWx1ZSA/PyBcIlwiKS50b1VwcGVyQ2FzZSgpKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuY29uc3QgaGFzU3ltYm9sID0gKHNldDogU2V0PHN0cmluZz4gfCB1bmRlZmluZWQsIHN5bWJvbDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gIGlmICghc2V0KSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBzZXQuaGFzKFN0cmluZyhzeW1ib2wgPz8gXCJcIikudG9VcHBlckNhc2UoKSk7XG59O1xuXG5jb25zdCBjbGFtcFBhbGV0dGVJbmRleCA9IChpZHg6IG51bWJlciwgcGFsZXR0ZTogcmVhZG9ubHkgc3RyaW5nW10pOiBudW1iZXIgPT4ge1xuICBpZiAoIXBhbGV0dGUubGVuZ3RoKSByZXR1cm4gMDtcbiAgaWYgKGlkeCA8IDApIHJldHVybiBwYWxldHRlLmxlbmd0aCAtIDE7XG4gIGlmIChpZHggPj0gcGFsZXR0ZS5sZW5ndGgpIHJldHVybiBwYWxldHRlLmxlbmd0aCAtIDE7XG4gIHJldHVybiBpZHg7XG59O1xuXG5mdW5jdGlvbiByZXNvbHZlQmFzZVJpbmdDb2xvcih7XG4gIGZyb3plbixcbiAgZnJvemVuU3RhZ2UsXG4gIHJpbmdTdHJhdGVneSxcbiAgZGlyZWN0U3ltYm9sLFxuICBpbnZlcnNlU3ltYm9sLFxuICBzeW1ib2xTZXRzLFxufToge1xuICBmcm96ZW46IGJvb2xlYW47XG4gIGZyb3plblN0YWdlOiBGcm96ZW5TdGFnZSB8IG51bGw7XG4gIHJpbmdTdHJhdGVneTogUmluZ1N0cmF0ZWd5O1xuICBkaXJlY3RTeW1ib2w6IHN0cmluZztcbiAgaW52ZXJzZVN5bWJvbDogc3RyaW5nO1xuICBzeW1ib2xTZXRzOiBTeW1ib2xTZXRzO1xufSk6IHN0cmluZyB8IG51bGwge1xuICBpZiAoZnJvemVuKSB7XG4gICAgaWYgKGZyb3plblN0YWdlKSByZXR1cm4gRlJPWkVOX1NUQUdFX0NPTE9SU1tmcm96ZW5TdGFnZV07XG4gICAgcmV0dXJuIFBSRVZJRVdfUklOR19DT0xPUlMuZnJvemVuO1xuICB9XG4gIGlmIChyaW5nU3RyYXRlZ3kgPT09IFwibm9uZVwiKSByZXR1cm4gbnVsbDtcblxuICBjb25zdCBoYXNEaXJlY3QgPSBoYXNTeW1ib2woc3ltYm9sU2V0cy5wcmV2aWV3LCBkaXJlY3RTeW1ib2wpIHx8IGhhc1N5bWJvbChzeW1ib2xTZXRzLnBheWxvYWQsIGRpcmVjdFN5bWJvbCk7XG4gIGlmIChoYXNEaXJlY3QpIHJldHVybiBQUkVWSUVXX1JJTkdfQ09MT1JTLmRpcmVjdDtcblxuICBjb25zdCBoYXNJbnZlcnNlID0gaGFzU3ltYm9sKHN5bWJvbFNldHMucHJldmlldywgaW52ZXJzZVN5bWJvbCkgfHwgaGFzU3ltYm9sKHN5bWJvbFNldHMucGF5bG9hZCwgaW52ZXJzZVN5bWJvbCk7XG4gIGlmIChoYXNJbnZlcnNlKSByZXR1cm4gUFJFVklFV19SSU5HX0NPTE9SUy5pbnZlcnNlO1xuXG4gIHJldHVybiBQUkVWSUVXX1JJTkdfQ09MT1JTLm1pc3Npbmc7XG59XG5cbmZ1bmN0aW9uIGRldGVjdFNpZ25GbGlwKHtcbiAgcmluZ1N0cmF0ZWd5LFxuICBmcm96ZW4sXG4gIGN1cnJlbnQsXG4gIHByZXZpb3VzLFxufToge1xuICByaW5nU3RyYXRlZ3k6IFJpbmdTdHJhdGVneTtcbiAgZnJvemVuOiBib29sZWFuO1xuICBjdXJyZW50OiBudW1iZXIgfCBudWxsO1xuICBwcmV2aW91czogbnVtYmVyIHwgbnVsbDtcbn0pOiBcInBsdXNUb01pbnVzXCIgfCBcIm1pbnVzVG9QbHVzXCIgfCBudWxsIHtcbiAgaWYgKHJpbmdTdHJhdGVneSAhPT0gXCJzaWduLWZsaXBcIiB8fCBmcm96ZW4pIHJldHVybiBudWxsO1xuICBpZiAoY3VycmVudCA9PSBudWxsIHx8IHByZXZpb3VzID09IG51bGwpIHJldHVybiBudWxsO1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZShjdXJyZW50KSB8fCAhTnVtYmVyLmlzRmluaXRlKHByZXZpb3VzKSkgcmV0dXJuIG51bGw7XG5cbiAgY29uc3QgcHJldlNpZ24gPSBNYXRoLnNpZ24ocHJldmlvdXMpO1xuICBjb25zdCBjdXJyU2lnbiA9IE1hdGguc2lnbihjdXJyZW50KTtcbiAgaWYgKHByZXZTaWduID4gMCAmJiBjdXJyU2lnbiA8IDApIHJldHVybiBcInBsdXNUb01pbnVzXCI7XG4gIGlmIChwcmV2U2lnbiA8IDAgJiYgY3VyclNpZ24gPiAwKSByZXR1cm4gXCJtaW51c1RvUGx1c1wiO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVDZWxsUHJlc2VudGF0aW9uKHtcbiAgcnVsZXMsXG4gIHZhbHVlLFxuICBwcmV2VmFsdWUsXG4gIGZyb3plbixcbiAgZnJvemVuU3RhZ2UgPSBudWxsLFxuICBkaXJlY3RTeW1ib2wsXG4gIGludmVyc2VTeW1ib2wsXG4gIHN5bWJvbFNldHMsXG59OiB7XG4gIHJ1bGVzOiBNYXRyaXhDb2xvclJ1bGVzO1xuICB2YWx1ZTogbnVtYmVyIHwgbnVsbDtcbiAgcHJldlZhbHVlPzogbnVtYmVyIHwgbnVsbDtcbiAgZnJvemVuOiBib29sZWFuO1xuICBmcm96ZW5TdGFnZT86IEZyb3plblN0YWdlIHwgbnVsbDtcbiAgZGlyZWN0U3ltYm9sOiBzdHJpbmc7XG4gIGludmVyc2VTeW1ib2w6IHN0cmluZztcbiAgc3ltYm9sU2V0czogU3ltYm9sU2V0cztcbn0pOiBDZWxsUHJlc2VudGF0aW9uIHtcbiAgY29uc3QgcGFsZXR0ZVBvc2l0aXZlID0gcnVsZXMucG9zaXRpdmVQYWxldHRlID8/IFBPU0lUSVZFX1NIQURFUztcbiAgY29uc3QgcGFsZXR0ZU5lZ2F0aXZlID0gcnVsZXMubmVnYXRpdmVQYWxldHRlID8/IE5FR0FUSVZFX1NIQURFUztcbiAgY29uc3QgZGVyaXZlZCA9IHJ1bGVzLmRlcml2ZSh2YWx1ZSk7XG4gIGNvbnN0IHByZXZpb3VzRGVyaXZlZCA9IHByZXZWYWx1ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHJ1bGVzLmRlcml2ZShwcmV2VmFsdWUgPz8gbnVsbCk7XG5cbiAgbGV0IHBvbGFyaXR5OiBNYXRyaXhDZWxsW1wicG9sYXJpdHlcIl0gPSBcIm5ldXRyYWxcIjtcbiAgbGV0IGJhY2tncm91bmQgPSB2YWx1ZSA9PSBudWxsID8gWkVST19CQUNLR1JPVU5EIDogTVVURURfQkFDS0dST1VORDtcbiAgbGV0IHRleHRDb2xvcjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIGNvbnN0IGVmZmVjdGl2ZVN0YWdlOiBGcm96ZW5TdGFnZSB8IG51bGwgPSBmcm96ZW5TdGFnZSA/PyAoZnJvemVuID8gXCJtaWRcIiA6IG51bGwpO1xuXG4gIGlmIChmcm96ZW4gfHwgZWZmZWN0aXZlU3RhZ2UpIHtcbiAgICBjb25zdCBzdGFnZSA9IGVmZmVjdGl2ZVN0YWdlID8/IFwibWlkXCI7XG4gICAgYmFja2dyb3VuZCA9IEZST1pFTl9TVEFHRV9CQUNLR1JPVU5EU1tzdGFnZV07XG4gICAgdGV4dENvbG9yID0gc3RhZ2UgPT09IFwibG9uZ1wiID8gXCIjZWRlOWZlXCIgOiBcIiMyMDEwM2ZcIjtcbiAgfSBlbHNlIGlmIChkZXJpdmVkICE9IG51bGwgJiYgTnVtYmVyLmlzRmluaXRlKGRlcml2ZWQpKSB7XG4gICAgY29uc3QgYWJzID0gTWF0aC5hYnMoZGVyaXZlZCk7XG4gICAgaWYgKGFicyA8IHJ1bGVzLnplcm9GbG9vcikge1xuICAgICAgYmFja2dyb3VuZCA9IFpFUk9fQkFDS0dST1VORDtcbiAgICAgIHRleHRDb2xvciA9IFwiIzQyMjAwNlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpZHggPSBydWxlcy50aHJlc2hvbGRzLmZpbmRJbmRleCgodCkgPT4gYWJzIDwgdCk7XG4gICAgICBjb25zdCBwYWxldHRlID0gZGVyaXZlZCA+PSAwID8gcGFsZXR0ZVBvc2l0aXZlIDogcGFsZXR0ZU5lZ2F0aXZlO1xuICAgICAgY29uc3QgcGFsZXR0ZUluZGV4ID0gY2xhbXBQYWxldHRlSW5kZXgoaWR4ID09PSAtMSA/IHBhbGV0dGUubGVuZ3RoIC0gMSA6IGlkeCwgcGFsZXR0ZSk7XG4gICAgICBjb25zdCBoZXggPSBwYWxldHRlW3BhbGV0dGVJbmRleF0gPz8gcGFsZXR0ZVtwYWxldHRlLmxlbmd0aCAtIDFdID8/IFwiIzBmMTcyYVwiO1xuICAgICAgYmFja2dyb3VuZCA9IHdpdGhBbHBoYShoZXgsIDAuODUpO1xuICAgICAgcG9sYXJpdHkgPSBkZXJpdmVkID49IDAgPyBcInBvc2l0aXZlXCIgOiBcIm5lZ2F0aXZlXCI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJhY2tncm91bmQgPSBNVVRFRF9CQUNLR1JPVU5EO1xuICB9XG5cbiAgY29uc3QgcmluZ0NvbG9yID0gcmVzb2x2ZUJhc2VSaW5nQ29sb3Ioe1xuICAgIGZyb3plbixcbiAgICBmcm96ZW5TdGFnZTogZWZmZWN0aXZlU3RhZ2UsXG4gICAgcmluZ1N0cmF0ZWd5OiBydWxlcy5yaW5nU3RyYXRlZ3ksXG4gICAgZGlyZWN0U3ltYm9sLFxuICAgIGludmVyc2VTeW1ib2wsXG4gICAgc3ltYm9sU2V0cyxcbiAgfSk7XG5cbiAgY29uc3Qgc2lnbkZsaXAgPSBkZXRlY3RTaWduRmxpcCh7XG4gICAgcmluZ1N0cmF0ZWd5OiBydWxlcy5yaW5nU3RyYXRlZ3ksXG4gICAgZnJvemVuLFxuICAgIGN1cnJlbnQ6IGRlcml2ZWQsXG4gICAgcHJldmlvdXM6IHByZXZpb3VzRGVyaXZlZCxcbiAgfSk7XG5cbiAgbGV0IGZpbmFsUmluZyA9IHJpbmdDb2xvcjtcbiAgaWYgKHNpZ25GbGlwID09PSBcInBsdXNUb01pbnVzXCIpIHtcbiAgICBmaW5hbFJpbmcgPSBTSUdOX0ZMSVBfUklOR19DT0xPUlMucGx1c1RvTWludXM7XG4gIH0gZWxzZSBpZiAoc2lnbkZsaXAgPT09IFwibWludXNUb1BsdXNcIikge1xuICAgIGZpbmFsUmluZyA9IFNJR05fRkxJUF9SSU5HX0NPTE9SUy5taW51c1RvUGx1cztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZCxcbiAgICBwb2xhcml0eSxcbiAgICB0ZXh0Q29sb3IsXG4gICAgcmluZ0NvbG9yOiBmaW5hbFJpbmcsXG4gICAgZGVyaXZlZCxcbiAgICBzaWduRmxpcCxcbiAgICBmcm96ZW5TdGFnZTogZWZmZWN0aXZlU3RhZ2UsXG4gIH07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkUHJldmlld1N5bWJvbFNldChcbiAgY29pbnM6IHN0cmluZ1tdXG4pOiBQcm9taXNlPHsgc3ltYm9sczogc3RyaW5nW107IHNldDogU2V0PHN0cmluZz47IHNvdXJjZTogUHJldmlld1NvdXJjZSB9PiB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBjb2lucy5tYXAoKGNvaW4pID0+IFN0cmluZyhjb2luID8/IFwiXCIpLnRvVXBwZXJDYXNlKCkpO1xuICBjb25zdCB7IHN5bWJvbHMsIHNvdXJjZSB9ID0gYXdhaXQgZ2V0UHJldmlld1N5bWJvbHMobm9ybWFsaXplZCk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRTeW1ib2xzID0gc3ltYm9scy5tYXAoKHN5bSkgPT4gU3RyaW5nKHN5bSA/PyBcIlwiKS50b1VwcGVyQ2FzZSgpKTtcbiAgcmV0dXJuIHtcbiAgICBzeW1ib2xzOiBub3JtYWxpemVkU3ltYm9scyxcbiAgICBzZXQ6IG1ha2VTZXQobm9ybWFsaXplZFN5bWJvbHMpLFxuICAgIHNvdXJjZSxcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJDT0xPUl9BTUJFUiIsIkNPTE9SX0ZST1pFTiIsIkNPTE9SX01VVEVEIiwiQ09MT1JfTkVHQVRJVkVfU0hBREVTIiwiQ09MT1JfUE9TSVRJVkVfU0hBREVTIiwiQ09MT1JfTU9PX05FR0FUSVZFX1NIQURFUyIsIkNPTE9SX01PT19QT1NJVElWRV9TSEFERVMiLCJGUk9aRU5fU1RBR0VfQ09MT1JTIiwid2l0aEFscGhhIiwiZ2V0UHJldmlld1N5bWJvbHMiLCJQT1NJVElWRV9TSEFERVMiLCJORUdBVElWRV9TSEFERVMiLCJNT09fUE9TSVRJVkVfU0hBREVTIiwiTU9PX05FR0FUSVZFX1NIQURFUyIsIlpFUk9fQkFDS0dST1VORCIsIk1VVEVEX0JBQ0tHUk9VTkQiLCJGUk9aRU5fU1RBR0VfQkFDS0dST1VORFMiLCJyZWNlbnQiLCJtaWQiLCJsb25nIiwiUFJFVklFV19SSU5HX0NPTE9SUyIsImRpcmVjdCIsImludmVyc2UiLCJtaXNzaW5nIiwiZnJvemVuIiwiRlJPWkVOX1JJTkdfQ09MT1JTIiwiU0lHTl9GTElQX1JJTkdfQ09MT1JTIiwibWludXNUb1BsdXMiLCJwbHVzVG9NaW51cyIsIm1ha2VTZXQiLCJ2YWx1ZXMiLCJvdXQiLCJTZXQiLCJ2YWx1ZSIsImFkZCIsIlN0cmluZyIsInRvVXBwZXJDYXNlIiwiaGFzU3ltYm9sIiwic2V0Iiwic3ltYm9sIiwiaGFzIiwiY2xhbXBQYWxldHRlSW5kZXgiLCJpZHgiLCJwYWxldHRlIiwibGVuZ3RoIiwicmVzb2x2ZUJhc2VSaW5nQ29sb3IiLCJmcm96ZW5TdGFnZSIsInJpbmdTdHJhdGVneSIsImRpcmVjdFN5bWJvbCIsImludmVyc2VTeW1ib2wiLCJzeW1ib2xTZXRzIiwiaGFzRGlyZWN0IiwicHJldmlldyIsInBheWxvYWQiLCJoYXNJbnZlcnNlIiwiZGV0ZWN0U2lnbkZsaXAiLCJjdXJyZW50IiwicHJldmlvdXMiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInByZXZTaWduIiwiTWF0aCIsInNpZ24iLCJjdXJyU2lnbiIsInJlc29sdmVDZWxsUHJlc2VudGF0aW9uIiwicnVsZXMiLCJwcmV2VmFsdWUiLCJwYWxldHRlUG9zaXRpdmUiLCJwb3NpdGl2ZVBhbGV0dGUiLCJwYWxldHRlTmVnYXRpdmUiLCJuZWdhdGl2ZVBhbGV0dGUiLCJkZXJpdmVkIiwiZGVyaXZlIiwicHJldmlvdXNEZXJpdmVkIiwidW5kZWZpbmVkIiwicG9sYXJpdHkiLCJiYWNrZ3JvdW5kIiwidGV4dENvbG9yIiwiZWZmZWN0aXZlU3RhZ2UiLCJzdGFnZSIsImFicyIsInplcm9GbG9vciIsInRocmVzaG9sZHMiLCJmaW5kSW5kZXgiLCJ0IiwicGFsZXR0ZUluZGV4IiwiaGV4IiwicmluZ0NvbG9yIiwic2lnbkZsaXAiLCJmaW5hbFJpbmciLCJsb2FkUHJldmlld1N5bWJvbFNldCIsImNvaW5zIiwibm9ybWFsaXplZCIsIm1hcCIsImNvaW4iLCJzeW1ib2xzIiwic291cmNlIiwibm9ybWFsaXplZFN5bWJvbHMiLCJzeW0iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/matrices/colouring.ts\n"));

/***/ })

});