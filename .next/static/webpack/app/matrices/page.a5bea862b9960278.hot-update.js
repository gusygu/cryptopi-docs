"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/matrices/page",{

/***/ "(app-pages-browser)/./src/app/matrices/colouring.ts":
/*!***************************************!*\
  !*** ./src/app/matrices/colouring.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FROZEN_RING_COLORS: () => (/* binding */ FROZEN_RING_COLORS),\n/* harmony export */   FROZEN_STAGE_BACKGROUNDS: () => (/* binding */ FROZEN_STAGE_BACKGROUNDS),\n/* harmony export */   MOO_NEGATIVE_SHADES: () => (/* binding */ MOO_NEGATIVE_SHADES),\n/* harmony export */   MOO_POSITIVE_SHADES: () => (/* binding */ MOO_POSITIVE_SHADES),\n/* harmony export */   MUTED_BACKGROUND: () => (/* binding */ MUTED_BACKGROUND),\n/* harmony export */   NEGATIVE_SHADES: () => (/* binding */ NEGATIVE_SHADES),\n/* harmony export */   POSITIVE_SHADES: () => (/* binding */ POSITIVE_SHADES),\n/* harmony export */   PREVIEW_RING_COLORS: () => (/* binding */ PREVIEW_RING_COLORS),\n/* harmony export */   SIGN_FLIP_RING_COLORS: () => (/* binding */ SIGN_FLIP_RING_COLORS),\n/* harmony export */   ZERO_BACKGROUND: () => (/* binding */ ZERO_BACKGROUND),\n/* harmony export */   loadPreviewSymbolSet: () => (/* binding */ loadPreviewSymbolSet),\n/* harmony export */   resolveCellPresentation: () => (/* binding */ resolveCellPresentation)\n/* harmony export */ });\n/* harmony import */ var _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/features/matrices/colors */ \"(app-pages-browser)/./src/components/features/matrices/colors.ts\");\n/* harmony import */ var _lib_preview__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/preview */ \"(app-pages-browser)/./src/lib/preview.ts\");\n\n\nconst POSITIVE_SHADES = _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_POSITIVE_SHADES;\nconst NEGATIVE_SHADES = _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_NEGATIVE_SHADES;\nconst MOO_POSITIVE_SHADES = _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_MOO_POSITIVE_SHADES;\nconst MOO_NEGATIVE_SHADES = _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_MOO_NEGATIVE_SHADES;\nconst NULL_SENSITIVITY = 1e-8;\nconst ZERO_BACKGROUND = (0,_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.withAlpha)(_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_AMBER, 0.32);\nconst MUTED_BACKGROUND = (0,_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.withAlpha)(_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_MUTED, 0.28);\nconst FROZEN_STAGE_BACKGROUNDS = {\n    recent: (0,_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.withAlpha)(_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS.recent, 0.42),\n    mid: (0,_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.withAlpha)(_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS.mid, 0.5),\n    long: (0,_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.withAlpha)(_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS.long, 0.62)\n};\nconst PREVIEW_RING_COLORS = {\n    direct: \"#34d399\",\n    inverse: \"#f87171\",\n    missing: \"#94a3b8\",\n    frozen: _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.COLOR_FROZEN\n};\nconst FROZEN_RING_COLORS = {\n    recent: _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS.recent,\n    mid: _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS.mid,\n    long: _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS.long\n};\nconst SIGN_FLIP_RING_COLORS = {\n    minusToPlus: \"#38bdf8\",\n    plusToMinus: \"#fb923c\"\n};\nconst makeSet = (values)=>{\n    const out = new Set();\n    for (const value of values){\n        out.add(String(value !== null && value !== void 0 ? value : \"\").toUpperCase());\n    }\n    return out;\n};\nconst hasSymbol = (set, symbol)=>{\n    if (!set) return false;\n    return set.has(String(symbol !== null && symbol !== void 0 ? symbol : \"\").toUpperCase());\n};\nconst clampPaletteIndex = (idx, palette)=>{\n    if (!palette.length) return 0;\n    if (idx < 0) return palette.length - 1;\n    if (idx >= palette.length) return palette.length - 1;\n    return idx;\n};\nfunction resolveBaseRingColor(param) {\n    let { frozen, frozenStage, ringStrategy, directSymbol, inverseSymbol, symbolSets } = param;\n    if (frozen) {\n        if (frozenStage) return _components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.FROZEN_STAGE_COLORS[frozenStage];\n        return PREVIEW_RING_COLORS.frozen;\n    }\n    if (ringStrategy === \"none\") return null;\n    const hasDirect = hasSymbol(symbolSets.preview, directSymbol) || hasSymbol(symbolSets.payload, directSymbol);\n    if (hasDirect) return PREVIEW_RING_COLORS.direct;\n    const hasInverse = hasSymbol(symbolSets.preview, inverseSymbol) || hasSymbol(symbolSets.payload, inverseSymbol);\n    if (hasInverse) return PREVIEW_RING_COLORS.inverse;\n    return PREVIEW_RING_COLORS.missing;\n}\nfunction detectSignFlip(param) {\n    let { ringStrategy, frozen, current, previous } = param;\n    if (ringStrategy !== \"sign-flip\" || frozen) return null;\n    if (current == null || previous == null) return null;\n    if (!Number.isFinite(current) || !Number.isFinite(previous)) return null;\n    const prevSign = Math.sign(previous);\n    const currSign = Math.sign(current);\n    if (prevSign > 0 && currSign < 0) return \"plusToMinus\";\n    if (prevSign < 0 && currSign > 0) return \"minusToPlus\";\n    return null;\n}\nfunction resolveCellPresentation(param) {\n    let { rules, value, prevValue, frozen, frozenStage = null, directSymbol, inverseSymbol, symbolSets } = param;\n    const sanitize = (input)=>{\n        if (input == null) return null;\n        const num = Number(input);\n        if (!Number.isFinite(num)) return null;\n        if (Math.abs(num) <= NULL_SENSITIVITY) return null;\n        return num;\n    };\n    var _rules_positivePalette;\n    const palettePositive = (_rules_positivePalette = rules.positivePalette) !== null && _rules_positivePalette !== void 0 ? _rules_positivePalette : POSITIVE_SHADES;\n    var _rules_negativePalette;\n    const paletteNegative = (_rules_negativePalette = rules.negativePalette) !== null && _rules_negativePalette !== void 0 ? _rules_negativePalette : NEGATIVE_SHADES;\n    const normalizedValue = sanitize(value);\n    const derived = rules.derive(normalizedValue);\n    const normalizedPrev = prevValue === undefined ? null : sanitize(prevValue !== null && prevValue !== void 0 ? prevValue : null);\n    const previousDerived = prevValue === undefined ? null : rules.derive(normalizedPrev);\n    let polarity = \"neutral\";\n    let background = normalizedValue == null ? ZERO_BACKGROUND : MUTED_BACKGROUND;\n    let textColor;\n    const effectiveStage = frozenStage !== null && frozenStage !== void 0 ? frozenStage : frozen ? \"mid\" : null;\n    if (frozen || effectiveStage) {\n        const stage = effectiveStage !== null && effectiveStage !== void 0 ? effectiveStage : \"mid\";\n        background = FROZEN_STAGE_BACKGROUNDS[stage];\n        textColor = stage === \"long\" ? \"#ede9fe\" : \"#20103f\";\n    } else if (derived != null && Number.isFinite(derived)) {\n        const abs = Math.abs(derived);\n        if (abs < rules.zeroFloor) {\n            background = ZERO_BACKGROUND;\n            textColor = \"#422006\";\n        } else {\n            const idx = rules.thresholds.findIndex((t)=>abs < t);\n            const palette = derived >= 0 ? palettePositive : paletteNegative;\n            const paletteIndex = clampPaletteIndex(idx === -1 ? palette.length - 1 : idx, palette);\n            var _palette_paletteIndex, _ref;\n            const hex = (_ref = (_palette_paletteIndex = palette[paletteIndex]) !== null && _palette_paletteIndex !== void 0 ? _palette_paletteIndex : palette[palette.length - 1]) !== null && _ref !== void 0 ? _ref : \"#0f172a\";\n            background = (0,_components_features_matrices_colors__WEBPACK_IMPORTED_MODULE_0__.withAlpha)(hex, 0.85);\n            polarity = derived >= 0 ? \"positive\" : \"negative\";\n        }\n    } else {\n        background = MUTED_BACKGROUND;\n    }\n    const ringColor = resolveBaseRingColor({\n        frozen,\n        frozenStage: effectiveStage,\n        ringStrategy: rules.ringStrategy,\n        directSymbol,\n        inverseSymbol,\n        symbolSets\n    });\n    const signFlip = detectSignFlip({\n        ringStrategy: rules.ringStrategy,\n        frozen,\n        current: derived,\n        previous: previousDerived\n    });\n    let finalRing = ringColor;\n    if (signFlip === \"plusToMinus\") {\n        finalRing = SIGN_FLIP_RING_COLORS.plusToMinus;\n    } else if (signFlip === \"minusToPlus\") {\n        finalRing = SIGN_FLIP_RING_COLORS.minusToPlus;\n    }\n    return {\n        background,\n        polarity,\n        textColor,\n        ringColor: finalRing,\n        derived,\n        signFlip,\n        frozenStage: effectiveStage\n    };\n}\nasync function loadPreviewSymbolSet(coins) {\n    const normalized = coins.map((coin)=>String(coin !== null && coin !== void 0 ? coin : \"\").toUpperCase());\n    const { symbols, source } = await (0,_lib_preview__WEBPACK_IMPORTED_MODULE_1__.getPreviewSymbols)(normalized);\n    const normalizedSymbols = symbols.map((sym)=>String(sym !== null && sym !== void 0 ? sym : \"\").toUpperCase());\n    return {\n        symbols: normalizedSymbols,\n        set: makeSet(normalizedSymbols),\n        source\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvbWF0cmljZXMvY29sb3VyaW5nLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBWStDO0FBQ3VCO0FBd0IvRCxNQUFNVSxrQkFBa0JOLHVGQUFxQkEsQ0FBQztBQUM5QyxNQUFNTyxrQkFBa0JSLHVGQUFxQkEsQ0FBQztBQUM5QyxNQUFNUyxzQkFBc0JOLDJGQUF5QkEsQ0FBQztBQUN0RCxNQUFNTyxzQkFBc0JSLDJGQUF5QkEsQ0FBQztBQUU3RCxNQUFNUyxtQkFBbUI7QUFFbEIsTUFBTUMsa0JBQWtCUCwrRUFBU0EsQ0FBQ1IsNkVBQVdBLEVBQUUsTUFBTTtBQUNyRCxNQUFNZ0IsbUJBQW1CUiwrRUFBU0EsQ0FBQ04sNkVBQVdBLEVBQUUsTUFBTTtBQUN0RCxNQUFNZSwyQkFBd0Q7SUFDbkVDLFFBQVFWLCtFQUFTQSxDQUFDRCxxRkFBbUJBLENBQUNXLE1BQU0sRUFBRTtJQUM5Q0MsS0FBS1gsK0VBQVNBLENBQUNELHFGQUFtQkEsQ0FBQ1ksR0FBRyxFQUFFO0lBQ3hDQyxNQUFNWiwrRUFBU0EsQ0FBQ0QscUZBQW1CQSxDQUFDYSxJQUFJLEVBQUU7QUFDNUMsRUFBRTtBQUVLLE1BQU1DLHNCQUFzQjtJQUNqQ0MsUUFBUTtJQUNSQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsUUFBUXhCLDhFQUFZQTtBQUN0QixFQUFXO0FBRUosTUFBTXlCLHFCQUFrRDtJQUM3RFIsUUFBUVgscUZBQW1CQSxDQUFDVyxNQUFNO0lBQ2xDQyxLQUFLWixxRkFBbUJBLENBQUNZLEdBQUc7SUFDNUJDLE1BQU1iLHFGQUFtQkEsQ0FBQ2EsSUFBSTtBQUNoQyxFQUFFO0FBRUssTUFBTU8sd0JBQXdCO0lBQ25DQyxhQUFhO0lBQ2JDLGFBQWE7QUFDZixFQUFXO0FBT1gsTUFBTUMsVUFBVSxDQUFDQztJQUNmLE1BQU1DLE1BQU0sSUFBSUM7SUFDaEIsS0FBSyxNQUFNQyxTQUFTSCxPQUFRO1FBQzFCQyxJQUFJRyxHQUFHLENB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QUFJLGFBQWE7UUFDekM7SUFDRixPQUFPO1FBQ0xNLGFBQWFuRTtJQUNmO0lBRUEsTUFBTTZFLFlBQVkvQyxxQkFBcUI7UUFDckNyQjtRQUNBc0IsYUFBYXNDO1FBQ2JyQyxjQUFja0IsTUFBTWxCLFlBQVk7UUFDaENDO1FBQ0FDO1FBQ0FDO0lBQ0Y7SUFFQSxNQUFNMkMsV0FBV3RDLGVBQWU7UUFDOUJSLGNBQWNrQixNQUFNbEIsWUFBWTtRQUNoQ3ZCO1FBQ0FnQyxTQUFTb0I7UUFDVG5CLFVBQVV1QjtJQUNaO0lBRUEsSUFBSWMsWUFBWUY7SUFDaEIsSUFBSUMsYUFBYSxlQUFlO1FBQzlCQyxZQUFZcEUsc0JBQXNCRSxXQUFXO0lBQy9DLE9BQU8sSUFBSWlFLGFBQWEsZUFBZTtRQUNyQ0MsWUFBWXBFLHNCQUFzQkMsV0FBVztJQUMvQztJQUVBLE9BQU87UUFDTHVEO1FBQ0FEO1FBQ0FFO1FBQ0FTLFdBQVdFO1FBQ1hsQjtRQUNBaUI7UUFDQS9DLGFBQWFzQztJQUNmO0FBQ0Y7QUFFTyxlQUFlVyxxQkFDcEJDLEtBQWU7SUFFZixNQUFNQyxhQUFhRCxNQUFNRSxHQUFHLENBQUMsQ0FBQ0MsT0FBU2hFLE9BQU9nRSxpQkFBQUEsa0JBQUFBLE9BQVEsSUFBSS9ELFdBQVc7SUFDckUsTUFBTSxFQUFFZ0UsT0FBTyxFQUFFQyxNQUFNLEVBQUUsR0FBRyxNQUFNN0YsK0RBQWlCQSxDQUFDeUY7SUFDcEQsTUFBTUssb0JBQW9CRixRQUFRRixHQUFHLENBQUMsQ0FBQ0ssTUFBUXBFLE9BQU9vRSxnQkFBQUEsaUJBQUFBLE1BQU8sSUFBSW5FLFdBQVc7SUFDNUUsT0FBTztRQUNMZ0UsU0FBU0U7UUFDVGhFLEtBQUtULFFBQVF5RTtRQUNiRDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxhcHBcXG1hdHJpY2VzXFxjb2xvdXJpbmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBNYXRyaXhDZWxsIH0gZnJvbSBcIkAvY29tcG9uZW50cy9mZWF0dXJlcy9tYXRyaWNlcy9NYXRyaXhcIjtcbmltcG9ydCB7XG4gIENPTE9SX0FNQkVSLFxuICBDT0xPUl9GUk9aRU4sXG4gIENPTE9SX01VVEVELFxuICBDT0xPUl9ORUdBVElWRV9TSEFERVMsXG4gIENPTE9SX1BPU0lUSVZFX1NIQURFUyxcbiAgQ09MT1JfTU9PX05FR0FUSVZFX1NIQURFUyxcbiAgQ09MT1JfTU9PX1BPU0lUSVZFX1NIQURFUyxcbiAgRlJPWkVOX1NUQUdFX0NPTE9SUyxcbiAgdHlwZSBGcm96ZW5TdGFnZSxcbiAgd2l0aEFscGhhLFxufSBmcm9tIFwiQC9jb21wb25lbnRzL2ZlYXR1cmVzL21hdHJpY2VzL2NvbG9yc1wiO1xuaW1wb3J0IHsgZ2V0UHJldmlld1N5bWJvbHMsIHR5cGUgUHJldmlld1NvdXJjZSB9IGZyb20gXCJAL2xpYi9wcmV2aWV3XCI7XG5cbmV4cG9ydCB0eXBlIFJpbmdTdHJhdGVneSA9IFwicHJldmlld1wiIHwgXCJzaWduLWZsaXBcIiB8IFwibm9uZVwiO1xuXG5leHBvcnQgdHlwZSBNYXRyaXhDb2xvclJ1bGVzID0ge1xuICBrZXk6IHN0cmluZztcbiAgdGhyZXNob2xkczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHBvc2l0aXZlUGFsZXR0ZT86IHJlYWRvbmx5IHN0cmluZ1tdO1xuICBuZWdhdGl2ZVBhbGV0dGU/OiByZWFkb25seSBzdHJpbmdbXTtcbiAgemVyb0Zsb29yOiBudW1iZXI7XG4gIGRlcml2ZTogKHZhbHVlOiBudW1iZXIgfCBudWxsKSA9PiBudW1iZXIgfCBudWxsO1xuICByaW5nU3RyYXRlZ3k6IFJpbmdTdHJhdGVneTtcbn07XG5cbmV4cG9ydCB0eXBlIENlbGxQcmVzZW50YXRpb24gPSB7XG4gIGJhY2tncm91bmQ6IHN0cmluZztcbiAgcG9sYXJpdHk6IE1hdHJpeENlbGxbXCJwb2xhcml0eVwiXTtcbiAgdGV4dENvbG9yPzogc3RyaW5nO1xuICByaW5nQ29sb3I6IHN0cmluZyB8IG51bGw7XG4gIGRlcml2ZWQ6IG51bWJlciB8IG51bGw7XG4gIHNpZ25GbGlwOiBcInBsdXNUb01pbnVzXCIgfCBcIm1pbnVzVG9QbHVzXCIgfCBudWxsO1xuICBmcm96ZW5TdGFnZTogRnJvemVuU3RhZ2UgfCBudWxsO1xufTtcblxuZXhwb3J0IGNvbnN0IFBPU0lUSVZFX1NIQURFUyA9IENPTE9SX1BPU0lUSVZFX1NIQURFUztcbmV4cG9ydCBjb25zdCBORUdBVElWRV9TSEFERVMgPSBDT0xPUl9ORUdBVElWRV9TSEFERVM7XG5leHBvcnQgY29uc3QgTU9PX1BPU0lUSVZFX1NIQURFUyA9IENPTE9SX01PT19QT1NJVElWRV9TSEFERVM7XG5leHBvcnQgY29uc3QgTU9PX05FR0FUSVZFX1NIQURFUyA9IENPTE9SX01PT19ORUdBVElWRV9TSEFERVM7XG5cbmNvbnN0IE5VTExfU0VOU0lUSVZJVFkgPSAxZS04O1xuXG5leHBvcnQgY29uc3QgWkVST19CQUNLR1JPVU5EID0gd2l0aEFscGhhKENPTE9SX0FNQkVSLCAwLjMyKTtcbmV4cG9ydCBjb25zdCBNVVRFRF9CQUNLR1JPVU5EID0gd2l0aEFscGhhKENPTE9SX01VVEVELCAwLjI4KTtcbmV4cG9ydCBjb25zdCBGUk9aRU5fU1RBR0VfQkFDS0dST1VORFM6IFJlY29yZDxGcm96ZW5TdGFnZSwgc3RyaW5nPiA9IHtcbiAgcmVjZW50OiB3aXRoQWxwaGEoRlJPWkVOX1NUQUdFX0NPTE9SUy5yZWNlbnQsIDAuNDIpLFxuICBtaWQ6IHdpdGhBbHBoYShGUk9aRU5fU1RBR0VfQ09MT1JTLm1pZCwgMC41KSxcbiAgbG9uZzogd2l0aEFscGhhKEZST1pFTl9TVEFHRV9DT0xPUlMubG9uZywgMC42MiksXG59O1xuXG5leHBvcnQgY29uc3QgUFJFVklFV19SSU5HX0NPTE9SUyA9IHtcbiAgZGlyZWN0OiBcIiMzNGQzOTlcIixcbiAgaW52ZXJzZTogXCIjZjg3MTcxXCIsXG4gIG1pc3Npbmc6IFwiIzk0YTNiOFwiLFxuICBmcm96ZW46IENPTE9SX0ZST1pFTixcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBGUk9aRU5fUklOR19DT0xPUlM6IFJlY29yZDxGcm96ZW5TdGFnZSwgc3RyaW5nPiA9IHtcbiAgcmVjZW50OiBGUk9aRU5fU1RBR0VfQ09MT1JTLnJlY2VudCxcbiAgbWlkOiBGUk9aRU5fU1RBR0VfQ09MT1JTLm1pZCxcbiAgbG9uZzogRlJPWkVOX1NUQUdFX0NPTE9SUy5sb25nLFxufTtcblxuZXhwb3J0IGNvbnN0IFNJR05fRkxJUF9SSU5HX0NPTE9SUyA9IHtcbiAgbWludXNUb1BsdXM6IFwiIzM4YmRmOFwiLFxuICBwbHVzVG9NaW51czogXCIjZmI5MjNjXCIsXG59IGFzIGNvbnN0O1xuXG50eXBlIFN5bWJvbFNldHMgPSB7XG4gIHByZXZpZXc6IFNldDxzdHJpbmc+O1xuICBwYXlsb2FkPzogU2V0PHN0cmluZz47XG59O1xuXG5jb25zdCBtYWtlU2V0ID0gKHZhbHVlczogSXRlcmFibGU8c3RyaW5nPik6IFNldDxzdHJpbmc+ID0+IHtcbiAgY29uc3Qgb3V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgb3V0LmFkZChTdHJpbmcodmFsdWUgPz8gXCJcIikudG9VcHBlckNhc2UoKSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbmNvbnN0IGhhc1N5bWJvbCA9IChzZXQ6IFNldDxzdHJpbmc+IHwgdW5kZWZpbmVkLCBzeW1ib2w6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICBpZiAoIXNldCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gc2V0LmhhcyhTdHJpbmcoc3ltYm9sID8/IFwiXCIpLnRvVXBwZXJDYXNlKCkpO1xufTtcblxuY29uc3QgY2xhbXBQYWxldHRlSW5kZXggPSAoaWR4OiBudW1iZXIsIHBhbGV0dGU6IHJlYWRvbmx5IHN0cmluZ1tdKTogbnVtYmVyID0+IHtcbiAgaWYgKCFwYWxldHRlLmxlbmd0aCkgcmV0dXJuIDA7XG4gIGlmIChpZHggPCAwKSByZXR1cm4gcGFsZXR0ZS5sZW5ndGggLSAxO1xuICBpZiAoaWR4ID49IHBhbGV0dGUubGVuZ3RoKSByZXR1cm4gcGFsZXR0ZS5sZW5ndGggLSAxO1xuICByZXR1cm4gaWR4O1xufTtcblxuZnVuY3Rpb24gcmVzb2x2ZUJhc2VSaW5nQ29sb3Ioe1xuICBmcm96ZW4sXG4gIGZyb3plblN0YWdlLFxuICByaW5nU3RyYXRlZ3ksXG4gIGRpcmVjdFN5bWJvbCxcbiAgaW52ZXJzZVN5bWJvbCxcbiAgc3ltYm9sU2V0cyxcbn06IHtcbiAgZnJvemVuOiBib29sZWFuO1xuICBmcm96ZW5TdGFnZTogRnJvemVuU3RhZ2UgfCBudWxsO1xuICByaW5nU3RyYXRlZ3k6IFJpbmdTdHJhdGVneTtcbiAgZGlyZWN0U3ltYm9sOiBzdHJpbmc7XG4gIGludmVyc2VTeW1ib2w6IHN0cmluZztcbiAgc3ltYm9sU2V0czogU3ltYm9sU2V0cztcbn0pOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKGZyb3plbikge1xuICAgIGlmIChmcm96ZW5TdGFnZSkgcmV0dXJuIEZST1pFTl9TVEFHRV9DT0xPUlNbZnJvemVuU3RhZ2VdO1xuICAgIHJldHVybiBQUkVWSUVXX1JJTkdfQ09MT1JTLmZyb3plbjtcbiAgfVxuICBpZiAocmluZ1N0cmF0ZWd5ID09PSBcIm5vbmVcIikgcmV0dXJuIG51bGw7XG5cbiAgY29uc3QgaGFzRGlyZWN0ID0gaGFzU3ltYm9sKHN5bWJvbFNldHMucHJldmlldywgZGlyZWN0U3ltYm9sKSB8fCBoYXNTeW1ib2woc3ltYm9sU2V0cy5wYXlsb2FkLCBkaXJlY3RTeW1ib2wpO1xuICBpZiAoaGFzRGlyZWN0KSByZXR1cm4gUFJFVklFV19SSU5HX0NPTE9SUy5kaXJlY3Q7XG5cbiAgY29uc3QgaGFzSW52ZXJzZSA9IGhhc1N5bWJvbChzeW1ib2xTZXRzLnByZXZpZXcsIGludmVyc2VTeW1ib2wpIHx8IGhhc1N5bWJvbChzeW1ib2xTZXRzLnBheWxvYWQsIGludmVyc2VTeW1ib2wpO1xuICBpZiAoaGFzSW52ZXJzZSkgcmV0dXJuIFBSRVZJRVdfUklOR19DT0xPUlMuaW52ZXJzZTtcblxuICByZXR1cm4gUFJFVklFV19SSU5HX0NPTE9SUy5taXNzaW5nO1xufVxuXG5mdW5jdGlvbiBkZXRlY3RTaWduRmxpcCh7XG4gIHJpbmdTdHJhdGVneSxcbiAgZnJvemVuLFxuICBjdXJyZW50LFxuICBwcmV2aW91cyxcbn06IHtcbiAgcmluZ1N0cmF0ZWd5OiBSaW5nU3RyYXRlZ3k7XG4gIGZyb3plbjogYm9vbGVhbjtcbiAgY3VycmVudDogbnVtYmVyIHwgbnVsbDtcbiAgcHJldmlvdXM6IG51bWJlciB8IG51bGw7XG59KTogXCJwbHVzVG9NaW51c1wiIHwgXCJtaW51c1RvUGx1c1wiIHwgbnVsbCB7XG4gIGlmIChyaW5nU3RyYXRlZ3kgIT09IFwic2lnbi1mbGlwXCIgfHwgZnJvemVuKSByZXR1cm4gbnVsbDtcbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCB8fCBwcmV2aW91cyA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoY3VycmVudCkgfHwgIU51bWJlci5pc0Zpbml0ZShwcmV2aW91cykpIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IHByZXZTaWduID0gTWF0aC5zaWduKHByZXZpb3VzKTtcbiAgY29uc3QgY3VyclNpZ24gPSBNYXRoLnNpZ24oY3VycmVudCk7XG4gIGlmIChwcmV2U2lnbiA+IDAgJiYgY3VyclNpZ24gPCAwKSByZXR1cm4gXCJwbHVzVG9NaW51c1wiO1xuICBpZiAocHJldlNpZ24gPCAwICYmIGN1cnJTaWduID4gMCkgcmV0dXJuIFwibWludXNUb1BsdXNcIjtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQ2VsbFByZXNlbnRhdGlvbih7XG4gIHJ1bGVzLFxuICB2YWx1ZSxcbiAgcHJldlZhbHVlLFxuICBmcm96ZW4sXG4gIGZyb3plblN0YWdlID0gbnVsbCxcbiAgZGlyZWN0U3ltYm9sLFxuICBpbnZlcnNlU3ltYm9sLFxuICBzeW1ib2xTZXRzLFxufToge1xuICBydWxlczogTWF0cml4Q29sb3JSdWxlcztcbiAgdmFsdWU6IG51bWJlciB8IG51bGw7XG4gIHByZXZWYWx1ZT86IG51bWJlciB8IG51bGw7XG4gIGZyb3plbjogYm9vbGVhbjtcbiAgZnJvemVuU3RhZ2U/OiBGcm96ZW5TdGFnZSB8IG51bGw7XG4gIGRpcmVjdFN5bWJvbDogc3RyaW5nO1xuICBpbnZlcnNlU3ltYm9sOiBzdHJpbmc7XG4gIHN5bWJvbFNldHM6IFN5bWJvbFNldHM7XG59KTogQ2VsbFByZXNlbnRhdGlvbiB7XG4gIGNvbnN0IHNhbml0aXplID0gKGlucHV0OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkKTogbnVtYmVyIHwgbnVsbCA9PiB7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IG51bSA9IE51bWJlcihpbnB1dCk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobnVtKSkgcmV0dXJuIG51bGw7XG4gICAgaWYgKE1hdGguYWJzKG51bSkgPD0gTlVMTF9TRU5TSVRJVklUWSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICBjb25zdCBwYWxldHRlUG9zaXRpdmUgPSBydWxlcy5wb3NpdGl2ZVBhbGV0dGUgPz8gUE9TSVRJVkVfU0hBREVTO1xuICBjb25zdCBwYWxldHRlTmVnYXRpdmUgPSBydWxlcy5uZWdhdGl2ZVBhbGV0dGUgPz8gTkVHQVRJVkVfU0hBREVTO1xuICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSBzYW5pdGl6ZSh2YWx1ZSk7XG4gIGNvbnN0IGRlcml2ZWQgPSBydWxlcy5kZXJpdmUobm9ybWFsaXplZFZhbHVlKTtcbiAgY29uc3Qgbm9ybWFsaXplZFByZXYgPSBwcmV2VmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBzYW5pdGl6ZShwcmV2VmFsdWUgPz8gbnVsbCk7XG4gIGNvbnN0IHByZXZpb3VzRGVyaXZlZCA9IHByZXZWYWx1ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHJ1bGVzLmRlcml2ZShub3JtYWxpemVkUHJldik7XG5cbiAgbGV0IHBvbGFyaXR5OiBNYXRyaXhDZWxsW1wicG9sYXJpdHlcIl0gPSBcIm5ldXRyYWxcIjtcbiAgbGV0IGJhY2tncm91bmQgPSBub3JtYWxpemVkVmFsdWUgPT0gbnVsbCA/IFpFUk9fQkFDS0dST1VORCA6IE1VVEVEX0JBQ0tHUk9VTkQ7XG4gIGxldCB0ZXh0Q29sb3I6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICBjb25zdCBlZmZlY3RpdmVTdGFnZTogRnJvemVuU3RhZ2UgfCBudWxsID0gZnJvemVuU3RhZ2UgPz8gKGZyb3plbiA/IFwibWlkXCIgOiBudWxsKTtcblxuICBpZiAoZnJvemVuIHx8IGVmZmVjdGl2ZVN0YWdlKSB7XG4gICAgY29uc3Qgc3RhZ2UgPSBlZmZlY3RpdmVTdGFnZSA/PyBcIm1pZFwiO1xuICAgIGJhY2tncm91bmQgPSBGUk9aRU5fU1RBR0VfQkFDS0dST1VORFNbc3RhZ2VdO1xuICAgIHRleHRDb2xvciA9IHN0YWdlID09PSBcImxvbmdcIiA/IFwiI2VkZTlmZVwiIDogXCIjMjAxMDNmXCI7XG4gIH0gZWxzZSBpZiAoZGVyaXZlZCAhPSBudWxsICYmIE51bWJlci5pc0Zpbml0ZShkZXJpdmVkKSkge1xuICAgIGNvbnN0IGFicyA9IE1hdGguYWJzKGRlcml2ZWQpO1xuICAgIGlmIChhYnMgPCBydWxlcy56ZXJvRmxvb3IpIHtcbiAgICAgIGJhY2tncm91bmQgPSBaRVJPX0JBQ0tHUk9VTkQ7XG4gICAgICB0ZXh0Q29sb3IgPSBcIiM0MjIwMDZcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaWR4ID0gcnVsZXMudGhyZXNob2xkcy5maW5kSW5kZXgoKHQpID0+IGFicyA8IHQpO1xuICAgICAgY29uc3QgcGFsZXR0ZSA9IGRlcml2ZWQgPj0gMCA/IHBhbGV0dGVQb3NpdGl2ZSA6IHBhbGV0dGVOZWdhdGl2ZTtcbiAgICAgIGNvbnN0IHBhbGV0dGVJbmRleCA9IGNsYW1wUGFsZXR0ZUluZGV4KGlkeCA9PT0gLTEgPyBwYWxldHRlLmxlbmd0aCAtIDEgOiBpZHgsIHBhbGV0dGUpO1xuICAgICAgY29uc3QgaGV4ID0gcGFsZXR0ZVtwYWxldHRlSW5kZXhdID8/IHBhbGV0dGVbcGFsZXR0ZS5sZW5ndGggLSAxXSA/PyBcIiMwZjE3MmFcIjtcbiAgICAgIGJhY2tncm91bmQgPSB3aXRoQWxwaGEoaGV4LCAwLjg1KTtcbiAgICAgIHBvbGFyaXR5ID0gZGVyaXZlZCA+PSAwID8gXCJwb3NpdGl2ZVwiIDogXCJuZWdhdGl2ZVwiO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiYWNrZ3JvdW5kID0gTVVURURfQkFDS0dST1VORDtcbiAgfVxuXG4gIGNvbnN0IHJpbmdDb2xvciA9IHJlc29sdmVCYXNlUmluZ0NvbG9yKHtcbiAgICBmcm96ZW4sXG4gICAgZnJvemVuU3RhZ2U6IGVmZmVjdGl2ZVN0YWdlLFxuICAgIHJpbmdTdHJhdGVneTogcnVsZXMucmluZ1N0cmF0ZWd5LFxuICAgIGRpcmVjdFN5bWJvbCxcbiAgICBpbnZlcnNlU3ltYm9sLFxuICAgIHN5bWJvbFNldHMsXG4gIH0pO1xuXG4gIGNvbnN0IHNpZ25GbGlwID0gZGV0ZWN0U2lnbkZsaXAoe1xuICAgIHJpbmdTdHJhdGVneTogcnVsZXMucmluZ1N0cmF0ZWd5LFxuICAgIGZyb3plbixcbiAgICBjdXJyZW50OiBkZXJpdmVkLFxuICAgIHByZXZpb3VzOiBwcmV2aW91c0Rlcml2ZWQsXG4gIH0pO1xuXG4gIGxldCBmaW5hbFJpbmcgPSByaW5nQ29sb3I7XG4gIGlmIChzaWduRmxpcCA9PT0gXCJwbHVzVG9NaW51c1wiKSB7XG4gICAgZmluYWxSaW5nID0gU0lHTl9GTElQX1JJTkdfQ09MT1JTLnBsdXNUb01pbnVzO1xuICB9IGVsc2UgaWYgKHNpZ25GbGlwID09PSBcIm1pbnVzVG9QbHVzXCIpIHtcbiAgICBmaW5hbFJpbmcgPSBTSUdOX0ZMSVBfUklOR19DT0xPUlMubWludXNUb1BsdXM7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmQsXG4gICAgcG9sYXJpdHksXG4gICAgdGV4dENvbG9yLFxuICAgIHJpbmdDb2xvcjogZmluYWxSaW5nLFxuICAgIGRlcml2ZWQsXG4gICAgc2lnbkZsaXAsXG4gICAgZnJvemVuU3RhZ2U6IGVmZmVjdGl2ZVN0YWdlLFxuICB9O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZFByZXZpZXdTeW1ib2xTZXQoXG4gIGNvaW5zOiBzdHJpbmdbXVxuKTogUHJvbWlzZTx7IHN5bWJvbHM6IHN0cmluZ1tdOyBzZXQ6IFNldDxzdHJpbmc+OyBzb3VyY2U6IFByZXZpZXdTb3VyY2UgfT4ge1xuICBjb25zdCBub3JtYWxpemVkID0gY29pbnMubWFwKChjb2luKSA9PiBTdHJpbmcoY29pbiA/PyBcIlwiKS50b1VwcGVyQ2FzZSgpKTtcbiAgY29uc3QgeyBzeW1ib2xzLCBzb3VyY2UgfSA9IGF3YWl0IGdldFByZXZpZXdTeW1ib2xzKG5vcm1hbGl6ZWQpO1xuICBjb25zdCBub3JtYWxpemVkU3ltYm9scyA9IHN5bWJvbHMubWFwKChzeW0pID0+IFN0cmluZyhzeW0gPz8gXCJcIikudG9VcHBlckNhc2UoKSk7XG4gIHJldHVybiB7XG4gICAgc3ltYm9sczogbm9ybWFsaXplZFN5bWJvbHMsXG4gICAgc2V0OiBtYWtlU2V0KG5vcm1hbGl6ZWRTeW1ib2xzKSxcbiAgICBzb3VyY2UsXG4gIH07XG59XG4iXSwibmFtZXMiOlsiQ09MT1JfQU1CRVIiLCJDT0xPUl9GUk9aRU4iLCJDT0xPUl9NVVRFRCIsIkNPTE9SX05FR0FUSVZFX1NIQURFUyIsIkNPTE9SX1BPU0lUSVZFX1NIQURFUyIsIkNPTE9SX01PT19ORUdBVElWRV9TSEFERVMiLCJDT0xPUl9NT09fUE9TSVRJVkVfU0hBREVTIiwiRlJPWkVOX1NUQUdFX0NPTE9SUyIsIndpdGhBbHBoYSIsImdldFByZXZpZXdTeW1ib2xzIiwiUE9TSVRJVkVfU0hBREVTIiwiTkVHQVRJVkVfU0hBREVTIiwiTU9PX1BPU0lUSVZFX1NIQURFUyIsIk1PT19ORUdBVElWRV9TSEFERVMiLCJOVUxMX1NFTlNJVElWSVRZIiwiWkVST19CQUNLR1JPVU5EIiwiTVVURURfQkFDS0dST1VORCIsIkZST1pFTl9TVEFHRV9CQUNLR1JPVU5EUyIsInJlY2VudCIsIm1pZCIsImxvbmciLCJQUkVWSUVXX1JJTkdfQ09MT1JTIiwiZGlyZWN0IiwiaW52ZXJzZSIsIm1pc3NpbmciLCJmcm96ZW4iLCJGUk9aRU5fUklOR19DT0xPUlMiLCJTSUdOX0ZMSVBfUklOR19DT0xPUlMiLCJtaW51c1RvUGx1cyIsInBsdXNUb01pbnVzIiwibWFrZVNldCIsInZhbHVlcyIsIm91dCIsIlNldCIsInZhbHVlIiwiYWRkIiwiU3RyaW5nIiwidG9VcHBlckNhc2UiLCJoYXNTeW1ib2wiLCJzZXQiLCJzeW1ib2wiLCJoYXMiLCJjbGFtcFBhbGV0dGVJbmRleCIsImlkeCIsInBhbGV0dGUiLCJsZW5ndGgiLCJyZXNvbHZlQmFzZVJpbmdDb2xvciIsImZyb3plblN0YWdlIiwicmluZ1N0cmF0ZWd5IiwiZGlyZWN0U3ltYm9sIiwiaW52ZXJzZVN5bWJvbCIsInN5bWJvbFNldHMiLCJoYXNEaXJlY3QiLCJwcmV2aWV3IiwicGF5bG9hZCIsImhhc0ludmVyc2UiLCJkZXRlY3RTaWduRmxpcCIsImN1cnJlbnQiLCJwcmV2aW91cyIsIk51bWJlciIsImlzRmluaXRlIiwicHJldlNpZ24iLCJNYXRoIiwic2lnbiIsImN1cnJTaWduIiwicmVzb2x2ZUNlbGxQcmVzZW50YXRpb24iLCJydWxlcyIsInByZXZWYWx1ZSIsInNhbml0aXplIiwiaW5wdXQiLCJudW0iLCJhYnMiLCJwYWxldHRlUG9zaXRpdmUiLCJwb3NpdGl2ZVBhbGV0dGUiLCJwYWxldHRlTmVnYXRpdmUiLCJuZWdhdGl2ZVBhbGV0dGUiLCJub3JtYWxpemVkVmFsdWUiLCJkZXJpdmVkIiwiZGVyaXZlIiwibm9ybWFsaXplZFByZXYiLCJ1bmRlZmluZWQiLCJwcmV2aW91c0Rlcml2ZWQiLCJwb2xhcml0eSIsImJhY2tncm91bmQiLCJ0ZXh0Q29sb3IiLCJlZmZlY3RpdmVTdGFnZSIsInN0YWdlIiwiemVyb0Zsb29yIiwidGhyZXNob2xkcyIsImZpbmRJbmRleCIsInQiLCJwYWxldHRlSW5kZXgiLCJoZXgiLCJyaW5nQ29sb3IiLCJzaWduRmxpcCIsImZpbmFsUmluZyIsImxvYWRQcmV2aWV3U3ltYm9sU2V0IiwiY29pbnMiLCJub3JtYWxpemVkIiwibWFwIiwiY29pbiIsInN5bWJvbHMiLCJzb3VyY2UiLCJub3JtYWxpemVkU3ltYm9scyIsInN5bSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/matrices/colouring.ts\n"));

/***/ })

});