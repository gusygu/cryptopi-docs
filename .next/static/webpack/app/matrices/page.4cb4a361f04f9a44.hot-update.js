"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/matrices/page",{

/***/ "(app-pages-browser)/./src/components/features/matrices/colors.ts":
/*!****************************************************!*\
  !*** ./src/components/features/matrices/colors.ts ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   COLOR_AMBER: () => (/* binding */ COLOR_AMBER),\n/* harmony export */   COLOR_FROZEN: () => (/* binding */ COLOR_FROZEN),\n/* harmony export */   COLOR_MOO_NEGATIVE_SHADES: () => (/* binding */ COLOR_MOO_NEGATIVE_SHADES),\n/* harmony export */   COLOR_MOO_POSITIVE_SHADES: () => (/* binding */ COLOR_MOO_POSITIVE_SHADES),\n/* harmony export */   COLOR_MUTED: () => (/* binding */ COLOR_MUTED),\n/* harmony export */   COLOR_NEGATIVE_SHADES: () => (/* binding */ COLOR_NEGATIVE_SHADES),\n/* harmony export */   COLOR_POSITIVE_SHADES: () => (/* binding */ COLOR_POSITIVE_SHADES),\n/* harmony export */   FROZEN_STAGE_COLORS: () => (/* binding */ FROZEN_STAGE_COLORS),\n/* harmony export */   colorForChange: () => (/* binding */ colorForChange),\n/* harmony export */   withAlpha: () => (/* binding */ withAlpha)\n/* harmony export */ });\nconst COLOR_POSITIVE_SHADES = [\n    \"#e1f8ec\",\n    \"#bdf3d4\",\n    \"#8ce9b4\",\n    \"#53d68a\",\n    \"#25c064\",\n    \"#14974a\",\n    \"#0f7639\",\n    \"#0b4f27\"\n];\nconst COLOR_NEGATIVE_SHADES = [\n    \"#ffe6e2\",\n    \"#ffc9c1\",\n    \"#ffa294\",\n    \"#ff7a68\",\n    \"#ff4f3d\",\n    \"#e0321f\",\n    \"#b71f14\",\n    \"#8a1a0d\"\n];\nconst COLOR_MOO_POSITIVE_SHADES = [\n    \"#e0f0ff\",\n    \"#c3e1ff\",\n    \"#9dcfff\",\n    \"#71b8ff\",\n    \"#4297ff\",\n    \"#2274e6\",\n    \"#1758b5\",\n    \"#0f3c7d\"\n];\nconst COLOR_MOO_NEGATIVE_SHADES = [\n    \"#ffe9d6\",\n    \"#ffd2ad\",\n    \"#ffb078\",\n    \"#ff9152\",\n    \"#ff732e\",\n    \"#e45911\",\n    \"#b84508\",\n    \"#7c2c04\"\n];\nconst COLOR_AMBER = \"#facc15\";\nconst COLOR_MUTED = \"rgba(148, 163, 184, 0.28)\";\nconst COLOR_FROZEN = \"#a855f7\";\nconst FROZEN_STAGE_COLORS = {\n    recent: \"#d8b4fe\",\n    mid: COLOR_FROZEN,\n    long: \"#6d28d9\"\n};\nconst MAG_THRESHOLDS = [\n    0.0005,\n    0.0015,\n    0.003,\n    0.006,\n    0.0125,\n    0.025,\n    0.05\n];\nfunction colorForChange(value) {\n    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { frozen = false, frozenStage = null, zeroFloor = MAG_THRESHOLDS[0] } = opts;\n    if (frozenStage) return FROZEN_STAGE_COLORS[frozenStage];\n    if (frozen) return COLOR_FROZEN;\n    if (value == null || !Number.isFinite(value)) return COLOR_MUTED;\n    const abs = Math.abs(value);\n    if (abs < zeroFloor) return COLOR_AMBER;\n    let idx = MAG_THRESHOLDS.findIndex((t)=>abs < t);\n    if (idx < 0) idx = COLOR_POSITIVE_SHADES.length - 1;\n    return value >= 0 ? COLOR_POSITIVE_SHADES[idx] : COLOR_NEGATIVE_SHADES[idx];\n}\nfunction withAlpha(color, alpha) {\n    if (!color) return \"rgba(15, 23, 42, \".concat(alpha, \")\");\n    if (color.startsWith(\"rgba\")) {\n        return color.replace(/rgba\\(([^)]+)\\)/, (_match, inner)=>{\n            const parts = inner.split(\",\").map((part)=>part.trim());\n            const [r, g, b] = parts;\n            return \"rgba(\".concat(r, \", \").concat(g, \", \").concat(b, \", \").concat(alpha, \")\");\n        });\n    }\n    if (color.startsWith(\"rgb\")) {\n        return color.replace(/rgb\\(([^)]+)\\)/, (_match, inner)=>\"rgba(\".concat(inner, \", \").concat(alpha, \")\"));\n    }\n    if (!color.startsWith(\"#\")) return color;\n    const hex = color.slice(1);\n    const normalized = hex.length === 3 ? hex.split(\"\").map((h)=>h + h).join(\"\") : hex;\n    const int = parseInt(normalized, 16);\n    const r = int >> 16 & 255;\n    const g = int >> 8 & 255;\n    const b = int & 255;\n    return \"rgba(\".concat(r, \", \").concat(g, \", \").concat(b, \", \").concat(alpha, \")\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2ZlYXR1cmVzL21hdHJpY2VzL2NvbG9ycy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQU8sTUFBTUEsd0JBQXdCO0lBQ25DO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRCxDQUFDO0FBRUssTUFBTUMsd0JBQXdCO0lBQ25DO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRCxDQUFDO0FBRUssTUFBTUMsNEJBQTRCO0lBQ3ZDO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRCxDQUFDO0FBRUssTUFBTUMsNEJBQTRCO0lBQ3ZDO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRCxDQUFDO0FBRUssTUFBTUMsY0FBYyxVQUFVO0FBQzlCLE1BQU1DLGNBQWMsNEJBQTRCO0FBQ2hELE1BQU1DLGVBQWUsVUFBVTtBQUkvQixNQUFNQyxzQkFBbUQ7SUFDOURDLFFBQVE7SUFDUkMsS0FBS0g7SUFDTEksTUFBTTtBQUNSLEVBQUU7QUFFRixNQUFNQyxpQkFBaUI7SUFBQztJQUFRO0lBQVE7SUFBTztJQUFPO0lBQVE7SUFBTztDQUFLO0FBRW5FLFNBQVNDLGVBQ2RDLEtBQWdDO1FBQ2hDQyxPQUFBQSxpRUFBbUYsQ0FBQztJQUVwRixNQUFNLEVBQUVDLFNBQVMsS0FBSyxFQUFFQyxjQUFjLElBQUksRUFBRUMsWUFBWU4sY0FBYyxDQUFDLEVBQUUsRUFBRSxHQUFHRztJQUM5RSxJQUFJRSxhQUFhLE9BQU9ULG1CQUFtQixDQUFDUyxZQUFZO0lBQ3hELElBQUlELFFBQVEsT0FBT1Q7SUFDbkIsSUFBSU8sU0FBUyxRQUFRLENBQUNLLE9BQU9DLFFBQVEsQ0FBQ04sUUFBUSxPQUFPUjtJQUNyRCxNQUFNZSxNQUFNQyxLQUFLRCxHQUFHLENBQUNQO0lBQ3JCLElBQUlPLE1BQU1ILFdBQVcsT0FBT2I7SUFDNUIsSUFBSWtCLE1BQU1YLGVBQWVZLFNBQVMsQ0FBQyxDQUFDQyxJQUFNSixNQUFNSTtJQUNoRCxJQUFJRixNQUFNLEdBQUdBLE1BQU10QixzQkFBc0J5QixNQUFNLEdBQUc7SUFDbEQsT0FBT1osU0FBUyxJQUFJYixxQkFBcUIsQ0FBQ3NCLElBQUksR0FBR3JCLHFCQUFxQixDQUFDcUIsSUFBSTtBQUM3RTtBQUVPLFNBQVNJLFVBQVVDLEtBQWEsRUFBRUMsS0FBYTtJQUNwRCxJQUFJLENBQUNELE9BQU8sT0FBTyxvQkFBMEIsT0FBTkMsT0FBTTtJQUM3QyxJQUFJRCxNQUFNRSxVQUFVLENBQUMsU0FBUztRQUM1QixPQUFPRixNQUFNRyxPQUFPLENBQUMsbUJBQW1CLENBQUNDLFFBQVFDO1lBQy9DLE1BQU1DLFFBQVFELE1BQU1FLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUMsQ0FBQ0MsT0FBU0EsS0FBS0MsSUFBSTtZQUN0RCxNQUFNLENBQUNDLEdBQUdDLEdBQUdDLEVBQUUsR0FBR1A7WUFDbEIsT0FBTyxRQUFjTSxPQUFORCxHQUFFLE1BQVVFLE9BQU5ELEdBQUUsTUFBVVgsT0FBTlksR0FBRSxNQUFVLE9BQU5aLE9BQU07UUFDekM7SUFDRjtJQUNBLElBQUlELE1BQU1FLFVBQVUsQ0FBQyxRQUFRO1FBQzNCLE9BQU9GLE1BQU1HLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQ0MsUUFBUUMsUUFBVSxRQUFrQkosT0FBVkksT0FBTSxNQUFVLE9BQU5KLE9BQU07SUFDcEY7SUFDQSxJQUFJLENBQUNELE1BQU1FLFVBQVUsQ0FBQyxNQUFNLE9BQU9GO0lBQ25DLE1BQU1jLE1BQU1kLE1BQU1lLEtBQUssQ0FBQztJQUN4QixNQUFNQyxhQUFhRixJQUFJaEIsTUFBTSxLQUFLLElBQUlnQixJQUFJUCxLQUFLLENBQUMsSUFBSUMsR0FBRyxDQUFDLENBQUNTLElBQU1BLElBQUlBLEdBQUdDLElBQUksQ0FBQyxNQUFNSjtJQUNqRixNQUFNSyxNQUFNQyxTQUFTSixZQUFZO0lBQ2pDLE1BQU1MLElBQUksT0FBUSxLQUFNO0lBQ3hCLE1BQU1DLElBQUksT0FBUSxJQUFLO0lBQ3ZCLE1BQU1DLElBQUlNLE1BQU07SUFDaEIsT0FBTyxRQUFjUCxPQUFORCxHQUFFLE1BQVVFLE9BQU5ELEdBQUUsTUFBVVgsT0FBTlksR0FBRSxNQUFVLE9BQU5aLE9BQU07QUFDekMiLCJzb3VyY2VzIjpbIkg6XFxVc2Vyc1xcR3VzXFxzb3VyY2VcXHJlcG9cXGR5bmFtaWNzXFxkeW5hbWljcy1iXFxjcnlwdG9waS1keW5hbWljc1xcc3JjXFxjb21wb25lbnRzXFxmZWF0dXJlc1xcbWF0cmljZXNcXGNvbG9ycy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgQ09MT1JfUE9TSVRJVkVfU0hBREVTID0gW1xuICBcIiNlMWY4ZWNcIixcbiAgXCIjYmRmM2Q0XCIsXG4gIFwiIzhjZTliNFwiLFxuICBcIiM1M2Q2OGFcIixcbiAgXCIjMjVjMDY0XCIsXG4gIFwiIzE0OTc0YVwiLFxuICBcIiMwZjc2MzlcIixcbiAgXCIjMGI0ZjI3XCIsXG5dO1xuXG5leHBvcnQgY29uc3QgQ09MT1JfTkVHQVRJVkVfU0hBREVTID0gW1xuICBcIiNmZmU2ZTJcIixcbiAgXCIjZmZjOWMxXCIsXG4gIFwiI2ZmYTI5NFwiLFxuICBcIiNmZjdhNjhcIixcbiAgXCIjZmY0ZjNkXCIsXG4gIFwiI2UwMzIxZlwiLFxuICBcIiNiNzFmMTRcIixcbiAgXCIjOGExYTBkXCIsXG5dO1xuXG5leHBvcnQgY29uc3QgQ09MT1JfTU9PX1BPU0lUSVZFX1NIQURFUyA9IFtcbiAgXCIjZTBmMGZmXCIsXG4gIFwiI2MzZTFmZlwiLFxuICBcIiM5ZGNmZmZcIixcbiAgXCIjNzFiOGZmXCIsXG4gIFwiIzQyOTdmZlwiLFxuICBcIiMyMjc0ZTZcIixcbiAgXCIjMTc1OGI1XCIsXG4gIFwiIzBmM2M3ZFwiLFxuXTtcblxuZXhwb3J0IGNvbnN0IENPTE9SX01PT19ORUdBVElWRV9TSEFERVMgPSBbXG4gIFwiI2ZmZTlkNlwiLFxuICBcIiNmZmQyYWRcIixcbiAgXCIjZmZiMDc4XCIsXG4gIFwiI2ZmOTE1MlwiLFxuICBcIiNmZjczMmVcIixcbiAgXCIjZTQ1OTExXCIsXG4gIFwiI2I4NDUwOFwiLFxuICBcIiM3YzJjMDRcIixcbl07XG5cbmV4cG9ydCBjb25zdCBDT0xPUl9BTUJFUiA9IFwiI2ZhY2MxNVwiO1xuZXhwb3J0IGNvbnN0IENPTE9SX01VVEVEID0gXCJyZ2JhKDE0OCwgMTYzLCAxODQsIDAuMjgpXCI7XG5leHBvcnQgY29uc3QgQ09MT1JfRlJPWkVOID0gXCIjYTg1NWY3XCI7XG5cbmV4cG9ydCB0eXBlIEZyb3plblN0YWdlID0gXCJyZWNlbnRcIiB8IFwibWlkXCIgfCBcImxvbmdcIjtcblxuZXhwb3J0IGNvbnN0IEZST1pFTl9TVEFHRV9DT0xPUlM6IFJlY29yZDxGcm96ZW5TdGFnZSwgc3RyaW5nPiA9IHtcbiAgcmVjZW50OiBcIiNkOGI0ZmVcIixcbiAgbWlkOiBDT0xPUl9GUk9aRU4sXG4gIGxvbmc6IFwiIzZkMjhkOVwiLFxufTtcblxuY29uc3QgTUFHX1RIUkVTSE9MRFMgPSBbMC4wMDA1LCAwLjAwMTUsIDAuMDAzLCAwLjAwNiwgMC4wMTI1LCAwLjAyNSwgMC4wNV07XG5cbmV4cG9ydCBmdW5jdGlvbiBjb2xvckZvckNoYW5nZShcbiAgdmFsdWU6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQsXG4gIG9wdHM6IHsgZnJvemVuPzogYm9vbGVhbjsgZnJvemVuU3RhZ2U/OiBGcm96ZW5TdGFnZSB8IG51bGw7IHplcm9GbG9vcj86IG51bWJlciB9ID0ge31cbik6IHN0cmluZyB7XG4gIGNvbnN0IHsgZnJvemVuID0gZmFsc2UsIGZyb3plblN0YWdlID0gbnVsbCwgemVyb0Zsb29yID0gTUFHX1RIUkVTSE9MRFNbMF0gfSA9IG9wdHM7XG4gIGlmIChmcm96ZW5TdGFnZSkgcmV0dXJuIEZST1pFTl9TVEFHRV9DT0xPUlNbZnJvemVuU3RhZ2VdO1xuICBpZiAoZnJvemVuKSByZXR1cm4gQ09MT1JfRlJPWkVOO1xuICBpZiAodmFsdWUgPT0gbnVsbCB8fCAhTnVtYmVyLmlzRmluaXRlKHZhbHVlKSkgcmV0dXJuIENPTE9SX01VVEVEO1xuICBjb25zdCBhYnMgPSBNYXRoLmFicyh2YWx1ZSk7XG4gIGlmIChhYnMgPCB6ZXJvRmxvb3IpIHJldHVybiBDT0xPUl9BTUJFUjtcbiAgbGV0IGlkeCA9IE1BR19USFJFU0hPTERTLmZpbmRJbmRleCgodCkgPT4gYWJzIDwgdCk7XG4gIGlmIChpZHggPCAwKSBpZHggPSBDT0xPUl9QT1NJVElWRV9TSEFERVMubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIHZhbHVlID49IDAgPyBDT0xPUl9QT1NJVElWRV9TSEFERVNbaWR4XSA6IENPTE9SX05FR0FUSVZFX1NIQURFU1tpZHhdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2l0aEFscGhhKGNvbG9yOiBzdHJpbmcsIGFscGhhOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAoIWNvbG9yKSByZXR1cm4gYHJnYmEoMTUsIDIzLCA0MiwgJHthbHBoYX0pYDtcbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCJyZ2JhXCIpKSB7XG4gICAgcmV0dXJuIGNvbG9yLnJlcGxhY2UoL3JnYmFcXCgoW14pXSspXFwpLywgKF9tYXRjaCwgaW5uZXIpID0+IHtcbiAgICAgIGNvbnN0IHBhcnRzID0gaW5uZXIuc3BsaXQoXCIsXCIpLm1hcCgocGFydCkgPT4gcGFydC50cmltKCkpO1xuICAgICAgY29uc3QgW3IsIGcsIGJdID0gcGFydHM7XG4gICAgICByZXR1cm4gYHJnYmEoJHtyfSwgJHtnfSwgJHtifSwgJHthbHBoYX0pYDtcbiAgICB9KTtcbiAgfVxuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcInJnYlwiKSkge1xuICAgIHJldHVybiBjb2xvci5yZXBsYWNlKC9yZ2JcXCgoW14pXSspXFwpLywgKF9tYXRjaCwgaW5uZXIpID0+IGByZ2JhKCR7aW5uZXJ9LCAke2FscGhhfSlgKTtcbiAgfVxuICBpZiAoIWNvbG9yLnN0YXJ0c1dpdGgoXCIjXCIpKSByZXR1cm4gY29sb3I7XG4gIGNvbnN0IGhleCA9IGNvbG9yLnNsaWNlKDEpO1xuICBjb25zdCBub3JtYWxpemVkID0gaGV4Lmxlbmd0aCA9PT0gMyA/IGhleC5zcGxpdChcIlwiKS5tYXAoKGgpID0+IGggKyBoKS5qb2luKFwiXCIpIDogaGV4O1xuICBjb25zdCBpbnQgPSBwYXJzZUludChub3JtYWxpemVkLCAxNik7XG4gIGNvbnN0IHIgPSAoaW50ID4+IDE2KSAmIDI1NTtcbiAgY29uc3QgZyA9IChpbnQgPj4gOCkgJiAyNTU7XG4gIGNvbnN0IGIgPSBpbnQgJiAyNTU7XG4gIHJldHVybiBgcmdiYSgke3J9LCAke2d9LCAke2J9LCAke2FscGhhfSlgO1xufVxyXG4iXSwibmFtZXMiOlsiQ09MT1JfUE9TSVRJVkVfU0hBREVTIiwiQ09MT1JfTkVHQVRJVkVfU0hBREVTIiwiQ09MT1JfTU9PX1BPU0lUSVZFX1NIQURFUyIsIkNPTE9SX01PT19ORUdBVElWRV9TSEFERVMiLCJDT0xPUl9BTUJFUiIsIkNPTE9SX01VVEVEIiwiQ09MT1JfRlJPWkVOIiwiRlJPWkVOX1NUQUdFX0NPTE9SUyIsInJlY2VudCIsIm1pZCIsImxvbmciLCJNQUdfVEhSRVNIT0xEUyIsImNvbG9yRm9yQ2hhbmdlIiwidmFsdWUiLCJvcHRzIiwiZnJvemVuIiwiZnJvemVuU3RhZ2UiLCJ6ZXJvRmxvb3IiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImFicyIsIk1hdGgiLCJpZHgiLCJmaW5kSW5kZXgiLCJ0IiwibGVuZ3RoIiwid2l0aEFscGhhIiwiY29sb3IiLCJhbHBoYSIsInN0YXJ0c1dpdGgiLCJyZXBsYWNlIiwiX21hdGNoIiwiaW5uZXIiLCJwYXJ0cyIsInNwbGl0IiwibWFwIiwicGFydCIsInRyaW0iLCJyIiwiZyIsImIiLCJoZXgiLCJzbGljZSIsIm5vcm1hbGl6ZWQiLCJoIiwiam9pbiIsImludCIsInBhcnNlSW50Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/features/matrices/colors.ts\n"));

/***/ })

});